//ÔΩ°‚òÜ‚úº‚òÖ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚òÖ‚úº‚òÜÔΩ°
//.        LADY BUG BUTECA
//ÔΩ°‚òÜ‚úº‚òÖ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚òÖ‚úº‚òÜÔΩ°
//const express = require('express');
//const app = express();
//const PORT = process.env.PORT || 3000;

// Define a porta aqui

// Rota b√°sica
//app.get('/', (req, res) => {
//  res.send('Lady bot esta online!');
//});

// Inicia o servidor
//app.listen(PORT, () => {
//  console.log(`Servidor rodando na porta ${PORT}`);
//});

//=======================================*/

const { downloadContentFromMessage, relayWAMessage, mentionedJid, processTime, MediaType, Browser, MessageType, Presence, Mimetype, Browsers, delay, getLastMessageInChat, prepareWAMessageMedia } = require('@whiskeysockets/baileys');

//_-_-_-__-_-_-_-_-_-MODULOS/FUN√á√ïES-_-_-_-_-_-__-_-_-_-_-\\

const { fs, Boom, axios, yts, crypto, util, P, linkfy, request, cheerio, ms, ffmpeg, webp_mp4, qrterminal, exec, spawn, execSync, moment, color, time, hora, date, getBuffer, convertSticker, recognize, fetchJson, fetchText, getBase64, createExif, response, addLimit, upload, nit, sesc, validmove, setGame, addComandosId, deleteComandos, getComandoBlock, getComandos, addComandos, palavrasANA, quizanimais, getpc, supre, wait, getExtension, generateMessageID, getGroupAdmins, getMembros, getRandom, banner2, banner3, isFiltered, addFilter, temporizador, chyt, kyun, simih, botoff, colors, comand, sendButton, sendListB, sendRoulette, sendPayment, RSM_FUNC, saveJSON, isJsonIncludes, alerandom, letras, randomLetra, getname, addNumberMais, identArroba, iniMai, contar, gerarkey, sendHours, rmLetras, replaceAll, contarMin, contarDias, converterDias, converterMin, allvaluerent, sendFutureTime, isIDacc, GenerateQRpix, sendRouletteButton, nicks } = require('./config.js');

const jimp = require('jimp')

const { arcloud } = require('./arcc.js')

const AssemblyAI = require("assemblyai");

const assemblyApiKey = '1448709aa4044b21934de9aca30509c2'

const { payment } = require("./mercado-pago-API/index.js")

const dataMP = JSON.parse(fs.readFileSync(`./dono/mercado pago.json`))

const { superimg } = require("./database/superimg.js")

//-_-_-_-_-_--_-_-_-_-JS-MENUS/INFORMA√á√ïES-_-_-_-_-_-_-_-_-_-_\\

const { anotacao, infocontador, infobemvindo, infolistanegra, infotransmitir, infopalavrao, infobancarac, configbot, cmd_termux, destrava, destrava2, tabela, conselhob, palavrasc, joguinhodavelhajs, joguinhodavelhajs2, obrigadoEXT, setting, logoslink, globegroup, music, tinder, amongus, vdddsf, akinator, mute, figname, countMessage, sendVideoAsSticker, sendImageAsSticker, sendVideoAsSticker2, sendImageAsSticker2, sotoy, daily, comandos, limitefll, addVote, delVote, antispam, anotar, enviarfiguUrl, getFileBuffer, DLT_FL, sleep, antiModLetra, convertBytes, pushnames, ausentes, avisos, funcgp, revealmsg, adsgp, bcgp, rankcmd } = require('./config.js');

//_-_-_-_-_-_-_-_-_-_-_-_-(INFOS)_-_-_-_-_-_-_-_-_-_-_-_-_-_-_--\\
var { botoes, forwarding, crtt, visualizarmsg, modoaluguel, API_KEY_ALEATORY, API_KEY_SABRINA, API_KEY_BLACK, API_KEY_CONSULT, stopcmdlist, site, blackchannel, idchatofc, idprivategp, dono1, dono2, dono3, dono4, dono5, dono6 } = require("./dono/config-all.json");

var { NomeDoBot, NickDono, prefix } = require("./dono/settings.json");

const { __esModule } = require('cheerio');

const figurinhas = JSON.parse(fs.readFileSync("./database/data/figurinhas.json"));

const recolherLNK = JSON.parse(fs.readFileSync("./armor/funcoes/recolherLNK.json"));

const links = JSON.parse(fs.readFileSync('./basededados/links.json'));

//====================‚â†‚â†===============\\
 
var numerodono_ofc = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "");

var nmrdnCmMais = "+" + numerodono_ofc.slice(0, 2) + " " + numerodono_ofc.slice(2, 4) + " " + numerodono_ofc.slice(4, numerodono_ofc.length - 4) + "-" + numerodono_ofc.slice(numerodono_ofc.length - 4, numerodono_ofc.length)

async function reiniciarBLK() {
file = require.resolve("./start.js");
delete require.cache[file];
require(file);
}

var AsMsg = [];

// ABAIXO: IN√çCIO DE CONEX√ÉO

async function startBlack() {

module.exports = blackmd = async(blackmd, qrcode) => {
module.exports = upsert = async(upsert, blackmd) => {
async function msgupsrt() {
const nmrdn_dono2 = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "") + "@s.whatsapp.net";

var hora120 = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

RSM_FUNC(blackmd, nmrdn_dono2, hora120, upsert);

for (const info of upsert?.messages || []) {

const from = info.key.remoteJid;
const isGroup = from.endsWith('@g.us');

if(fs.existsSync(`./basededados/grupos/${from}.json`)) {
var jsonGp = JSON.parse(fs.readFileSync(`./basededados/grupos/${from}.json`));
}

// üá∏‚ÄäüáÆ‚Ääüá≤‚Ääüáµ‚Ääüá±‚ÄäüáÆ‚Ääüá´‚ÄäüáÆ‚Ääüá®‚Ääüá¶‚Ääüá®‚Ääüá¥‚Ääüá™‚Ääüá∏‚Ää\\
// RODAR COMANDOS DE OUTROS BOTS \\

var conn = blackmd
var japa = blackmd
var aqua = blackmd
var lukaz = blackmd
var pl = blackmd
var vieno = blackmd
var mikasa = blackmd
var sabrina = blackmd
var chris = blackmd
var kaic = blackmd
var kimbler = blackmd
var vitu = blackmd
var lulu = blackmd
var loli = blackmd

if(fs.existsSync(`./basededados/grupos/${from}.json`) && jsonGp[0].x9 && info.messageStubType){
switch(info.messageStubType){
case 29:
await delay(1000);
blackmd.sendMessage(info.key.remoteJid, {text: `@${info.participant.split("@")[0]} *acaba de promover o/a* @${info.messageStubParameters[0].split("@")[0]} *√† ADM do grupo...* üëë`
, mentions: [info.messageStubParameters[0], info.participant]});
break;
case 30:
await delay(1000);
blackmd.sendMessage(info.key.remoteJid, {
text: `@${info.participant.split("@")[0]} *acaba de rebaixar o/a* @${info.messageStubParameters[0].split("@")[0]} *√† membro comum do grupo...* ü•≤`
, mentions: [info.messageStubParameters[0], info.participant]});
break;
}}
  
if(!info.message) return;
if(upsert.type == "append") return;  
const baileys = require('@whiskeysockets/baileys');
const type = baileys.getContentType(info.message);
const content = JSON.stringify(info.message);
const pushTestName = info.pushName ? info.pushName : 'Usu√°rio';
if(visualizarmsg) {
await blackmd.readMessages([info.key]);
} else {
if(from == "status@broadcast") return;
}

global.prefix;
global.blocked;

const speed = require('performance-now');

//==============(BODY)================\\

var body = type === "conversation" ? info.message.conversation : type == "editedMessage" ? info.message.editedMessage.message.protocolMessage.editedMessage?.conversation || info.message.editedMessage.message.protocolMessage.editedMessage?.imageMessage?.caption || info.message.editedMessage.message.protocolMessage.editedMessage?.videoMessage?.caption || info.message.editedMessage.message.protocolMessage.editedMessage?.documentMessage?.caption : type === "viewOnceMessageV2" ? info.message.viewOnceMessageV2.message.imageMessage ? info.message.viewOnceMessageV2.message.imageMessage.caption : info.message.viewOnceMessageV2.message.videoMessage.caption : type === "imageMessage" ? info.message.imageMessage.caption : type === "videoMessage" ? info.message.videoMessage.caption : type === "extendedTextMessage" ? info.message.extendedTextMessage.text : type === "viewOnceMessage" ? info.message.viewOnceMessage.message.videoMessage ? info.message.viewOnceMessage.message.videoMessage.caption : info.message.viewOnceMessage.message.imageMessage.caption : type === "documentWithCaptionMessage" ? info.message.documentWithCaptionMessage.message.documentMessage.caption : type === "buttonsMessage" ? info.message.buttonsMessage.imageMessage.caption : type === "buttonsResponseMessage" ? info.message.buttonsResponseMessage.selectedButtonId : type === "listResponseMessage" ? info.message.listResponseMessage.singleSelectReply.selectedRowId : type === "templateButtonReplyMessage" ? info.message.templateButtonReplyMessage.selectedId : type === "groupInviteMessage" ? info.message.groupInviteMessage.caption : type === "pollCreationMessageV3" ? info.message.pollCreationMessageV3 : type === "interactiveResponseMessage" ? JSON.parse(info.message.interactiveResponseMessage.nativeFlowResponseMessage.paramsJson).id : type === "text" ? info.text : ""

var Procurar_String = info.message?.conversation || info.message?.viewOnceMessageV2?.message?.imageMessage?.caption || info.message?.viewOnceMessageV2?.message?.videoMessage?.caption || info.message?.imageMessage?.caption || info.message?.videoMessage?.caption || info.message?.extendedTextMessage?.text || info.message?.viewOnceMessage?.message?.videoMessage?.caption || info.message?.viewOnceMessage?.message?.imageMessage?.caption || info.message?.documentWithCaptionMessage?.message?.documentMessage?.caption || info.message?.buttonsMessage?.imageMessage?.caption || ""

const args = body.trim().split(/ +/).slice(1);

var budy2 = body.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

if(isGroup && fs.existsSync(`./basededados/grupos/${from}.json`) && jsonGp[0].multiprefix) {
var prefix = jsonGp[0]?.prefixos[jsonGp[0]?.prefixos?.indexOf(String(body)?.trim()?.charAt(0))] || jsonGp[0].prefixos[0]
}

if(isGroup && fs.existsSync(`./basededados/grupos/${from}.json`) && !jsonGp[0].multiprefix) {
var prefix = setting.prefix;
} else if(!isGroup) {
var prefix = setting.prefix
};

var isCmd = body.trim().startsWith(prefix);

const command = isCmd ? budy2.trim().slice(1).split(/ +/).shift().toLocaleLowerCase(): null;

const q_2 = budy2.trim().split(/ +/).slice(1).join(' ');

const q = args.join(' ');

var budy = (type === 'conversation') ? info.message?.conversation : (type === 'extendedTextMessage') ? info.message?.extendedTextMessage?.text : '';

var budy3 = budy.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

var PR_String = Procurar_String.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

const q_ofc = PR_String.trim().split(/ +/).slice(1).join(" ");

//======================================\\

try {var groupMetadata = isGroup ? await blackmd.groupMetadata(from): ""} catch {return}

const groupName = isGroup ? groupMetadata.subject : '';

const sender = isGroup ? info.key.participant.includes(':') ? info.key.participant.split(':')[0] +'@s.whatsapp.net': info.key.participant : info.key.remoteJid;

const pushname = JSON.stringify(pushnames).includes(sender) ? pushnames[pushnames.map(i => i.id).indexOf(sender)].nick : pushTestName

const messagesC = PR_String.slice(0).trim().split(/ +/).shift().toLowerCase();

const arg = body.substring(body.indexOf(' ') + 1);

const botNumber = await blackmd.user.id.split(':')[0]+'@s.whatsapp.net';
const argss = body.split(/ +/g);
const testat = body;
const ants = body;

const groupDesc = isGroup ? groupMetadata.desc : ''

const groupMembers = isGroup ? groupMetadata.participants : ''

const isnit = nit.includes(sender) 

const issupre = supre.includes(sender)

const ischyt = chyt.includes(sender)

const isSesc = sesc.includes(sender)

const groupAdmins = isGroup ? getGroupAdmins(groupMembers) : ''

const somembros = isGroup ? getMembros(groupMembers) : ''

const apikeymeta = `https://raw.githubusercontent.com/iamriz7/kopel_/main/kopel.json`

//=======================================\\

const nmrdn = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` || isnit

const numerodono = [`${nmrdn}`, `${dono1}@s.whatsapp.net`, `${dono2}@s.whatsapp.net`, `${dono3}@s.whatsapp.net`, `${dono4}@s.whatsapp.net`, `${dono5}@s.whatsapp.net`, `${dono6}@s.whatsapp.net`]

//============(SORTEIO-CONST)============\\

const { infosorteio } = require('./armor/js/infosorteio.js')

//===========(enviar.espere)=============\\

const { pia } = require('./armor/js/piadas.js');

const { mensagens } = require('./armor/js/aleatoria.js');

const { sortear } = require('./armor/js/aleatoria.js');

var enviarmen = mensagens[Math.floor(Math.random() * mensagens.length)];

react1 = ['‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç', 'ü§é', '‚ù§‚Äçüî•', '‚ù§‚Äçü©π', 'üíû', 'üíó', 'üíñ'];

react2 = react1[Math.floor(Math.random()*react1.length)]

//================BANNED===================\\

const { banned, saveBannedUsu, isBanned, banirUsuario, desbanirUsuario, getBannedUsu, bannedExpired, isBannedMessageUsu } = require("./basededados/banusu/ban.js")

//================ALL-VIP===================\\

const { vip, saveVip, addVip, rmVip, delVip, getUsuVip, isOnlyVip, isAdvencedVip, isInfinityVip, vipTime, vipgp, saveGroupVip, addGroupVip, delGroupVip, getGroupVip, isOnlyGroupVip, isAdvencedGroupVip, isInfinityGroupVip, vipGroupTime, valoresVIP } = require("./basededados/all-vip/vip-config.js")

//================RPG-FUNC===================\\
//SISTEMA RPG\\

const caussa = JSON.parse(fs.readFileSync('./funcoes_rpg/caussa/caussa.json'));

const anotar = JSON.parse(fs.readFileSync('./database/func/tabela/anotar.json'));

const tagrico = JSON.parse(fs.readFileSync('./funcoes_rpg/tagrico/tagrico.json'));

const sapato = JSON.parse(fs.readFileSync('./funcoes_rpg/sapato/sapato.json'));

const palitor = JSON.parse(fs.readFileSync('./funcoes_rpg/palitor/palitor.json'));
const carab = JSON.parse(fs.readFileSync('./funcoes_rpg/carab/carab.json'));
const casa = JSON.parse(fs.readFileSync('./funcoes_rpg/casa/casa.json'));
const aguacoco = JSON.parse(fs.readFileSync('./funcoes_rpg/agua/aguacoco.json'));

const roupab = JSON.parse(fs.readFileSync('./funcoes_rpg/roupa/roupab.json'));

const dindin = JSON.parse(fs.readFileSync("./funcoes_rpg/dinheiro/dindin.json"));
const espada = JSON.parse(fs.readFileSync('./funcoes_rpg/espada/espada.json'));
// RPG

// Agora sim pode fazer includes
const isRoupab = roupab.includes(sender)
const iscasa = casa.includes(sender)
const isaguacoco = aguacoco.includes(sender)
const isCarab = carab.includes(sender) 
const isCaussa = caussa.includes(sender)
const istagrico = tagrico.includes(sender)
const isSapato = sapato.includes(sender)
const isPalitor = palitor.includes(sender) 
const isespada = espada.includes(sender)

// FIM DO RPG
const { cidadesRPG, saveCityBlackRPG, createCityBlackRPG, existCity, limitCity, findCity, filesDBuserBC, registrarUsuInBlackCity, rmUsuBlackCity, isYouInBlackCity, totalUserBlackCity } = require("./basededados/RPGBLACKCITY/blackrpg.js")
// Verifica o dinheiro do usu√°rio
const checkATMuser = (sender) => {
    let position = false
    Object.keys(dindin).forEach((i) => {
        if (dindin[i].id === sender) {
            position = i
        }
    })
    if (position !== false) {
        return dindin[position].dindin
    } else {
        return 0 // Se o usu√°rio n√£o existir, retorna 0
    }
}

// Remove dinheiro do usu√°rio
const confirmATM = (sender, amount) => {
    let position = false
    Object.keys(dindin).forEach((i) => {
        if (dindin[i].id === sender) {
            position = i
        }
    })
    if (position !== false) {
        dindin[position].dindin -= amount
        fs.writeFileSync('./funcoes_rpg/dinheiro/dindin.json', JSON.stringify(dindin))
    }
}

// Adiciona dinheiro para o usu√°rio
const addKoinUser = (sender, amount) => {
    let position = false
    Object.keys(dindin).forEach((i) => {
        if (dindin[i].id === sender) {
            position = i
        }
    })
    if (position !== false) {
        dindin[position].dindin += amount
        fs.writeFileSync('./funcoes_rpg/dinheiro/dindin.json', JSON.stringify(dindin))
    }
}

// Cria um novo usu√°rio no sistema de dinheiro
const addATM = (sender) => {
    const obj = {
        id: sender,
        dindin: 0
    }
    dindin.push(obj)
    fs.writeFileSync('./funcoes_rpg/dinheiro/dindin.json', JSON.stringify(dindin))
}

//================LEVEL-FUNC===================\\

const { isYouInLevel, dbpt, patente, saveLeVeLdb, level, addlevel, rmlevel, addXP, rmXP, blockLevelUser, unBlockLevelUser, isBlockGetLevelUser, levelDBuser, cardxp, addCardExperience, addUsuCardXP, valoresXP, getCardXPusu, saveCardXP, cardTime } = require("./basededados/leveling/level.js")

//================STOP-CMD===================\\

const { stopcmd, saveSC, isBlockGlobalCmd, addStopCmd, rmStopCmd } = require("./basedefuncionamento/configcmd/stopcmd.js")

//================SHIELD-LINK===================\\

const { shieldantilinkgp, notGroupRegisteredSALGP, addShieldGP, rmShieldGP, saveSALGP, isShieldGPuser, getShieldGPuser, shieldantilinkhard, notGroupRegisteredSALHARD, addShieldHARD, rmShieldHARD, saveSALHARD, isShieldHARDuser, getShieldHARDuser } = require("./basededados/shieldantilink/shield-all.js")

//================LIMITE-CMD===================\\

const { limitcmd, saveLimitCmd, rgGroupLC, isLimitCmd, addLimitCmd, addCmdUsageLC, isMaxUsageLC, addLimitAllCmd, rmLimitCmd, rmLimitAllCmd, getLimitCmd, nextDayLC } = require(`./basedefuncionamento/configcmd/limitcmd.js`)

//================CASAMENTO===================\\

const { waitFriendZone, saveWaitFriendZone, dbFriendZone, saveDBfriendZone, getDBFZuser, isGroupOfPedidoFriendZone, userEstaNamorando, gerarPedidoDeNamoro, userPediuAlguemEmNamoro, cancelarPedidoDeNamoro, isWaitUsuFZ_namoro, deletarAntigoPedidoDeNamoro, aceitarPedidoDeNamoro, recusarPedidoDeNamoro, userEstaCasado, isUserMencFZ, gerarPedidoDeCasamento, userPediuAlguemEmCasamento, cancelarPedidoDeCasamento, isWaitUsuFZ_casamento, aceitarPedidoDeCasamento, recusarPedidoDeCasamento, terminarOuDivorciar, aniversarioDeNamoroOuCasamento } = require("./basededados/namoro-casamento/relacionamento.js")

//================FORCA===================\\

const { saveUsuForcaGame, usuarios_forca, addUsuarioForca, rmUsuarioForca, addAcertoUsuForca, addErroUsuForca, existIdForcaGameInUsu, registrarIdNaForca, addVitoriaForca, addDerrotaForca, getUsuDatabaseForca, saveForcaWord, forcaWord, sendPathForcaGame, existSomeWordForcaGame, existThemeWordForcaGame, getThemeWordForcaGame, getRandomWordForcaGame, rgWordForcaGame, rmThemeForcaGame, rmWordForcaGame, isForcaGame, saveForcaGame, startForcaGame, resetForcaGame, restartForcaGame, getJSONforcaGame, letraFoiJogada, isTrueLetter, isLetterFinishForcaGame, registrarLetraForca, getWordSplitForcaGame, getErrEmojiForcaGame, sendTextForcaGame, jogarLetraForcaGame } = require("./armor/jogo/forca/forca.js")

//===============COINS-RENT==============\\

const { moedas, saveCoins, registrarUsuInVirtualBalance, addCoinsInVirtualBalance, rmCoinsInVirtualBalance, getSepCoins, getCoinsUsu, gerarkey, gerarTypeKey, validarKey, allKeysRentSystem, groupspath, grupos, saveGroupsRent, courtesyGroup, addGroupInRent, rmGroupInRent, aluguel, saveRent, sendTimeDay, sendTimeHours, sendLetterTime, isGroupInRent, addRent, tirarRent, delRent, rentContSystem, addCourtesy, isCourtesyGroup, getGroupRent, valoresDeAluguel, getValuesRent, existKeyRentSystem, getClientKey, rmTypeKey, getSaveGroup, isSaveGroup } = require("./basedefuncionamento/saldo virtual/config-keys.js")

//===============OPEN-CLOSE-GP==============\\

const { openclosegp, saveOpenCloseGP, rgGroupOCfunc, getGroupOpenCloseFunc, addOpenCloseGP, rmOpenCloseGP, isIDopenCloseGP, ABRIR_E_FECHAR_GRUPO, getLastOpenCloseGP } = require("./basedefuncionamento/abrir-fechar-grupo/index.js")

//==================ADS-FUNC=================\\

const { ads, saveADS, addGroupInAds, getGroupAds, addAds, isIDads, rmAds, adsFunc, adsStartList, addAdminAds, getAdminAds, rmAdminAds, existAdminAds } = require("./basedefuncionamento/mensagensprogramadas/adssystem.js")

//==================HOR√ÅRIOS=================\\

const { paidHours, savePaid, addGroupInPaid, getGroupInPaid, getIDinPaid, addPaid, rmPaid, isIDinPaid, groupLinkPaid, paidSGL, addGroupLinkInPaid, getGroupLinkFromPaidID, getInfoPaidGroupLink, rmGroupLinkInPaid } = require("./basedefuncionamento/horarios/paid hours.js")

//==================AUTO-DOWNLOAD=================\\

const { autodw, saveAutoDW, addUsuInAutoDW, getUsuAutoDW, activateAutoDWinUsu, disableAutoDWinUsu, idAllLinkAutoDW } = require("./basededados/downloadslinks/autodw.js")

//================= Fun√ß√µes de Grupo ü•ã

const groupdbpath = `./basededados/grupos/${from}.json`

const configpath = "./dono/config-all.json"

if(isGroup && !fs.existsSync(groupdbpath)){
var data = [{
name: groupName,
groupId: from, x9: false, 
antiimg: false, antivideo: false,
antiaudio: false, antisticker: false,
antidoc: false, antictt: false,
antiloc: false, antilinkgp: false,
banlinkgp: true, antilinkhard: false,
banlinkhard: true, antifake: false, antispam: false, 
antinotas: false, anticatalogo: false,
modorpg: false, visuUnica: false, soadm: false,
listanegra: [], advertir: [], prefixos: ["!"], legenda_estrangeiro: "0",
legenda_documento: "0", legenda_video: "0",
legenda_imagem: "0", multiprefix: false, 
antipalavrao: {
active: false,
palavras: []
},
limitec: {
active: false,
quantidade: 4000
},
acceptGroup: {
active: false,
time: 1200
},
wellcome: [{
bemvindo1: false,
legendabv: "#tempo# #numerodele#, seja bem vindo (a) ao grupo #nomedogp#",
legendasaiu: 0,
fundobemvindo: links.fundo1,
fundosaiu: links.fundo2
},
{
bemvindo2: false,
legendabv: "#tempo# #numerodele#, seja bem vindo (a) ao grupo #nomedogp#",
legendasaiu: 0
},
{
bemvindo3: false,
selo: false,
legendabv: `#tempo# #numerodele#, seja bem vindo (a) ao grupo #nomedogp#`,
legendasaiu: 0
},
{
bemvindo4: false,
selo: false,
legendabv: `#tempo# #numerodele#, seja bem vindo (a) ao grupo #nomedogp#`,
legendasaiu: 0
},
{
bemvindo5: false,
legendabv: `#tempo# #numerodele#, seja bem vindo (a) ao grupo #nomedogp#`,
fundobemvindo: links.fundo3,
legendasaiu: 0,
fundosaiu: links.fundo4
}],
simi1: false, simi2: false,
autosticker: false, autoresposta: false,
jogos: false, level: false,
bangp: false, nsfw: false,
antiporno: false, autotranscricao: false
}]
fs.writeFileSync(groupdbpath, JSON.stringify(data, null, 2) + '\n')
}

const dataGp = isGroup ? JSON.parse(fs.readFileSync(groupdbpath)) : undefined 

var DFNMULTIP = `./basedefuncionamento/prefixo/multip_${from}.json`

function setGp(index){
fs.writeFileSync(groupdbpath, JSON.stringify(index, null, 2) + '\n')}

function setObg(index){
fs.writeFileSync(configpath, JSON.stringify(index, null, 2) + '\n')}

//=======(ADMS/DONO/ETC..CONST)========\\

const whatIsPhone = info.key.id.length > 21 ? "Android üë§" : info.key.id.substring(0, 2) == '3A' ? "iPhone üçé" : "Whatsapp Web üåê"

const isIOS = whatIsPhone.toLowerCase().includes(`iphone`) ? true : false

const quoted = info.quoted ? info.quoted : seloctt

const isBot = info.key.fromMe ? true : false

const isOwner = numerodono.includes(sender) || isBot || isnit || issupre || ischyt || isSesc || isIDacc(sender)

dfndofc = setting.numerodono+"@s.whatsapp.net"

const DonoOficial = dfndofc.includes(sender) 

const isSupremeOwner = (id = sender) => {
  if(nmrdn.includes(id) || nit.includes(id) || supre.includes(id) || chyt.includes(id) || sesc.includes(id)) return true
  return false
  }

const isAllOwner = (id = sender) => {
if(numerodono.includes(id) || nit.includes(id) || supre.includes(id) || chyt.includes(id) || sesc.includes(id)) return true
return false
}

const isAdmin = (id = sender) => {
if(groupAdmins.includes(id)) return true
return false
}

const isVip = isOnlyVip(sender)

const isGroupVip = (id = from) => {return isOnlyGroupVip(id)}

const isAllVip = (id = sender) => {
if(isOnlyVip(id) || isGroupVip(from)) return true
return false
}

const randomUser = isGroup ? groupMembers[alerandom(groupMembers.length)].id : nmrdn

const isBotGroupAdmins = groupAdmins.includes(botNumber) || false

const isGroupAdmins = groupAdmins.includes(sender) || false || DonoOficial || isOwner

const isVisualizar = obrigadoEXT.visualizarmsg

const isVerificado = obrigadoEXT.verificado

const isAudioMenu = obrigadoEXT.menu_audio

const isAntiPv2 = obrigadoEXT.antipv2

const isConsole = obrigadoEXT.consoleoff

const isBotoff = obrigadoEXT.botoff

const listanegraG = obrigadoEXT.listanegraG

const isAntiPv = obrigadoEXT.antipv

const isAnticall = obrigadoEXT.anticall

const isStopCmd = obrigadoEXT.stopcmdlist

const isJoguin = isGroup ? joguinhodavelhajs.includes(sender) : false

const MercadoPagoKey = dataMP.token

//
const time2 = moment().tz('America/Sao_Paulo').format('HH:mm:ss')
if(time2 > "00:00:00" && time2 < "05:00:00"){
var tempo = 'Boa madrugada'
} if(time2 > "05:00:00" && time2 < "12:00:00"){
var tempo = 'Bom dia'
} if(time2 > "12:00:00" && time2 < "18:00:00"){
var tempo = 'Boa tarde'
} if(time2 > "18:00:00"){
var tempo = 'Boa noite'
}

const time_emoji = moment().tz('America/Sao_Paulo').format('HH:mm:ss')
if(time_emoji > "00:00:00" && time_emoji < "05:00:00"){
var tempo_emoji = 'üåë'
} if(time_emoji > "05:00:00" && time_emoji < "12:00:00"){
var tempo_emoji = '‚òÄÔ∏è'
} if(time_emoji > "12:00:00" && time_emoji < "18:00:00"){
var tempo_emoji = 'üçÉ'
} if(time_emoji > "18:00:00"){
var tempo_emoji = 'üåô'
}

const time_pro = moment().tz('America/Sao_Paulo').format('HH:mm:ss')
if(time_pro > "00:00:00" && time_pro < "05:00:00"){
var tempo_pro = 'uma'
} if(time_pro > "05:00:00" && time_pro < "12:00:00"){
var tempo_pro = 'um'
} if(time_pro > "12:00:00" && time_pro < "18:00:00"){
var tempo_pro = 'uma'
} if(time_pro > "18:00:00"){
var tempo_pro = 'uma'
}

//============(FUN√á√ïES)============\\


const isAntiImg = isGroup ? dataGp[0].antiimg : undefined

const isAntiVid = isGroup ? dataGp[0].antivideo : undefined

const isAntiAudio = isGroup ? dataGp[0].antiaudio : undefined

const isAntiSticker = isGroup ? dataGp[0].antisticker : undefined

const Antidoc = isGroup ? dataGp[0].antidoc : undefined

const isAntiCtt = isGroup ? dataGp[0].antictt : undefined

const Antiloc = isGroup ? dataGp[0].antiloc : undefined

const isAntilinkgp = isGroup ? dataGp[0].antilinkgp : undefined

const isBanlinkgp = isGroup ? dataGp[0].banlinkgp : undefined

const isAntiLinkHard = isGroup ? dataGp[0].antilinkhard : undefined

const isBanLinkHard = isGroup ? dataGp[0].banlinkhard : undefined

const isAntifake = isGroup ? dataGp[0].antifake : undefined

const isAntiMembros = isGroup ? dataGp[0].soadm: undefined

const isAntiVisuUnica = isGroup ? dataGp[0].visuUnica : undefined

const ADVT = isGroup ? dataGp[0].advertir: undefined

const isx9 = isGroup ? dataGp[0].x9 : undefined

const isMultiP = isGroup ? dataGp[0].multiprefix : undefined

const isAntiNotas = isGroup ? dataGp[0].antinotas : undefined

const isAnticatalogo = isGroup ? dataGp[0].anticatalogo : undefined

const isWelkom = isGroup ? dataGp[0].wellcome[0].bemvindo1 : undefined

const isWelkom2 = isGroup ? dataGp[0].wellcome[1].bemvindo2 : undefined

const isWelkom3 = isGroup ? dataGp[0].wellcome[2].bemvindo3 : undefined

const isWelkom4 = isGroup ? dataGp[0].wellcome[3].bemvindo4 : undefined

const isWelkom5 = isGroup ? dataGp[0].wellcome[4].bemvindo5 : undefined

const isSimi = isGroup ? dataGp[0].simi1 : undefined

const isSimi2 = isGroup ? dataGp[0].simi2 : undefined

const isAutofigu = isGroup ? dataGp[0].autosticker : undefined

const isAutorepo = isGroup ? dataGp[0].autoresposta : undefined

const isModobn =  isGroup ? dataGp[0].jogos : undefined

const isLevelingOn = isGroup ? dataGp[0].level : undefined

const isBanchat = isGroup ? dataGp[0].bangp : undefined

const isNsfw = isGroup ? dataGp[0].nsfw : undefined

const isPalavrao = isGroup ? dataGp[0].antipalavrao.active : undefined

const isPalavras = isGroup ? dataGp[0].antipalavrao.palavras : undefined

const isAntiFlood = isGroup ? dataGp[0].limitec.active : undefined

//const isAntiSpam = isGroup ? dataGp[0].antispam : undefined

const isLimitec = isGroup ? dataGp[0].limitec.quantidade : undefined

const isAcceptGroup = isGroup ? dataGp[0].acceptGroup.active : undefined

const isAutoTranscricao = isGroup ? dataGp[0].autotranscricao : undefined

const isBlackCity = isGroup ? dataGp[0].modorpg : undefined

const isAntiPorno = isGroup ? dataGp[0].antiporno : undefined

const isModRent = obrigadoEXT.modoaluguel == true ? true : false

const isMsgPV = obrigadoEXT.msgpv == true ? true : false

const isChatOfc = from == obrigadoEXT.idchatofc ? true : false

const isPrivateChat = from == obrigadoEXT.idprivategp ? true : false

const sorteio = JSON.parse(fs.readFileSync("./basedefuncionamento/sorteio.json"))

const TMGP = JSON.parse(fs.readFileSync("./basedefuncionamento/TMGP.json"))

const novidades = JSON.parse(fs.readFileSync("./database/data/novidades.json"))

const gbmsg = JSON.parse(fs.readFileSync("./basededados/gbmsg.json"))

const audios = JSON.parse(fs.readFileSync("./database/data/audios.json"))

const adivinharnmr = JSON.parse(fs.readFileSync("./armor/jogo/adivinharnmr.json"))

const { Aki } = require('aki-api')

const jogo = { jogador: '', now: true }

//=======================================\\

enviar = {
  espere: `${enviarmen}`,
  successo: 'Ô∏è‚ù¨ ‚úî ‚ù≠ Sucesso üñ§',
  levelon: '‚ù¨ ‚úî ‚ù≠ *leveling* *ativado*',
  leveloff: '‚ù¨ X ‚ù≠  *leveling* *desativado*',
  levelnoton: '‚ù¨ X ‚ù≠ *leveling n√£o ativado*',
  levelnol: '*error* 0 ¬∞-¬∞',
  adsatc: `[‚ùó] √â necess√°rio ativar o adssystem neste grupo primeiramente... Use ${prefix}startads ‚ùå`,
  error: {
    stick: '*falhou, tente novamente ^_^*',
    Iv: 'Link invalido ‚òπÔ∏è'
  },
  msg: {
  grupo: '[‚ùó] Este comando s√≥ pode ser usado em grupos! ‚ùå',
  vip: '[‚ùó] ESTE COMANDO √â S√ì PARA *USU√ÅRIOS VIP*',
  advip: '[‚ùó] ESTE COMANDO REQUER O MOD *ADVENCED VIP*',
  mod: `[‚ùó] ESTE PEDIDO √â ESPEC√çFICO PARA USUARIO MOD ${NickDono}*`,
  banido: '[‚ùó] Voc√™ est√° proibido de usar os comandos do bot... Entre em contato com meu dono para saber o por que ‚ùå' ,
  dono: '[‚ùó] Este comando est√° restrito ao uso do meu dono ‚ùå',
  donoblk: `[‚ùó] Este comando s√≥ pode ser usado pelo ${NickDono}, meu dono ‚ùå`,
  adm: '[‚ùó] Este comando s√≥ pode ser usado por administradores de grupo! ‚ùå',
  Badmin: '[‚ùó] Este comando s√≥ pode ser usado quando o bot se torna administrador! ‚ùå',
  modobz: `[‚ùó] Este comando s√≥ pode ser usado com as brincadeiras ativadas... Use ${prefix}modozoeira ‚ùå`,
  consulta: '[‚öôÔ∏è] consultando dados, aguarde um momento‚ùó',
  notusu: `[‚ùó] ID do usu√°rio n√£o encontrado ou inexistente ‚ùå`,
  pvnotvip: "[ ‚ùó ] o uso desde recurso no PV est√° liberado apenas para usu√°rios VIP ‚ùå",
  modonsfw: `[ ‚ùó ] Este comando s√≥ pode ser usado com o nsfw ativo... Para ativar, use ${prefix}modonsfw`
  },
  stopcmd: {
    isblock: `Este comando J√Å est√° bloqueado...`,
    notblock: `Este comando N√ÉO est√° bloqueado...`
  },
  shield: {
    gp: {
      true: `[‚ùï] Este usu√°rio j√° est√° protegido ao envio de links de grupo ‚úî`,
      false: `[‚ùó] Este usu√°rio n√£o est√° na lista de protegidos do anti link de grupo ‚ùå`
    },
    hard: {
      true: `[‚ùï] Este usu√°rio j√° est√° protegido ao envio de links em geral ‚úî`,
      false: `[‚ùó] Este usu√°rio n√£o est√° na lista de protegidos do anti link hard ‚ùå`
    }
  },
  rpg: {
    ativar: `[‚ùó] √© necess√°rio ativar o RPG primeiro... Use ${prefix}modorpg ‚ô®Ô∏è`,
    registrar: `${tempo} ${pushname}, vejo que voc√™ n√£o est√° registrado na Black City.. Caso queira entrar, use o comando ${prefix}rgbc, para assim usar destes sistemas üòâ`,
    existrg: `Seu registro foi encontrado na lady City... Olhe o comando ${prefix}saldo`,
    notcdd: `[‚ùó] N√£o h√° cidades dispon√≠veis ‚ùå`,
    notexistcity: `Ops, a cidade "#city#" n√£o est√° inclusa na database do RPG... Olhe no ${prefix}cidadesrpg para saber quais cidades est√£o dispon√≠veis para registro üòÄ`,
    citylimit: `[‚ùó] Esta cidade j√° est√° com a capacidade m√°xima de moradores... Procure outra cidade ‚ô®Ô∏è`,
    welcome: `${tempo} @#usu#, seu registro foi efetuado com sucesso... Bem vindo (a) a Black City ü•∞`
  }
}

var downoff = 'Sistema apresenta instabilidades... Pfvr, volte mais tarde.'

var downon = 'Sistema cancelou a opera√ß√£o, devido a demora na resposta...'

var semfoto = `https://telegra.ph/file/1523c1871a80285c2b2e8.jpg`

//==========(VERIFICADO)===============\\

if(isVerificado) {
//verificado whatsapp
var selo = { key: {fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": `${NomeDoBot}`}}}
//selo contato
var seloctt = { key: {fromMe: false, participant: `0@s.whatsapp.net`, ... {}}, message: { "contactMessage": { "displayName": `${pushname}`, "vcard": `BEGIN:VCARD\nVERSION:3.0\nN:XL;${pushname},;;;\nFN:${pushname},\nitem1.TEL;waid=${sender.split('@')[0]}:${sender.split('@')[0]}\nitem1.X-ABLabel:Ponsel\nEND:VCARD` }}}
//selo black
var seloblk = {key: {fromMe: false, participant: `0@s.whatsapp.net`, ... {}}, message: {"contactMessage": {"displayName": `üëë BLACK DOMINAH üëë`, "vcard": `BEGIN:VCARD\nVERSION:3.0\nN:XL;üëë BLACK DOMINAH üëë,;;;\nFN:üëë BLACK DOMINAH üëë,\nitem1.TEL;waid=${botNumber.split('@')[0]}:${botNumber.split('@')[0]}\nitem1.X-ABLabel:Ponsel\nEND:VCARD`}}}
} else {
var selo = info
var seloctt = info
var seloblk = info
}

// FUN√á√ïES DE MARCA√á√ïES ESSENCIAL \\

const menc_prt = info.message?.extendedTextMessage?.contextInfo?.participant

const menc_jid = args?.join(" ").replace("@", "") + "@s.whatsapp.net"

const menc_jid2 = info.message?.extendedTextMessage?.contextInfo?.mentionedJid

const sender_ou_n = q.includes("@") ? menc_jid : sender

const mrc_ou_numero = q.length > 6 && !q.includes("@") ? q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` : menc_prt 

const menc_os2 = q.includes("@") ? menc_jid : menc_prt 

const marc_tds = q.includes("@") ? menc_jid : q.length > 6 && !q.includes("@") ? q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` : menc_prt 

const menc_prt_nmr = q.length > 12 ? q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` : menc_prt

const getCase = (cases) => {
return 'case '+`'${cases}'`+fs.readFileSync("./index.js").toString().split('case \''+cases+'\'')[1].split("break")[0]+"break"
}

const reverse = (texto) => {
  return texto.split("").reverse().join("")
}

const getallcases = () => {
  findindex = fs.readFileSync("index.js").toString().match(/case\s+'(.+?)'/g)
  cstt = []
  for(i of findindex) {
    cstt.push(i.split(`'`)[1])
  }
  return cstt
}

const allCases = getallcases();

function remover(id, usu) {
blackmd.groupParticipantsUpdate(id, [usu], "remove")}

function promover(id, usu) {
blackmd.groupParticipantsUpdate(id, [usu], "promote")}

function rebaixar(id, usu) {
blackmd.groupParticipantsUpdate(id, [usu], "demote")}

function aceitar(id, usu) {
blackmd.groupRequestParticipantsUpdate(id, [usu], "approve")}

function recusar(id, usu) {
blackmd.groupRequestParticipantsUpdate(id, [usu], "reject")}

function abrirgp(id) {blackmd.groupSettingUpdate(id, 'not_announcement')}

function fechargp(id) {blackmd.groupSettingUpdate(id, 'announcement')}

async function wppuser(user) {
const [result] = await blackmd.onWhatsApp(user)
if(result == undefined) return reply(`[‚ùó] erro, o mod "${user}" n√£o foi encontrado no whatsapp ‚ùå`)}

async function carregamento(id, txt, hehe) {
  var download = [
    `${txt} ${txt.length > 0 ? "\n" : ""} ü·¥è·¥Ä·¥Ö…™…¥…¢„Äò‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äô10%`,
    `${txt} ${txt.length > 0 ? "\n" : ""} ü·¥è·¥Ä·¥Ö…™…¥…¢„Äò‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äô35%`,
    `${txt} ${txt.length > 0 ? "\n" : ""} ü·¥è·¥Ä·¥Ö…™…¥…¢„Äò‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí„Äô51%`,
    `${txt} ${txt.length > 0 ? "\n" : ""} ü·¥è·¥Ä·¥Ö…™…¥…¢„Äò‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí„Äô62%`,
    `${txt} ${txt.length > 0 ? "\n" : ""} ü·¥è·¥Ä·¥Ö…™…¥…¢„Äò‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí„Äô80%`,
    `${txt} ${txt.length > 0 ? "\n" : ""} ü·¥è·¥Ä·¥Ö…™…¥…¢„Äò‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà„Äô100%`,
    `${txt.length > 0 ? "~_*¬© black system*_~\n" : ""}ùôªùôæùô∞ùô≥ùô∏ùôΩùô∂ ùô≤ùôæùôºùôøùôªùô¥ùöÉùô¥ùô≥...`
    ]
  let { key } = await blackmd.sendMessage(id, {text: `${txt} ${txt.length > 0 ? "\n" : ""} ü·¥è·¥Ä·¥Ö…™…¥…¢„Äò‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äô0%`}, {quoted: hehe})
  await sleep(2000)
  for(let i = 0; i < download.length; i++) {
    await blackmd.sendMessage(id, {text: download[i], edit: key }, {quoted: hehe})
  }
}

const barrinha = (parte, todo, value = true) => {
  nmr = ((parte / todo) * 10).toFixed(0)
  pc = ((parte / todo) * 100).toFixed(1)
  return `„Äò${"‚ñà".repeat(nmr) + "‚ñí".repeat(10 - nmr)}„Äô${value == true ? pc+"%" : value == false ? "" : ""}`
}

const progresso = (parte, todo, value = true) => {
  nmr = ((parte / todo) * 10).toFixed(0)
  pc = ((parte / todo) * 100).toFixed(1)
  return `${value == true ? "„Äé "+pc+"% „Äè" : value == false ? "" : ""}[${"‚ñà".repeat(nmr) + "‚ñí".repeat(10 - nmr)}]`
}

const largeNumber = (value) => {
  if(Number(value) < 0) return "O n√∫mero precisa ser ‚â• 0"
  nmr = `${Number(value).toFixed(0)}`
  if(nmr.length >= 4) {
    const existPoint = (nmr) => {
      if(Number(nmr) !== 0) return "." + `${nmr}`
      return ``
    }
    if(nmr.length >= 4) txt = nmr.slice(0, (nmr.length - 3)) + existPoint(nmr.slice((nmr.length - 3), (nmr.length - 2))) + "K"
    if(nmr.length >= 7) txt = nmr.slice(0, (nmr.length - 6)) + existPoint(nmr.slice((nmr.length - 6), (nmr.length - 5))) + "M"
    if(nmr.length >= 10) txt = nmr.slice(0, (nmr.length - 9)) + existPoint(nmr.slice((nmr.length - 9), (nmr.length - 8))) + "B"
    if(nmr.length >= 13) txt = nmr.slice(0, (nmr.length - 12)) + existPoint(nmr.slice((nmr.length - 12), (nmr.length - 11))) + "T"
  } else { txt = nmr }
  return txt
}

const permuteFigPackName = (secondtxt, usu = sender) => {
  if(isOnlyVip(usu)) {
    if(isJsonIncludes(figname, usu)) {
      AB = figname.map(i => i.id).indexOf(usu)
      if(isJsonIncludes(figname[AB].fig, "pack")) {
        BC = figname[AB].fig.map(i => i.mod).indexOf("pack")
        return figname[AB].fig[BC].pack
      } else return secondtxt
    } else return secondtxt
  } else return secondtxt
}

const permuteFigAuthorName = (secondtxt, usu = sender) => {
  if(isOnlyVip(usu)) {
    if(isJsonIncludes(figname, usu)) {
      AB = figname.map(i => i.id).indexOf(usu)
      if(isJsonIncludes(figname[AB].fig, "author")) {
        BC = figname[AB].fig.map(i => i.mod).indexOf("author")
        return figname[AB].fig[BC].author
      } else return secondtxt
    } else return secondtxt
  } else return secondtxt
}

const divisores = (base) => {
  nmr = Number(base)
  caixa = []
  for(a = 0; a < nmr; a++) {
    for(b = 0; b < nmr; b++) {
      if(((a + 1) * (b + 1)) == nmr) caixa.push(a + 1)
    }
  }
  return caixa
}

const raiz = (base) => {
  nmr = Number(base)
  meta = nmr / 2
  total = 0
  for(i = 1; i < (meta + 1); i++) {
    if((i*i) == nmr) total += 1
  }
  if(total > 0) return true
  return false
}

const findRaiz = (base) => {
  nmr = Number(base)
  if(raiz(nmr)) {
    meta = nmr / 2
    caixa = []
    for(i = 1; i < (meta + 1); i++) {
      if((i*i) == nmr) caixa.push(i)
    }
    return caixa[0]
  } else return "O n√∫mero n√£o tem raiz"
}

const porCentPorCent = (txt1, txt2, nmr = 1) => {
  nmr1 = Number(txt1)
  nmr2 = Number(txt2)
  return Number((nmr1 * nmr2) / 100).toFixed(nmr)
}

const existCmd = (txt) => {
  cmd = txt.toLowerCase()
  nmr = 0
  for(i of allCases) {
    if(cmd == i) nmr += 1
  }
  if(nmr > 0) return true
  return false
}

const getSimilarity = require(`./armor/js/similaridade.js`)

const similarityCmd = (txt) => {
  getsmlrt = getSimilarity(allCases, txt)
  if(rmLetras(getsmlrt.nome).includes(`nao encontrado`)) return [{comando: getsmlrt.nome, porcentagem: getsmlrt.porcentagem}]
  return [{comando: prefix+getsmlrt.nome, porcentagem: Number(getsmlrt.porcentagem).toFixed(1)}]
}

/*const similarityCmd = (txt) => {
  cmd = rmLetras(txt)
  data = [
    {
      comando: `"n√£o encontrado"`,
      porcentagem: 0
    }
  ]
  separar = [{maior: []}, {menor: []}]
  for(a of allCases) {
    corte = a
    if(corte.length >= cmd.length) {
      separar[0].maior.push(corte)
    } else {
      separar[1].menor.push(corte)
    }
  }
  primeiro = []
  total = 0
  for(b = 0; b < cmd.length; b++) {
    for(c of separar[0].maior) {
      if(cmd[b] == c[b]) {
        contadorcmd = 0
        for(d of primeiro) {
          if(c == d.cmd) {
            d.quantidade += 1
            contadorcmd += 1
            total += 1
          }
        }
        if(contadorcmd <= 0) primeiro.push({cmd: c, quantidade: 1})
      }
    }
  }
  for(e of separar[1].menor) {
    for(f = 0; f < e.length; f++) {
      if(cmd[f] == e[f]) {
        hehe = 0
        for(d of primeiro) {
          if(e == d.cmd) {
            c.quantidade += 1
            hehe += 1
            total += 1
          }
        }
        if(contadorcmd <= 0) primeiro.push({cmd: e, quantidade: 1})
      }
    }
  }
  if(primeiro.length <= 0) return data
  mapa = primeiro.map(i => i)
  rank = mapa.sort((a, b) => (a.quantidade < b.quantidade) ? 0 : -1)
  segundo = []
  for(g of primeiro) {
    if(g.quantidade == rank[0].quantidade) segundo.push(g.cmd)
  }
  por1 = ((total + rank.length) / allCases.length) * 100
  por2 = (1 / segundo.length) * 100
  final = porCentPorCent(por1, por2) * rank[0].quantidade
  data[0].comando = prefix + segundo[alerandom(segundo.length)]
  data[0].porcentagem = Number(final > 100 ? 100 : final).toFixed(1)
  return data
}*/

const permuteNumberEmoji = (nmr) => {
  nt = String(nmr)
  nv = ``
  for(i of nt) {
    if(Number(i) == 0) np = `0Ô∏è‚É£`
    if(Number(i) == 1) np = `1Ô∏è‚É£`
    if(Number(i) == 2) np = `2Ô∏è‚É£`
    if(Number(i) == 3) np = `3Ô∏è‚É£`
    if(Number(i) == 4) np = `4Ô∏è‚É£`
    if(Number(i) == 5) np = `5Ô∏è‚É£`
    if(Number(i) == 6) np = `6Ô∏è‚É£`
    if(Number(i) == 7) np = `7Ô∏è‚É£`
    if(Number(i) == 8) np = `8Ô∏è‚É£`
    if(Number(i) == 9) np = `9Ô∏è‚É£`
    nv += np
  }
  return nv
}

////////////////////////////////////////////


var isUrl = (url) => {
if(linkfy.find(url)[0]) return true
return false
}

if(!isCmd && info.key.fromMe) return

const reply = (texto) => {
blackmd.sendMessage(from, { text: texto }, {quoted: seloctt}).catch(e => {
return reply("Erro..");
})
}

function replyJson(txt) {
return reply(JSON.stringify(txt, null, 2))}

const privateCmd = (id, pc, cmd, porcentagem) => {
notcmd = `
‚ïì‚îÄ‚îÅ‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚îÅ‚îÄ‚îí
‚î¢‚ïï ‚ùå *…¥√£·¥è ·¥á…¥·¥Ñ·¥è…¥·¥õ Ä·¥Ä·¥Ö·¥è* ‚ùå
‚ïΩ‚ïü ‚Ä¢ Usu√°rio: @${id.split("@")[0]}
‚ïΩ‚ïü ‚Ä¢ Comando: „Äé ${pc} „Äè n√£o existe
‚ïΩ‚ïü ‚Ä¢ sugest√£o: ~> ${cmd}
‚ïΩ‚ïü ‚Ä¢ semelhan√ßa: ~> ${porcentagem}%
‚ïΩ‚ïü ‚Ä¢ Olhe o menu „Äé ${prefix}menu „Äè
‚ïΩ‚ïë  Para saber mais...
‚îï‚ï®‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚îö`
return notcmd
}

const shuffle = (XXX) => {
palavra = `${XXX} `
armax = []
for(i = 0; i < palavra.length; i++) {
armax.push({letra: palavra.split(palavra.slice(i+1))[0].slice(i)})
}
pross = ""
total_armax = armax.length
for(a = 0; a < total_armax; a++) {
alex = Math.floor(Math.random()*armax.length)
pross += `${armax[alex].letra}`
armax.splice(alex, 1)
}
return pross
}

const morse = (XXX) => {
palavra = `${XXX} `
armax = []
for(i = 0; i < palavra.length; i++) {
armax.push({letra: palavra.split(palavra.slice(i+1))[0].slice(i).replace("√£", "a").replace("√°", "a").replace("√™", "e").replace("√©", "e").replace("√≠", "i").replace("√≥", "o").replace("√¥", "o").replace("√∫", "u")})
}
pross = ""
total_armax = armax.length
for(a = 0; a < total_armax; a++) {
alex = armax[a].letra.toLowerCase()
if(alex == " ") pross += ` `
if(alex == "a") pross += `- .-`
if(alex == "b") pross += `- -...`
if(alex == "c") pross += `- -.-.`
if(alex == "d") pross += `- -..`
if(alex == "e") pross += `- .`
if(alex == "f") pross += `- ..-.`
if(alex == "g") pross += `- --.`
if(alex == "h") pross += `- ....`
if(alex == "i") pross += `- ..`
if(alex == "j") pross += `- .---`
if(alex == "k") pross += `-.-.`
if(alex == "l") pross += `‚Äì .-..`
if(alex == "m") pross += `‚Äì --`
if(alex == "n") pross += `‚Äì-.`
if(alex == "o") pross += `‚Äì ---`
if(alex == "p") pross += `‚Äì .--.`
if(alex == "q") pross += `‚Äì --.-`
if(alex == "r") pross += `‚Äì .-.`
if(alex == "s") pross += `‚Äì ...`
if(alex == "t") pross += `‚Äì-`
if(alex == "u") pross += `--..`
if(alex == "v") pross += `‚Äì ‚Ä¶-`
if(alex == "w") pross += `--..-.`
if(alex == "x") pross += `-.- .. .-..  --.`
if(alex == "y") pross += `‚Äì.---`
if(alex == "z") pross += `‚Äì--..`
}
return pross
}

const romanN = (txt) => {
  nmr = Number(txt) ? txt : Number(txt)
  total = `${nmr}`
  if(nmr > 1 && !total.includes(`.`)) {
    if(total.length == 1) {
      if(nmr <= 3) alg = `I`.repeat(nmr)
      if(nmr == 4) alg = `IV`
      if(nmr == 5) alg = `V`
      if(nmr >= 6 && nmr != 9) alg = `V`+`I`.repeat(nmr-5)
      if(nmr == 9) alg = `IX`
    }
    if(total.length == 2) {
      dez = Number(total.slice(0, 1))
      um = Number(total.slice(1))
      if(dez <= 3) alg = `X`.repeat(dez)
      if(dez == 4) alg = `XL`
      if(dez == 5) alg = `L`
      if(dez >= 6 && dez != 9) alg = `L`+`X`.repeat(dez-5)
      if(dez == 9) alg = `XC`
      if(um <= 3) alg += `I`.repeat(um)
      if(um == 4) alg += `IV`
      if(um == 5) alg += `V`
      if(um >= 6 && um != 9) alg += `V`+`I`.repeat(um-5)
      if(um == 9) alg += `IX`
    }
    if(total.length == 3) {
      cem = Number(total.slice(0, 1))
      dez = Number(total.slice(1, 2))
      um = Number(total.slice(2))
      if(cem <= 3) alg = `C`.repeat(cem)
      if(cem == 4) alg = `CD`
      if(cem == 5) alg = `D`
      if(cem >= 6 && cem != 9) alg = `D`+`C`.repeat(cem-5)
      if(cem == 9) alg = `CM`
      if(dez <= 3) alg += `X`.repeat(dez)
      if(dez == 4) alg += `XL`
      if(dez == 5) alg += `L`
      if(dez >= 6 && dez != 9) alg += `L`+`X`.repeat(dez-5)
      if(dez == 9) alg += `XC`
      if(um <= 3) alg += `I`.repeat(um)
      if(um == 4) alg += `IV`
      if(um == 5) alg += `V`
      if(um >= 6 && um != 9) alg += `V`+`I`.repeat(um-5)
      if(um == 9) alg += `IX`
    }
    if(total.length > 3) {
      mil = Number(total.slice(0, total.length-3))
      cem = Number(total.slice(total.length-3, total.length-2))
      dez = Number(total.slice(total.length-2, total.length-1))
      um = Number(total.slice(total.length-1))
      alg = `M`.repeat(mil)
      if(cem <= 3) alg += `C`.repeat(cem)
      if(cem == 4) alg += `CD`
      if(cem == 5) alg += `D`
      if(cem >= 6 && cem != 9) alg += `D`+`C`.repeat(cem-5)
      if(cem == 9) alg += `CM`
      if(dez <= 3) alg += `X`.repeat(dez)
      if(dez == 4) alg += `XL`
      if(dez == 5) alg += `L`
      if(dez >= 6 && dez != 9) alg += `L`+`X`.repeat(dez-5)
      if(dez == 9) alg += `XC`
      if(um <= 3) alg += `I`.repeat(um)
      if(um == 4) alg += `IV`
      if(um == 5) alg += `V`
      if(um >= 6 && um != 9) alg += `V`+`I`.repeat(um-5)
      if(um == 9) alg += `IX`
    }
    return alg
  } else return `erro`
}

const realtime = () => {
tempo100 = Number(sendHours('MM'))
if(tempo100 == 1) mesAtt = "janeiro"
if(tempo100 == 2) mesAtt = "fevereiro"
if(tempo100 == 3) mesAtt = "mar√ßo"
if(tempo100 == 4) mesAtt = "abril"
if(tempo100 == 5) mesAtt = "maio"
if(tempo100 == 6) mesAtt = "junho"
if(tempo100 == 7) mesAtt = "julho"
if(tempo100 == 8) mesAtt = "agosto"
if(tempo100 == 9) mesAtt = "setembro"
if(tempo100 == 10) mesAtt = "outubro"
if(tempo100 == 11) mesAtt = "novembro"
if(tempo100 == 12) mesAtt = "dezembro"
return `${sendHours('HH')} hora${Number(sendHours('HH')) !== 1 ? "s" : ""}, ${sendHours('mm')} minuto${Number(sendHours('mm')) !== 1 ? "s" : ""} e ${sendHours('ss')} segundo${Number(sendHours('ss')) !== 1 ? "s" : ""} do dia ${sendHours('DD')} de ${mesAtt} de ${sendHours('YYYY')}`
}

const envPV = (texto) => {
blackmd.sendMessage(sender, {text: texto})
}

const envImagePV = (link, mark) => {
blackmd.sendMessage(sender, {image: {url: link}}, {quoted: infoark})
}

const sendSticker = (from, filename, info) => {
blackmd.sendMessage(from, {sticker: {url: fileName}}, {quoted: info})
}

async function sendContact(id, nome1, nome2, nmr) {
nmr1 = `${nmr.split('@')[0].replace(new RegExp("[()+-/ +/]", "gi"), "")}`
nmr2 = "+" + nmr1.slice(0, 2) + " " + nmr1.slice(2, 4) + " " + nmr1.slice(4, nmr1.length - 4) + "-" + nmr1.slice(nmr1.length - 4, nmr1.length)
vcard = 'BEGIN:VCARD\n' // metadata of the contact card
            + 'VERSION:3.0\n' 
            + `FN: ${nome1}\n` // full name
            + `ORG: ${nome2};\n` // the organization of the contact
            + `TEL;type=CELL;type=VOICE;waid=${nmr1}:${nmr2}\n` // WhatsApp ID + phone number
            + 'END:VCARD'
await blackmd.sendMessage(id, {contacts: {  displayName: nome1,  contacts: [{ vcard }] }})
}

async function sendUrlText(id, texto, title, desc, foto, link, hehe) {
menc = []
sp = texto.split(` `)
for(i of sp) {
if(i.includes(`@`)) menc.push(identArroba(i))
}
blackmd.sendMessage(id, {text: texto, contextInfo: {mentionedJid: menc, externalAdReply: {title: title, body: desc, thumbnail: await getBuffer(foto), mediaType: 1, showAdAttribution: true, sourceUrl: link}}}, {quoted: hehe})
}

async function sendUrlText2(id, texto, title, desc, foto, link, hehe) {
blackmd.sendMessage(id, {text: texto, contextInfo: {externalAdReply: {title: title, body: desc, thumbnail: await getBuffer(foto), mediaType: 1, renderLargerThumbnail: true, showAdAttribution: true, sourceUrl: link}}}, {quoted: hehe})
}

async function sendUrlDoc(id, txt, tipo, titulo, tamanho, nome, desc, thumb, link, hehe) {
menc = []
sp = txt.split(` `)
for(i of sp) {
if(i.includes(`@`)) menc.push(identArroba(i))
}
blackmd.sendMessage(id, {document: Buffer.from('oi curioso'), caption: txt, mimetype: tipo, fileName: titulo, fileLength: 1000000 * Number(tamanho), contextInfo: {mentionedJid: menc, externalAdReply: {title: nome, body: desc, mediaType: 1, thumbnail: await getBuffer(thumb), showAdAttribution: true, renderLargerThumbnail: true, sourceUrl: link}}}, {quoted: hehe})
}

function sendChannelText(id, txt, channel, name, hehe) {
menc = []
sp = txt.split(` `)
for(i of sp) {
if(i.includes(`@`)) menc.push(identArroba(i))
}
blackmd.sendMessage(id, {text: txt, mentions: menc, contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: name}}}, {quoted: hehe})}

function sendChannelImage(id, img, txt, channel, hehe) {
menc = []
sp = txt.split(` `)
for(i of sp) {
if(i.includes(`@`)) menc.push(identArroba(i))
}
blackmd.sendMessage(id, {image: {url: img}, caption: txt, mentions: menc, contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: name}}}, {quoted: hehe})}

const sendVideo = (id, link, desc, hehe) => {
  return blackmd.sendMessage(id, {video: {url: link}, caption: desc, mentions: [sender], mimetype: 'video/mp4'}, {quoted: hehe})
}

const sendAudio = (id, link, tipo, hehe) => {
  return blackmd.sendMessage(id, {audio: {url: link}, mimetype: tipo}, {quoted: hehe})
}

const sendImage = (id, ytb, cap, hehe) => {
blackmd.sendMessage(id, {image: {url: ytb}, caption: cap}, {quoted: hehe})
}

const sendMess = (hehe, ytb, yah) => {
menc = []
sp = ytb.split(`\n`).join(` `).split(` `)
for(i of sp) {
if(i.includes(`@`)) menc.push(identArroba(i))
}
blackmd.sendMessage(hehe, {text: ytb, mentions: menc}, {quoted: yah})
}

const sendMenu = (cap) => {
blackmd.sendMessage(from, {image: {url: logoslink.logo}, caption: cap, mentions: [sender]}, {quoted: seloctt})
}

function sendMenuPrime() {if(isAudioMenu) {blackmd.sendMessage(from, {audio: {url:'./database/audios/audiomenu.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: seloctt})}
const { menuprime } = require("./dono/menus/comandos.js")
menutxt = menuprime(pushname, date, hora120, isVip, pushnames, prefix)
sendUrlDoc(from, menutxt, `application/vnd.android.package-archive`, `Ladybot v5`, 99000000, NomeDoBot, ``, logoslink.menu, site)}

const mentions = (teks, memberr, id) => {
(id == null || id == undefined || id == false) ? blackmd.sendMessage(from, {text: teks.trim(), mentions: memberr}) : blackmd.sendMessage(from, {text: teks.trim(), mentions: memberr})
}
	
const mention = (teks= '', ms = info) => {
memberr = []
vy = teks.includes('\n') ? teks.split('\n') : [teks]
for(vz of vy){ for(zn of vz.split(' ')){
if(zn.includes('@'))memberr.push(parseInt(zn.split('@')[1])+'@s.whatsapp.net')
}}
blackmd.sendMessage(from, {text: teks.trim(), mentions: memberr}, {quoted: info}) 
}

const mencionarIMG = (teks= '', Url, ms) => {
memberr = []
vy = teks.includes('\n') ? teks.split('\n') : [teks]
for(vz of vy){ for(zn of vz.split(' ')){
if(zn.includes('@'))memberr.push(parseInt(zn.split('@')[1])+'@s.whatsapp.net')
}}
blackmd.sendMessage(from, {image: {url: Url}, caption: teks.trim(), mentions: memberr}, {quoted: info}) 
}

const reagir = async (idgp, emj) => {
var reactionMessage = {
react: {
text: emj, 
key: info.key
}
} 
blackmd.sendMessage(idgp, reactionMessage)
}

const verificarN = async(sla) => {
const [result] = await blackmd.onWhatsApp(sla)
if(result == undefined) {
reply("Este usu√°rio n√£o √© existente no WhatsApp")
} else {
reply(`-> ${sla} N√∫mero inserido √© existente no WhatsApp.\n\ncom o id: ${result.jid}`)
}
}

if(isGroup && isBotGroupAdmins && !isGroupAdmins && !isOwner && !info.key.fromMe) {
if(menc_jid2?.length >= groupMembers.length - 1) { 
if(isGroupAdmins) return reply(`Ala, usando marca√ß√£o de imune lixo kkkkk tua sorte √© que tu √© adm üëÄ`)
blackmd.sendMessage(from, {text: "Acha mesmo que voc√™ vai sair marcando todo mundo com esse imune lixo a√≠ ? kkk sinta o poder do BAN üó£Ô∏è"})
blackmd.sendMessage(from, {audio: {url:'./database/audios/ban.m4a'}, mimetype: 'audio/mp4', ptt:true})
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
blackmd.groupParticipantsUpdate(from, [sender], "remove")
}
}

const enviarfigu = async (figu, tag) => {
blackmd.sendMessage(from, {sticker: {url: figu}}, {quoted: tag})
}

if(isAutofigu && isGroup) {
async function autofiguf() {
setTimeout(async() => {    

if(budy.includes(`${prefix}sticker`) || budy.includes(`${prefix}s`) || budy.includes(`${prefix}stk`) || budy.includes(`${prefix}st`) || budy.includes(`${prefix}fsticker`) || budy.includes(`${prefix}f`) || budy.includes(`${prefix}fstiker`)) return

if(type == 'imageMessage') {
var pack =`${pushname}`
var author2 = `${NomeDoBot}`
owgi = await getFileBuffer(info.message.imageMessage, 'image')
let encmediaa = await sendImageAsSticker2(blackmd, from, owgi, info, {packname: permuteFigPackName(pack), author: permuteFigAuthorName(author2)})
DLT_FL(encmediaa)
}

if(type == 'videoMessage') {
if((isMedia && info.message.videoMessage.seconds < 10)){
var pack =`${pushname}`
var author2 = `${NomeDoBot}`
owgi = await getFileBuffer(info.message.videoMessage, 'video')
let encmedia = await sendVideoAsSticker2(blackmd, from, owgi, info, {packname: permuteFigPackName(pack), author: permuteFigAuthorName(author2)})
DLT_FL(encmedia)
}
} 
}, 1000)
}
autofiguf().catch(e => {
console.log(e)
})
}

var nmrdnofc1 = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "")

const semana = sendHours("dddd")

if(isOwner && budy.includes("reiniciar-lady") || info.key.fromMe && budy.includes("reiniciar-bot")) {
fs.writeFileSync("./cnt-upd.json",JSON.stringify([], null, 2))
setTimeout(() => {
file = require.resolve("./start.js")  
delete require.cache[file]
require(file)  
}, 500)
setTimeout(() => {
DLT_FL("./cnt-upd.json")
}, 1500)
}

//========================================\\

if(isGroup && !isJsonIncludes(openclosegp, from)) rgGroupOCfunc(from)

if(isGroup && !isJsonIncludes(ads, from)) addGroupInAds(from)

if(isGroup && !isJsonIncludes(paidHours, from)) addGroupInPaid(from)

if(isGroup && !isJsonIncludes(groupLinkPaid, from)) addGroupLinkInPaid(blackmd, from)

async function paidFunc() {
    if(paidHours.length > 0) {
        totalpaid = 0
        for(p of paidHours) {
            if(p.horarios.length > 0) totalpaid += 1
        }
        if(totalpaid > 0) {
            try {
                ABC = await fetchJson(`https://blacksystemofc.com.br/vip/horarios?apikey=black`)
                for(a of paidHours) {
                    if(a.horarios.length > 0 && a.start) {
                        for(b of a.horarios) {
                            if(b.dias <= 0) {
                                if(contarMin(sendHours(`HH:mm`)) >= contarMin(b.tempo)) {
                                    multiplicador = b.nmr
                                    if(b.letra == `h`) multiplicador *= 60
                                    atual = sendHours(`HH:`) + (b.letra == `m` ? !String(b.nmr / 5).includes(`.`) ? String(Number(sendHours(`mm`)) - (Number(sendHours(`mm`)) % 5)) : sendHours(`mm`) : `00`)
                                    soma = contarMin(atual) + multiplicador
                                    if(soma >= 1440) {
                                        b.tempo = converterMin(soma % 1440)
                                        savePaid()
                                        b.dias += (soma - (soma % 1440)) / 1440
                                        savePaid()
                                    } else {
                                        b.tempo = converterMin(soma)
                                        savePaid()
                                    }
                                    blackmd.sendMessage(a.groupId, {image: {url: getGroupLinkFromPaidID(a.groupId)}, caption: `üçÄ *HOR√ÅRIOS PAGANTES DAS ${sendHours("HH")}h* üí∞

${ABC.resultado.map(h => `*${h.name}*
${h.times.map(p => `‚•≤ ${p}`).join(`\n`)}`).join(`\n\n`)}

${ABC.dica}`, contextInfo: {forwardingScore: 999, isForwarded: true}})
                                }
                            } else {
                                if(Number(sendHours(`DD`)) !== Number(b.save)) {
                                    b.save = sendHours(`DD`)
                                    savePaid()
                                    b.dias -= 1
                                    savePaid()
                                }
                            }
                        }
                    }
                }
            } catch(e) {console.log(e)}
        }
    }
}

//executores de ambas as fun√ß√µes
if(body != undefined && from != undefined) { rentContSystem(blackmd, sendMess, tempo); cardTime(blackmd, tempo); ABRIR_E_FECHAR_GRUPO(blackmd); adsFunc(blackmd); paidFunc(); }

//BAN GRUPO & BOT OFF
if(isGroup && isCmd && isBanchat && !isOwner) return

if(isGroup && isCmd && isAntiMembros && !isOwner && !isGroupAdmins) return

if(isBotoff && !isOwner) return

let isCmdKey = Array(`alugar`, `aluguel`, `recarga`, `recarregar`, `rp`, `me`, `buygp`, `buycort`, `buykeygp`, `buyvip`, `buyvipgp`, `buycard`, `buycardxp`, `reembolsar`, `loja`, `store`, `lojalista`, `storelist`, `transferirgp`).some(item => item === command)

if(isCmd && isCmdKey) registrarUsuInVirtualBalance(sender)

bannedExpired()

if(isCmd) isBannedMessageUsu(from, sender, blackmd, `[‚ùó] Aten√ß√£o @${sender.split("@")[0]}, voc√™ est√° impedido de usar o bot... Caso tenha alguma d√∫vida, chame meu dono para saber o pq üìµ`)

if(isBanned(sender)) return

if(isGroup && isCmd && !isOwner && !isCmdKey && isModRent) {
  if(!isSaveGroup(from)) addGroupInRent(from)
  gp = getSaveGroup(from)
  if(!gp.validado && !isGroupInRent(from)) {
    if(gp.limite <= 1) {
      rmGroupInRent(from)
      reply(`Visto que os senhores n√£o se v√™em interessados em adquirir uma key, vou indo...`)
      await sleep(3000)
      return blackmd.groupLeave(from)
    } else {
      gp.limite -= 1
      saveGroupsRent()
      return reply(`‚úãüèΩüò≥ü§öüèΩ PAROU !! N√£o encontrei esse grupo em meus registros... Pfvr, caso o mesmo seja alugado, ser√° necess√°rio o uso de uma chave de acesso para ativar os comandos. Caso n√£o tenha uma, podes comprar no comando ${prefix}buykeygp`)
    }
  }
}

if(isGroup && !isOwner && isModRent && !existKeyRentSystem(body) && !isJsonIncludes(grupos, from) && !isJsonIncludes(aluguel, from)) return

if(isGroup && isCmd) {
  caixa = []
  for(i of allCases) {
    if(type == "conversation" && command == i) caixa.push(i)
  }
  if(caixa.length > 0) {
    var contadorcmd = 0
    for(c of rankcmd) {
      if(caixa[0] == c.cmd) {
        c.usado += 1
        saveJSON(rankcmd, "./basededados/rankcmd.json")
        contadorcmd += 1
      }
    }
    if(contadorcmd <= 0) {
      rankcmd.push({cmd: caixa[0], usado: 1})
      saveJSON(rankcmd, "./basededados/rankcmd.json")
    }
  }
}

//=======================================\\

const sendStickerFromUrl = async(to, url) => {
try {
var names = Date.now() / 10000;
var download = function (uri, filename, callback) {
request.head(uri, function (err, res, body) {
request(uri).pipe(fs.createWriteStream(filename)).on('close', callback);
});
};
download(url, './sticker' + names + '.png', async function () {
console.log('enviando sticker');
let filess = './sticker' + names + '.png'
let asw = './sticker' + names + '.webp'
exec(`ffmpeg -i ${filess} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${asw}`, (err) => {
let media = fs.readFileSync(asw)
blackmd.sendMessage(to, {sticker: media}, {sendEphemeral: true, contextInfo: { forwardingScore: 50, isForwarded: true}, quoted: seloctt}).catch(e => {
return reply("Erro..")
})
DLT_FL(filess)
DLT_FL(asw)
});
});
} catch {
return reply("Erro.. FNC")
}
}

const sendStickerFromImageLink = async(id, image, packname, author, hehe) => {
  img = await prepareWAMessageMedia({image: image}, {upload: blackmd.waUploadToServer})
  getfile = await getFileBuffer(img, `image`)
  envst = await sendImageAsSticker(blackmd, from, getfile, hehe, {packname: packname, author: author})
  DLT_FL(envst)
}

//=========(isQuoted/consts)=============\\
const isImage = type == 'imageMessage'
const isVideo = type == 'videoMessage'
const isVisuU2 = type == 'viewOnceMessageV2'
const isAudio = type == 'audioMessage'
const isSticker = type == 'stickerMessage'
const isContact = type == 'contactMessage'
const isLocation = type == 'locationMessage'
const isProduct = type == 'productMessage'
const isMedia = (type === 'imageMessage' || type === 'videoMessage' || type === 'audioMessage' || type == "viewOnceMessage" || type == "viewOnceMessageV2")
typeMessage = body.substr(0, 50).replace(/\n/g, '')
if(isImage) typeMessage = "Image"
else if(isVideo) typeMessage = "Video"
else if(isAudio) typeMessage = "Audio"
else if(isSticker) typeMessage = "Sticker"
else if(isContact) typeMessage = "Contact"
else if(isLocation) typeMessage = "Location"
else if(isProduct) typeMessage = "Product"

const isQuotedMsg = type === 'extendedTextMessage' && content.includes('conversation')

const isQuotedMsg2 = type === 'extendedTextMessage' && content.includes('text')

const isQuotedImage = type === 'extendedTextMessage' && content.includes('imageMessage')

const isQuotedVisuU = type === 'extendedTextMessage' && content.includes('viewOnceMessage')

const isQuotedVisuU2 = type === 'extendedTextMessage' && content.includes('viewOnceMessageV2')

const isQuotedVideo = type === 'extendedTextMessage' && content.includes('videoMessage')

const isQuotedDocument = type === 'extendedTextMessage' && content.includes('documentMessage')

const isQuotedDocW = type === 'extendedTextMessage' && content.includes('documentWithCaptionMessage')

const isQuotedAudio = type === 'extendedTextMessage' && content.includes('audioMessage')

const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')

const isQuotedContact = type === 'extendedTextMessage' && content.includes('contactMessage')

const isQuotedLocation = type === 'extendedTextMessage' && content.includes('locationMessage')

const isQuotedProduct = type === 'extendedTextMessage' && content.includes('productMessage')
            
//////BLOCK CMD///////
//(CREDITOS AO KAUAN GAY)\\
if(isGroup){
const checar = getComandos(from)
if(checar === undefined) addComandosId(from)
}
if(isGroup && isCmd && !isOwner && !isnit && getComandoBlock(from).includes(command)) return reply('‚ö†Ô∏è *COMANDO BLOQUEADO* ‚ö†Ô∏è')

if(isGroup && isCmd && isStopCmd && isBlockGlobalCmd(command) && !isOwner) return reply("‚ö†Ô∏è *INDISPON√çVEL TEMPORARIAMENTE* ‚ö†Ô∏è")

if(isGroup) {
  if(!isJsonIncludes(limitcmd, from)) rgGroupLC(from)
  if(isCmd && !isOwner) {
    getcmd = isLimitCmd(from, command)
    if(getcmd.boolean) {
      if(isMaxUsageLC(from, command)) return reply(`‚ö† _Este comando atingiu o m√°ximo de uso neste grupo por hoje... Por favor, volte amanh√£_ ü•∞`)
      addCmdUsageLC(from, command)
    }
  }
}

nextDayLC();

aniversarioDeNamoroOuCasamento(blackmd);

////FIMMMMMMMMM/////
if(isConsole) {
if(isGroup && info.message?.reactionMessage?.text) {
console.log(colors.cyan(`
‚ïì‚îÄ‚îÅ${"‚éì‚éî".repeat(20)}‚éì‚îÅ‚îÄ‚îí
‚î¢‚ïï\t\t${colors.white(NomeDoBot)}
‚ïΩ‚ïü ‚Ä¢ usu√°rio ~> ${colors.brightYellow(pushname)}
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ n√∫mero ~> ${colors.brightMagenta(sender.includes(`status`) ? `status` : addNumberMais(sender))}
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ grupo ~> ${isGroup ? colors.blue(groupName) : colors.red(`"privado"`)}
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ rea√ß√£o ~>„Äé ${info.message.reactionMessage.text} „Äè
‚îï‚ï®${"‚öã".repeat(44)}‚îö
`))
} else if(isGroup && !isCmd) {
console.log(colors.cyan(`
‚ïì‚îÄ‚îÅ${"‚éì‚éî".repeat(20)}‚éì‚îÅ‚îÄ‚îí
‚î¢‚ïï\t\t${colors.white(NomeDoBot)}
‚ïΩ‚ïü ‚Ä¢ usu√°rio ~> ${colors.brightYellow(pushname)}
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ n√∫mero ~> ${colors.brightMagenta(sender.includes(`status`) ? `status` : addNumberMais(sender))}
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ grupo ~> ${colors.blue(groupName)}
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ tipo ~> ${colors.white(type == "stickerMessage" ? `"figurinha"` : type == "documentMessage" ? `"documento"` : type == "locationMessage" ? `"localiza√ß√£o"` : type == "audioMessage" ? `"√°udio"` : type == "videoMessage" ? `"v√≠deo"` : type == "imageMessage" ? `"imagem"` : `"mensagem"`)}
‚îï‚ï®${"‚öã".repeat(44)}‚îö
`))
} else if(isCmd && !isGroup) {
console.log(colors.cyan(`
‚ïì‚îÄ‚îÅ${"‚éì‚éî".repeat(20)}‚éì‚îÅ‚îÄ‚îí
‚î¢‚ïï\t\t${colors.white(NomeDoBot)}
‚ïΩ‚ïü ‚Ä¢ usu√°rio ~> ${colors.brightYellow(pushname)}
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ n√∫mero ~> ${colors.brightMagenta(sender.includes(`status`) ? `status` : addNumberMais(sender))}
‚ïΩ‚ïë
‚ïΩ‚ïë„Äé ${colors.red("privado")} „Äè
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ comando ~> ${colors.white(prefix+command)}
‚îï‚ï®${"‚öã".repeat(44)}‚îö
`)) 
} else if(isCmd && isGroup) {
console.log(colors.cyan(`
‚ïì‚îÄ‚îÅ${"‚éì‚éî".repeat(20)}‚éì‚îÅ‚îÄ‚îí
‚î¢‚ïï\t\t${colors.white(NomeDoBot)}
‚ïΩ‚ïü ‚Ä¢ usu√°rio ~> ${colors.brightYellow(pushname)}
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ n√∫mero ~> ${colors.brightMagenta(sender.includes(`status`) ? `status` : addNumberMais(sender))}
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ grupo ~> ${colors.blue(groupName)}
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ comando ~> ${colors.white(prefix+command)}
‚îï‚ï®${"‚öã".repeat(44)}‚îö
`))
} else {
console.log(colors.cyan(`
‚ïì‚îÄ‚îÅ${"‚éì‚éî".repeat(20)}‚éì‚îÅ‚îÄ‚îí
‚î¢‚ïï\t\t${colors.white(NomeDoBot)}
‚ïΩ‚ïü ‚Ä¢ usu√°rio ~> ${colors.brightYellow(pushname)}
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ n√∫mero ~> ${colors.brightMagenta(sender.includes(`status`) ? `status` : addNumberMais(sender))}
‚ïΩ‚ïë
‚ïΩ‚ïë„Äé ${colors.red("privado")} „Äè
‚îï‚ï®${"‚öã".repeat(44)}‚îö
`))
}
}

//======(JOGO-DA-VELHA)=======(Fun√ß√£o)===\\

async function joguinhodavelha() {
if(joguinhodavelhajs2.includes(from) || joguinhodavelhajs.includes(sender)) {
const cmde = budy.toLowerCase().split(" ")[0] || "";
let arrNum = ["1", "2", "3", "4", "5", "6", "7", "8", "9"];
if(fs.existsSync(`./armor/tictactoe/db/${from}.json`)) {
const boardnow = setGame(`${from}`);
if(budy == "Cex") return reply("why");
if(
budy.toLowerCase() == "s" ||
budy.toLowerCase() == "sim" ||
budy.toLowerCase() == "ok"
) {
if(boardnow.O == sender.replace("@s.whatsapp.net", "")) {
if(boardnow.status)
return reply(`O jogo j√° come√ßou antes!`);
const matrix = boardnow._matrix;
boardnow.status = true;
fs.writeFileSync(`./armor/tictactoe/db/${from}.json`,
JSON.stringify(boardnow, null, 2)
);
const chatAccept = `*üéÆ·èÄÃ∏·é™Ã∏·é∑Ã∏·é¨Ã∏ ·é†Ã∏·é™Ã∏ ·èôÃ∏·é¨Ã∏·èûÃ∏·éªÃ∏·é™Ã∏üïπÔ∏è*
                    
‚ùå : @${boardnow.X}
‚≠ï : @${boardnow.O}
               
Sua vez... : @${boardnow.turn == "X" ? boardnow.X : boardnow.O}

${matrix[0][0]}  ${matrix[0][1]}  ${matrix[0][2]}
${matrix[1][0]}  ${matrix[1][1]}  ${matrix[1][2]}
${matrix[2][0]}  ${matrix[2][1]}  ${matrix[2][2]}
`;
mention(chatAccept);
}
} else if(
budy.toLowerCase() == "n" ||
budy.toLowerCase() == "n√£o" ||
budy.toLowerCase() == "no"
) {
if(boardnow.O == sender.replace("@s.whatsapp.net", "")) {
if(boardnow.status)
return reply(`O jogo j√° come√ßou!`);
DLT_FL(`./armor/tictactoe/db/${from}.json`);
mention(`@${boardnow.X} *_Infelizmente seu oponente n√£o aceitou o desafio ‚ùåüòï_*`)
joguinhodavelhajs.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
}
}
}

if(arrNum.includes(cmde)) {
const boardnow = setGame(`${from}`);
if(!boardnow.status) return reply(`Parece que seu oponente n√£o aceitou o desafio ainda...`)
if(
(boardnow.turn == "X" ? boardnow.X : boardnow.O) !=
     
sender.replace("@s.whatsapp.net", "")
)
return;
const moving = validmove(Number(budy), `${from}`);
const matrix = moving._matrix;
if(moving.isWin) {
if(moving.winner == "SERI") {
const chatEqual = `*üéÆ·èÄÃ∏·é™Ã∏·é∑Ã∏·é¨Ã∏ ·é†Ã∏·é™Ã∏ ·èôÃ∏·é¨Ã∏·èûÃ∏·éªÃ∏·é™Ã∏üïπÔ∏è*
          
Jogo termina empatado üòê
`;
reply(chatEqual);
DLT_FL(`./armor/tictactoe/db/${from}.json`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs)) 
joguinhodavelhajs2.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
return;
}
const abt = Math.ceil(Math.random() + 4000)
const winnerJID = moving.winner == "O" ? moving.O : moving.X;
const looseJID = moving.winner == "O" ? moving.X : moving.O;
const limWin = Math.floor(Math.random() * 1) + 10;
const limLoose = Math.floor(Math.random() * 1) + 5;
const chatWon = `*üéÆ·èÄÃ∏·é™Ã∏·é∑Ã∏·é¨Ã∏ ·é†Ã∏·é™Ã∏ ·èôÃ∏·é¨Ã∏·èûÃ∏·éªÃ∏·é™Ã∏üïπÔ∏è*
          
Vencido por @${winnerJID} üòéüëë
`;

blackmd.sendMessage(from, {text: chatWon, mentions: [identArroba(winnerJID)]}, {quoted: seloctt,
mentions: [
moving.winner == "O" ?
moving.O + "@s.whatsapp.net" :
moving.X + "@s.whatsapp.net"]
});
setTimeout( () => {
if(fs.existsSync("./armor/tictactoe/db/" + from + ".json")) {
DLT_FL("./armor/tictactoe/db/" + from + ".json");
reply(`*üïπÔ∏èJOGO DA VELHA RESETADO... üïπÔ∏è*

*‚ö†Ô∏è JOGADORES DEMORARAM MUITO ‚ö†Ô∏è*`);
} else {
console.log(colors.red(time, "red"), colors.magenta("[ EXPIRADO ]"), colors.red('Jogo da velha espirado'));
}
joguinhodavelhajs.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
}, 300000) //5 minutos
DLT_FL(`./armor/tictactoe/db/${from}.json`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs)) 
joguinhodavelhajs2.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
} else {
const chatMove = `*üéÆ·èÄÃ∏·é™Ã∏·é∑Ã∏·é¨Ã∏ ·é†Ã∏·é™Ã∏ ·èôÃ∏·é¨Ã∏·èûÃ∏·éªÃ∏·é™Ã∏üïπÔ∏è*
          
‚ùå : @${moving.X}
‚≠ï : @${moving.O}

Sua vez : @${moving.turn == "X" ? moving.X : moving.O}

${matrix[0][0]}  ${matrix[0][1]}  ${matrix[0][2]}
${matrix[1][0]}  ${matrix[1][1]}  ${matrix[1][2]}
${matrix[2][0]}  ${matrix[2][1]}  ${matrix[2][2]}
`;
mention(chatMove);
}
} 
} 
}

//=================================\\

joguinhodavelha()

if(isGroup && !isGroupAdmins && !isOwner && info?.message?.requestPaymentMessage && isBotGroupAdmins) {
  fechargp(from)
  await sleep(1500)
  remover(from, sender)
  await sleep(2000)
  for(i = 0; i < 5; i++) {
    await sleep(500)
    sendMess(from, `${`\t`.repeat(10)}\n${i == 4 ? "LIMPEZA CONCLU√çDA üóëÔ∏è" : ""}`.repeat(50))
  }
  await sleep(1500)
  abrirgp(from)
}

if(isGroup) {
  notGroupRegisteredSALGP(from);
  notGroupRegisteredSALHARD(from);
}

if(isAntilinkgp && isGroup && isBotGroupAdmins && !isGroupAdmins) {
  if(Procurar_String.includes("chat.whatsapp.com/")){
    if(isBot) return 
    link_dgp = await blackmd.groupInviteCode(from)
    if(Procurar_String.match(link_dgp)) return reply(`Como esse √© o link do nosso grupo, n√£o irei remover... Voc√™ deu sorte dessa vez üò∞`)
    if(!JSON.stringify(groupMembers).includes(sender)) return
    function delgp() {blackmd.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})}
    //aqui come√ßa o escudo anti link
    if(isShieldGPuser(from, sender)) {
      pessoa = getShieldGPuser(from, sender)
      isInfinity = pessoa.infinito
      if(isInfinity) {
        delgp()
        await sleep(2000)
        return sendMess(from, `Sem links pfvr ${pushname}...`)
      } else {
        if(pessoa.quant > 0) {
          pessoa.quant -= 1
          saveSALGP();
          await sleep(2000)
          nmr = getShieldGPuser(from, sender).quant + 1
          return sendMess(from, `Anti link GP est√° ativado ${pushname}... Pra sua sorte, voc√™ ainda tem direito a enviar +${nmr} link${nmr != 1 ? `s` : ``} ü•∞`)
        } else {
          rmShieldGP(from, sender)
          delgp()
          await sleep(1000)
          remover(from, sender)
          await sleep(1000)
          return sendMess(from, `Suas chances acabaram ${pushname}... Falta de aviso n√£o foi üò™`)
        }
      }
    } else if(!isBanlinkgp) {
      delgp()
      await sleep(1500)
      AB = dataGp[0].advertir.map(i => i.id).indexOf(sender)
      if(AB >= 0) {
        if(dataGp[0].advertir[AB].adv < 2) {
          dataGp[0].advertir[AB].adv += 1
          setGp(dataGp)
          return blackmd.sendMessage(from, {text: `[‚ùó] Aten√ß√£o @${sender.split("@")[0]}, voc√™ foi advertido ${dataGp[0].advertir[AB].adv} vezes... O pr√≥ximo envio de link resultar√° em banimento üí¢`, mentions: [sender]})
        } else {
          blackmd.sendMessage(from, {text: `[‚ùó] Voc√™ n√£o me deu escolha @${sender.split("@")[0]}... Por desacato a autoridade, irei te aplicar a devida puni√ß√£o üí¢`, mentions: [sender]})
          dataGp[0].advertir.splice(AB, 1)
          setGp(dataGp)
          await sleep(1500)
          return remover(from, sender)
        }
      } else {
        dataGp[0].advertir.push({id: sender, adv: 1})
        setGp(dataGp)
        return blackmd.sendMessage(from, {text: `[‚ùó] Aten√ß√£o @${sender.split("@")[0]}, √© terminantemente proibido o envio de links neste grupo... Por sorte, o sistema de ban est√° desativado, mas isso n√£o lhe isenta de ser advertido üí¢`, mentions: [sender]})
      }
    } else {
      blackmd.sendMessage(from, {text: `[‚ùó] aplicando puni√ß√£o ao usu√°rio @${sender.split("@")[0]} por enviar link ‚ùå`, mentions: [sender]})
      await sleep(1000)
      remover(from, sender)
      await sleep(1000)
      delgp()
    }
  }
}

if(isUrl(PR_String) && isAntiLinkHard && !isGroupAdmins && isBotGroupAdmins && !info.key.fromMe) {
  if(Procurar_String.includes("chat.whatsapp.com")) {
    link_dgp = await blackmd.groupInviteCode(from)
    if(Procurar_String.match(link_dgp)) return reply('Link do nosso grupo, n√£o irei remover.. ') 
  }
  if(isCmd && isTrueFalse) return
  if(!JSON.stringify(groupMembers).includes(sender)) return
  function delhard() {blackmd.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})}
  //aqui come√ßa o escudo anti link
  if(isShieldHARDuser(from, sender)) {
    pessoa = getShieldHARDuser(from, sender)
    isInfinity = pessoa.infinito
    if(isInfinity) {
      delhard()
      await sleep(2000)
      return sendMess(from, `Sem links pfvr ${pushname}...`)
    } else {
      if(pessoa.quant > 0) {
        pessoa.quant -= 1
        saveSALHARD();
        await sleep(2000)
        nmr = getShieldHARDuser(from, sender).quant + 1
        return sendMess(from, `Anti link HARD est√° ativado ${pushname}... Pra sua sorte, voc√™ ainda tem direito a enviar +${nmr} link${nmr != 1 ? `s` : ``} ü•∞`)
      } else {
        rmShieldHARD(from, sender)
        delhard()
        await sleep(1000)
        remover(from, sender)
        await sleep(1000)
        return sendMess(from, `Suas chances acabaram ${pushname}... Falta de aviso n√£o foi üò™`)
      }
    }
  } else if(!isBanLinkHard) {
    delhard()
    await sleep(1500)
    AB = dataGp[0].advertir.map(i => i.id).indexOf(sender)
    if(AB >= 0) {
      if(dataGp[0].advertir[AB].adv < 2) {
        dataGp[0].advertir[AB].adv += 1
        setGp(dataGp)
        return blackmd.sendMessage(from, {text: `[‚ùó] Aten√ß√£o @${sender.split("@")[0]}, voc√™ foi advertido ${dataGp[0].advertir[AB].adv} vezes... O pr√≥ximo envio de link resultar√° em banimento üí¢`, mentions: [sender]})
      } else {
        blackmd.sendMessage(from, {text: `[‚ùó] Voc√™ n√£o me deu escolha @${sender.split("@")[0]}... Por desacato a autoridade, irei te aplicar a devida puni√ß√£o üí¢`, mentions: [sender]})
        dataGp[0].advertir.splice(AB, 1)
        setGp(dataGp)
        await sleep(1500)
        return remover(from, sender)
      }
    } else {
      dataGp[0].advertir.push({id: sender, adv: 1})
      setGp(dataGp)
      return blackmd.sendMessage(from, {text: `[‚ùó] Aten√ß√£o @${sender.split("@")[0]}, √© terminantemente proibido o envio de links neste grupo... Por sorte, o sistema de ban est√° desativado, mas isso n√£o lhe isenta de ser advertido üí¢`, mentions: [sender]})
    }
  } else {
    blackmd.sendMessage(from, {text: `[‚ùó] aplicando puni√ß√£o ao usu√°rio @${sender.split("@")[0]} por enviar link ‚ùå`, mentions: [sender]})
    await sleep(1000)
    remover(from, sender)
    await sleep(1000)
    delhard()
  }
}

if(isCmd && !isVip) {
if(isFiltered(sender)) {
return mention(`üõë Para evitar spam, aguarde 5s @${sender.split("@")[0]} üìµ`)
} else {
addFilter(sender)
}
}

const allGroupIDcountMessage = [];
for(i of countMessage) {
allGroupIDcountMessage.push(i.groupId);
}

const isGroupCountMessage = (grupo = from) => {return allGroupIDcountMessage.indexOf(grupo) >= 0 ? true : false}

const getCountGroupMessage = isGroup && allGroupIDcountMessage.indexOf(from) >= 0 ? countMessage[allGroupIDcountMessage.indexOf(from)] : {}

const usuInCountMessage = (usu = sender) => {
  if(!isGroupCountMessage(from)) return false
  return isJsonIncludes(getCountGroupMessage.participants, usu)
}

const getUsuCountMessage = (usu = sender) => {
  AB = getCountGroupMessage.participants.map(i => i.id).indexOf(usu)
  return getCountGroupMessage.participants[AB]
}

//========(CONTADOR-DE-MENSAGENS)========\\
if(budy2 != undefined && isGroup) {
  if(!isJsonIncludes(countMessage, from)) {
    countMessage.push({groupId: from, participants: []})
    saveJSON(countMessage, `./basededados/countmsg.json`)
  } else {
    AB = countMessage.map(a => a.groupId).indexOf(from)
    if(!isJsonIncludes(countMessage[AB].participants, sender)) {
      countMessage[AB].participants.push({id: sender, mensagens: 0, comandos: 0})
      saveJSON(countMessage, `./basededados/countmsg.json`)
    } else {
      AC = countMessage[AB].participants.map(b => b.id).indexOf(sender)
      usu = countMessage[AB].participants[AC]
      msg = 0
      cmd = 0
      if(isCmd) cmd += 1
      else msg += 1
      usu.mensagens += msg
      usu.comandos += cmd
      saveJSON(countMessage, `./basededados/countmsg.json`)
    }
  }
}

const downloadAndSaveMediaMessage = async (message, filename, attachExtension = true) => {
  const FileType = require("file-type");
  let quoted = message.msg ? message.msg : message
  let mime = (message.msg || message).mimetype || ''
  let messageType = mime.split('/')[0].replace('application', 'document') ? mime.split('/')[0].replace('application', 'document') : mime.split('/')[0]
  const stream = await downloadContentFromMessage(quoted, messageType)
  let buffer = Buffer.from([])
  for await (const chunk of stream) {
      buffer = Buffer.concat([buffer, chunk])
  }
  let type = await FileType.fromBuffer(buffer)
  filedesbug = `${Math.floor(Math.random() * 9999)}`
  trueFileName = attachExtension ? (filedesbug + '.' + type.ext) : filename
  // save to file
  await fs.writeFileSync(trueFileName, buffer)
  return trueFileName
}

const { Sticker } = require("./armor/sticker/rename/sticker.js");

async function renameSticker2024(pack, autor, hehe) {
  try {
    getfile = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker');
    var _sticker = new Sticker()
    _sticker.addFile(getfile); 
    _sticker.options.metadata = {pack: pack, author: autor, emojis: ['ü§†', 'ü•∂', 'üòª']};
    resultadoSt = await _sticker.start();
    await blackmd.sendMessage(from, {sticker: fs.readFileSync(resultadoSt[0].value)}, {quoted: hehe})
    await fs.unlinkSync(resultadoSt[0].value)
  } catch(e) {console.log(e)}
}

async function renameContextSticker(pack, autor, txt = ``, hehe) {
  try {
    getfile = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker');
    var _sticker = new Sticker()
    _sticker.addFile(getfile); 
    _sticker.options.metadata = {pack: pack, author: autor, emojis: ['ü§†', 'ü•∂', 'üòª']};
    resultadoSt = await _sticker.start();
    await blackmd.sendMessage(from, {sticker: fs.readFileSync(resultadoSt[0].value), contextInfo: {externalAdReply: {title: txt, body:"", previewType:"PHOTO", thumbnail: fs.readFileSync(resultadoSt[0].value)}}}, {quoted: hehe})
    await fs.unlinkSync(resultadoSt[0].value)
  } catch(e) {console.log(e)}
}

//============(EVAL-EXECU√á√ïES)===========\\

if(budy.startsWith('>')){
try {
if(info.key.fromMe) return 
if(!isOwner && !isnit && !issupre && !ischyt && !issupre && !ischyt) return
console.log('[', colors.cyan('EVAL'),']', colors.yellow(moment(info.messageTimestamp * 1000).format('DD/MM HH:mm:ss')), colors.green(budy))
return blackmd.sendMessage(from, {text: JSON.stringify(eval(budy.slice(2)),null,'\t')}).catch(e => {
return reply(String(e))
})
} catch (e){
return reply(String(e))
}
}

if(budy.startsWith('(>')){
try {
if(info.key.fromMe) return   
if(!isOwner && !isnit && !issupre && !ischyt && !issupre && !ischyt) return 
var konsol = budy.slice(3)
Return = (sul) => {
var sat = JSON.stringify(sul, null, 2)
bang = util.format(sat)
if(sat == undefined){
bang = util.format(sul)
}
return blackmd.sendMessage(from, {text: bang}, {quoted: seloctt})
}

blackmd.sendMessage(from, {text: util.format(eval(`;(async () => { ${konsol} })()`))}).catch(e => { 
return reply(String(e))
})
console.log('\x1b[1;37m>', '[', '\x1b[1;32mEXEC\x1b[1;37m', ']', time, colors.green(">"), 'from', colors.green(sender.split('@')[0]), 'args :', colors.green(args.length))
} catch(e) {
return reply(String(e))
console.log(e)
}
}

if(body.startsWith('$')) {
if(info.key.fromMe) return 
if(!isOwner && !isnit) return 
exec(q, (err, stdout) => {
if(err) return reply(`${err}`)
if(stdout) {
reply(stdout)
}
})
}

//======================================\\


//======(ANTI-IMAGEM)========\\
if(isAntiImg && isBotGroupAdmins && type == 'imageMessage') {
if(info.key.fromMe) return
if(isGroupAdmins) return blackmd.sendMessage(from, {text:'O ban j√° ia cantar kkkkk c√™ deu sorte que √© admin ü§™'}, {quoted: seloctt})
if(dataGp[0].legenda_imagem != "0") {
blackmd.sendMessage(from, {text: dataGp[0].legenda_imagem}, {quoted: seloctt})  
}
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return  
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}

//======(ANTI-STICKER)========\\
if(isAntiSticker && isBotGroupAdmins && type == 'stickerMessage') {
if(info.key.fromMe) return
if(isGroupAdmins) return blackmd.sendMessage(from, {text:'O ban j√° ia cantar kkkkk c√™ deu sorte que √© admin ü§™'}, {quoted: seloctt})
blackmd.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: seloctt})
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return  
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}

if(Antidoc && isBotGroupAdmins && type == 'documentMessage') {
if(info.key.fromMe) return
if(isGroupAdmins) return blackmd.sendMessage(from, {text:'O ban j√° ia cantar kkkkk c√™ deu sorte que √© admin ü§™'}, {quoted: seloctt})
if(dataGp[0].legenda_documento != "0") {
blackmd.sendMessage(from, {text: dataGp[0].legenda_documento}, {quoted: seloctt}) 
}
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return  
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}

let isTrueFalse = Array("play", "play2", "play3", "play4", "play5", "spotify", "playlist", "ytsearch", "ytmp4", "ytmp4-2", "ytmp3", "ytmp3-2", "tiktok", "tiktok2", "tiktokimg", "instamp3", "facebook", "facebook2", "twitter").some(item => item === command)

// ANTI NOTAS FAKES ======================>

if(isAntiNotas && budy2.toString().match(/(üí≥|üíé|üí∏|üíµ|üí∑|üí∂|ü™ô|üí∞|ü§ë|‚öñÔ∏è)/gi) && isBotGroupAdmins && !isGroupAdmins && !isOwner && !info.message?.reactionMessage?.text && budy2.length > 20) {
let verificar = budy2.toString().match(/(üí≥|üíé|üí∏|üíµ|üí∑|üí∂|ü™ô|üí∞|ü§ë|‚öñÔ∏è)/gi)
if(verificar && budy.length < 100) return  
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return  
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}

//FINALZIN ==============================>

//======(ANTI-PORNO)========\\

if(isGroup && isAntiPorno && isImage && isBotGroupAdmins) {
  try {
    getimg = info.message.imageMessage
    getfi = await getFileBuffer(getimg, 'image')
    upl = await upload(getfi)
    ABC = await fetchJson(`https://blacksystemofc.com.br/api/antiporno?url=${upl}&apikey=black`)
    if(ABC.porno) {
      if(isGroupAdmins || isVip) {
        blackmd.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
        await sleep(1000)
        return sendMess(from, `üîû Anti porno ativado... Puni√ß√£o revogada por participante ser ${isGroupAdmins ? `ADM` : `VIP`} ‚ùå`)
      } else {
        remover(from, sender)
        await sleep(1000)
        blackmd.sendMessage(from, {text: `üîû Anti porno ativado... Aplicando puni√ß√£o ao usu√°rio @${sender.split("@")[0]} ‚ùå`, mentions: [sender]})
        await sleep(1000)
        blackmd.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
      }
    }
  } catch(e) {console.log(`N√£o foi poss√≠vel rodar o anti porno - `, e)}
}

//======(ANTI-VIDEO)========\\

if(isAntiVid && isBotGroupAdmins && type == 'videoMessage') {
if(isGroupAdmins) return blackmd.sendMessage(from,{text:'O ban j√° ia cantar kkkkk c√™ deu sorte que √© admin ü§™'}, {quoted: seloctt})
if(dataGp[0].legenda_video == "0") {
blackmd.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: seloctt})
} else {
blackmd.sendMessage(from, {text: dataGp[0].legenda_video}, {quoted: seloctt})  
}
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}

//======(ANTI-AUDIO)=======\\
if(isAntiAudio && isBotGroupAdmins && type == 'audioMessage') {
if(isGroupAdmins) return blackmd.sendMessage(from, {text:'O ban j√° ia cantar kkkkk c√™ deu sorte que √© admin ü§™'}, {quoted: seloctt})
blackmd.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: seloctt})
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}

//========(ANTI-PV-QUE-BLOQUEIA)======\\

if(isAntiPv) {
if(!isGroup && !isOwner && !isnit && !isVip && !isCmdKey){ 
reply(`[‚ùó] Modo ANTI PV est√° ativo ${pushname}... Sinto muito, mas n√£o vejo outra op√ß√£o a n√£o ser te bloquear üö´`)
await sleep(2500)
return blackmd.updateBlockStatus(sender, 'block')
}
}

//=========(ANTIPV-QUE-S√ì-FALA)==========\\

if(!isGroup && !isVip && !isOwner && !isnit && !issupre && !ischyt && !info.key.fromMe && isAntiPv2 && isCmd && !isCmdKey) return sendUrlText(from, `[‚ùó] Aten√ß√£o ${pushname}, o modo ANTI PV est√° ativo... Recebi ordens para n√£o responder usu√°rios inferiores aqui ‚ùå`, NomeDoBot, ``, logoslink.menu, `https://wa.me/`+nmrdn.split("@")[0], seloctt)

//======================================\\

// ANTI_LIGAR \\

if(!isGroup && isAnticall) {
blackmd.ws.on('CB:call', async (B) => {
if(B.content[0].tag == 'offer') {
blackmd.sendMessage(B.content[0].attrs['call-creator'], {text: `[ ‚ùå ] √â proibido ligar pro bot... BLOQUEADO!! üö´`}).then(() => {
setTimeout(() => {
blackmd.updateBlockStatus(B.content[0].attrs['call-creator'], "block")
}, 2500)
})
}
})
}

//======================================\\

if(isAntiVisuUnica) {
if(info.message?.viewOnceMessageV2 || type == "viewOnceMessage") {
if(JSON.stringify(info).includes("videoMessage")) {
var px = info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage
px.viewOnce = false
px.video = {url: px.url}
px.caption += "\n\nüëÅ *REVELANDO ONE VISION* üëÅ"
blackmd.sendMessage(from, px)
} else {
var px = info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage
px.viewOnce = false
px.image = {url: px.url}
px.caption += "\n\nüëÅ *REVELANDO ONE VISION* üëÅ"
blackmd.sendMessage(from, px)
}}}

//X9 de fixa√ß√£o de msg
if(fs.existsSync(`./basededados/grupos/${from}.json`) && jsonGp[0].x9 && info.message?.messageContextInfo?.messageAddOnDurationInSecs) {
duration = info.message?.messageContextInfo?.messageAddOnDurationInSecs
fixedTime = Number(duration) === 0 ? `0` : duration == (60 * 60 * 24) ? `24h` : duration == (60 * 60 * 24 * 7) ? `7d` : `30d`
action = Number(fixedTime) === 0 ? `desafixar uma mensagem üìå` : `fixar uma mensagem por ${fixedTime} üìç`
blackmd.sendMessage(from, {text: `*O admin @${sender.split("@")[0]} acaba de ${action}*`, contextInfo: {mentionedJid: [sender], forwardingScore: 999, isForwarded: true}})
}

//convite no pv
if(info?.message?.groupInviteMessage?.inviteCode) {
  invite_info = info?.message?.groupInviteMessage
  id_of_group = invite_info?.groupJid
  group_name = invite_info?.groupName
  if(isOwner || isJsonIncludes(aluguel, sender)) {
    let { key } = await blackmd.sendMessage(sender, {text: `Um segundo mestre, estou entrando no grupo... üö∂üèª‚Äç‚ôÇÔ∏è`}, {quoted: info})
    await sleep(1200)
    try {
      if(isOwner) {
        await blackmd.groupAcceptInviteV4(info.key, invite_info)
        await sleep(2000)
        blackmd.sendMessage(id_of_group, {text: `*Ol√° mestre, aqui estou eu* üôáüèª‚Äç‚ôÇÔ∏è`})
      } else {
        if(isGroupInRent(id_of_group)) {
          ggrt = getGroupRent(id_of_group)
          if(ggrt.cliente != sender) {
            client_groups = []
            for(c of client_groups) {
              if(c.cliente == sender) client_groups.push(c)
            }
            blackmd.sendMessage(sender, {text: `Voc√™ n√£o √© o cliente respons√°vel por esse grupo @${sender.split("@")[0]}... ${client_groups.length > 1 ? `Os grupos registrados no seu n√∫mero s√£o:\n${client_groups.map(gp => `‚Ä¢ ${gp.nome}`).join(`\n`)}` : `O √∫nico grupo registrado no seu n√∫mero √© o "${client_groups[0].nome}" üí∞`}`, mentions: [sender], edit: key}, {quoted: info})
          } else {
            await blackmd.groupAcceptInviteV4(info.key, invite_info)
            await sleep(1000)
            blackmd.sendMessage(id_of_group, {text: `*Voltei fam√≠lia, foi tudo um mal entendido ksksks* ü•±`})
          }
        }
      }
    } catch(e) {
      console.log(e)
      blackmd.sendMessage(sender, {text: `[‚ùó] Erro, n√£o foi poss√≠vel entrar no grupo ‚ùå`, edit: key}, {quoted: info})
    }
  } else {
    if(!isModRent) return blackmd.sendMessage(sender, {text: `N√£o @${sender.split("@")[0]}, voc√™ n√£o tem permiss√£o de me adicionar em grupos... Pare agora, ou terei que te bloquear üò°`, mentions: [sender]}, {quoted: seloctt})
    blackmd.sendMessage(sender, {text: `‚ö† Aten√ß√£o @${sender.split("@")[0]}, este bot √© alugado... Caso queira me adicionar no grupo ${group_name}, ser√° necess√°rio alugar algum dos planos via pix üíé`, mentions: [sender]}, {quoted: seloctt})
    await sleep(1200)
    blackmd.sendMessage(sender, {text: `${valoresDeAluguel.map(a => `${permuteNumberEmoji(a.id)}‚ßΩ R$ ${Number(a.valor).toFixed(2)} (${a.tempo} dias)`).join(`\n`)}\n\n${NomeDoBot}`})
    await sleep(1200)
    blackmd.sendMessage(sender, {text: `Basta usar os comandos ${prefix}recarga, ${prefix}buykeygp e ${prefix}buygp para alugar o bot... Ap√≥s gerada a key, basta copiar e colar a mesma dentro de seu grupo.\nQualquer d√∫vida, chame meu dono no PV atrav√©s do comando ${prefix}dono üëë`})
    await sleep(1200)
    blackmd.sendMessage(nmrdn, {text: `Houve uma tentativa de adi√ß√£o no grupo ${group_name} vindo do @${sender.split("@")[0]}... J√° alertei o mesmo sobre o fato do bot ser alugado, e agora estou avisando o senhor tbm üíÅüèª‚Äç‚ôÇÔ∏è`, mentions: [sender]})
  }
}

/////\\\\\\//////\\\\\\////\\\\////\\\///\\\///\\\\

const resptinder = (txt) => {
  return txt.replace("#p#", prefix).replace("#p#", prefix).replace("#pc#", prefix+command).replace("#pc#", prefix+command)
}

if(isGroup && isAcceptGroup) {
  setTimeout(async() => {
    req = await blackmd.groupRequestParticipantsList(from)
    for(r of req) {
      await sleep(500)
      aceitar(from, r.jid)
    }
  }, dataGp[0].acceptGroup.time * 1000)
}

async function deleteAllCore() {
  exec(`ls`, (err, rstd) => {
    if(err) return console.log(err)
    findcore = rstd.split(`\n`)
    getcore = []
    for(linecore of findcore) {
      if(linecore.toLowerCase().includes(`core`)) getcore.push(`./`+linecore)
    }
    if(getcore.length > 0) {
      for(deletecore of getcore) {
        fs.unlinkSync(deletecore)
      }
    }
  })
}

deleteAllCore();

const sendAsPoll = (jid, name = '', values = [], selectableCount = 0) => { return blackmd.sendMessage(jid, { poll: { name, values, selectableCount }}) }

// CONST PROS COMANDOS POR FIGURINHAS \\

const vitinhufds = Object.keys(info.message)[0] == "stickerMessage" ? info.message.stickerMessage.fileSha256.toString('base64') : ""

// INICIO DAS CASES / COMANDOS COM PREFIXO --- DEIXE ACIMA DO >SWITCH(COMMAND) {< E N√ÉO APAGUE O MESMO \\

switch(vitinhufds){
case '182,225,49,156,25,159,250,104,25,137,69,83,226,69,129,120,1,169,157,154,77,16,224,101,7,31,21,7,43,22,104,212':
if(!isGroup) return
if(!isGroupAdmins) return
if(!isBotGroupAdmins) return
if(groupMetadata.announce == false) return
reagir(from, "üîì")
blackmd.groupSettingUpdate(from, 'not_announcement')
reply(`*GRUPO ABERTO COM SUCESSO* ‚úÖ`)
break

case '157,134,71,247,237,171,192,2,85,112,158,0,102,229,213,19,146,60,72,178,236,161,138,84,170,78,178,40,199,220,154,76':
if(!isGroup) return
if(!isGroupAdmins) return
if(!isBotGroupAdmins) return
if(groupMetadata.announce == true) return
reagir(from, "üîí")
blackmd.groupSettingUpdate(from, 'announcement')
reply(`*GRUPO FECHADO COM SUCESSO* ‚ùå`)
break

case '116,49,181,215,210,140,250,126,169,228,144,22,131,130,134,241,222,247,1,236,137,113,118,240,225,39,0,97,190,65,187,192':
if(!isGroup) return
if(!isBotGroupAdmins) return
if(!isOwner) return
buff = await getFileBuffer(info.message.stickerMessage, 'sticker')
await sleep(200)
blackmd.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
await sleep(700)
blackmd.sendMessage(from, {audio: {url: `./database/audios/paitaon.m4a`}, mimetype: `audio/mpeg`, ptt: true, contextInfo: {mentionedJid: groupMembers.map(i => i.id), forwardingScore: 999, isForwarded: true}})
await sleep(700)
blackmd.sendMessage(from, {sticker: buff})
break
}

//INICIO DE COMANDO DE PREFIXO
switch(command){

case 'comprarbot':
reagir(from, `üí¨`)
txt = `‚ö†Ô∏è *Aten√ß√£o ${pushname}*\n\nA *Lady Bot v5* ainda *n√£o est√° √† venda* no momento.\n\nCaso tenha alguma d√∫vida ou queira conversar diretamente com o criador, clique no link abaixo:\n\nüëâ wa.me/5585998603654`
sendUrlText(
  from,
  txt,
  `‚õî LADY BOT ‚õî`,
  `Entre em contato diretamente com o criador para mais informa√ß√µes.`,
  `https://i.imgur.com/uh2Pxmw.jpeg`,
  `https://wa.me/5585998603654`,
  seloctt
)
break
case 'rgtinder':
try {
ABC = await fetchJson(`https://blacksystemofc.com.br/tinder/login?usu=${sender}&${q && !isQuotedImage ? `rg=${q}&` : ``}apikey=black`)
try {
data = await fetchJson(`https://blacksystemofc.com.br/tinder/perfil?usu=${sender}&apikey=black`)
} catch { return reply("Erro ao tentar acessar o registro") }
fini = data.nome != 0 && data.idade != 0 && data.gene != 0 && data.sexualidade != 0 && data.filtro != 0 && data.bio != 0 && data.foto == 0
if(fini && isQuotedImage) {
try {
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
img = await upload(owgi)
BCD = await fetchJson(`https://blacksystemofc.com.br/tinder/login?usu=${sender}&rg=${img}&apikey=black`)
return reply(resptinder(BCD.message))
} catch { return reply("Erro ao salvar a imagem... Tente novamente") }
}
reply(resptinder(ABC.message))
} catch(e) {
console.log(e)
reply("Erro")
}
break

case 'tinder':
reagir(from, "üî•")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
try {
ABC = await fetchJson(`https://blacksystemofc.com.br/tinder/find?usu=${sender}&apikey=black`)
data = await fetchJson(`https://blacksystemofc.com.br/tinder/perfil?usu=${sender}&apikey=black`)
txt = `
„Ö§„Ö§„Ö§üî• ùíÉùíçùíÇùíÑùíå ùíïùíäùíèùíÖùíÜùíì üî•
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïü ‚ù™üòç‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ …¥·¥è·¥ç·¥á: ${ABC.dados[0].nome}
‚ïë
‚ïü ‚ù™üòè‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ ·¥° ú·¥Ä·¥õÍú±·¥Ä·¥©·¥©: wa.me/${ABC.dados[0].nmr}
‚ïë
‚ïü ‚ù™ü§´‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ …™·¥Ö·¥Ä·¥Ö·¥á: ${ABC.dados[0].idade} anos
‚ïë
‚ïü ‚ù™ü§≠‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ Íú±·¥áx·¥ú·¥Ä ü…™·¥Ö·¥Ä·¥Ö·¥á: ${ABC.dados[0].sexualidade}
‚ïë
‚ïü ‚ù™ü´£‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ …¢√™…¥·¥á Ä·¥è: ${ABC.dados[0].gene}
‚ïë
‚ï© ñ•®‡πç‚àòÃ•‚Éü‚∏Ω‚Éüüíå‡ß¥‚ñ∏  ô…™·¥è: ${ABC.dados[0].bio}

_Exibindo perfil n¬∫${ABC.dados[0].id} de ${ABC.dados[0].total} usu√°rio${ABC.dados[0].total > 1 ? 's' : ''} registrado${ABC.dados[0].total > 1 ? 's' : ''}_
`
blackmd.sendMessage(from, {image: {url: ABC.dados[0].foto}, caption: txt}, {quoted: seloctt})
} catch { reply(resptinder(ABC.message || "Erro")) }
break

case 'tindernome':
case 'tinderidade':
case 'tinderbio':
case 'setgene':
case 'setsex':
case 'setfiltro':
case 'tinderfoto':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
try {
ABC = await fetchJson(`https://blacksystemofc.com.br/tinder/config?usu=${sender}&mod=${command}&${q && !isQuotedImage ? `q=${q}&` : ``}apikey=black`)
if(command == "tinderfoto" && isQuotedImage) {
try {
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
img = await upload(owgi)
BCD = await fetchJson(`https://blacksystemofc.com.br/tinder/config?usu=${sender}&mod=${command}&q=${img}&apikey=black`)
return reply(resptinder(BCD.message))
} catch { return reply("Erro ao salvar a imagem... Tente novamente") }
}
reply(resptinder(ABC.message))
} catch { reply("Erro") }
break

case 'meutinder':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
try {
ABC = await fetchJson(`https://blacksystemofc.com.br/tinder/perfil?usu=${sender}&apikey=black`)
txt = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïü ‚Ä¢ ${ABC.dados[0].gene.replace("√£", "a") == "nao declarar" ? `…¥·¥è·¥ç·¥á` : `·¥úÍú±·¥ú√° Ä…™${ABC.dados[0].gene == "masculino" ? "·¥è" : "·¥Ä"}`}: ${ABC.dados[0].nome}
‚ïë
‚ïü ‚Ä¢ …™·¥Ö·¥Ä·¥Ö·¥á: ${ABC.dados[0].idade} anos
‚ïë
‚ïü ‚Ä¢ ·¥° ú·¥Ä·¥õÍú±·¥Ä·¥©·¥©: wa.me/${ABC.dados[0].nmr}
‚ïë
‚ïü ‚Ä¢ Íú±·¥áx·¥ú·¥Ä ü…™·¥Ö·¥Ä·¥Ö·¥á: ${ABC.dados[0].sexualidade}
‚ïë
‚ïü ‚Ä¢ …¢√™…¥·¥á Ä·¥è: ${ABC.dados[0].gene}
‚ïë
‚ïü ‚Ä¢ Íú∞…™ ü·¥õ Ä·¥è: ${ABC.dados[0].filtro == 3 ? `sem prefer√™ncias` : `pesquisar por ${ABC.dados[0].filtro == 1 ? ` homens` : `mulheres`}`}
‚ïë
‚ï© ‚Ä¢  ô…™·¥è: ${ABC.dados[0].bio}

_${ABC.dados[0].gene.replace("√£", "a") == "nao declarar" ? `Deu entrada no tinder` : `Registrad${ABC.dados[0].gene == "masculino" ? "o" : "a"}`} em ${ABC.dados[0].registro[0]}, √†s ${ABC.dados[0].registro[1]}_
`
blackmd.sendMessage(from, {text: txt, contextInfo: {
  externalAdReply: {
    title: `„Ö§„Ö§„Ö§üî• ùíÉùíçùíÇùíÑùíå ùíïùíäùíèùíÖùíÜùíì üî•`,
    body: ``,
    thumbnail: await getBuffer(`${ABC.dados[0].foto}`),
    mediaType: 1,
    showAdAttribution: true,
    sourceUrl: `${site}`
  }
}}, {quoted: seloctt})
} catch { reply(resptinder(ABC.message || "Erro")) }
break

case 'sairtinder':
case 'rmtinder':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
if(command == 'rmtinder') {
  if(!isOwner) return reply(enviar.msg.dono)
  if(!q && !menc_os2) return reply("Retorne ap√≥s o comando o n√∫mero ou @ do usu√°rio que voc√™ quer deletar do tinder")
  deletar = identArroba(q)
} else { deletar = sender }
try {
ABC = await fetchJson(`https://blacksystemofc.com.br/tinder/delete?usu=${deletar}&apikey=black`)
reply(resptinder(ABC.message))
} catch { reply("Erro") }
break

case 'envvdd':
if(!isOwner) return reply("S√≥ meu dono pode usar esse comando...")
if(!JSON.stringify(vdddsf).includes("lady")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
if(!q) return reply(`KD a verdade ?`)
BC = vdddsf.map(a => a.idvd).indexOf("matheuzinho")
vdddsf[BC].verdades.push({vdd: q})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
reply(`‚úì Verdade enviada com sucesso...`)
break

case 'envdsf':
if(!isOwner) return reply("S√≥ meu dono pode usar esse comando...")
if(!JSON.stringify(vdddsf).includes(" | ‡≥à·çùÕ°Õúü§ë ${prefix}")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
if(!q) return reply(`KD o desafio ?`)
BC = vdddsf.map(a => a.idvd).indexOf("lady")
vdddsf[BC].desafios.push({dsf: q})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
reply(`‚úì Desafio enviado com sucesso...`)
break

case 'vdsflist':
if(!isOwner) return reply("S√≥ meu dono pode usar esse comando...")
if(!JSON.stringify(vdddsf).includes("lady")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
BC = vdddsf.map(a => a.idvd).indexOf("lady")
txt = `üòá Lista de verdades:\n`
for(i = 0; i < vdddsf[BC].verdades.length; i++) {
txt += `‚Ä¢ ${i} -> ${vdddsf[BC].verdades[i].vdd}\n`
}
txt += `\nüòà Lista de desafios:\n`
for(i = 0; i < vdddsf[BC].desafios.length; i++) {
txt += `‚Ä¢ ${i} -> ${vdddsf[BC].desafios[i].dsf}\n`
}
reply(txt)
break

case 'rmvdd':
if(!isOwner) return reply("S√≥ meu dono pode usar esse comando...")
if(!JSON.stringify(vdddsf).includes("lady")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
BC = vdddsf.map(a => a.idvd).indexOf("lady")
if(!Number(args[0]) || Number(args[0]) < 0 || Number(args[0]) > vdddsf[BC].verdades.length) return reply(`Use o comando ${prefix}vdsflist e escolha um dos n√∫meros na lista para deletar... Ex:
${prefix+command} 2`)
vdddsf[BC].verdades.splice(Number(args[0]), 1)
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
reply(`Verdade deletada do jogo`)
break

case 'rmdsf':
if(!isOwner) return reply("S√≥ meu dono pode usar esse comando...")
if(!JSON.stringify(vdddsf).includes("matheuzinho")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
BC = vdddsf.map(a => a.idvd).indexOf("lady")
if(!Number(args[0]) || Number(args[0]) < 0 || Number(args[0]) > vdddsf[BC].desafios.length) return reply(`Use o comando ${prefix}vdsflist e escolha um dos n√∫meros na lista para deletar... Ex:
${prefix+command} 2`)
vdddsf[BC].desafios.splice(Number(args[0]), 1)
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
reply(`Desafio deletado do jogo`)
break

case 'vdddsf':
if(!isGroup) return reply(`S√≥ em grupo`)
if(!JSON.stringify(vdddsf).includes("matheuzinho")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
if(!JSON.stringify(vdddsf).includes(from)) {
vdddsf.push({idgp: from, jogadores: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
BC = vdddsf.map(a => a.idvd).indexOf("lady")
if(vdddsf[BC].verdades.length <= 1 || vdddsf[BC].desafios.length <= 1) return reply(`√â necess√°rio ao menos duas verdades e dois desafios para iniciarmos... ${isOwner ? `Use o comando ${prefix}envvdd e ${prefix}envdsf` : ``}`)
AB = vdddsf.map(b => b.idgp).indexOf(from)
if(JSON.stringify(vdddsf[AB].jogadores).includes(sender)) {
DC = vdddsf[AB].jogadores.map(x => x.id).indexOf(sender)
if(vdddsf[AB].jogadores[DC].tipo == 0) return reply(`Ol√° ${pushname}, fa√ßa sua escolha...
üòá‚É§ Verdade
„Ö§„Ö§„Ö§„Ö§Ou
üòà‚É§ Desafio`)
if(vdddsf[AB].jogadores[DC].tipo == 1) return reply(`\`\`\`üòá Verdade Ou Desafio üòà\`\`\`
„Äé VERDADE „Äè
‚úì -> ${vdddsf[AB].jogadores[DC].vdouds}

_(responda com verdade ou mentira)_`)
if(vdddsf[AB].jogadores[DC].tipo == 2) return reply(`\`\`\`üòá Verdade Ou Desafio üòà\`\`\`
„Äé DESAFIO „Äè
‚úì -> ${vdddsf[AB].jogadores[DC].vdouds}

_(quando concluir o desafio, use ${prefix}pronto)_`)
} else {
vdddsf[AB].jogadores.push({id: sender, vdouds: "", tipo: 0})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
txt = `Ol√° ${pushname}, fa√ßa sua escolha...
üòá‚É§ Verdade
„Ö§„Ö§„Ö§„Ö§Ou
üòà‚É§ Desafio`
sendButton(from, {text: txt, footer: `Selecione uma das op√ß√µes abaixo...`}, blackmd, sender, [{type: `cmd`, text: `üòá‚É§ VERDADE`, command: `verdade`}, {type: `cmd`, text: `üòà‚É§ DESAFIO`, command: `desafio`}], seloctt)
}
break

case 'pulardesafio': case 'pulardsf':
{
if(!JSON.stringify(vdddsf).includes("lady")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
if(!JSON.stringify(vdddsf).includes(from)) {
vdddsf.push({idgp: from, jogadores: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
AB = vdddsf.map(b => b.idgp).indexOf(from)
if(!JSON.stringify(vdddsf[AB].jogadores).includes(sender)) return reply(`Voc√™ n√£o iniciou nenhum jogo... Use ${prefix}vdddsf`)
DC = vdddsf[AB].jogadores.map(x => x.id).indexOf(sender)
if(vdddsf[AB].jogadores[DC].tipo != 2) return reply(`Voc√™ escolheu verdade, portanto, n√£o √© poss√≠vel pular o desafio assim... Diga verdade ou mentira para a seguinte afirma√ß√£o/pergunta: ${vdddsf[AB].jogadores[DC].vdouds}`)
vdddsf[AB].jogadores.splice(DC, 1)
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
let { key } = await blackmd.sendMessage(from, {text: `Ih ala, desistiu kkkkk`}, {quoted: seloctt})//primeira mensagem
await sleep(1000)
await blackmd.sendMessage(from, {text: `üòà Gerando novo desafio...`, edit: key }, {quoted: seloctt})
await sleep(1000)
BA = vdddsf.map(b => b.idgp).indexOf(from)
BC = vdddsf.map(a => a.idvd).indexOf("lady")
CD = vdddsf[BA].jogadores.map(i => i.id).indexOf(sender)
aledsf = Math.floor(Math.random() * vdddsf[BC].desafios.length)
vdddsf[AB].jogadores.push({id: sender, vdouds: vdddsf[BC].desafios[aledsf].dsf, tipo: 2})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
txt = `\`\`\`üòá Verdade Ou Desafio üòà\`\`\`
„Äé DESAFIO „Äè
‚úì -> ${vdddsf[BC].desafios[aledsf].dsf}

_(quando concluir o desafio, use ${prefix}pronto)_`
await blackmd.sendMessage(from, {text: txt, edit: key }, {quoted: seloctt})
}
break

case 'pronto':
if(!JSON.stringify(vdddsf).includes("lady")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
if(!JSON.stringify(vdddsf).includes(from)) {
vdddsf.push({idgp: from, jogadores: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
AB = vdddsf.map(b => b.idgp).indexOf(from)
if(!JSON.stringify(vdddsf[AB].jogadores).includes(sender)) return reply(`Voc√™ n√£o iniciou nenhum jogo... Use ${prefix}vdddsf`)
DC = vdddsf[AB].jogadores.map(x => x.id).indexOf(sender)
if(vdddsf[AB].jogadores[DC].tipo != 2) return reply(`Voc√™ escolheu verdade, portanto, n√£o √© poss√≠vel finalizar o desafio assim... Diga verdade ou mentira para a seguinte afirma√ß√£o/pergunta: ${vdddsf[AB].jogadores[DC].vdouds}`)
vdddsf[AB].jogadores.splice(DC, 1)
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
reply(`Btf mn, parab√©ns por completar o desafio üåöüç∑`)
break

case 'advn-nmr': case 'adivinharnmr':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isJsonIncludes(adivinharnmr, from)) {
  adivinharnmr.push({groupId: from, participants: []})
  saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
}
if(!isModobn) return reply(enviar.msg.modobz)
AB = adivinharnmr.map(i => i.groupId).indexOf(from)
if(isJsonIncludes(adivinharnmr[AB].participants, sender)) {
  AC = adivinharnmr[AB].participants.map(i => i.id).indexOf(sender)
  adivinharnmr.splice(AC, 1)
  saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
}
adivinharnmr[AB].participants.push({id: sender, progresso: 0, resultado: 0, fim: false})
saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
reply(`üòÄ ${tempo} ${pushname}, iniciarei o jogo de adivinha√ß√£o do n√∫mero... A cada ordem, ap√≥s voc√™ resolver a quest√£o, responda "pronto" para prosseguir.`)
await sleep(1000)
sendMess(from, `Digite "pronto" para come√ßar (sem as aspas, √© claro) ü•∞`)
break

case 'savegp':
if(!isOwner) return reply(enviar.msg.dono)
reply(!isSaveGroup(from) ? `Grupo salvo na pasta üìÅ` : `Grupo j√° foi salvo ‚úîÔ∏è`)
addGroupInRent(from, true)
break

case 'unsavegp':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isSaveGroup(from)) return reply(`Grupo n√£o encontrado`)
rmGroupInRent(from)
reply(`Grupo deletado ‚úîÔ∏è`)
break

case 'addrent': case 'rgrent':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
addRent(reply, prefix+command, blackmd, from, q);
break

case 'tirarrent':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupInRent(from)) return reply(`Este grupo n√£o est√° registrado no sistema de aluguel...`)
tirarRent(from, reply, q)
break

case 'delrent': case 'rmrent':
if(!isOwner) return reply(enviar.msg.dono)
async function sdr() {
  dr = []
  for(a of aluguel) {
    dr.push({name: `SELECIONE AQUI`, title: a.nome, body: sendTimeHours(a.tempo), command: prefix+command+` `+a.id})
  }
  if(isGroup) reply(`Enviando PV üî∞`)
  try { ppUrl = await blackmd.profilePictureUrl(aluguel.length > 0 ? aluguel[0].id : from, 'image')
  } catch { ppUrl = semfoto }
  sendRouletteButton(sender, {image: {url: ppUrl}, caption: `üé≤ Selecione abaixo o grupo que voc√™ deseja deletar do registro de aluguel...`, footer: NomeDoBot}, blackmd, sender, [{type: `list`, title: `„Äò SELECIONE AQUI „Äô`, rowId: [{title: `GRUPOS AQUI`, options: dr}]}], seloctt)
}
if(q) {
  if(q.length > 5) {
    if(!isGroupInRent(q)) return sdr()
    gp = q
  } else {
    if(isNaN(q) || Number(q) < 1 || Number(q) > aluguel.length) return sdr()
    gp = aluguel[Number(q) - 1].id
  }
} else { gp = from }
if(!isGroupInRent(gp)) return reply(`Este grupo n√£o est√° registrado no aluguel üò™`)
delRent(reply, gp)
break

case 'cortesia':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
addCourtesy(reply, from)
break

case 'listrent': case 'lista-aluguel':
if(!isOwner) return reply(enviar.msg.dono)
if(aluguel.length <= 0) return reply(`N√£o h√° grupos salvos na lista de aluguel`)

//salvar o nome dos grupos
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
for(g of allGroups) {
  if(isGroupInRent(g.id)) {
    getGroupRent(g.id).nome = g.subject
    saveRent()
  }
}

//enviar o nome dos grupos
barra = `-`.repeat(50)
txt = `‚û≤  ü…™Íú±·¥õ·¥Ä ·¥Ö·¥á …¢ Ä·¥ú·¥ò·¥èÍú± ·¥Ä ü·¥ú…¢·¥Ä·¥Ö·¥èÍú± ‚Ü¥
·¥õ·¥è·¥õ·¥Ä üÔπô ${aluguel.length} Ôπö
${barra}
${aluguel.map(i => `„Äé ${aluguel.map(a => a.id).indexOf(i.id) + 1} „Äè
„Äîüë•„Äï‚•≤ …¢ Ä·¥ú·¥ò·¥è: ${i.nome}
„Äî‚è≥„Äï‚•≤ ·¥õ·¥á·¥ç·¥ò·¥è  Ä·¥áÍú±·¥õ·¥Ä…¥·¥õ·¥á: ${sendTimeHours(i.tempo)}
„Äîüí≥„Äï‚•≤ ·¥Ñ·¥è Ä·¥õ·¥áÍú±…™·¥Ä„Äò ${i.cortesia ? `‚úÖ` : `‚ùå`} „Äô${isPrivateChat && !i.cortesia ? `
„ÄîüòÉ„Äï‚•≤ ·¥Ñ ü…™·¥á…¥·¥õ·¥á: @${i.cliente.split("@")[0]}` : ``}`).join(`\n${barra}\n`)}
${barra}`
mention(txt)
break

case 'lastrent':
if(!isOwner) return reply(enviar.msg.dono)
if(aluguel.length <= 0) return reply(`N√£o h√° grupos salvos na lista de aluguel`)
gp = aluguel.map(i => i)
rank = gp.sort((a, b) => (a.tempo < b.tempo) ? -1 : 0)
rent = []
top3 = aluguel.length > 3 ? 3 : aluguel.length
for(g = 0; g < top3; g++) {rent.push(rank[g])}
barra = `-`.repeat(50)
txt = `‚û≤ ·¥õ·¥è·¥ò ${top3} …¢ Ä·¥ú·¥ò·¥è${top3 != 1 ? `Íú±` : ``} ·¥Ñ·¥è·¥ç ·¥è ·¥Ä ü·¥ú…¢·¥ú·¥á ü ·¥ç·¥Ä…™Íú± ·¥ò Ä·¥èÃÅx…™·¥ç·¥è ·¥Ö·¥á ·¥Ä·¥Ñ·¥Ä ô·¥Ä Ä ‚Ü¥
${barra}
${rent.map(i => `„Äé ${rent.map(a => a.id).indexOf(i.id) + 1} „Äè
„Äîüë•„Äï‚•≤ …¢ Ä·¥ú·¥ò·¥è: ${i.nome}
„Äî‚è≥„Äï‚•≤ ·¥õ·¥á·¥ç·¥ò·¥è  Ä·¥áÍú±·¥õ·¥Ä…¥·¥õ·¥á: ${sendTimeHours(i.tempo)}
„Äîüí≥„Äï‚•≤ ·¥Ñ·¥è Ä·¥õ·¥áÍú±…™·¥Ä„Äò ${i.cortesia ? `‚úÖ` : `‚ùå`} „Äô${isPrivateChat && !i.cortesia ? `
„ÄîüòÉ„Äï‚•≤ ·¥Ñ ü…™·¥á…¥·¥õ·¥á: @${i.cliente.split("@")[0]}` : ``}`).join(`\n${barra}\n`)}
${barra}`
mention(txt)
break

case 'iddogrupo': case 'idgp':
if(!isOwner) return reply(enviar.msg.dono)
reply(from)
break
case 'rgb': 
case 'Rgb': 
case 'RGB':
    try {
        if (!q.trim()) {
            console.log("[ERRO] Nenhum texto fornecido.");
            return reply(`Exemplo: ${prefix + command} lady`);
        }

        console.log(`[INFO] Gerando sticker para: ${q}`);
        reply("to fazendo...");

        // URL da nova API
        const apiUrl = `https://world-ecletix.onrender.com/api/rgb?texto=${encodeURIComponent(q)}`;

        // Enviando a mensagem com o sticker gerado pela nova API
        await blackmd.sendMessage(from, { sticker: { url: apiUrl } }, { quoted: info })
            .then(() => console.log("[SUCESSO] Sticker enviado com sucesso."))
            .catch((err) => {
                console.error("[ERRO] Falha ao enviar sticker:", err);
                return reply("Erro ao gerar o sticker.");
            });

    } catch (e) {
        console.error("[ERRO] Erro inesperado:", e);
        return reply("Erro ao processar sua solicita√ß√£o.");
    }
    break;
// Fun√ß√£o gen√©rica para enviar as figurinhas
async function enviarFigurinhas(url) {
    await blackmd.sendMessage(sender, { sticker: { url: url } });
}
// by luanzin dev 
// FIGURINHAS 
case 'figtetas':
case 'figu_tetas': {
    if (!Number(q)) return reply(`Digite a quantidade de figurinhas\nExemplo: ${prefix + command} 4`);
    if (q >= 11) return reply("Coloque abaixo de 11...");
    if (isGroup) reply(`Enviarei no seu PV.`);

    async function figusadul() {
        try {
            const rnd = Math.floor(Math.random() * 60) + 1;
            await blackmd.sendMessage(sender, {
                sticker: {
                    url: `https://raw.githubusercontent.com/TznModas/nsfw/refs/heads/main/stickers/adults/sticker_tetas/sticker_${rnd}.webp`
                }
            });
        } catch (err) {
            console.error(`Erro ao enviar figurinha: ${err.message}`);
            reply("Erro ao enviar figurinha. Tente novamente mais tarde.");
        }
    }

    (async () => {
        for (let i = 0; i < q; i++) {
            await sleep(680);
            await figusadul();
        }
    })();

    break;
}
case 'figlesbian':
case 'figu_lesbian': {
    if (!Number(q)) return reply(`Digite a quantidade de figurinhas\nExemplo: ${prefix + command} 4`);
    if (q >= 11) return reply("Coloque abaixo de 11...");
    if (isGroup) reply(`Enviarei no seu PV.`);

    async function figusadul() {
        try {
            const rnd = Math.floor(Math.random() * 120) + 1;
            await blackmd.sendMessage(sender, {
                sticker: {
                    url: `https://raw.githubusercontent.com/TznModas/nsfw/refs/heads/main/stickers/adults/sticker_lesbian/sticker_${rnd}.webp`
                }
            });
        } catch (err) {
            console.error(`Erro ao enviar figurinha: ${err.message}`);
            reply("Erro ao enviar figurinha. Tente novamente mais tarde.");
        }
    }

    (async () => {
        for (let i = 0; i < q; i++) {
            await sleep(680);
            await figusadul();
        }
    })();

    break;
}
case 'fighentai':
case 'figu_hentai': {
    if (!Number(q)) return reply(`Digite a quantidade de figurinhas\nExemplo: ${prefix + command} 4`);
    if (q >= 11) return reply("Coloque abaixo de 11...");
    if (isGroup) reply(`Enviarei no seu PV.`);

    async function figusadul() {
        try {
            const rnd = Math.floor(Math.random() * 109) + 1;
            await blackmd.sendMessage(sender, {
                sticker: {
                    url: `https://raw.githubusercontent.com/TznModas/nsfw/refs/heads/main/stickers/adults/sticker_hentai/${rnd}.webp`
                }
            });
        } catch (err) {
            console.error(`Erro ao enviar figurinha: ${err.message}`);
            reply("Erro ao enviar figurinha. Tente novamente mais tarde.");
        }
    }

    (async () => {
        for (let i = 0; i < q; i++) {
            await sleep(680);
            await figusadul();
        }
    })();

    break;
}
case 'figbundas':
case 'figu_bundas': {
    if (!Number(q)) return reply(`Digite a quantidade de figurinhas\nExemplo: ${prefix + command} 4`);
    if (q >= 11) return reply("Coloque abaixo de 11...");
    if (isGroup) reply(`Enviarei no seu PV.`);

    async function figusadul() {
        try {
            const rnd = Math.floor(Math.random() * 60) + 1;
            await blackmd.sendMessage(sender, {
                sticker: {
                    url: `https://raw.githubusercontent.com/TznModas/nsfw/refs/heads/main/stickers/adults/sticker_bundas/sticker_${rnd}.webp`
                }
            });
        } catch (err) {
            console.error(`Erro ao enviar figurinha: ${err.message}`);
            reply("Erro ao enviar figurinha. Tente novamente mais tarde.");
        }
    }

    (async () => {
        for (let i = 0; i < q; i++) {
            await sleep(680);
            await figusadul();
        }
    })();

    break;
}
case 'figu_porn':
case 'figporn': {
    if (!Number(q)) return reply(`Digite a quantidade de figurinhas\nExemplo: ${prefix + command} 4`);
    if (q >= 11) return reply("Coloque abaixo de 11...");
    if (isGroup) reply(`Enviarei no seu PV.`);

    async function figusadul() {
        try {
            const rnd = Math.floor(Math.random() * 200) + 1;
            await blackmd.sendMessage(sender, {
                sticker: {
                    url: `https://raw.githubusercontent.com/TznModas/nsfw/refs/heads/main/stickers/adults/sticker_porn/${rnd}.webp`
                }
            });
        } catch (err) {
            console.error(`Erro ao enviar figurinha: ${err.message}`);
            reply("Erro ao enviar figurinha. Tente novamente mais tarde.");
        }
    }

    (async () => {
        for (let i = 0; i < q; i++) {
            await sleep(680);
            await figusadul();
        }
    })();

    break;
}
case 'figuroblox': case 'figu_roblox':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. n√£o pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_roblox`);
    }
    break;

case 'figu_coreana': case 'figucoreana':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. n√£o pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_coreana`);
    }
    break;

case 'figudesenho': case 'figu_desenho':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. n√£o pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_desenho`);
    }
    break;

case 'figurinhas1': case 'figurinhas1':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. n√£o pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figurinhas`);
    }
    break;

case 'figurinhas2': case 'Figurinhas2':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. n√£o pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figurinhas2`);
    }
    break;

case 'figuemoji': case 'figu_emoji':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. n√£o pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_emoji`);
    }
    break;

case 'figualeatorio': case 'figu_alearorio':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. n√£o pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_aleatorio`);
    }
    break;

case 'figu_anime': case 'figu_anime':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. n√£o pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_anime`);
    }
    break;

case 'figuraiva': case 'figu_raiva':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. n√£o pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_raiva`);
    }
    break;

case 'figuengracada': case 'figu_engracada':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. n√£o pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_engracada`);
    }
    break;
    
case 'tirardocntd': case 'delmsg': case 'delcntd':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
if(!marc_tds) return reply(`Marque o usu√°rio que voc√™ quer deletar do contador, o @ ou a mensagem`)
txt = `Este usu√°rio n√£o est√° na database do contador deste grupo...`
AB = allGroupIDcountMessage.indexOf(from)
if(AB < 0) return reply(txt)
AC = getCountGroupMessage.participants.map(i => i.id).indexOf(marc_tds)
if(AC < 0) return reply(txt)
getCountGroupMessage.participants.splice(AC, 1)
saveJSON(countMessage, "./basededados/countmsg.json")
mention(`Usu√°rio @${marc_tds.split("@")[0]} deletado do contador de mensagens com sucesso...`)
break

case 'addmsgcntd': case 'rmmsgcntd':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
if(!q.includes(`/`)) return reply(`Use assim: ${prefix+command} @/1000`)
var [usumsg, quantmsg] = q.split(`/`)
if(!Number(quantmsg)) return reply(`${quantmsg} n√£o √© n√∫mero`)
usu = usumsg.toLowerCase() == `me` ? sender : identArroba(usumsg)
if(!usuInCountMessage(usu)) return mention(`O usu√°rio @${usu1.split("@")[0]} n√£o est√° na database do contador deste grupo...`)
dbuser = getUsuCountMessage(usu)
if(command.includes(`add`)) {dbuser.mensagens += Number(quantmsg)} else {dbuser.mensagens -= Number(quantmsg)}
saveJSON(countMessage, "./basededados/countmsg.json")
mention(`${quantmsg} mensage${Number(quantmsg) != 1 ? `ns` : `m`} fo${Number(quantmsg) != 1 ? `ram` : `i`} ${command.includes(`add`) ? `adicionada${Number(quantmsg) != 1 ? `s` : ``}` : `removida${Number(quantmsg) != 1 ? `s` : ``}`} do usu√°rio @${usu.split(`@`)[0]} com sucesso ‚úî`)
break

case 'addcmdcntd': case 'rmcmdcntd':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
if(!q.includes(`/`)) return reply(`Use assim: ${prefix+command} @/1000`)
var [usumsg, quantmsg] = q.split(`/`)
if(!Number(quantmsg)) return reply(`${quantmsg} n√£o √© n√∫mero`)
usu = usumsg.toLowerCase() == `me` ? sender : identArroba(usumsg)
if(!usuInCountMessage(usu)) return mention(`O usu√°rio @${usu1.split("@")[0]} n√£o est√° na database do contador deste grupo...`)
dbuser = getUsuCountMessage(usu)
if(command.includes(`add`)) {dbuser.comandos += Number(quantmsg)} else {dbuser.comandos -= Number(quantmsg)}
saveJSON(countMessage, "./basededados/countmsg.json")
mention(`${quantmsg} comando${Number(quantmsg) != 1 ? `s` : ``} fo${Number(quantmsg) != 1 ? `ram` : `i`} ${command.includes(`add`) ? `adicionado${Number(quantmsg) != 1 ? `s` : ``}` : `removido${Number(quantmsg) != 1 ? `s` : ``}`} do usu√°rio @${usu.split(`@`)[0]} com sucesso ‚úî`)
break

case 'transferirmsg': case 'trfrmsg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(contar(q, `/`) != 1) return reply(`Este comando √© para transferir as mensagens do n√∫mero antigo de um usu√°rio para o seu novo n√∫mero... Retorne ap√≥s o comando o n√∫mero antigo do usu√°rio, e o seu novo n√∫mero, separando ambos com uma barra ( / ), ex:
${prefix+command} ${addNumberMais(botNumber)}/${addNumberMais(randomUser)}`)
usu1 = identArroba(q.split(`/`)[0])
usu2 = identArroba(q.split(`/`)[1])
if(!usuInCountMessage(usu1)) return mention(`O usu√°rio @${usu1.split("@")[0]} n√£o est√° na database do contador deste grupo...`)
if(!usuInCountMessage(usu2)) return mention(`O usu√°rio @${usu2.split("@")[0]} n√£o est√° na database do contador deste grupo...`)
dbuser1 = getUsuCountMessage(usu1)
dbuser2 = getUsuCountMessage(usu2)
msg = dbuser1.mensagens
cmd = dbuser1.comandos
dbuser2.mensagens += msg
dbuser2.comandos += cmd
saveJSON(countMessage, "./basededados/countmsg.json")
AB = getCountGroupMessage.participants.map(i => i.id).indexOf(usu1)
getCountGroupMessage.participants.splice(AB, 1)
saveJSON(countMessage, "./basededados/countmsg.json")
mention(`As ${msg} mensagens e ${cmd} comandos do usu√°rio @${usu1.split("@")[0]} foram transferidos para o usu√°rio @${usu2.split("@")[0]} com sucesso...`)
break

case 'anotar':
case 'tirar_nota':
case 'rmnota':
if(!isGroup) return reply(enviar.msg.grupo)  
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(command == "anotar") {
var [q5, q10] = q.trim().split("|")
if(!q5 || !q10 || !q.includes("|")) return reply(`Digite o t√≠tulo da anota√ß√£o e o texto que deseja anotar..\nExemplo: ${prefix}anotar M4|O mais brabo das edits...`)
if(JSON.stringify(anotar).includes(from)) {  
var i2 = anotar.map(i => i.grupo).indexOf(from)  
if(JSON.stringify(anotar[i2].puxar).includes(q5)) {
var i3 = anotar[i2].puxar.map(i => i.nota).indexOf(q5)  
if(anotar[i2].puxar[i3].nota == q5) return reply(`Esta anota√ß√£o j√° est√° inclusa, utilize outro t√≠tulo.. Ou voc√™ pode tirar com\n${prefix}tirar_nota ${q5}`)
}
}
if(!JSON.stringify(anotar).includes(from)) {
anotar.push({grupo: from, puxar: [{nota: q5, anotacao: q10}]})
fs.writeFileSync("./basedefuncionamento/tabela/anotar.json", JSON.stringify(anotar))
reply("Anota√ß√£o registrada com sucesso...")
} else {
anotar[i2].puxar.push({nota: q5, anotacao: q10})
fs.writeFileSync("./basedefuncionamento/tabela/anotar.json", JSON.stringify(anotar))
reply("Anota√ß√£o registrada com sucesso...")  
}
} else {
if(!q) return reply("Digite qual anota√ß√£o deseja tirar pelo t√≠tulo..")
if(JSON.stringify(anotar).includes(from)) {  
var i2 = anotar.map(i => i.grupo).indexOf(from)  
if(JSON.stringify(anotar[i2].puxar).includes(q)) {
var i3 = anotar[i2].puxar.map(i => i.nota).indexOf(q)  
}
}
if(0 > anotar[i2].puxar.map(i => i.nota).indexOf(q)) return reply("Esta nota n√£o est√° inclusa, verifique com aten√ß√£o...")
anotar[i2].puxar.splice(i3, 1)
fs.writeFileSync("./basedefuncionamento/tabela/anotar.json", JSON.stringify(anotar))
reply(`Anota√ß√£o ${q} tirada com sucesso...`)
}
break

case 'anotacao':
case 'anotacoes':  
case 'nota':
case 'notas':
if(!isGroup) return reply(enviar.msg.grupo)
if(command == "anotacao" || command == "nota") {
if(!q.trim()) return reply("Digite o t√≠tulo da anota√ß√£o que deseja puxar..")
if(!JSON.stringify(anotar).includes(from)) return reply("Este grupo n√£o tem nenhuma anota√ß√£o...")
var i2 = anotar.map(i => i.grupo).indexOf(from)  
if(!JSON.stringify(anotar[i2].puxar).includes(q)) return reply("N√£o cont√©m nenhuma anota√ß√£o com este t√≠tulo.")
var i3 = anotar[i2].puxar.map(i => i.nota).indexOf(q)  
mention(`„Äà ${anotar[i2].puxar[i3].anotacao} „Äâ`)
} else {
var i2 = anotar.map(i => i.grupo).indexOf(from)    
if(i2 < 0) return reply("Este grupo n√£o tem nenhuma anota√ß√£o...")
var i2 = anotar.map(i => i.grupo).indexOf(from) 
var antr = anotar[i2]?.puxar 
txtin = "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n"
for ( i = 0; i < antr?.length; i++) {
txtin += `‚Üù Anota√ß√£o: ‚üÆ ${anotar[i2]?.puxar[i]?.nota} ‚üØ - „Äà ${anotar[i2]?.puxar[i]?.anotacao} „Äâ\n\n`
}
txtin += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n"
mention(txtin)
}
break

case 'download-link':
if(q.includes("video") || q.includes("mp4")) {
blackmd.sendMessage(from, {video: {url: q}, mimetype: 'video/mp4'}, {quoted: seloctt}).catch(e => {
reply("Erro, visualize se este link √© v√°lido...")
})
} else if(q.includes("webp") || q.includes("jpg")) {
blackmd.sendMessage(from, {image: {url: q}}, {quoted: seloctt}).catch(e => {
reply("Erro, visualize se este link √© v√°lido...")
})
}
break

case 'infoanotacao':
blackmd.sendMessage(from, {text: anotacao(prefix)})
break


case 'addnv-adc': case 'rmnv-adc':
case 'addnv-mod': case 'rmnv-mod':
case 'addnv-rm': case 'rmnv-rm':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply("KD o comando?")
com = command.split("-")[1]
if(com == "adc") nmr = 0
if(com == "mod") nmr = 1
if(com == "rm") nmr = 2
if(command.startsWith("add")) {
var [co, de] = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/").split("/")
novidades[nmr].add.push({cmd: co.toLowerCase(), desc: de ? de : ""})
saveJSON(novidades, "./database/data/novidades.json")
reply(`*_Comando adicionado a lista com sucesso ‚úÖ_*`)
} else {
AB = novidades[nmr].add.map(i => i.cmd).indexOf(q.toLowerCase())
if(AB < 0) return reply("Comando n√£o encontrado")
novidades[nmr].add.splice(AB, 1)
saveJSON(novidades, "./database/data/novidades.json")
reply(`*_Comando removido da lista com sucesso ‚úîÔ∏è_*`)
}
break

case 'novidades':
case 'novo':
reagir(from, "‚úÖ")
reply(`
‚úÖ *COMANDOS ADICIONADOS:*

${novidades[0].add.length > 0 ? novidades[0].add.map(a => `‚Ä¢ ${prefix+a.cmd} ${a.desc.length > 0 ? `_(${a.desc})_` : ``}`).join("\n") : "üö´ nenhum üö´"}

---------------------------------------------------------
‚ö†Ô∏è *COMANDOS ALTERADOS:*

${novidades[1].add.length > 0 ? novidades[1].add.map(b => `‚Ä¢ ${prefix+b.cmd} ${b.desc.length > 0 ? `_(${b.desc})_` : ``}`).join("\n") : "üö´ nenhum üö´"}

---------------------------------------------------------
üóëÔ∏è *COMANDOS REMOVIDOS:*

${novidades[2].add.length > 0 ? novidades[2].add.map(c => `‚Ä¢ ${prefix+c.cmd} ${c.desc.length > 0 ? `_(${c.desc})_` : ``}`).join("\n") : "üö´ nenhum üö´"}

---------------------------------------------------------
üí¨ *NOSSO CHAT:* ${prefix}ladygp
‚ùì *Alguma sugest√£o ? Use o comando:* ${prefix}sugest√£o
üíæ *Algum bug ? relate √† nossa equipe no comando:* ${prefix}bug
`)
break

case 'getcase': case 'puxarcase': case 'gc': {
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`KD o nome do comando? Ex: ${prefix+command} menu`)
let { key } = await blackmd.sendMessage(from, {text: "üîé üÑ±üÖÑüÖÇüÑ≤üÑ∞üÑΩüÑ≥üÑæ üÑ≤üÑ∞üÖÇüÑ¥ üîç"}, {quoted: seloctt})
await sleep(1000)
try { var [cmdgc, idusu] = q.replace(`/ `, `/`).replace(` /`, `/`).replace(` / `, `/`).split(`/`)
gccmd = `${getCase(rmLetras(cmdgc))}`
if(!idusu) return blackmd.sendMessage(from, {text: gccmd, edit: key}, {quoted: seloctt})
envusu = identArroba(idusu)
blackmd.sendMessage(from, {text: `_Enviando a *case '${rmLetras(cmdgc)}':* no PV do @${envusu.split("@")[0]}_ üëÄ`, mentions: [envusu, sender], edit: key}, {quoted: seloctt})
await sleep(500)
blackmd.sendMessage(envusu, {text: `_Ol√° @${envusu.split(`@`)[0]}, ${tempo}... @${sender.split(`@`)[0]} te enviou a *case '${rmLetras(cmdgc)}':*_ ü•∞`, mentions: [envusu, sender]})
await sleep(1000)
sendMess(envusu, gccmd) } catch(e) { console.log(e)
blackmd.sendMessage(from, {text: `*[ ‚ùó ] Comando N√£o Encontrado ‚ùå*`, edit: key}, {quoted: seloctt}) } }
break

case 'getlinha':
if(!isOwner) return reply(enviar.msg.dono)
const arquivo = fs.readFileSync("index.js", "utf-8")
const localCase = arquivo.indexOf(`case '${q}'`)
if(localCase === -1) return reply('Comando n√£o encontrado.')
reply(`O comando '${q}' est√° na linha: ` + arquivo.substr(0, localCase).split("\n").length)
break

case 'enquete':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!q.includes('/') || !q.includes('|')) return reply(`Olha s√≥ como faz ${pushname}

${prefix+command} lady a mais braba ?|sim/n√£o/tlvz`)
luck1 = q.split('|')[0]
luck2 = q.split('|')[1]
math1 = `${luck2} `
math2 = []
for(i = 0; i < math1.length; i++) {
math2.push({sla: math1.split(math1.slice(i+1))[0].slice(i)})
}
math3 = 1
for(i = 0; i < math2.length; i++) {
if(math2[i].sla.includes('/')) {
math3 += 1
}
}
if(math3 < 2) {
reply(`Defina ao m√≠nimo duas alternativas de respostas...`)
} else {
math4 = []
for(i = 0; i < math3; i++) {
math4.push(luck2.split('/')[i])
}
sendAsPoll(from, luck1, math4)
}
break


case 'verificado-global':
case 'globalv':
case 'selo':
if(!isOwner) return reply(enviar.msg.dono)
if(!isVerificado) {
obrigadoEXT.verificado = true
setObg(obrigadoEXT)
reply(`üî∞ verificado global ativado com sucesso ‚úÖ`)
} else if(isVerificado) {
obrigadoEXT.verificado = false
setObg(obrigadoEXT)
reply(`‚ûø verificado global desativado com sucesso ‚úîÔ∏è`)
}
break

case "botoes":
if(!isOwner) return reply(enviar.msg.dono);
if(botoes) {
botoes = false
obrigadoEXT.botoes = false
setObg(obrigadoEXT)
reply("‚úñÔ∏è Os bot√µes foram desativados... S√°bia atitude ‚ûø");
} else if(!botoes) {
botoes = true
obrigadoEXT.botoes = true
setObg(obrigadoEXT)
reply(`‚úîÔ∏è Os bot√µes foram ativados... Use com sabedoria „Ä∞Ô∏è`)
}
await sleep(700)
console.log(colors.green(`Restart necess√°rio para save de dados..`))
process.exit()
break;

case 'audio-menu': 
if(!isOwner) return reply(enviar.msg.dono)
if(!isAudioMenu) {
obrigadoEXT.menu_audio = true
setObg(obrigadoEXT)
reply(`‚úîÔ∏è O √°udio menu foi ativado com sucesso „Ä∞Ô∏è`)
} else if(isAudioMenu) {
obrigadoEXT.menu_audio = false
setObg(obrigadoEXT)
reply(`‚úñÔ∏è O √°udio menu foi desativado com sucesso ‚ûø`)
}
break

case 'console':   
if(!isOwner) return reply(enviar.msg.dono)
if(!isConsole) {
obrigadoEXT.consoleoff = true
setObg(obrigadoEXT)
reply(`‚úîÔ∏è O console foi ativado... Todas as a√ß√µes do bot ser√£o mostradas l√° „Ä∞Ô∏è`) 
} else if(isConsole) {
obrigadoEXT.consoleoff = false
setObg(obrigadoEXT)
reply(`‚úñÔ∏è O console foi desativado... As a√ß√µes do bot n√£o ser√£o mais vistas l√° ‚ûø`)
}
break

case 'menu': case 'm':
setTimeout(() => {reagir(from, react2)}, 300)
if(isIOS || isGroup) return sendMenuPrime()
botaoblk = {
  type: `list`,
  title: `„Äò  ùôºùöòùöúùöùùöõùöäùöõ ùôªùöíùöúùöùùöä „Äô`,
  rowId: [
    {
      title: "„Äé Lady bot „Äè",
      options: [
        {title: "„Äîüëë ùôÑùôâùôÅùôä-ùòøùôäùôâùôä üëë„Äï", command: `${prefix}infodono`, body: `‚Æë ${NomeDoBot}`}
      ]
    },
    {
      title: "„Äé ùô≥ùô∏ùöÖùô¥ùöÅùöÇùôæùöÇ ùôºùô¥ùôΩùöÑùöÇ „Äè",
      options: [
        {title: "„Äîüíé ùôàùôÄùôâùôê-ùôãùôçùôÑùôâùòæùôÑùôãùòºùôá üíé„Äï", command: `${prefix}comandos`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüéó ùôàùôÄùôâùôê-ùòºùòøùôà üéóÔ∏è„Äï", command: `${prefix}menuadm`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüí∞ ùôàùôÄùôâùôê-ùòºùôáùôêùôÇùôêùôÄùôá üí∞„Äï", command: `${prefix}menualuguel`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîü§™ ùôàùôÄùôâùôê-ùôïùôäùôÄùôÑùôçùòº ü§™„Äï", command: `${prefix}menuzoeira`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äî‚ù§Ô∏è‚Äçüî• ùôàùôÄùôâùôê-ùôèùôÑùôâùòøùôÄùôç ‚ù§Ô∏è‚Äçüî•„Äï", command: `${prefix}menutinder`, body: `‚Æë ${NomeDoBot}`},
        {title: "„ÄîüéÆ ùôàùôÄùôâùôê-ùôÇùòºùôàùôÄùôé üéÆ„Äï", command: `${prefix}menujogos`, body: `‚Æë ${NomeDoBot}`},
        //{title: "„Äîüè¶ ùôàùôÄùôâùôê-ùòΩùôáùòºùòæùôÜ-ùòæùôÑùôèùôî üè¶„Äï", command: `${prefix}menubc`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüß© ùôàùôÄùôâùôê-ùôÄùôÅùôÄùôÑùôèùôäùôé üß©„Äï", command: `${prefix}menuefeitos`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüß∏ ùôàùôÄùôâùôê-ùôàùôäùòøùôé üß∏„Äï", command: `${prefix}menumods`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüíù ùôàùôÄùôâùôê-ùôÅùôÑùôÇùôêùôçùôÑùôâùôÉùòºùôé üíù„Äï", command: `${prefix}menufigu`, body: `‚Æë ${NomeDoBot}`},
        {title: "„ÄîüòÉ ùôàùôÄùôâùôê-ùôÄùôàùôäùôÖùôÑ üòÉ„Äï", command: `${prefix}menuemoji`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüíø ùôàùôÄùôâùôê-ùòøùôäùôíùôâùôáùôäùòºùòøùôé üíø„Äï", command: `${prefix}menudownloads`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüìú ùôàùôÄùôâùôê-ùôáùôäùôÇùôäùôé üìú„Äï", command: `${prefix}menulogos`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîü§ë ùôàùôÄùôâùôê-ùôëùôÑùôã ü§ë„Äï", command: `${prefix}menuvip`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüîû ùôàùôÄùôâùôê+18 üîû„Äï", command: `${prefix}menu+18`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüé≠ ùôÄùôâùôèùôçùôÄùôèùôÄùôâùôÑùôàùôÄùôâùôèùôä üé≠„Äï", command: `${prefix}entretenimento`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüîé ùôãùôÄùôéùôåùôêùôÑùôéùòºùôé üîé„Äï", command: `${prefix}pesquisas`, body: `‚Æë ${NomeDoBot}`},
        {title: "„ÄîüïµÔ∏è‚Äç‚ôÇÔ∏è ùòæùôäùôâùôéùôêùôáùôèùòºùôé üïµÔ∏è‚Äç‚ôÇÔ∏è„Äï", command: `${prefix}menuvip`, body: `‚Æë ${NomeDoBot}`},
        {title: "„ÄîüóûÔ∏è ùôàùôÄùôâùôê-ùôâùôäùôèùôÑùòæùôÑùòºùôé üóûÔ∏è„Äï", command: `${prefix}menunot`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîü§ñ ùôàùôÄùôâùôê-ùôÑùòº ü§ñ„Äï", command: `${prefix}menuia`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüì∑ ùôíùòºùôáùôáùôãùòºùôãùôÄùôçùôé üì∑„Äï", command: `${prefix}menuwall`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüåû ùôàùôÄùôâùôê-ùôçùôãùôÇ üåû„Äï", command: `${prefix}menurpg`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äî ‚öíÔ∏èùôÅùôÄùôçùôçùòºùôàùôÄùôâùôèùòºùôé‚öíÔ∏è „Äï", command: `${prefix}menuf`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüî± ùôàùôÄùôâùôê-ùòøùôäùôâùôä üî±„Äï", command: `${prefix}menudono`, body: `‚Æë ${NomeDoBot}`}
      ]
    },
    {
      title: "„Äé ùô≤ùô∑ùô¥ùô≤ùô∫ùöÇ ùô¥ ùô∏ùôΩùôµùôæùöÅùôºùô∞ùô≤ùôæùô¥ùöÇ „Äè",
      options: [
        {title: "„Äî‚ö° ùòæùôÉùôÄùòæùôÜ-ùôãùôÑùôâùôÇ ‚ö°„Äï", command: `${prefix}ping`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüòº ùôàùôÄùôê-ùôãùôÄùôçùôÅùôÑùôá üòº„Äï", command: `${prefix}perfil`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüõí ùòºùôáùôêùôÇùòºùôç üõí„Äï", command: `${prefix}alugar`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüí¨ ùòæùôÉùòºùôè-ùôäùôÅùôÑùòæùôÑùòºùôá üí¨„Äï", command: `${prefix}ladygp`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äî‚úÖ ùòºùôëùòºùôáùôÑùòºùôç ‚úÖ„Äï", command: `${prefix}avalie`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüí° ùôéùôêùôÇùôÄùôéùôèùòºÃÉùôä üí°„Äï", command: `${prefix}sugestao`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüíæ ùôçùôÄùôãùôäùôçùôèùòºùôç-ùôêùôà-ùòΩùôêùôÇ üíæ„Äï", command: `${prefix}bug`, body: `‚Æë ${NomeDoBot}`},
        {title: "„Äîüêû ùôÑùôâùôÅùôä-ùôáùòºùòøùôî üêû„Äï", command: `${prefix}infobot`, body: `ùë®ùíñùíÖùíäùíê ùë∞ùíèùíáùíêùíìùíéùíÇùíèùíÖùíê...`}
      ]
    }
  ]
}
txt = `„Äîüè∑„Äï‚•≤ ùôâùôÑùòæùôÜ: ${pushname}
„ÄîüìÖ„Äï‚•≤ ùòøùòºùôèùòº: ${date}
„Äî‚è±„Äï‚•≤ ùôÉùôäùôçùòº: ${hora120}
„Äî‚öú„Äï‚•≤ ùôëùôÑùôã: ${isVip ? 'Sim ‚úÖ' : 'N√£o ‚ùå'}`, `${NomeDoBot}`
sendRouletteButton(sender, {image: {url: logoslink.logo}, caption: txt, footer: NomeDoBot, contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: blackchannel, newsletterName: `‰∫ó Lady bot‰∫ó`}}}, blackmd, sender, [botaoblk], info)
break

case 'comandos':
setTimeout(() => {reagir(from, `üòÉ`)}, 300)
sendMenuPrime()
break

case 'logos':
case 'menulogo':
case 'menulogos':
setTimeout(() => {reagir(from, "üìú")}, 300)
const { menulogos } = require("./dono/menus/menulogos.js")
mlogos = menulogos(sender, prefix)
sendMenu(mlogos)
break

case 'menu_consultas':
case 'menucon':
case 'consultas':
case 'consulta':
setTimeout(() => {reagir(from, "üïµÔ∏è‚Äç‚ôÇÔ∏è")}, 300)
const { menucon } = require("./dono/menus/consultas.js")
mcon = menucon(sender, prefix)
sendMenu(mcon)
break

case 'menunot':
case 'noticias':
case 'menu_noticias':
setTimeout(() => {reagir(from, "üóûÔ∏è")}, 300)
const { menunot } = require("./dono/menus/noticias.js")
mnoti = menunot(sender, prefix)
sendMenu(mnoti)
break

case 'entreter':
case 'entretenimento':
case 'menuent':
setTimeout(() => {reagir(from, "üé≠")}, 300)
const { menuent } = require("./dono/menus/entretenimento.js")
menue = menuent (sender, prefix)
sendMenu(menue)
break

case 'pesquisas':
case 'menupes':
case 'menup':
setTimeout(() => {reagir(from, "üîé")}, 300)
const { menupes } = require("./dono/menus/pesquisas.js")
pesq = menupes(sender, prefix)
sendMenu(pesq)
break

case 'menuf':
case 'ferramentas':
case 'menufer':
setTimeout(() => {reagir(from, "‚öíÔ∏è")}, 300)
const { menufer } = require("./dono/menus/ferramentas.js")
ferr = menufer(sender, prefix)
sendMenu(ferr)
break
case 'wallpapers':
case 'wallpaper':
case 'menuwall':
case 'menuw':
setTimeout(() => {reagir(from, "‚ùÑÔ∏è")}, 300)
const { menuwall } = require("./dono/menus/wallpapers.js")
wall = menuwal(sender, prefix)
sendMenu(wall)
break

case 'ia':
case 'menuias':
case 'menuia':
setTimeout(() => {reagir(from, "ü§ñ")}, 300)
const { menuia } = require("./dono/menus/menuia.js")
ias = menuia(sender, prefix)
sendMenu(ias)
break

case 'rpg':
case 'menurpg':
case 'Menurpg':
setTimeout(() => {reagir(from, "üåû")}, 300)
const { menurpg } = require("./dono/menus/menurpg.js")
rpg = menurpg(sender, prefix)
sendMenu(rpg)
break
case 'figurinhas':
case 'menufigurinhas':
case 'menufigu':
case 'menufig':
setTimeout(() => {reagir(from, "üíù")}, 300)
const { menufig } = require("./dono/menus/menufig.js")
menuf = menufig(sender, prefix)
sendMenu(menuf)
break

case 'menuemoji':
setTimeout(() => {reagir(from, "üòÉ")}, 300)
const { menuemoji } = require("./dono/menus/menuemoji.js")
MEJ = menuemoji(sender, prefix)
sendMenu(MEJ)
break

case 'menu+18': case '+18': case 'menunsfw':
if(isGroup && !isNsfw) return reply(`*Este comando s√≥ pode ser executado com o modo+18 ativo...*
*Para ativa-lo, digite* ${prefix}modo+18`)
if(!isGroup && !isVip) return reply("Este recurso no PV s√≥ est√° liberado para usu√°rios VIP")
setTimeout(() => {reagir(from, "üîû")}, 300)
const { menunsfw } = require("./dono/menus/menunsfw.js")
m18 = menunsfw(sender, prefix)
sendMenu(m18)
break

case 'menudownloads':
case 'menudown':
case 'downloads':
case 'musica':
case 'musicas':
case 'tocarmusica':
setTimeout(() => {reagir(from, "üíø")}, 300)
const { menudown } = require("./dono/menus/menudown.js")
sendMenu(menudown(sender, prefix))
break

case 'menujogos':
case 'jogos':
case 'menugames':
case 'games':
setTimeout(() => {reagir(from, "üéÆ")}, 300)
const { menujogos } = require("./dono/menus/menujogos.js")
menugame = menujogos(sender, prefix)
sendMenu(menugame)
break

case 'menutinder':
setTimeout(() => {reagir(from, "‚ù§Ô∏è‚Äçüî•")}, 300)
const { menutinder } = require("./dono/menus/menutinder.js")
sendMenu(menutinder(sender, prefix))
break

case 'menualuguel':
case 'menurent':
setTimeout(() => {reagir(from, "üí∞")}, 300)
const { menualuguel } = require("./dono/menus/menualuguel.js")
sendMenu(menualuguel(sender, prefix))
break

case 'menuadm':
case 'menuadms':
case 'adm':
setTimeout(() => {reagir(from, "üéóÔ∏è")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) { reply(enviar.msg.adm)
return blackmd.sendMessage(from, {audio: {url:'./database/audios/apenasadm.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
const { menuadm } = require("./dono/menus/menuadm.js")
sendMenu(menuadm(sender, prefix))
break

case 'menudono':
case 'donomenu':
if(!isOwner) { reply(enviar.msg.dono)
return blackmd.sendMessage(from, {audio: {url:'./database/audios/cmddono.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üî±")}, 300)
const { menudono } = require("./dono/menus/menudono.js")
txt = menudono(sender, prefix)
sendMenu(txt)
break

case 'efeitosimg':
case 'efeitos':  
case 'efeitoimg':
case 'menuefeitos':
reagir(from, "üß©")
const { menuefeitos } = require("./dono/menus/menuefeitos.js")
txt = menuefeitos(sender, prefix)
blackmd.sendMessage(from, {image: {url: logoslink.logo}, caption: txt, mentions: [sender]})
break

case 'alteradores':
case 'mods':
case 'mod':
case 'menumods':
reagir(from, "üß∏")
const { menumods } = require("./dono/menus/menumods.js")
txt = menumods(sender, prefix)
sendMenu(txt)
break

case 'menuzoeira':
case 'zoeira':
case 'brincadeiras':
setTimeout(() => {reagir(from, "ü§™")}, 300)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for um, apenas digite ${prefix}modozoeira 1`)
const { menuzoeira } = require("./dono/menus/menuzoeira.js")
MZ = menuzoeira(sender, prefix)
sendMenu(MZ)
break 

case 'menuvip':
case 'menupremium':
case 'menuprem':
case 'vip':
setTimeout(() => {reagir(from, "ü§ë")}, 300)
const { menuvip } = require("./dono/menus/menuvip.js")
mvip = menuvip(sender, prefix)
sendMenu(mvip)
break

case 'calendario':
case 'dados':
setTimeout(() => {reagir(from, "üìÖ")}, 300)
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
totalcmd = JSON.parse(fs.readFileSync("./database/data/totalcmd.json"))[0].totalcmd
day = `
${tempo_emoji} *${tempo.toUpperCase()}*
üë§ ${pushname}

üë• *GRUPO:* ${isGroup ? groupName : "privado"}
üìÜ *DATA & HORA ‚Ü¥*
${semana}, ${realtime()}
üé≤ *TOTAL-CMD:* ${totalcmd} comandos
ü§ñ *BOT:* ${NomeDoBot}
üëë *DONO:* ${NickDono}

üì† _Operando em ${allGroups.length} grupos_
`
if(isGroupInRent(from)) {
hehe = getGroupRent(from)
day += `üîã *Bateria restante para uso ‚Ü¥*
-> ${barrinha(hehe.tempo, hehe.totalRent)} ${hehe.cliente == sender || isOwner ? `\n¬ª‚ü© ${sendTimeHours(hehe.tempo)} at√© o fim do contrato ‚ü®¬´` : ``}
`
}
reply(`${day}`)
break

case 'stickerid'://vitukjk
if(isQuotedSticker) {
const stickerId = info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage.fileSha256.toString('hex').toUpperCase();
reply(`${stickerId}`);
} else {
reply('Marque uma figurinha para mostrar o ID.');
}
break


case 'ladyg': case 'grupooficial':
reagir(from, `‚úÖ`)
try {
nome = (await blackmd.groupMetadata(obrigadoEXT.idchatofc)).subject
link = await blackmd.groupInviteCode(obrigadoEXT.idchatofc)
try { ppUrl = await blackmd.profilePictureUrl(obrigadoEXT.idchatofc, 'image')
} catch { ppUrl = semfoto }
if(isGroup) {
linkgp = `*Link do nosso grupo:* ‚úÖ

https://chat.whatsapp.com/`+link
sendUrlText(from, linkgp, nome, `Chat OFC da lady v5`, ppUrl, `https://chat.whatsapp.com/`+link, seloctt)
} else {
sendUrlDoc(from, `*Link do nosso Chat...* ‚úÖ

üîó _Clique na imagem para entrar_`, `application/pdf`,
`${tempo_emoji}‚É§ ${tempo.toUpperCase()}`,
10000, nome, '', ppUrl, `https://chat.whatsapp.com/`+link, seloctt)
}
} catch { reply("Erro") }
break

case 'site':
reagir(from, "üåê")
sendUrlText(from,
`*Site oficial do luanzn:* ‚úÖ\n\n`+site,
`üîé ${NomeDoBot} üîç`,
`Um site para amantes de tecnologia e inova√ß√µes com conte√∫dos √∫nicos`,
logoslink.menu,
site,
seloctt)
break

case 'infolady':
reagir(from, "ü•∞")
ib = `${tempo_emoji} _${tempo} ${pushname}, caiu de paraquedas e n√£o sabe como funciona tudo por aqui? Chega mais..._

ü§ñ _a ladybug √© uma bot altamente sofisticado, capaz de operar de forma remota e autom√°tica em seu grupo, com altas fun√ß√µes de administra√ß√£o e divers√£o. Nossa equipe se empenha diariamente para manter o bot online com os melhores sistemas que voc√™ pode encontrar._

üí° _Quanto ao uso dos comandos, o prefixo usado √© ( ${prefix} ), basta digitar o mesmo na frente do comando para que esse seja executado... Claro que vc pode acabar digitando errado ou pode ser que o comando n√£o exista. Sendo assim, olhe no ${prefix}menu e n√£o exite em procurar o mesmo nos diversos menus que est√£o organizados l√°._

_-> Modo de uso do prefixo:_
‚ùå menu${prefix}
‚ùå ${prefix} menu
‚úÖ ${prefix}menu

üí¨ *NOSSO CHAT:* ${prefix}blackgp
üõí *Se desejas alugar o bot para seu grupo digite:* ${prefix}alugar
ü§î *D√∫vidas? Use:* ${prefix}suporte
‚ùì *Alguma sugest√£o ? Use o comando:* ${prefix}sugest√£o
üíæ *Algum bug ? relate √† nossa equipe no comando:* ${prefix}bug`
reply(ib)
break

case 'aluguel':
case 'alugueis':
case 'alugar':
case 'alugarbot': {
reagir(from, "üõí")
moneybot = `*_¬ª‚ü©Tabela de pre√ßos para alugar o bot ‚ü®¬´_*

${valoresDeAluguel.map(a => `${permuteNumberEmoji(a.id)}‚ßΩ R$ ${Number(a.valor).toFixed(2)} (${a.tempo} dias)`).join(`\n`)}
`
var download = [
` ü·¥è·¥Ä·¥Ö…™…¥…¢„Äò‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äô0%`,
` ü·¥è·¥Ä·¥Ö…™…¥…¢„Äò‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äô10%`,
` ü·¥è·¥Ä·¥Ö…™…¥…¢„Äò‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äô35%`,
` ü·¥è·¥Ä·¥Ö…™…¥…¢„Äò‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí„Äô51%`,
` ü·¥è·¥Ä·¥Ö…™…¥…¢„Äò‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí„Äô62%`,
` ü·¥è·¥Ä·¥Ö…™…¥…¢„Äò‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí„Äô80%`,
` ü·¥è·¥Ä·¥Ö…™…¥…¢„Äò‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà„Äô100%`,
`ùôªùôæùô∞ùô≥ùô∏ùôΩùô∂ ùô≤ùôæùôºùôøùôªùô¥ùöÉùô¥ùô≥...`
]
let { key } = await blackmd.sendMessage(from, {text: tempo+" "+pushname}, {quoted: info})
await sleep(2000)
for(let i = 0; i < download.length; i++) {
await blackmd.sendMessage(from, {text: download[i], edit: key }, {quoted: info})
}
reply(moneybot + `

‚ù™üçß‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ _use *${prefix}buykeygp* para escolher o tempo de aluguel e *${prefix}buygp* com o link do grupo para o bot entrar..._`)}
break

case 'loja': case 'store':
reagir(from, "üõçÔ∏è")
try { ppimg = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image'))}`)).data
} catch(e) { ppimg = semfoto }
txt = `„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§ *üõí„Äò LOJA „Äôüõí* 
‚ù™üõçÔ∏è‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ *ALUGU√âIS*
${valoresDeAluguel.map(a => `${permuteNumberEmoji(a.id)}‚ßΩ R$ ${Number(a.valor).toFixed(2)} (${a.tempo} dias)`).join(`\n`)}
_Use *${prefix}buykeygp*_

‚ù™üí∞‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ *VIP*
1Ô∏è‚É£ R$ ${Number(valoresVIP.vip).toFixed(2)} (30 dias - VIP global sem puxadas)
2Ô∏è‚É£ R$ ${Number(valoresVIP.vipcp).toFixed(2)} (30 dias - VIP global com puxadas)
3Ô∏è‚É£ R$ ${Number(valoresVIP.vipgp).toFixed(2)} (30 dias - VIP de grupo sem puxadas)
4Ô∏è‚É£ R$ ${Number(valoresVIP.vipgpcp).toFixed(2)} (30 dias - VIP de grupo com puxadas)
_Use *${prefix}buyvip* ou *${prefix}buyvipgp*_

‚ù™üîñ‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ *Card XP*
_Cada dia √© multiplicado 1 a mais (Se for 1 dia, multiplica por 2... Se for 3 dias, multiplica por 4, etc)_
${valoresXP.map(x => `*¬ª ${x.velocidade} ¬´*
` + x.dados.map(p => `${permuteNumberEmoji(p.id)}‚ßΩ R$ ${Number(p.valor).toFixed(2)} (${x.velocidade} por ${sendLetterTime(p.tempo)})`).join(`\n`)).join(`\n`)}
_Use *${prefix}buycard*_`
ft = `Caso queira visualizar a loja em lista, clique no bot√£o abaixo...`
butao = isGroup ? sendButton : sendRouletteButton
rent = isGroup ? {text: txt, footer: ft} : {image: {url: `https://telegra.ph/file/698a9e0883be7a1091ae7.jpg`}, caption: txt, footer: ft}
butao(from, rent, blackmd, sender, [{type: `cmd`, text: `ùôéùôèùôäùôçùôÄ ùôáùôÑùôéùôè üïπ`, command: prefix+`storelist`}], seloctt)
break

case 'storelist': case 'liststore': case 'lojalista': case 'listaloja':
txt =
`\t\t\t‚Æë ùôéùôèùôäùôçùôÄ ùôáùôÑùôéùôè ‚Æê
„Äîüë§„Äï‚Üù ·¥úÍú±·¥ú·¥ÄÃÅ Ä…™·¥è: @${sender.split("@")[0]}
„ÄîüìÜ„Äï‚Üù ·¥Ö·¥Ä·¥õ·¥Ä: ${sendHours("dddd, LL")}
„Äîüí∞„Äï‚Üù Íú±·¥Ä ü·¥Ö·¥è: R$ ${getSepCoins(sender)[2]}`
listaluguel = []
for(a of valoresDeAluguel) {
  listaluguel.push({name: `ALUGUE AGORA`, title: `${permuteNumberEmoji(a.id)}‚ßΩ ${a.tempo} dias`, body: `R$ ${Number(a.valor).toFixed(2)}`, command: prefix+`buykeygp `+a.tempo})
}
listvip = []
for(b = 0; b < 3; b++) {listvip.push({name: `VIP GLOBAL "SEM" PUXADAS`, title: `${permuteNumberEmoji(listvip.length + 1)}‚ßΩ ${(b + 1) * 10} dias`, body: `R$ ${Number((b + 1) * (valoresVIP.vip / 3)).toFixed(2)}`, command: prefix+`buyvip `+String((b + 1) * 10)},
{name: `VIP GLOBAL "COM" PUXADAS`, title: `${permuteNumberEmoji(listvip.length + 2)}‚ßΩ ${(b + 1) * 10} dias`, body: `R$ ${Number((b + 1) * (valoresVIP.vipcp / 3)).toFixed(2)}`, command: prefix+`buyvip `+String((b + 1) * 10)+`/puxadas`})}
for(c = 0; c < 3; c++) {listvip.push({name: `GRUPO VIP "SEM" PUXADAS`, title: `${permuteNumberEmoji(listvip.length + 1)}‚ßΩ ${(c + 1) * 10} dias`, body: `R$ ${Number((c + 1) * (valoresVIP.vipgp / 3)).toFixed(2)}`, command: prefix+`buyvipgp `+String((c + 1) * 10)},
{name: `GRUPO VIP "COM" PUXADAS`, title: `${permuteNumberEmoji(listvip.length + 2)}‚ßΩ ${(c + 1) * 10} dias`, body: `R$ ${Number((c + 1) * (valoresVIP.vipgpcp / 3)).toFixed(2)}`, command: prefix+`buyvipgp `+String((c + 1) * 10)+`/puxadas`})}
listcardxp = []
for(d of valoresXP) {
  for(e of d.dados) {listcardxp.push({name: d.velocidade, title: `${permuteNumberEmoji(listcardxp.length + 1)}‚ßΩ ${sendLetterTime(e.tempo)}`, body: `R$ ${Number(e.valor).toFixed(2)}`, command: prefix+`buycard ${d.velocidade}/${sendLetterTime(e.tempo)}`})}
}
but =
[{title: `ALUGUEL DE GRUPO`, options: listaluguel},
{title: `VIP GLOBAL E GRUPO VIP`, options: listvip},
{title: `CARD MULTI XP`, options: listcardxp}]
if(isGroup) reply(`Enviando PV`)
sendRouletteButton(sender, {image: {url: `https://telegra.ph/file/698a9e0883be7a1091ae7.jpg`}, caption: txt, mentions: [sender], footer: `_Escolha na lista abaixo o que desejas comprar ‚§µ_`, contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: blackchannel, newsletterName: `‰∫ó  ô ü·¥Ä·¥Ñ·¥ã Íú± èÍú±·¥õ·¥á·¥ç ·¥èÍú∞·¥Ñ ‰∫ó`}}}, blackmd, sender, [{type: `list`, title: `„Äò üí¢ CLIQUE AQUI üí¢ „Äô`, rowId: but}], seloctt)
break

case 'infoaluguel':
setTimeout(() => {reagir(from, "ü§ë")}, 300)
reply(`*Ol√° caro viajante, est√° perdido de como alugar o Black ?? Ett vou lhe dar uma r√°pida dica.* üßê
  
*Como visto na tabela acima, tem os pre√ßos de aluguel mensal... O pre√ßo varia dependendo da quantidade de meses; por√©m o pre√ßo √© unit√°rio por grupo.* üòÉ

*Por exemplo, se alugar dois grupos por 1 m√™s, vai ser ${valoresDeAluguel[1].valor}+${valoresDeAluguel[1].valor} = ${valoresDeAluguel[1].valor + valoresDeAluguel[1].valor}$. Ou se alugar dois grupos por dois meses, ser√° ${valoresDeAluguel[2].valor}+${valoresDeAluguel[2].valor} = ${valoresDeAluguel[2].valor + valoresDeAluguel[2].valor}$.* üíµ

*Caso voc√™ queira alugar o bot ou queira mais informa√ß√µes, chame meu dono no PV* üëë`)
break

case 'recarga': case 'recarregar': {
valores = [1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100]
caixa = [{tap: []}]
total = 0
for(a = 0; a < valores.length; a++) {
  if(caixa[total].tap.length < 3) {
    caixa[total].tap.push(valores[a])
  } else {
    caixa.push({tap: [valores[a]]})
    total += 1
  }
}
if(!valores.includes(Number(q))) {
  if(isIOS || isGroup) return reply(`*_Retorne o valor da recarga diretamente ap√≥s o comando, ex:_*
_${prefix+command} ${valores[alerandom(valores.length)]}_

*_Valores dispon√≠veis:_*
${caixa.map(a => `_` + a.tap.map(b => `R$ ${Number(b).toFixed(2)}`).join(`\t\t\t\t\t\t\t`) + `_`).join(`\n`)}`)
  matheuzinho = []
  for(v of valores) {
    matheuzinho.push({title: `ùó•ùóòùóñùóîùó•ùóöùóî ùó°ùó¢ ùó©ùóîùóüùó¢ùó• ùóóùóò ${v}$`, body: `referente a ${v} moeda${v != 1 ? "s" : ""}`, command: prefix+command+" "+String(v)})
  }
  return sendRouletteButton(sender, {image: {url: `https://blackstorage.store/midia/1735506461779.jpg`}, caption: tempo + " " + pushname + ", vejo que voc√™ n√£o escolheu o valor da recarga corretamente... Irei te mandar a tabela abaixo ‚Ü¥", footer: `ñ•®‡πç‚àòÃ•‚Éü‚∏Ω‚Éüüíå‡ß¥‚ñ∏ _Lembrando que essa recarga n√£o est√° vinculada a compra de nenhum produto no bot, com exce√ß√£o das moedas... Tais moedas ap√≥s compradas poder√£o ser usadas para afins como alugu√©is de grupos, VIP e outros. Para mais info, ver *${prefix}inforent*_`}, blackmd, sender, [{type: "list", title: `„Äò ùó•ùóòùóñùóîùó•ùóöùóîùó¶ „Äô`, rowId: [{title: NomeDoBot, options: matheuzinho}]}], seloctt)
}
nmr = Number(q)
var pagament = new payment(MercadoPagoKey)
try {
let inf = await pagament.create_payment(nmr)
console.log(colors.yellow(`\n\n[‚ö†Ô∏è] c√≥digo de pagamento gerado no valor de ${nmr}$ ‚öúÔ∏è\n\n`))
if(isGroup) reply('Por quest√µes de seguran√ßa, irei te enviar os dados no PV...')
await sleep(1000)
if(!isIOS) {
sendRouletteButton(sender, {image: Buffer.from(inf.qr_code, "base64"), caption: `QR code de pagamento acima... Caso queira apenas o c√≥digo, segue o pix copia e cola abaixo ‚Ü¥`, footer: NomeDoBot, contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: blackchannel, newsletterName: `‰∫ó  ô ü·¥Ä·¥Ñ·¥ã Íú± èÍú±·¥õ·¥á·¥ç ·¥èÍú∞·¥Ñ ‰∫ó`}}}, blackmd, sender, [{type: `copy_text`, text: `CLIQUE AQUI PARA COPIAR üìë`, url: inf.copy_paste}], seloctt)
} else {
blackmd.sendMessage(sender, {image: Buffer.from(inf.qr_code, "base64"), caption: `QR code de pagamento acima... Caso queira apenas o c√≥digo, segue o pix copia e cola abaixo ‚Ü¥`, footer: NomeDoBot, contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: blackchannel, newsletterName: `‰∫ó  ô ü·¥Ä·¥Ñ·¥ã Íú± èÍú±·¥õ·¥á·¥ç ·¥èÍú∞·¥Ñ ‰∫ó`}}}, {quoted: seloctt})
await sleep(3000)
sendMess(sender, inf.copy_paste)
}
await sleep(5000)
sendMess(sender, `Lembrando que voc√™ tem 10 minutos para efetuar o pagamento... Caso exceda o tempo, h√° possibilidade do sistema n√£o contabilizar as moedas.

Qualquer d√∫vida, use o comando ${prefix}suporte...`)

let check = await pagament.check_payment();

while(check.status == 'pending') { check = await pagament.check_payment() }
if(check.status == "approved") {
addCoinsInVirtualBalance(sender, nmr)
console.log(colors.green(`\n\n[‚ùï] pagamento efetuado com sucesso ‚úîÔ∏è\n\n`))
const sendComp = (taxa, valor) => {
sub = 100 / taxa
return `
‚îè‚ó§ ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÄ‚îÄ‚îÄ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ‚ó¢‚îì
[‚öôÔ∏è] *COMPROVANTE DE PAGAMENTO* [‚öôÔ∏è]
‚ïü‚îì
‚ïë‚î¢ ‚ù™üìñ‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ *Nome:* ${pushname}
‚ïë‚î¢ ‚ù™üì±‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ *N√∫mero:* @${sender.split('@')[0]}
‚ïë‚ïΩ
‚ïë‚î¢ ‚ù™üí∏‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ *Valor:* R$ ${Number(valor).toFixed(2)}
‚ïë‚î¢ ‚ù™üí∞‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ *Taxa:* ${taxa}% ( R$ ${Number(valor/sub).toFixed(2)} )
‚ïë‚î¢ ‚ù™ü™ô‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ *Total:* R$ ${Number(valor - (valor / sub)).toFixed(2)}
‚ïë‚ïΩ
‚ïë‚î¢ üìÖ‚É§ *Data:* ${sendHours('DD/MM/YYYY')}
‚ïë‚î¢ ‚è∞‚É§ *Hora:* ${sendHours('HH:mm:ss')}
‚ïë‚ïΩ
‚ïë‚ïΩ„Ö§„Ö§„Ö§„Ö§üí† Black System üí†
‚ïô‚î∑‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÄ‚îÄ‚îÄ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ
` }
blackmd.sendMessage(obrigadoEXT.idprivategp, {text: sendComp(1, nmr), mentions: [sender, nmrdn]})
await sleep(1000)
mention(`üí† Parab√©ns @${sender.split('@')[0]}, seu d√©bito foi aprovado no valor de *R$ ${Number(nmr).toFixed(2)}* debitado em sua conta virtual da Black System proveniente da recarga... Para mais info sobre o que fazer com suas moedas, acesse *${prefix}loja*`)
await sleep(1000)
return sendMess(sender, sendComp(0, nmr))
}
reply("Pagamento expirado „ÉÖ")
} catch(e) {
console.log(e)
reply("Sistema parece inst√°vel... Pfvr, volte mais tarde ‚úãüèΩüò≥ü§öüèΩ")
}
}
break

case 'me': case 'you':
if(command == `you`) {
if(!isOwner) return reply(enviar.msg.dono)
if(!marc_tds) return reply("Marque o usu√°rio que vc quer puxar o saldo")
usu = marc_tds
} else { usu = sender }
registrarUsuInVirtualBalance(usu)
try { ppimg = await blackmd.profilePictureUrl(`${usu.split('@')[0]}@c.us`, 'image')
} catch { ppimg = semfoto }
i = getCoinsUsu(usu)
txt = `üìñ *NOME:* ${getSepCoins(usu)[0]}
üí∏ *SALDO:* R$ ${getSepCoins(usu)[2]}
üì± *WHATSAPP:* wa.me/${i.id.split('@')[0]}
üÜî *ID:* ${i.UID}
üí≥ *CORTESIAS:* ${i.cortesia} ${i.keys.length > 0 ? `

üîë *KEYS:*
${i.keys.map(k => `‚Ä¢ *chave:* ${isGroup ? k.key.slice(0, 10) + `#`.repeat(k.key.length - 10) : k.key}
‚Ä¢ *tipo:* "${k.tipo == 1 ? `aluguel` : k.tipo == 2 ? `cortesia` : k.tipo == 3 ? `vip` : k.tipo == 4 ? `grupo vip` : `card xp`}"
‚Ä¢ *tempo:* ${k.tempo <= 0 ? `‚àû INFINITO` : k.tipo == 1 || k.tipo == 2 || k.tipo == 5 ? String((k.tempo - (k.tempo % 24)) / 24) + `d` + ((k.tempo % 24) > 0 ? ` e ` + String(k.tempo % 24) + `h` : ``) : String(k.tempo) + `d`}`).join(`\n\n`)}` : ``}

_Registrado em ${i.rg}_`
sendUrlText(from, txt, NomeDoBot, ``, ppimg, `https://wa.me/`+usu.split("@")[0], seloctt)
break

case 'keys':
if(!isOwner) return reply(enviar.msg.dono)
if(allKeysRentSystem.length <= 0) return reply(`N√£o h√° keys salvas na database do bot...`)
txt =
`üé≤ _*Total de keys:* ${allKeysRentSystem.length}_
${allKeysRentSystem.map(k => `üë§ *ID:* @${k.cliente.split("@")[0]}
üîë *CHAVE:* ${isGroup ? k.key.slice(0, 6) + `#`.repeat(k.key.length - 6) : k.key}
üßµ *TIPO:* "${k.tipo == 1 ? `aluguel` : k.tipo == 2 ? `cortesia` : k.tipo == 3 ? `vip` : k.tipo == 4 ? `grupo vip` : `card xp`}"
‚è± *TEMPO:* ${k.tempo <= 0 ? `‚àû INFINITO` : k.tipo == 1 || k.tipo == 2 || k.tipo == 5 ? String((k.tempo - (k.tempo % 24)) / 24) + `d` + ((k.tempo % 24) > 0 ? ` e ` + String(k.tempo % 24) + `h` : ``) : String(k.tempo) + `d`}`).join(`\n\n`)}`
mention(txt)
break

case 'addsaldo':
if(!isOwner) return reply(enviar.msg.dono)
var [nmr, quant] = q.split('/')
if(!nmr || !quant) return reply(`Voc√™ vai colocar o n√∫mero da pessoa e ap√≥s isso uma barra ( / ). Ap√≥s a barra, coloque o saldo que ser√° adc. Ex:
${prefix+command} ${nmrdn.split('@')[0]}/30`)
if(!Number(quant)) return reply(quant+" n√£o √© n√∫mero...")
usu = nmr.toLowerCase() == "me" ? sender : identArroba(nmr)
addCoinsInVirtualBalance(usu, quant)
mention(`üí† R$ ${Number(quant).toFixed(2)} adc ao saldo do usu√°rio @${usu.split('@')[0]}`)
break

case 'rmsaldo':
if(!isOwner) return reply(enviar.msg.dono)
var [nmr, quant] = q.split('/')
if(!nmr || !quant) return reply(`Voc√™ vai colocar o n√∫mero da pessoa e ap√≥s isso uma barra ( / ). Ap√≥s a barra, coloque o saldo que ser√° removido. Ex:
${prefix+command} ${nmrdn.split('@')[0]}/30`)
if(!Number(quant)) return reply(quant+" n√£o √© n√∫mero...")
usu = nmr.toLowerCase() == "me" ? sender : identArroba(nmr)
rmCoinsInVirtualBalance(usu, quant)
mention(`üí† R$ ${Number(quant).toFixed(2)} rmvd do saldo do usu√°rio @${usu.split('@')[0]}`)
break

case 'transferirsaldo': case 'transferir-saldo':
var [nmr, quant] = q.split('/')
if(!nmr || !quant) return reply(`Voc√™ vai colocar o n√∫mero da pessoa e ap√≥s isso uma barra ( / ). Ap√≥s a barra, coloque o saldo que ser√° transferido. Ex:
${prefix+command} ${nmrdn.split('@')[0]}/30`)
if(!Number(quant)) return reply(quant+" n√£o √© n√∫mero...")
if(Number(quant) < 0) return reply("O valor precisa ser maior que 0")
usu = identArroba(nmr)
if(usu.includes(sender)) return reply(`N√£o podes transferir para voc√™ msm n√©`)
if(usu.includes(botNumber)) return reply(`N√£o podes transferir para o bot n√©`)
registrarUsuInVirtualBalance(sender)
registrarUsuInVirtualBalance(usu)
if(Number(quant) > getCoinsUsu(sender).saldo) return reply("Voc√™ n√£o possui saldo para efetuar essa transfer√™ncia")
addCoinsInVirtualBalance(usu, quant)
rmCoinsInVirtualBalance(sender, quant)
mention(`üí† R$ ${Number(quant).toFixed(2)} transferido${Number(quant) === 1 ? "" : "s"} para o usu√°rio @${usu.split('@')[0]}`)
break

case 'buygp':
if(!q) return reply('Insira um link de convite do grupo ao lado do comando.')
if(!q.includes('chat.whatsapp.com/') || q.includes('|')) return reply(`Ops, verifique o link que voc√™ inseriu...\nUse: ${prefix} link do grupo`)
registrarUsuInVirtualBalance(sender)
if(Number(getCoinsUsu(sender).saldo) < 5 && getCoinsUsu(sender).keys.length <= 0) return reply(`Seu saldo est√° abaixo do m√≠nimo permitido para usar este comando... Recomendo efetuar uma recarga de moedas atrav√©s do comando ${prefix}recarga`)
link = q.split('app.com/')[1]
try {
blackmd.groupAcceptInvite(`${link}`)
await sleep(2000)
reply(`ü§ñ Entrando no grupo... Devo ressaltar que os comandos n√£o funcionar√£o ao menos que vc compre uma chave de acesso atrav√©s do comando *${prefix}buykeygp*`)
} catch(erro) {
if(JSON.stringify(erro).includes('resource-limit')) return reply(`O grupo j√° est√° com o n√∫mero m√°ximo de membros... N√£o consigo entrar ü´†`)
if(JSON.stringify(erro).includes('not-authorized')) return reply(`N√£o foi poss√≠vel entrar no grupo pq algum admin me baniu... Pfvr, pe√ßa para o meu dono me adicionar (chame ${prefix}dono)`)
reply(`N√£o foi poss√≠vel entrar no grupo... Pfvr, chame meu dono para ele registrar os dados üé≤`)
}
break

case 'buycort':
if(!q) return reply(`KD o link do grupo p√° eu liberar a cortesia?`)
if(!q.includes('chat.whatsapp.com/') || q.includes('|')) return reply(`Ops, verifique o link que voc√™ inseriu...\nUse: ${prefix} link do grupo`)
registrarUsuInVirtualBalance(sender)
if(Number(getCoinsUsu(sender).saldo) < 5) return reply(`Seu saldo est√° abaixo do m√≠nimo permitido para usar este comando... Recomendo efetuar uma recarga de moedas atrav√©s do comando ${prefix}recarga`)
if(getCoinsUsu(sender).cortesia <= 0) return reply(`Voc√™ n√£o possui mais *CARD CORTESIA* neste m√™s para prosseguir com este comando...`)
link = q.split('app.com/')[1]
try {
blackmd.groupAcceptInvite(`${link}`)
await sleep(2000)
gerarTypeKey(sender, {type: 2, grupo: from})
if(isGroup) reply(`Irei te enviar no PV üßµ`)
await sleep(1000)
dados = getCoinsUsu(sender)
dados.cortesia -= 1
saveCoins()
chave = dados.keys[dados.keys.length - 1].key
sendButton(sender, {text: `üí° A chave "${chave}" foi gerada com sucesso... Copie e cole a mesma no seu grupo para validar a cortesia e liberar os comandos do bot üòä`, footer: chave}, blackmd, sender, [{type: `copy_text`, text: `CLIQUE AQUI`, url: chave}], seloctt)
} catch(erro) {
if(JSON.stringify(erro).includes('resource-limit')) return reply(`O grupo j√° est√° com o n√∫mero m√°ximo de membros... N√£o consigo entrar ü´†`)
if(JSON.stringify(erro).includes('not-authorized')) return reply(`N√£o foi poss√≠vel entrar no grupo pq algum admin me baniu... Pfvr, pe√ßa para o meu dono me adicionar (chame ${prefix}dono)`)
reply(`N√£o foi poss√≠vel entrar no grupo... Pfvr, chame meu dono para ele registrar os dados üé≤`)
}
break

case 'gerarkeycort': {
if(!isOwner) return reply(enviar.msg.dono)
reagir(from, "üòÄ")
let { key } = await blackmd.sendMessage(from, {text: `üé≤ *_KEY GERADA COM SUCESSO_* üé≤`}, {quoted: info})
await sleep(1500)
gerarTypeKey(sender, {type: 2, grupo: from})
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
await sleep(500)
blackmd.sendMessage(from, {text: `${chave}`, edit: key}, {quoted: info})
await sleep(500)
sendMess(from, `üé≥ *_Descri√ß√£o ‚§µ_*
„ÄîüéØ„Äï‚•≤ *Tipo:* "cortesia"
„Äî‚è±„Äï‚•≤ *Tempo:* 24h`)
await sleep(500)
blackmd.sendMessage(from, {text: `Copie essa chave ou encaminhe ao privado do cliente ‚úî`}, {quoted: {
  key: {
    fromMe: false,
    participant: botNumber
  },
  message: {
    conversation: chave
  }
}})
}
break

case 'transferirgp':
if(!q || !q.includes(`chat.whatsapp.com`)) return reply(`Coloque ao lado do comando o link do novo grupo em que voc√™ deseja colocar o bot... Assim:
${prefix+command} link do grupo`)
gps = []
for(i of aluguel) {if(i.cliente == sender) gps.push({title: i.nome, body: sendTimeHours(i.tempo) + " at√© o fim do aluguel...", command: prefix+command+" "+q+"|"+i.id})}
if(gps.length <= 0) return reply(`‚òùüèªüòî Smt, voc√™ n√£o est√° na lista de clientes do bot... Mas n√£o se preocupe, voc√™ pode mudar isso alugando o bot para o seu grupo usando o comando ${prefix}buykeygp üí≠`)
barra = q.replace(" |", "|").replace("| ", "|").replace(" | ", "|")
var [link, idgp] = barra.split("|")
if(!idgp) {
if(isGroup) reply(`Chega PV üî∞`)
try { ppUrl = await blackmd.profilePictureUrl(from, 'image')
} catch { ppUrl = semfoto }
return sendRouletteButton(sender, {image: {url: ppUrl}, caption: `_Selecione na lista abaixo o grupo na qual voc√™ deseja transferir para o novo... Este antigo ser√° deletado do aluguel, e uma nova key ser√° enviada no seu privado_ üí≠`, footer: `_Listando abaixo os grupos na qual o seu n√∫mero consta como cliente..._`}, blackmd, sender, [{type: `list`, title: `üîª CLIQUE AQUI üî∫`, rowId: [{title: tempo+" "+pushname, options: gps}]}], seloctt)
}
if(!isGroupInRent(idgp)) return reply(`Este grupo n√£o est√° registrado no sistema de aluguel... Para que haja possibilidade de transferir o registro, voc√™ precisa usar este comando com um grupo na qual voc√™ seja cliente üòÉ`)
if(getGroupRent(idgp).cliente != sender) return reply(`Ops espertinho kkkk querendo pegar um grupo que n√£o √© seu?`)
try {
blackmd.groupAcceptInvite(link.split('app.com/')[1])
await sleep(1000)
temporent = getGroupRent(idgp).tempo
delRent(reply, idgp)
await sleep(1000)
if(isGroup) sendMess(from, `Irei te enviar a nova chave no PV üßµ`)
await sleep(1000)
blackmd.groupLeave(idgp)
gerarTypeKey(sender, {type: 1, grupo: from, tempo: String(temporent) + `h`})
await sleep(1000)
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
sendButton(sender, {text: `üí° A chave "${chave}" foi gerada com sucesso... Copie e cole a mesma no seu grupo para validar a transfer√™ncia de aluguel e liberar os comandos do bot no novo chat üòä`, footer: chave}, blackmd, sender, [{type: `copy_text`, text: `CLIQUE AQUI`, url: chave}], seloctt)
await sleep(1000)
sendMess(sender, `ü§ñ Entrando no grupo... Devo ressaltar que os comandos n√£o funcionar√£o ao menos que vc copie e cole essa chave de acesso dentro do novo grupo.`)
} catch(erro) {
console.log(erro)
if(JSON.stringify(erro).includes('resource-limit')) return reply(`O grupo j√° est√° com o n√∫mero m√°ximo de membros... N√£o consigo entrar ü´†`)
if(JSON.stringify(erro).includes('not-authorized')) return reply(`N√£o foi poss√≠vel entrar no grupo pq algum admin me baniu... Pfvr, pe√ßa para o meu dono me adicionar (chame ${prefix}dono)`)
reply(`N√£o foi poss√≠vel entrar no grupo... Pfvr, chame meu dono para ele registrar os dados üé≤`)
}
break

case 'buykeygp':
valores = []
for(i of valoresDeAluguel) {valores.push({name: NomeDoBot, title: `${i.tempo} dias`, body: `R$ ${Number(i.valor).toFixed(2)}`, command: `${prefix+command} ${i.tempo}`})}
sla = false
for(s of valoresDeAluguel) {if(q && Number(q) === s.tempo) sla = true}
if(!sla) {
if(isIOS) return reply(`üìä *_Escolha a quantidade de dias para alugar:_*
${valores.map(v => `- ${v.command}`).join(`\n`)}`)
if(isGroup) reply(`Enviando PV üî∞`)
try { img = await blackmd.profilePictureUrl(from, 'image')
} catch { img = semfoto }
return sendRouletteButton(sender, {image: {url: img}, caption: `Escolha na lista abaixo a quantidade de dias que voc√™ quer alugar para o seu grupo...`, footer: NomeDoBot}, blackmd, sender, [{type: `list`, title: `„Äò ESCOLHA AQUI „Äô`, rowId: [{title: `escolha abaixo`, options: valores}]}], seloctt)
}
gvr = getValuesRent(q)
if(getCoinsUsu(sender).saldo < gvr.valor) return reply(`[‚ùó] Voc√™ n√£o possui saldo suficiente para efetuar essa compra... Para alugar ${gvr.tempo} dias, ser√£o necess√°rios R$ ${(gvr.valor).toFixed(2)}, e voc√™ possui apenas R$ ${getSepCoins(sender)[2]} em sua conta... Use o comando ${prefix}recarga para adicionar moedas a sua conta e comprar as keys üòï`)
rmCoinsInVirtualBalance(sender, gvr.valor)
gerarTypeKey(sender, {type: 1, grupo: from, tempo: String(gvr.tempo) + `d`, valor: gvr.valor})
if(isGroup) reply(`Irei te enviar no PV üßµ`)
await sleep(1000)
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
sendButton(sender, {text: `üí° A chave "${chave}" foi gerada com sucesso... Copie e cole a mesma no seu grupo para validar o aluguel e liberar os comandos do bot üòä`, footer: chave}, blackmd, sender, [{type: `copy_text`, text: `CLIQUE AQUI`, url: chave}], seloctt)
//await sleep(500)
//sendImage(sender, `https://pomf2.lain.la/f/28mcqie5.jpg`, `Desse jeito caso n√£o saiba ‚úî`)
await sleep(500)
sendMess(sender, `A prop√≥sito, caso voc√™ n√£o tenha solicitado a entrada do bot no seu grupo, use *${prefix}buygp* com o link ao lado para o bot entrar ü•∞`)
break

case 'gerarkeygp': {
if(!isOwner) return reply(enviar.msg.dono)
barra = q.replace(' /', '/').replace('/ ', '/').replace(' / ', '/')
var [v1, v2] = barra.split('/')
if(!q.includes('/')) return reply(`Voc√™ vai colocar o n√∫mero da pessoa que alugou e ap√≥s isso uma barra ( / ). Ap√≥s a barra, coloque a quantidade de dias que este alugou para seu grupo. Ex:
${prefix+command} ${nmrdn.split('@')[0]}/30d`)
usu = v1.toLowerCase() == "me" ? sender : identArroba(v1)
const [checkkeygp] = await blackmd.onWhatsApp(usu.split('@')[0])
if(checkkeygp == undefined) return reply(`O n√∫mero ${usu.split('@')[0]} n√£o √© v√°lido no whatsapp`)
lt = v2.slice(v2.length - 1, v2.length).toLowerCase()
if(v2.length > 1 && lt != `d` && lt != `h`) return reply(`Voc√™ precisa setar o tempo de aluguel em h ou d... Ex:
${prefix+command} @/30d`)
clientrentcmd = usu
let { key } = await blackmd.sendMessage(from, {text: `üé≤ *_KEY GERADA COM SUCESSO_* üé≤`}, {quoted: info})
await sleep(1500)
gerarTypeKey(clientrentcmd, {type: 1, grupo: from, tempo: v2})
dados = getCoinsUsu(clientrentcmd)
chave = dados.keys[dados.keys.length - 1].key
await sleep(500)
blackmd.sendMessage(from, {text: `${chave}`, edit: key}, {quoted: info})
await sleep(500)
sendMess(from, `üé≥ *_Descri√ß√£o ‚§µ_*
„ÄîüéØ„Äï‚•≤ *Tipo:* "aluguel"
„Äî‚è±„Äï‚•≤ *Tempo:* ${Number(v2.slice(0, v2.length - 1)) > 0 ? v2 : `‚àû INFINITO`}
„Äîü§ì„Äï‚•≤ *Cliente:* @${clientrentcmd.split("@")[0]}`)
await sleep(500)
blackmd.sendMessage(from, {text: `Copie essa chave ou encaminhe ao privado do cliente ‚úî`}, {quoted: {
  key: {
    fromMe: false,
    participant: botNumber
  },
  message: {
    conversation: chave
  }
}})
}
break

case 'buyvip':
reagir(from, "ü§ë")
if(!q) return reply(`Coloque a quantidade de dias VIP...
Ex: ${prefix+command} 30
Ou
Ex: ${prefix+command} 30/puxadas`)
var [a, b] = q.split("/")
if(!Number(a) > 0) return reply("Apenas n√∫meros positivos para setar o tempo pfvr")
if(a.includes('.')) return reply("N√£o ser√£o aceitos n√∫meros decimais...")
isPux = b && (b.toLowerCase() === `puxadas` || b.toLowerCase() === `consultas` || b.toLowerCase() === `vip`) ? true : false
nmr = ((isPux ? valoresVIP.vipcp : valoresVIP.vip) / 30).toFixed(2)
usu = getCoinsUsu(sender)
valor = nmr * Number(a)
if(usu.saldo < valor) return reply(`[‚ùó] N√£o foi poss√≠vel completar a compra da Key... ${a} dia${Number(a) !== 1 ? 's' : ''} VIP "${isPux ? `com` : `sem`}" puxadas custar${Number(a) !== 1 ? '√£o' : '√°'} R$ ${(valor).toFixed(2)}, e voc√™ possui apenas R$ ${getSepCoins(sender)[2]} em sua conta... Use o comando ${prefix}recarga para adicionar moedas a sua conta e comprar as keys ‚ö†Ô∏è`)
rmCoinsInVirtualBalance(sender, valor)
gerarTypeKey(sender, {type: 3, grupo: from, tempo: a, mod: isPux, valor: valor})
if(isGroup) reply(`Irei te enviar no PV üßµ`)
await sleep(1000)
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
sendButton(sender, {text: `üí° A chave "${chave}" foi gerada com sucesso... Copie e cole a mesma em um grupo ou no privado do bot mesmo para validar o VIP e liberar seu acesso aos comandos especiais do sistema üòä`, footer: chave}, blackmd, sender, [{type: `copy_text`, text: `CLIQUE AQUI`, url: chave}], seloctt)
await sleep(1000)
sendMess(sender, `Lembrando que voc√™ pode doar essa key VIP para outra pessoa caso queira, basta enviar no PV dela... Pois se enviar no grupo o bot validar√° o VIP para voc√™ ü§©`)
break

case 'gerarkeyvip': {
if(!isOwner) return reply(enviar.msg.dono)
reagir(from, "ü§ë")
if(!q) return reply(`Coloque a quantidade de dias VIP...
Ex: ${prefix+command} 30
Ou
Ex: ${prefix+command} 30/puxadas`)
if(q.includes('.')) return reply("N√£o ser√£o aceitos n√∫meros decimais...")
var [a, b] = q.split("/")
isPux = b && (b.toLowerCase() === `puxadas` || b.toLowerCase() === `consultas` || b.toLowerCase() === `vip`) ? true : false
let { key } = await blackmd.sendMessage(from, {text: `üé≤ *_KEY GERADA COM SUCESSO_* üé≤`}, {quoted: info})
await sleep(1500)
gerarTypeKey(sender, {type: 3, grupo: from, mod: isPux, tempo: a})
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
await sleep(500)
blackmd.sendMessage(from, {text: `${chave}`, edit: key}, {quoted: info})
await sleep(500)
sendMess(from, `üé≥ *_Descri√ß√£o ‚§µ_*
„ÄîüéØ„Äï‚•≤ *Tipo:* "VIP"
„Äî‚è±„Äï‚•≤ *Tempo:* ${Number(a) > 0 ? String(a) + ` dias` : `‚àû INFINITO`}
„Äîüîé„Äï‚•≤ *Consultas:* ${isPux ? `sim ‚úî` : `n√£o ‚úñ`}`)
await sleep(500)
blackmd.sendMessage(from, {text: `Copie essa chave ou encaminhe ao privado do cliente ‚úî`}, {quoted: {
  key: {
    fromMe: false,
    participant: botNumber
  },
  message: {
    conversation: chave
  }
}})
}
break

case 'buyvipgp':
reagir(from, "ü§ë")
if(!q) return reply(`Coloque a quantidade de dias VIP...
Ex: ${prefix+command} 30
Ou
Ex: ${prefix+command} 30/puxadas`)
var [a, b] = q.split("/")
if(!Number(a) > 0) return reply("Apenas n√∫meros positivos para setar o tempo pfvr")
if(a.includes('.')) return reply("N√£o ser√£o aceitos n√∫meros decimais...")
isPux = b && (b.toLowerCase() === `puxadas` || b.toLowerCase() === `consultas` || b.toLowerCase() === `vip`) ? true : false
nmr = ((isPux ? valoresVIP.vipgpcp : valoresVIP.vipgp) / 30).toFixed(2)
usu = getCoinsUsu(sender)
valor = nmr * Number(a)
if(usu.saldo < valor) return reply(`[‚ùó] N√£o foi poss√≠vel completar a compra da Key... ${a} dia${Number(a) !== 1 ? 's' : ''} de GROUP VIP "${isPux ? `com` : `sem`}" puxadas custar${Number(a) !== 1 ? '√£o' : '√°'} R$ ${(valor).toFixed(2)}, e voc√™ possui apenas R$ ${getSepCoins(sender)[2]} em sua conta... Use o comando ${prefix}recarga para adicionar moedas a sua conta e comprar as keys ‚ö†Ô∏è`)
rmCoinsInVirtualBalance(sender, valor)
gerarTypeKey(sender, {type: 4, grupo: from, tempo: a, mod: isPux, valor: valor})
if(isGroup) reply(`Irei te enviar no PV üßµ`)
await sleep(1000)
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
sendButton(sender, {text: `üí° A chave "${chave}" foi gerada com sucesso... Copie e cole a mesma em seu grupo para validar o VIP neste chat e liberar o acesso aos comandos especiais do sistema para todos os membros presentes üòä`, footer: chave}, blackmd, sender, [{type: `copy_text`, text: `CLIQUE AQUI`, url: chave}], seloctt)
await sleep(1000)
sendMess(sender, `Lembrando que voc√™ pode doar essa key VIP para outra pessoa caso queira, basta enviar no PV dela... Pois se enviar no grupo o bot validar√° o VIP para o seu chat ü§©`)
break

case 'gerarkeyvipgp': {
if(!isOwner) return reply(enviar.msg.dono)
reagir(from, "ü§ë")
if(!q) return reply(`Coloque a quantidade de dias VIP...
Ex: ${prefix+command} 30
Ou
Ex: ${prefix+command} 30/puxadas`)
if(q.includes('.')) return reply("N√£o ser√£o aceitos n√∫meros decimais...")
var [a, b] = q.split("/")
isPux = b && (b.toLowerCase() === `puxadas` || b.toLowerCase() === `consultas` || b.toLowerCase() === `vip`) ? true : false
let { key } = await blackmd.sendMessage(from, {text: `üé≤ *_KEY GERADA COM SUCESSO_* üé≤`}, {quoted: info})
await sleep(1500)
gerarTypeKey(sender, {type: 4, grupo: from, mod: isPux, tempo: a})
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
await sleep(500)
blackmd.sendMessage(from, {text: `${chave}`, edit: key}, {quoted: info})
await sleep(500)
sendMess(from, `üé≥ *_Descri√ß√£o ‚§µ_*
„ÄîüéØ„Äï‚•≤ *Tipo:* "GROUP VIP"
„Äî‚è±„Äï‚•≤ *Tempo:* ${Number(a) > 0 ? a : `‚àû INFINITO`}
„Äîüîé„Äï‚•≤ *Consultas:* ${isPux ? `sim ‚úî` : `n√£o ‚úñ`}`)
await sleep(500)
blackmd.sendMessage(from, {text: `Copie essa chave ou encaminhe ao privado do cliente ‚úî`}, {quoted: {
  key: {
    fromMe: false,
    participant: botNumber
  },
  message: {
    conversation: chave
  }
}})
}
break

case 'reembolsar':
if(!q) return reply(`KD a key que vc deseja reembolsar?`)
if(!existKeyRentSystem(q)) return reply("[‚ùó] chave n√£o encontrada ou inexistente ‚ùå")
usu = getClientKey(q)
if(usu.cliente != sender) return reply("Espertinho ksksks mas essa key n√£o √© tua pra tu pegar reembolso nela")
nmr = usu.valor
tipo = usu.tipo
rmTypeKey(q)
if(tipo != 2) { addCoinsInVirtualBalance(sender, nmr)
reply(`üí† Saldo reembolsado em sua conta da Black System no valor de R$ ${Number(nmr).toFixed(2)} (Key deletada) ü§≠`)
} else { getCoinsUsu(sender).cortesia += 1
saveCoins()
reply(`üí† *CARD CORTESIA* restaurado (Key deletada) ü§≠`) }
break

case 'rmkey':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`KD a key que vc deseja apagar?`)
if(!existKeyRentSystem(q)) return reply("[‚ùó] chave n√£o encontrada ou inexistente ‚ùå")
rmTypeKey(q)
reply(`‚úãüèΩüò≥ü§öüèΩ A Key ${q} foi deletada do sistema com sucesso ‚úÖ`)
break

case 'resetkey':
if(!isOwner) return reply(enviar.msg.dono)
if(Number(q) !== 1) return reply(`Tem certeza disso? Esse comando ir√° deletar todas as keys presentes no sistema, independente de quais sejam... Se estiver certo disso, use ${prefix+command} 1`)
if(allKeysRentSystem.length <= 0) return reply(`N√£o h√° keys salvas no sistema`)
for(i of moedas) {
  if(i.keys.length > 0) {
    i.keys = []
    saveCoins()
  }
}
reply(`Todas as keys do sistema foram deletadas com sucesso ‚úî`)
await sleep(300)
console.log(colors.green(`Restart necess√°rio para save de dados..`))
process.exit()
break

case 'donate':
case 'doar':
case 'apoiar':
if(!q || isNaN(q) || Number(q) <= 0) return reply(`Quer doar e ajudar meu dono? üòç
Retorne ap√≥s o comando o valor que voc√™ deseja doar para o meu dono, ex: ${prefix+command} ${(alerandom(9) + 1) * 5}`)
nmr = Number(q)
if(isGroup) reply(`Vem PV ü•∞`)
await sleep(1000)
GenerateQRpix(sender, {text: `Equipe Black System agradece üíû`, footer: `BLACK SYSTEM OFC`, pix: nmr, chave: `mathgames72331621@gmail.com`, type: `email`}, blackmd)
break

case 'pix':
setTimeout(() => {reagir(from, "ü•π")}, 300)
sendRouletteButton(from, {image: {url: `https://blackstorage.store/midia/1735506461779.jpg`}, caption: `*Caso queira ajudar meu mestre com qualquer quantia... Aqui est√° o pix dele:* üôáüèª‚Äç‚ôÇÔ∏è

*Chave ‚Ü¥*`}, blackmd, sender, [{type: `copy_text`, text: `CHAVE EMAIL`, url: `blacksystemofc2025@gmail.com`}], seloctt)
break

case 'cobrar':
if(!isOwner) return reply(enviar.msg.dono)
if(!q.includes(`/`)) return reply(`Separe o n√∫mero do usu√°rio e o valor da cobran√ßa...
Ex: ${prefix+command} ${addNumberMais(sender)}/5`)
var [cusu, cvalor] = q.split(`/`)
usu = identArroba(cusu)
if(isNaN(cvalor)) return reply(`Retorne um n√∫mero v√°lido... "${cvalor}" n√£o √© n√∫mero.`)
nmr = Number(cvalor)
if(nmr <= 0) return reply(`A cobran√ßa precisa ser maior ser maior que zero.`)
mention(`*_Enviando cobran√ßa no PV do @${usu.split("@")[0]}..._* üí†`)
await sleep(700)
blackmd.sendMessage(usu, {text: `${Number(sendHours(`HH`)) >= 6 && Number(sendHours(`HH`)) < 12 ? `Buenos dias` : Number(sendHours(`HH`)) >= 12 && Number(sendHours(`HH`)) < 18 ? `Buenas tardes` : `Buenas noches`} @${usu.split("@")[0]}, te foi solicitado um pagamento vindo do @${sender.split("@")[0]} üí†`, mentions: [sender, usu]})
await sleep(1100)
GenerateQRpix(usu, {text: `PAGUE CALOTEIRO!!`, footer: `BLACK SYSTEM OFC`, pix: nmr, chave: `mathgames72331621@gmail.com`, type: `email`}, blackmd)
break

case 'criador':
ttgp = isGroup ? groupMembers.length * groupAdmins.length + somembros.length : 6
horar = moment.tz('America/Sao_Paulo').format('HH:mm')
datar = moment.tz('America/Sao_Paulo').format('DD/MM')
criador = `ü§ß *Ah o meu criador √© o luan, Ele foi quem desenvolveu esse sistema todo que voc√™ est√° usando* ü•∞`
sendUrlDoc(from, criador, 'application/pdf', `${horar}H ‚îã ${datar} üìÜ`, ttgp, NomeDoBot, ``, `https://telegra.ph/file/adad9b9a3606857e380be.jpg`, `https://wa.me/5585998603654`, seloctt)
break

case 'owner':
case 'odono':
case 'dono': 
case 'infodono':
reagir(from, "üëë")
const { infodono } = require("./dono/info/infodono.js")
sendContact(from, NickDono, NomeDoBot, numerodono_ofc)
sendButton(from, {image: {url: logoslink.logo}, caption: infodono(tempo, tempo_emoji, sender, NickDono, nmrdn, NomeDoBot, prefix), mentions: [sender], footer: NomeDoBot}, blackmd, sender, [{type: `copy_url`, text: `CLIQUE AQUI`, url: `https://wa.me/`+nmrdn.split("@")[0]}], seloctt)
break

case 'configurar-bot':
if(!isOwner) return reply(`INDISPON√çVEL`)
blackmd.sendMessage(from, {text: configbot(prefix)}, {quoted: selo})
break

case 'comandos-termux':
blackmd.sendMessage(from, {text: cmd_termux(prefix)}, {quoted: selo})
break

case 'destrava':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isVip) return reply(`[ ‚ùó ] Precisa ser VIP e admin ‚ùå`)
if(!isGroupAdmins) return reply(`Voc√™ ainda n√£o √© admin ü§™`)
blackmd.sendMessage(from, {text: destrava(prefix)}, {quoted: seloctt})
break

case 'getpp':
if(!isVip) return reply(enviar.msg.vip)
if(!menc_os2) return reply(`Marque o usu√°rio que voc√™ quer puxar a foto de perfil, a mensagem ou o @`)
try { ppimg = await blackmd.profilePictureUrl(`${menc_os2.split('@')[0]}@c.us`, 'image')
} catch { return mention(`[‚ùó] n√£o foi poss√≠vel pegar a foto de perfil do usu√°rio @${menc_os2.split("@")[0]} ‚ùå`) }
sendImage(from, ppimg, ``, seloblk)
break

case 'lerarquivo': case 'lerfile': {
  if(!isVip) return reply(enviar.msg.vip)
    if(!isQuotedDocument) return reply(`Marque um documento para que eu possa fazer a transcri√ß√£o...`)
      let { key } = await blackmd.sendMessage(from, {text: `üîé _Transcrevendo √°udio... Aguarde_ üîç`}, {quoted: info})
    await sleep(2000)
    try {
      media = isQuotedDocument ? info.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : info.message.documentMessage
      doc = await getFileBuffer(media, `document`)
      caminho = `./database/data/black.txt`
      fs.writeFileSync(caminho, doc)
      await sleep(700)
      txt = fs.readFileSync(caminho)
      await blackmd.sendMessage(from, {text: txt, edit: key}, {quoted: info})
      await sleep(600)
      return fs.unlinkSync(caminho)
    } catch(e) {
      console.log(e)
      await blackmd.sendMessage(from, {text: `[‚ùó] Erro, n√£o foi poss√≠vel ler este arquivo enviado... ‚ùå`, edit: key}, {quoted: info})
    }
  }
break
case 'perfil':
reagir(from, "üò∏")
usu = sender_ou_n
try {
  ppimg = await blackmd.profilePictureUrl(`${usu.split('@')[0]}@c.us`, 'image')
} catch {
  ppimg = semfoto
}
try {
  bio = (await blackmd.fetchStatus(usu)).status
} catch {
  bio = "üîí Privada üîí"
}
txt = `‚ïì‚îÄ‚îÅ‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚îÅ‚îÄ‚îí
‚î¢‚ïï„Ö§„Ö§„Ö§„Ö§„Ö§üì¶ ùôÇùôÄùôçùòºùôá üì¶
‚ïΩ‚ïü ‚Ä¢ …¥·¥è·¥ç·¥á: ${getname(usu)}
‚ïΩ‚ïü ‚Ä¢ …¥√∫·¥ç·¥á Ä·¥è: wa.me/${usu.split("@")[0]}
‚ïΩ‚ïü ‚Ä¢  ô…™·¥è: ${bio}
‚ïΩ‚ïü ‚Ä¢ Íú±·¥Ä ü·¥Ö·¥è: R$ `
if(isJsonIncludes(moedas, usu)) {
  A1 = moedas.map(a => a.id).indexOf(usu)
  txt += `${Number(moedas[A1].saldo).toFixed(2)}`
} else { txt += `00.00` }
txt += `
‚ïΩ‚ïü ~>„Äé ${isAllOwner(usu) ? "‚úÖ" : "‚ùå"} „Äè·¥Ö·¥è…¥·¥è
‚ïΩ‚ïü ~>„Äé ${isAdmin(usu) ? "‚úÖ" : "‚ùå"} „Äè·¥Ä·¥Ö·¥ç
‚ïΩ‚ïü ~>„Äé ${isOnlyVip(usu) ? "‚úÖ" : "‚ùå"} „Äè·¥†…™·¥©
‚ïΩ‚ïü ~>„Äé ${isJsonIncludes(vipgp, from) ? "‚úÖ" : "‚ùå"} „Äè…¢ Ä·¥ú·¥©·¥è ·¥†…™·¥©
‚îï‚ï®‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚îö`

if(isGroup || isJsonIncludes(level, usu)) {
  txt += `\n\n‚ïì‚îÄ‚îÅ‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚îÅ‚îÄ‚îí
‚î¢‚ïï„Ö§„Ö§„Ö§üìä ùòæùôäùôâùôèùòºùòøùôäùôçùôÄùôé üìä`
  if(isGroup) {
    B1 = countMessage.map(b => b.groupId).indexOf(from)
    B2 = countMessage[B1].participants.map(b => b.id).indexOf(usu)
    B3 = B2 >= 0 ? countMessage[B1].participants[B2] : ""
    txt += `
‚ïΩ‚ïü ‚Ä¢ ‚ù™üóíÔ∏è‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ ·¥ç·¥á…¥Íú±·¥Ä…¢·¥á…¥Íú±: ${B2 >= 0 ? largeNumber(B3.mensagens) : "0"}
‚î¢‚î∏ ‚Ä¢ ‚ù™üóÑÔ∏è‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ ·¥Ñ·¥è·¥ç·¥Ä…¥·¥Ö·¥èÍú±: ${B2 >= 0 ? largeNumber(B3.comandos) : "0"}
‚î¢‚ïï`
    }
    if(isJsonIncludes(level, usu)) {
    C1 = level.map(c => c.id).indexOf(usu)
    C2 = level[C1]
    C3 = level.map(i => i)
    C4 = C3.sort((a, b) => (a.contador < b.contador) ? 0 : -1)
    C5 = level.length > 10 ? 10 : level.length
    C6 = []
    for(i = 0; i < C5; i++) {
      if(i != null) {
        C6.push({id: C4[i].id})
      }
    }
    C7 = C6.map(c => c.id).indexOf(usu)
    txt += `
‚ïΩ‚ïü ‚Ä¢ ‚ù™üì¨‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏  ü·¥á·¥†·¥á ü: ${C2.level}
‚ïΩ‚ïü ‚Ä¢ ‚ù™üó≥Ô∏è‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ x·¥©: ${largeNumber(C2.contador)}
‚ïΩ‚ïü ‚Ä¢ ‚ù™üíé‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏  Ä·¥Ä…¥·¥ã: ${C7 >= 0 ? "Top " + (C7 + 1) : "\"n√£o est√° no rank\""}
‚ïΩ‚ïü ‚Ä¢ ‚ù™üì•‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ ·¥©·¥Ä·¥õ·¥á…¥·¥õ·¥á: ${patente(C2.contador)}
‚î¢‚î∏ ‚Ä¢ ‚ù™üö´‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏  ô ü·¥èq·¥ú·¥á·¥Ä·¥Ö·¥è„Äé ${C2.block ? "‚úÖ" : "‚ùå"} „Äè`
  }
  txt += `\n‚îï‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚îö`
}
if(isJsonIncludes(vip, usu)) {
  D1 = vip.map(d => d.id).indexOf(usu)
  D2 = vip[D1]
  txt += `\n\n‚ïì‚îÄ‚îÅ‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚îÅ‚îÄ‚îí
‚î¢‚ïï„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§üí∏ ùôëùôÑùôã üí∏`
  txt += !D2.infinito ? `
‚ïΩ‚ïë ${barrinha(((D2.dias - 1) * 24) + Number(sendHours("HH")), D2.total * 24)}
‚ïΩ‚ïü ‚Ä¢ ‚ù™ü§ë‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ _${sendTimeDay(D2.dias)} restante${Number(sendTimeDay(D2.dias).slice(0, 2)) !== 1 ? "s" : ""}_` : `
‚ïΩ‚ïë „Äò‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà„Äô100%
‚ïΩ‚ïü ‚Ä¢ ‚ù™ü§ë‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ _‚àû INFINITY_`
  txt += `\n‚îï‚ï®‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚îö`
}
if(isJsonIncludes(cardxp, usu)) {
  E1 = cardxp.map(e => e.id).indexOf(usu)
  E2 = cardxp[E1]
  txt += `\n\n‚ïì‚îÄ‚îÅ‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚ïæ‚ïº‚ïê‚îÅ‚îÄ‚îí
‚î¢‚ïï„Ö§„Ö§„Ö§„Ö§„Ö§üîñ ùòæùòºùôçùòø ùôìùôã üîñ
‚ïΩ‚ïü ‚Ä¢ üíæ‚É§ ·¥õ·¥è·¥õ·¥Ä ü: ${E2.cards.length}
‚ïΩ‚ïë `
  txt += E2.active ? `
‚ïΩ‚ïü ‚Ä¢ ‚ù™üìº‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ ·¥ç·¥ú ü·¥õ…™·¥© ü…™·¥Ñ·¥Ä·¥Ö·¥è Ä: ${E2.cards[E2.mapa].multi}x
‚ïΩ‚ïü ‚Ä¢ ‚ù™üìÜ‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ ·¥õ·¥á·¥ç·¥©·¥è: _${sendTimeHours(E2.tempo)} restante${Number(E2.tempo) !== 1 ? "s" : ""}_
‚ïΩ‚ïë ${barrinha(E2.tempo, E2.cards[E2.mapa].horas)}` : `‚ùå ·¥Ñ·¥Ä Ä·¥Ö …¥√£·¥è ·¥Ä·¥õ…™·¥†·¥Ä·¥Ö·¥è ‚ùå`
  txt += `\n‚îï‚ï®‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚îö`
}
sendUrlText(from, txt, `üòú ùôãùôÄùôçùôÅùôÑùôá ü§™`, ``, ppimg, `https://wa.me/`+usu.split("@")[0], seloctt)
break

case 'perfil2':
reagir(from, "ü§≠")
//foto de perfil
try {
ppimg = await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image')
} catch {
ppimg = semfoto
}
try {
var conselho = palavrasc[Math.floor(Math.random() * palavrasc.length)]
//bio do usu√°rio
try {
bioperfil = (await blackmd.fetchStatus(sender)).status
} catch {
bioperfil = "üîí Privada üîí"
}
const dptr = `„Ö§„Ö§„Äò ’è·é¨·ÇÆ ·è¢·é¨·é°“í·èÜ·èû „Äô
‚è§ÕüÕûÕüÕû Í¶øùôΩùöòùöñùöé *‚Ü¥*
‚áí ${pushname}

‚è§ÕüÕûÕüÕû Í¶øùöÜùöëùöäùöùùöúùöäùöôùöô *‚Ü¥*
‚áí wa.me/${sender.split("@")[0]}

‚è§ÕüÕûÕüÕû Í¶øùô±ùöíùöò *‚Ü¥*
‚áí ${bioperfil}

üêÇ‚É§ ùôΩ√≠ùöüùöéùöï ùô∂ùöäùöçùöò„Äé ${Math.floor(Math.random()*100)}% „Äè
üì±‚É§ ùöÇùöéùöû ùô≤ùöéùöïùöûùöïùöäùöõ„Äé ${info.key.id.length > 21 ? 'Android  ü§£' : info.key.id.substring(0, 2) == '3A' ? 'IOS üòÇüòÇüòÖ' : 'Zap zap web  üòÇüòÇ‚òùüèºüòÖ'} „Äè
üòà‚É§ ùôΩ√≠ùöüùöéùöï ùôøùöûùöùùöä„Äé ${Math.floor(Math.random()*100)}% „Äè
ü•µ‚É§ ùôΩ√≠ùöüùöéùöï ùô≥ùöé ùô∂ùöòùöúùöùùöòùöúùöûùöõùöä„Äé ${Math.floor(Math.random()*100)}% „Äè
üçº‚É§ ùôøùöõùöòùöêùöõùöäùöñùöä„Äé R$ ${Math.floor(Math.random()*9999)} „Äè


„Ö§„Ö§„Äò ·èüœ¥Œù’è·é¨·èû·éªœ¥ „Äô
${conselho}

_${tempo}_ ${tempo_emoji}
`
blackmd.sendMessage(from, {audio: {url:'./database/audios/criatura.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: seloctt})
await sleep(1000)
blackmd.sendMessage(from, {image: {url: ppimg}, caption: dptr}, {quoted: seloctt})
} catch (e) {
console.log(e)
}
break

case 'conselhobiblico':
case 'conselhosbiblico':  
case 'conselhosb':   
case 'conselhob':
case 'conselhos':
case 'conselho':
setTimeout(() => {reagir(from, "ü•∞")}, 300)
var conselhosb = conselhob[Math.floor(Math.random() * conselhob.length)]   
jr = `Oi√™, ${tempo} ${pushname} ! ^-^

üçÅùë™ùíêùíèùíîùíÜùíçùíâùíêùíî ùë©ùíäÃÅùíÉùíçùíäùíÑùíêùíî ùíëùíìùíÇ ùíóùíêùíÑùíÜÃÇ üçÅ

- ${conselhosb} 

‚è§ÕüÕûÕüÕû Í¶øBot‚ßΩ ${NomeDoBot}
‚è§ÕüÕûÕüÕû Í¶øGrupo‚ßΩ ${groupName}`
blackmd.sendMessage(from, {text: jr}, {quoted:info, contextInfo: {"mentionedJid": jr}})
break

case 'frases':
case 'frase':
setTimeout(() => {reagir(from, tempo_emoji)}, 300)
frases_ = palavrasc[Math.floor(Math.random() * palavrasc.length)]
reply(`${frases_}

‚è§ÕüÕûÕüÕû Í¶ø${NomeDoBot}
_${tempo}_ ${tempo_emoji}`)
break

case 'tabela':
blackmd.sendMessage(from, {text: tabela(prefix, NomeDoBot)}, {quoted: selo})
break 


case 'destrava2':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isVip) return reply(`[ ‚ùó ] Precisa ser VIP e admin ‚ùå`)
if(!isGroupAdmins) return reply(`Voc√™ ainda n√£o √© admin ü§™`)
blackmd.sendMessage(from, {text: destrava2 (prefix)}, {quoted: seloctt})
break 

case 'infobemvindo':
case 'infobv':  
blackmd.sendMessage(from, {text: infobemvindo(prefix, pushname)}, {quoted: selo})
break

case 'idiomas':
case 'idioma':
case 'infogtts':
txt = `  
IDIOMAS DO GTTS OU DO TRADUTOR

EXEMPLO :

>> ${prefix}gtts pt (texto)

o PT que coloquei, √© a linguagem, ent√£o pode por no lugar as 2 letras que define a linguagem, iguais os exemplos e os idiomas abaixo.

'af': 'Afrikaans',
'sq': 'Albanian',
'ar': 'Arabic',
'hy': 'Armenian',
'ca': 'Catalan',
'hr': 'Croatian',
'cs': 'Czech',
'da': 'Danish',
'nl': 'Dutch',
'en': 'English',
'eo': 'Esperanto',
'fi': 'Finnish',
'fr': 'French',
'de': 'German',
'el': 'Greek',
'ht': 'Haitian Creole',
'hi': 'Hindi',
'hu': 'Hungarian',
'is': 'Icelandic',
'id': 'Indonesian',
'it': 'Italian',
'ja': 'Japanese',
'ko': 'Korean',
'la': 'Latin',
'lv': 'Latvian',
'mk': 'Macedonian',
'no': 'Norwegian',
'pl': 'Polish',
'pt': 'Portugues',
'ro': 'Romanian',
'ru': 'Russian',
'sr': 'Serbian',
'sk': 'Slovak',
'es': 'Spanish',
'sw': 'Swahili',
'sv': 'Swedish',
'ta': 'Tamil',
'th': 'Thai',
'tr': 'Turkish',
'vi': 'Vietnamese',
'cy': 'Welsh'
 
üî•${NomeDoBot}üî•`

blackmd.sendMessage(from, {text: txt}, {quoted: selo})
break

case 'infocontador':
case 'infobanghost':  
blackmd.sendMessage(from, {text: infocontador(prefix, pushname)}, {quoted: selo})
break

case 'infolistanegra':
blackmd.sendMessage(from, {text: infolistanegra(prefix, pushname)}, {quoted: selo})
break

case 'inforgaluguel':
blackmd.sendMessage(from, {text: infoaluguel(prefix, pushname)}, {quoted: selo})
break

case 'infotransmitir':
blackmd.sendMessage(from, {text: infotransmitir(prefix, pushname)}, {quoted: selo})
break

case 'infopalavr√£o':
case 'infopalavrao':
blackmd.sendMessage(from, {text: infopalavrao(prefix, pushname)}, {quoted: selo})
break

case 'infobancarac':
blackmd.sendMessage(from, {text: infobancarac(prefix, pushname)}, {quoted: selo})
break

case 'git':
case 'git-bot':  
case 'gitdobot':
case 'gitbot':
reply(`üåê *Git dispon√≠vel no site:*
https://github.com/m4thxyz/blackofc`)
break

//========(FUN√á√ïES-PREMIUM-AQUI)=======\\

case 'ler':
case 'ocr':
case 'lerfoto':
if(!isVip) return reply(enviar.msg.vip)
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) {
encmedia = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'image')
fs.writeFileSync(rane, buffimg)
media = rane 
reply(enviar.espere)
await recognize(media, {lang: 'eng+ind', oem: 1, psm: 3})
.then(teks => {
reply(teks.trim())
DLT_FL(media)
})
.catch(err => {
reply(err.message)
DLT_FL(media)
})
} else {
reply('Somente fotos!')
}
break
case 'revelar':
case 'rvisu':
case 'revelarvisu':
if(!isVip) return reply(enviar.msg.vip)
if(!isQuotedVisuU || !isQuotedVisuU2) return reply(`marque uma foto/video em visualiza√ß√£o unica`)
try{
reagir(from, "üëÅÔ∏è")
if(JSON.stringify(info).includes("videoMessage")) {
var vio = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var viewImage = vio?.imageMessage || info.message?.imageMessage || vio?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || vio?.viewOnceMessage?.message?.imageMessage
var viewVideo = vio?.videoMessage || info.message?.videoMessage || vio?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || vio?.viewOnceMessage?.message?.videoMessage
viewVideo.viewOnce = false
viewVideo.video = {url: viewVideo.url}
viewVideo.caption += "\n\nüëÅÔ∏è *REVELANDO ONE VISION* üëÅÔ∏è"
blackmd.sendMessage(from, viewVideo, {quoted: info})
} else if(JSON.stringify(info).includes("imageMessage")) {
var vio = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var viewImage = vio?.imageMessage || info.message?.imageMessage || vio?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || vio?.viewOnceMessage?.message?.imageMessage
var viewVideo = vio?.videoMessage || info.message?.videoMessage || vio?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || vio?.viewOnceMessage?.message?.videoMessage
viewImage.viewOnce = false
viewImage.image = {url: viewImage.url}
viewImage.caption += "\n\nüëÅÔ∏è *REVELANDO ONE VISION* üëÅÔ∏è"
blackmd.sendMessage(from, viewImage, {quoted: info})
} else if(info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.viewOnceMessageV2Extension?.message?.audioMessage) {
var viewAudio = info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.viewOnceMessageV2Extension?.message?.audioMessage
viewAudio.viewOnce = false
viewAudio.ptt = true
media = await getFileBuffer(viewAudio, `audio`)
blackmd.sendMessage(from, {audio: media}, {quoted: info})
}
} catch(e){
console.log(e)
reply(`Erro`)
}
break

case 'listavip':
reagir(from, "üíé")
if(!isVip) { reply(enviar.msg.vip)
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
caixa = []
for(v of vip) {
  caixa.push({mapa: vip.map(i => i.id).indexOf(v.id) + 1, id: v.id, dias: v.dias, infinito: v.infinito, advenced: v.advenced})
}
total = caixa.length
if(isGroup && isJsonIncludes(vipgp, from)) {
  AB = vipgp.map(i => i.id).indexOf(from)
  vg = vipgp[AB]
  for(g of groupMembers) {
    if(!isJsonIncludes(vip, g.id)) caixa.push({mapa: groupMembers.map(i => i.id).indexOf(g.id) + 1 + total, id: g.id, dias: vg.dias, infinito: vg.infinito, advenced: vg.advenced})
  }
}
if(caixa.length <= 0) return reply(`N√£o h√° usu√°rios VIP salvos na pasta do bot...`)
txt = `„Äé ü§ë *ALTA REALEZA* ü§ë „Äè
${caixa.map(c =>
`¬ª${c.mapa}¬´
üë§ *Usu√°rio:* @${c.id.split("@")[0]}
‚è≥ *Tempo:* ${c.infinito ? `‚àû *INFINITY [ VIP ]*` : sendTimeDay(c.dias)}
üë®üèª‚Äçüíª *Consultas (${c.advenced ? `‚úÖ` : `‚ùå`})*`).join(`\n\n`)}`
txt += `\n\n„Ö§ *TOTAL„Äò* ${caixa.length} *„Äô*\n\n‚è§ÕüÕûÕüÕû Í¶ø${tempo} ${tempo_emoji}`
mencionarIMG(txt, `https://files.catbox.moe/pcg8iv.jpg`)
break

case 'listavipgp': case 'listagpvip':
reagir(from, "üíé")
if(!isVip) return reply(enviar.msg.vip)
if(vipgp.length <= 0) return reply(`N√£o h√° grupos vips salvos na pasta üíÅüèª‚Äç‚ôÇÔ∏è`)
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
onlygpsvip = []
for(i of allGroups) {
  if(isJsonIncludes(vipgp, i.id)) {
    AB = vipgp.map(b => b.id).indexOf(i.id)
    onlygpsvip.push({id: i.id, nome: i.subject, dias: vipgp[AB].dias, infinito: vipgp[AB].infinito, advenced: vipgp[AB].advenced})
  }
}
txt = `„Äé ü§ë *ALL GROUPS VIP* ü§ë „Äè
${onlygpsvip.map(c =>
`¬ª${onlygpsvip.map(d => d.id).indexOf(c.id) + 1}¬´
üë• *Grupo:* ${c.nome}
‚è≥ *Tempo:* ${c.infinito ? `‚àû *INFINITY [ VIP ]*` : sendTimeDay(c.dias)}
üë®üèª‚Äçüíª *Consultas (${c.advenced ? `‚úÖ` : `‚ùå`})*`).join(`\n\n`)}`
txt += `\n\n„Ö§ *TOTAL„Äò* ${onlygpsvip.length} *„Äô*\n\n‚è§ÕüÕûÕüÕû Í¶ø${tempo} ${tempo_emoji}`
mencionarIMG(txt, `https://i.imgur.com/Mk2k4uD.jpeg`)
break

case 'metodos':
if(!isVip) return reply(enviar.msg.vip)
const { metodos } = require('./armor/js/metodos.js');
tipo = q
if(tipo.toLowerCase().startsWith("desban")) {
  dbn = q.split('desban')[1]
  if(Number(dbn) > 0 && Number(dbn) <= metodos.desban.length && !dbn.includes('.')) {
    txt = metodos.desban[Number(dbn)-1]
  } else return reply(`Escolha um n√∫mero de 1-${metodos.desban.length}, ex:\n${prefix+command} desban 2`)
} else if(tipo.toLowerCase().startsWith("sair do -1")) {
  sd1 = q.split('sair do -1')[1]
  if(Number(sd1) > 0 && Number(sd1) <= metodos.sairdomenos1.length && !sd1.includes('.')) {
    txt = metodos.sairdomenos1[Number(sd1)-1]
  } else return reply(`Escolha um n√∫mero de 1-${metodos.sairdomenos1.length}, ex:\n${prefix+command} sair do -1 2`)
} else if(tipo.toLowerCase().replace("√∫", "u").startsWith("desativar numero")) {
  dn = q.replace("√∫", "u").split('desativar numero')[1]
  if(Number(dn) > 0 && Number(dn) <= metodos.desativarnumero.length && !dn.includes('.')) {
    txt = metodos.desativarnumero[Number(dn)-1]
  } else return reply(`Escolha um n√∫mero de 1-${metodos.desativarnumero.length}, ex:\n${prefix+command} desativar n√∫mero 2`)
} else return reply(`Vc precisa escolher o m√©todo:
> ${prefix+command} desban
> ${prefix+command} sair do -1
> ${prefix+command} desativar n√∫mero`)
reply(txt+`\n\n„Äò Lady üëë bot „Äô`)
break

case 'getquoted':
case 'getinfo':  
case 'get':  
reply(JSON.stringify(info.message.extendedTextMessage.contextInfo, null, 3))
break

case 'get-txt':  
reply(JSON.stringify(info.message.extendedTextMessage.contextInfo.quotedMessage.conversation, null, 2))
break

case 'netflix': case 'globoplay': case 'amazonprime': case 'telecine': case 'canvas': case 'hbo': case 'starsplus': case 'sportify':
if(!isJsonIncludes(moedas, sender)) return reply(`Voc√™ n√£o possui saldo... Veja ${prefix}me`)
account = `./database/contas/${command}.json`
if(!fs.existsSync(account)) return reply("Banco de dados dessa conta n√£o foi encontrado... Pfvr, chame meu dono para resolver.")
acc = JSON.parse(fs.readFileSync(account))
if(acc.length <= 0) return reply("Nenhuma conta em estoque no momento... Pfvr, volte mais tarde")
if(command == 'netflix') valor = 10
if(command == 'globoplay') valor = 15
if(command == 'amazonprime') valor = 10
if(command == 'telecine') valor = 20
if(command == 'canvas') valor = 5
if(command == 'hbo') valor = 10
if(command == 'starsplus') valor = 5
if(command == 'sportify') valor = 5
AB = moedas.map(i => i.id).indexOf(sender)
if(moedas[AB].saldo < valor) return reply(`Esta a√ß√£o lhe custaria R$ ${valor.toFixed(2)}, mas o seu saldo se encontra abaixo disso... Fa√ßa uma recarga no comando ${prefix}recarga`)
moedas[AB].saldo -= valor
saveJSON(moedas, `./basedefuncionamento/aluguel/moedas.json`)
BC = alerandom(acc.length)
txt = `„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§üåü ${command.toUpperCase()} üåü

‚úâÔ∏è *Login:* ${acc[BC].login}
üîë *Senha:* ${acc[BC].senha}

_Conta debitada no valor de R$ ${valor.toFixed(2)}... Nossa equipe agradece a confian√ßa em nossos servi√ßos_ ü•∞`
if(isGroup) { reply(`*Enviando* ü•∞`) }
await sleep(1000)
sendMess(sender, txt)
acc.splice(BC, 1)
saveJSON(acc, account)
break

case 'add-netflix': case 'add-globoplay': case 'add-amazonprime': case 'add-telecine': case 'add-canvas': case 'add-hbo': case 'add-starsplus': case 'add-sportify':
if(!isOwner) return reply(`S√≥ meu dono`)
conta = command.split("add-")[1]
account = `./database/contas/${conta}.json`
if(!fs.existsSync(account)) return reply("JSON n√£o encontrado para armazenar os dados... Verifica isso a√≠")
barra = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/")
var [continha, password] = barra.split("/")
if(!continha || !password) return reply(`Separe ap√≥s o comando, o login e senha com uma barra ( / ), ex:
${prefix+command} teupaidecalinha@gmail.com/12345`)
acc = JSON.parse(fs.readFileSync(account))
if(isJsonIncludes(acc, continha)) return reply("Conta j√° existente no banco de dados üìÇ")
acc.push({login: continha, senha: password})
saveJSON(acc, account)
reply(`Conta ${conta.toUpperCase()} adicionada com sucesso ‚úÖ`)
break

case 'rm-netflix': case 'rm-globoplay': case 'rm-amazonprime': case 'rm-telecine': case 'rm-canvas': case 'rm-hbo': case 'rm-starsplus': case 'rm-sportify':
if(!isOwner) return reply(`S√≥ meu dono`)
conta = command.split("rm-")[1]
account = `./database/contas/${conta}.json`
if(!fs.existsSync(account)) return reply("JSON n√£o encontrado para armazenar os dados... Verifica isso a√≠")
if(!q) return reply(`Retorne o email da conta ou o n√∫mero dela presente no comando ${prefix+"lista-"+conta} para deletar üóëÔ∏è`)
acc = JSON.parse(fs.readFileSync(account))
try {
loc = Number(q) ? Number(q) - 1 : acc.map(i => i.login).indexOf(q)
reply(`Conta ${acc[loc].login} deletada com sucesso ‚úÖ`)
acc.splice(loc, 1)
return saveJSON(acc, account)
} catch { return reply("Conta n√£o existente no banco de dados üìÇ") }
break

case 'lista-netflix': case 'lista-globoplay': case 'lista-amazonprime': case 'lista-telecine': case 'lista-canvas': case 'lista-hbo': case 'lista-starsplus': case 'lista-sportify':
if(!isOwner) return reply(`S√≥ meu dono`)
conta = command.split("lista-")[1]
account = `./database/contas/${conta}.json`
acc = JSON.parse(fs.readFileSync(account))
if(!fs.existsSync(account)) return reply("JSON n√£o encontrado para armazenar os dados... Verifica isso a√≠")
txt = `üåü *Lista de contas ${conta.toUpperCase()}:*`
for(i = 0; i < acc.length; i++) {
  txt += `\n\n[ ${i+1} ]\n*Login:* ${acc[i].login}\n*Senha:* ${acc[i].senha}`
}
txt += `\n\nüìú *Total:* ${acc.length}`
reply(txt)
break

case 'disney':
if(!isVip) return reply(enviar.msg.vip)
disney = JSON.parse(fs.readFileSync("./database/disney.json"))
moon = disney[Math.floor(Math.random() * disney.length)]
blackmd.sendMessage(from, {image: {url: 'https://telegra.ph/file/9cb91bf0953c17ca4268a.jpg'}, caption: `
> Lembre-se: teste a conta para ver se tem acesso ou n√£o, algumas contas n√£o tem mais acesso v√°lido, boa sorte.

> Login: ${moon.login}

> Senha: ${moon.senha}`}, {quoted: info})
break

case 'gerarcpf':
if(!isVip) return reply(enviar.msg.vip)
cp1 = `${Math.floor(Math.random() * 300) + 600}`
cp2 = `${Math.floor(Math.random() * 300) + 600}`
cp3 = `${Math.floor(Math.random() * 300) + 600}`
cp4 = `${Math.floor(Math.random() * 30) + 60}`
cpf = `${cp1}.${cp2}.${cp3}-${cp4}`
blackmd.sendMessage(from, {text: `ùêÇùêèùêÖ ùêÜùêÑùêëùêÄùêÉùêé ùêÇùêéùêå„Äé ùêíùêîùêÇùêÑùêíùêíùêé „Äèüíª\n\n${cpf}`}, {quoted: seloctt})
break

case 'gerarcartao':
    if (!q) {
        return blackmd.sendMessage(from, { text: '[‚öôÔ∏è] Por favor, envie o tipo de cart√£o que deseja gerar. Exemplo: .gerarcartao Visa' }, { quoted: info });
    }

    const tipoCartao = encodeURIComponent(q);
    const apiCartao = `https://api.ownblox.biz.id/api/vcc?type=${tipoCartao}&count=5`;

    try {
        const responseCartao = await axios.get(apiCartao);

        if (Array.isArray(responseCartao.data)) {
            let listaCartoes = 'üí≥ Cart√µes gerados:\n\n';
            responseCartao.data.forEach((cartao, index) => {
                listaCartoes += `üÜî Cart√£o ${index + 1}:\n`;
                listaCartoes += `‚Ä¢ Nome: ${cartao.name}\n`;
                listaCartoes += `‚Ä¢ N√∫mero: ${cartao.number}\n`;
                listaCartoes += `‚Ä¢ CVV: ${cartao.cvv}\n`;
                listaCartoes += `‚Ä¢ Validade: ${cartao.expiry}\n\n`;
            });

            blackmd.sendMessage(from, { text: listaCartoes.trim() }, { quoted: info });
        } else if (responseCartao.data.error) {
            blackmd.sendMessage(from, { text: `üö® Erro: ${responseCartao.data.error}` }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o consegui gerar os cart√µes.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao gerar cart√µes:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao tentar gerar cart√µes.' }, { quoted: info });
    }
    break;


case 'listafake': case 'listafakes':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
reagir(from, "üá∫üá∏")
txt = `üá∫üá∏ *Lista de n√∫meros fake presentes neste grupo:*\n`
let totalfake = 0
for(i = 0; i < groupMembers.length; i++) {
  if(groupMembers[i].id.split(groupMembers[i].id.slice(2))[0] === ("55")) {} else {
    txt += `‚áí ${isGroupAdmins ? '@' : 'wa.me/'}${groupMembers[i].id.split("@")[0]}\n`
    totalfake += 1
  }
}
txt += `\nüá∫üá∏ Total: ${totalfake}`
if(totalfake > 0) {
  var resp = isGroupAdmins ? mention : reply
  resp(txt)
} else {
  reply("N√£o h√° n√∫meros fake neste grupo...")
}
break

case 'brlist': case 'listabr':
if(!isGroup) return reply(enviar.msg.grupo)
reagir(from, "üáßüá∑")
txt = `üáßüá∑ *Lista de n√∫meros brasileiros presentes neste grupo:*\n`
let totalbr = 0
for(i = 0; i < groupMembers.length; i++) {
  if(groupMembers[i].id.split(groupMembers[i].id.slice(2))[0] === ("55")) {
    if(groupMembers[i].id.includes(botNumber)) {} else {
      txt += `‚áí ${isGroupAdmins ? '@' : 'wa.me/'}${groupMembers[i].id.split("@")[0]}\n`
      totalbr += 1
    }
  }
}
txt += `\nüáßüá∑ Total: ${totalbr}`
if(totalbr > 0) {
  var resp = isGroupAdmins ? mention : reply
  resp(txt)
} else {
  reply("N√£o h√° n√∫meros brasileiros neste grupo...")
}
break

case 'dddlist': case 'listaddd':
if(!isGroup) return reply(enviar.msg.grupo)
if(!q) return reply(`Use ${prefix+command} DDD`)
if(!Number(args[0])) return reply(`${args[0]} n√£o √© n√∫mero...`)
if(Number(args[0]) < 10 || Number(args[0]) > 99) return reply("Retorne um DDD v√°lido")
reagir(from, "üáßüá∑")
txt = `üáßüá∑ *Lista de n√∫meros brasileiros com DDD +${args[0]} presentes neste grupo:*\n`
let totalddd = 0
for(i = 0; i < groupMembers.length; i++) {
  if(groupMembers[i].id.split(groupMembers[i].id.slice(4))[0] === (`55${args[0]}`)) {
    if(groupMembers[i].id.includes(botNumber)) {} else {
      txt += `‚áí ${isGroupAdmins ? '@' : 'wa.me/'}${groupMembers[i].id.split("@")[0]}\n`
      totalddd += 1
    }
  }
}
txt += `\nüáßüá∑ Total: ${totalddd}`
if(totalddd > 0) {
  var resp = isGroupAdmins ? mention : reply
  resp(txt)
} else {
  reply(`N√£o h√° n√∫meros com o DDD +${args[0]} neste grupo...`)
}
break

case 'gerarnmr':
if(!isVip) return reply(enviar.msg.vip)
if(args.length < 1) return reply(`*Digite o DDD para gerar...*\n*Exemplo:* ${prefix + command} 91`)
nmrale1 = `${Math.floor(Math.random() * 3) + 6}`
nmrale2 = `${Math.floor(Math.random() * 3) + 6}`
nmrale3 = `${Math.floor(Math.random() * 3) + 6}`
nmrale4 = `${Math.floor(Math.random() * 3) + 6}`
nmrale5 = `${Math.floor(Math.random() * 3) + 6}`
nmrale6 = `${Math.floor(Math.random() * 3) + 6}`
nmrale7 = `${Math.floor(Math.random() * 3) + 6}`
nmrale8 = `${Math.floor(Math.random() * 3) + 6}`
nmrale = `${nmrale1+nmrale2+nmrale3+nmrale4+nmrale5+nmrale6+nmrale7+nmrale8}`
blackmd.sendMessage(from, {text: `*Gerando n√∫mero de tell com o DDD* ${q}‚ßΩ

‚áí ${q}9${nmrale}
wa.me/55${q+nmrale}`}, {quoted: seloctt})
break

case 'encurtalink':
if(!isVip) return reply(enviar.msg.vip)
if(!q) return reply(`Ex: ${prefix+command} ${site}`)
try {
link = q
anu = await axios.get(`https://tinyurl.com/api-create.php?url=${link}`)
reply(`${anu.data}`)
} catch (e) {
emror = String(e)
reply(`${e}`)
}
break
case 'tinyurl':
case 'linkcurto': {
  if (!text) return reply(`*‚ùó Informe uma URL para encurtar!*`);

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tinyurl?url=${encodeURIComponent(text)}`);
    
    if (data.status !== 200 || !data.result) {
      return reply(`*‚ùó Erro ao encurtar o link.*`);
    }

    await sock.sendMessage(from, {
      text: `*üîó Link encurtado com sucesso!*\n\n*Original:* ${text}\n*Encurtado:* ${data.result}`,
      mentions: [sender]
    }, { quoted: msg });

    reaction(msg, '‚úÖ');
  } catch (e) {
    console.error(e);
    reply(`*‚ùó Erro ao encurtar o link.*`);
    reaction(msg, '‚ùå');
  }
  break;
}
case 'adfoc':
  if (!q) return reply('Me envie o link que deseja encurtar.')

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/shortlink/adfoc?url=${encodeURIComponent(q)}`)

    if (data?.status === 200 && data?.result) {
      reply(`Link encurtado com sucesso:\n${data.result}`)
    } else {
      reply('N√£o foi poss√≠vel encurtar o link.')
    }
  } catch (err) {
    console.log(err)
    reply('Erro ao encurtar o link.')
  }
  break
  case 'bitly':
  if (!q) return reply('Me envie o link que deseja encurtar.')

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/shortlink/bitly?url=${encodeURIComponent(q)}`)

    if (data?.status === 200 && data?.result) {
      reply(`Link encurtado com sucesso:\n${data.result}`)
    } else {
      reply('N√£o foi poss√≠vel encurtar o link.')
    }
  } catch (err) {
    console.log(err)
    reply('Erro ao encurtar o link.')
  }
  break
  case 'ouo':
  if (!q) return reply('Me envie o link que deseja encurtar.')

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/shortlink/ouo?url=${encodeURIComponent(q)}`)

    if (data?.status === 200 && data?.result) {
      reply(`Link encurtado com sucesso:\n${data.result}`)
    } else {
      reply('N√£o foi poss√≠vel encurtar o link.')
    }
  } catch (err) {
    console.log(err)
    reply('Erro ao encurtar o link.')
  }
  break
  case 'cleanuri':
  if (!q) return reply('Me envie o link que deseja encurtar.')

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/shortlink/cleanuri?url=${encodeURIComponent(q)}`)

    if (data?.status === 200 && data?.result) {
      reply(`Link encurtado com sucesso:\n${data.result}`)
    } else {
      reply('N√£o foi poss√≠vel encurtar o link.')
    }
  } catch (err) {
    console.log(err)
    reply('Erro ao encurtar o link.')
  }
  break
case 'ssurl':
  if (!q) return reply('Me envie o link que deseja encurtar.')

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/shortlink/ssur?url=${encodeURIComponent(q)}`)

    if (data?.status === 200 && data?.result) {
      reply(`Link encurtado com sucesso:\n${data.result}`)
    } else {
      reply('N√£o foi poss√≠vel encurtar o link.')
    }
  } catch (err) {
    console.log(err)
    reply('Erro ao encurtar o link.')
  }
  break
case 'shortlink':
  if (!q) return reply('Me envie o link que deseja encurtar.')

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/shortlink/vurl?url=${encodeURIComponent(q)}`)

    if (data?.status !== 200 || !data?.result) {
      return reply('N√£o foi poss√≠vel encurtar o link.')
    }

    reply(`Link encurtado com sucesso:\n${data.result}`)
  } catch (err) {
    console.log(err)
    reply('Erro ao encurtar o link.')
  }
  break
  
// CONSULTAS
//consultas by world ecletix & lady-botv4 
case 'telefone':
case "numero": {
    if (!q) {
        return reply("Voc√™ precisa fornecer um n√∫mero para consultar.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/numero?q=${encodeURIComponent(q)}`);

        // Caso retorne que n√£o foi encontrado
        if (Array.isArray(data) && data[0]?.includes("N√ÉO ENCONTRADO")) {
            return reply("‚ö†Ô∏è Telefone n√£o encontrado.");
        }

        // Fun√ß√£o para extrair valores do array
        const extrair = (chave) => {
            const item = data.find(x => x.startsWith(chave));
            return item ? item.replace(chave, "").trim() : "N√£o informado";
        };

        const telefone = extrair("‚Ä¢ TELEFONE:");
        const nome = extrair("‚Ä¢ NOME:");
        const cpf = extrair("‚Ä¢ CPF/CNPJ:");
        const logradouro = extrair("‚Ä¢ LOGRADOURO:");
        const numero = extrair("‚Ä¢ N√öMERO:");
        const complemento = extrair("‚Ä¢ COMPLEMENTO:");
        const bairro = extrair("‚Ä¢ BAIRRO:");
        const cidade = extrair("‚Ä¢ CIDADE:");
        const estado = extrair("‚Ä¢ ESTADO:");
        const cep = extrair("‚Ä¢ CEP:");

        let resposta =
            `üîç *CONSULTA DE TELEFONE* üîç\n` +
            `‚Ä¢ Telefone: ${telefone}\n` +
            `‚Ä¢ Nome: ${nome}\n` +
            `‚Ä¢ CPF/CNPJ: ${cpf}\n` +
            `‚Ä¢ Endere√ßo: ${logradouro}, ${numero}\n` +
            `‚Ä¢ Complemento: ${complemento}\n` +
            `‚Ä¢ Bairro: ${bairro}\n` +
            `‚Ä¢ Cidade/Estado: ${cidade} - ${estado}\n` +
            `‚Ä¢ CEP: ${cep}\n\n` +
            `‚Ä¢ Usu√°rio: ${pushname}\n` +
            `‚Ä¢ Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro ao consultar telefone:", err);
        reply("Erro ao consultar o telefone. Tente novamente mais tarde.");
    }
}
break;
case "nome2": {
    if (!q) {
        return reply("Voc√™ precisa fornecer um nome completo para consulta.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/nome-completo?q=${encodeURIComponent(q)}`);

        // Verifica se a resposta cont√©m mensagem de erro
        if (Array.isArray(data) && data[0]?.includes("NOME N√ÉO ENCONTRADO")) {
            return reply(data[0]); // Retorna a mensagem de erro da API
        }

        // Verifica se a resposta √© v√°lida e completa
        if (!Array.isArray(data) || data.length < 6) {
            return reply("N√£o consegui obter os resultados, tente novamente mais tarde.");
        }

        const resultado = {
            resultado: data[1]?.replace("‚Ä¢ RESULTADO: ", "") || "Desconhecido",
            nome: data[2]?.replace("‚Ä¢ NOME: ", "") || "Desconhecido",
            cpf: data[3]?.replace("‚Ä¢ CPF: ", "") || "Desconhecido",
            sexo: data[4]?.replace("‚Ä¢ SEXO: ", "") || "Desconhecido",
            nascimento: data[5]?.replace("‚Ä¢ NASCIMENTO: ", "") || "Desconhecido"
        };

        const message =
            `üîç *CONSULTA DE NOME* üîç\n` +
            `‚Ä¢ Resultado: ${resultado.resultado}\n` +
            `‚Ä¢ Nome: ${resultado.nome}\n` +
            `‚Ä¢ CPF: ${resultado.cpf}\n` +
            `‚Ä¢ Sexo: ${resultado.sexo}\n` +
            `‚Ä¢ Nascimento: ${resultado.nascimento}\n` +
            `‚Ä¢ Usu√°rio: ${pushname}\n` +
            `‚Ä¢ Bot: ${NomeDoBot}`;

        reply(message);

    } catch (error) {
        console.error("Erro ao processar a consulta de nome:", error);
        return reply("Ocorreu um erro ao consultar o nome. Por favor, tente novamente mais tarde.");
    }
} break;
case "nome3": {
    if (!q) {
        return reply("Voc√™ precisa fornecer um nome para consulta.");
    }

    try {
        const { data } = await axios.get(`https://api-bruxel4s.shop/api/consulta/nome?query=${encodeURIComponent(q)}`);

        const resultados = data.resultados;
        if (!Array.isArray(resultados) || resultados.length === 0) {
            return reply("Nenhum resultado encontrado para esse nome.");
        }

        const r = resultados[0];

        let resposta =
            `üßæ *CONSULTA POR NOME* üßæ\n\n` +
            `‚Ä¢ Nome: ${r.nome || "N√£o informado"}\n` +
            `‚Ä¢ CPF: ${r.cpf || "N√£o informado"}\n` +
            `‚Ä¢ Nascimento: ${r.nascimento || "N√£o informado"}\n` +
            `‚Ä¢ Sexo: ${r.sexo || "N√£o informado"}\n` +
            `‚Ä¢ Pai: ${r.pai || "N√£o encontrado"}\n` +
            `‚Ä¢ M√£e: ${r.mae || "N√£o encontrado"}\n\n` +
            `‚Ä¢ Usu√°rio: ${pushname}\n` +
            `‚Ä¢ Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro na consulta nome6:", err);
        reply("Erro ao consultar o nome. Tente novamente mais tarde.");
    }
}
break;
case "email": {
    if (!q) {
        return reply("Voc√™ precisa fornecer um e-mail para consulta.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/email?q=${encodeURIComponent(q)}`);

        // Verifica se a resposta cont√©m mensagem de erro
        if (Array.isArray(data) && (data[0]?.includes("N√ÉO ENCONTRADO"))) {
            return reply(data[0]); // Retorna diretamente a mensagem de erro da API
        }

        // Verifica se a resposta √© v√°lida e cont√©m todos os dados esperados
        if (!Array.isArray(data) || data.length < 6) {
            return reply("N√£o consegui obter os resultados, tente novamente mais tarde.");
        }

        const resultado = {
            resultado: data[1]?.replace("‚Ä¢ RESULTADO: ", "") || "Desconhecido",
            nome: data[2]?.replace("‚Ä¢ NOME: ", "") || "Desconhecido",
            documento: data[3]?.replace("‚Ä¢ CPF/CNPJ: ", "") || "Desconhecido",
            sexo: data[4]?.replace("‚Ä¢ SEXO: ", "") || "Desconhecido",
            nascimento: data[5]?.replace("‚Ä¢ NASCIMENTO: ", "") || "Desconhecido"
        };

        const message =
            `üîç *CONSULTA DE E-MAIL* üîç\n` +
            `‚Ä¢ Resultado: ${resultado.resultado}\n` +
            `‚Ä¢ Nome: ${resultado.nome}\n` +
            `‚Ä¢ CPF/CNPJ: ${resultado.documento}\n` +
            `‚Ä¢ Sexo: ${resultado.sexo}\n` +
            `‚Ä¢ Nascimento: ${resultado.nascimento}\n` +
            `‚Ä¢ Usu√°rio: ${pushname}\n` +
            `‚Ä¢ Bot: ${NomeDoBot}`;

        reply(message);

    } catch (error) {
        console.error("Erro ao processar a consulta de e-mail:", error);
        return reply("Ocorreu um erro ao consultar o e-mail. Por favor, tente novamente mais tarde.");
    }
} break;
case "cpf": {
    if (!q) {
        return reply("Voc√™ precisa fornecer um CPF para consulta.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/consultarcpf?cpf=${encodeURIComponent(q)}`);

        if (Array.isArray(data) && data[0]?.includes("CPF INV√ÅLIDO")) {
            return reply(data[0]);
        }

        const extrair = (chave) => {
            const item = data.find(x => x.startsWith(chave));
            return item ? item.replace(chave, "").trim() : "N√£o informado";
        };

        const nome = extrair("‚Ä¢ NOME:");
        const cpf = extrair("‚Ä¢ CPF:");
        const nascimento = extrair("‚Ä¢ NASCIMENTO:");
        const idade = extrair("‚Ä¢ IDADE:");
        const signo = extrair("‚Ä¢ SIGNO:");
        const sexo = extrair("‚Ä¢ SEXO:");
        const mae = extrair("‚Ä¢ M√ÉE:");
        const pai = extrair("‚Ä¢ PAI:");
        const logradouro = extrair("‚Ä¢ LOGRADOURO:");
        const numero = extrair("‚Ä¢ N√öMERO:");
        const complemento = extrair("‚Ä¢ COMPLEMENTO:");
        const bairro = extrair("‚Ä¢ BAIRRO:");
        const cidade = extrair("‚Ä¢ CIDADE:");
        const estado = extrair("‚Ä¢ ESTADO:");
        const pais = extrair("‚Ä¢ PA√çS:");
        const cep = extrair("‚Ä¢ CEP:");
        const telefone = extrair("‚Ä¢ TELEFONE:");

        let resposta =
            `üîç *CONSULTA DE CPF* üîç\n` +
            `‚Ä¢ Nome: ${nome}\n` +
            `‚Ä¢ CPF: ${cpf}\n` +
            `‚Ä¢ Nascimento: ${nascimento} (Idade: ${idade})\n` +
            `‚Ä¢ Signo: ${signo}\n` +
            `‚Ä¢ Sexo: ${sexo}\n` +
            `‚Ä¢ M√£e: ${mae}\n` +
            `‚Ä¢ Pai: ${pai}\n\n` +
            `*Endere√ßo:*\n` +
            `${logradouro}, ${numero} ${complemento}\n` +
            `${bairro} - ${cidade}/${estado} - ${cep}\n` +
            `Pa√≠s: ${pais}\n\n` +
            `‚Ä¢ Telefone: ${telefone}\n\n` +
            `‚Ä¢ Usu√°rio: ${pushname}\n` +
            `‚Ä¢ Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro na consulta consultarcpf:", err);
        reply("Erro ao consultar o CPF. Tente novamente mais tarde.");
    }
}
break;
case "cpf2": {
    if (!q) {
        return reply("Voc√™ precisa fornecer um n√∫mero de CPF para consulta.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/cpf2?q=${encodeURIComponent(q)}`);

        // Verifica se a resposta √© uma mensagem de erro
        if (Array.isArray(data) && data[0]?.includes("CPF INV√ÅLIDO")) {
            return reply(data[0]); // Retorna a mensagem de erro diretamente
        }

        if (!Array.isArray(data) || data.length < 5) {
            return reply("N√£o consegui obter os resultados. Tente novamente mais tarde.");
        }

        // Extrair partes principais da resposta
        const extrairValor = (prefixo) => {
            const item = data.find(linha => linha.startsWith(prefixo));
            return item ? item.replace(prefixo, '').trim() : "Desconhecido";
        };

        const nome = extrairValor("‚Ä¢ NOME:");
        const nascimento = extrairValor("‚Ä¢ NASCIMENTO:");
        const idade = extrairValor("‚Ä¢ IDADE:");
        const cpf = extrairValor("‚Ä¢ CPF:");
        const score = extrairValor("‚Ä¢ SCORE:");
        const status = extrairValor("‚Ä¢ STATUS RECEITA FEDERAL:");
        const emails = data.slice(data.indexOf("‚Ä¢ E-MAILS:") + 1, data.indexOf("‚Ä¢ ENDERE√áOS:")) || [];

        const enderecosIndex = data.indexOf("‚Ä¢ ENDERE√áOS:");
        const telefonesIndex = data.indexOf("‚Ä¢ TELEFONES PROPRIET√ÅRIO:");
        const enderecos = data.slice(enderecosIndex + 1, telefonesIndex) || [];

        const telefones = data.slice(telefonesIndex + 1, data.indexOf("‚Ä¢ TELEFONES COMERCIAIS:")) || [];

        // Monta mensagem
        let message =
            `üîç *CONSULTA DE CPF* üîç\n` +
            `‚Ä¢ Nome: ${nome}\n` +
            `‚Ä¢ Nascimento: ${nascimento} (Idade: ${idade})\n` +
            `‚Ä¢ CPF: ${cpf}\n` +
            `‚Ä¢ Score: ${score}\n` +
            `‚Ä¢ Status RF: ${status}\n` +
            `\n*E-mails encontrados:*\n${emails.join('\n') || 'Nenhum'}\n` +
            `\n*Endere√ßos:*\n${enderecos.join('\n') || 'Nenhum'}\n` +
            `\n*Telefones:*\n${telefones.join('\n') || 'Nenhum'}\n` +
            `\n‚Ä¢ Usu√°rio: ${pushname}\n` +
            `‚Ä¢ Bot: ${NomeDoBot}`;

        reply(message);

    } catch (error) {
        console.error("Erro ao consultar CPF:", error);
        return reply("Erro ao consultar CPF. Tente novamente mais tarde.");
    }
} break;
case "cpf3": {
    if (!q) {
        return reply("Voc√™ precisa fornecer um n√∫mero de CPF para consulta.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/cpf3?q=${encodeURIComponent(q)}`);

        if (Array.isArray(data) && data[0]?.includes("CPF INV√ÅLIDO")) {
            return reply(data[0]);
        }

        const extrair = (chave) => {
            const item = data.find(x => x.startsWith(chave));
            return item ? item.replace(chave, "").trim() : "N√£o informado";
        };

        const nome = extrair("‚Ä¢ NOME:");
        const nascimento = extrair("‚Ä¢ NASCIMENTO:");
        const idade = extrair("‚Ä¢ IDADE:");
        const cpf = extrair("‚Ä¢ CPF:");
        const score = extrair("‚Ä¢ SCORE:");
        const status = extrair("‚Ä¢ STATUS RECEITA FEDERAL:");
        const mae = extrair("‚Ä¢ M√ÉE:");
        const pai = extrair("‚Ä¢ PAI:");
        const profissao = extrair("‚Ä¢ PROFISS√ÉO:");
        const renda = extrair("‚Ä¢ RENDA PRESUMIDA:");

        const emails = data.slice(data.indexOf("‚Ä¢ E-MAILS:") + 1, data.indexOf("‚Ä¢ ENDERE√áOS:")) || [];
        const enderecos = data.slice(data.indexOf("‚Ä¢ ENDERE√áOS:") + 1, data.indexOf("‚Ä¢ TELEFONES PROPRIET√ÅRIO:")) || [];
        const telefones = data.slice(data.indexOf("‚Ä¢ TELEFONES PROPRIET√ÅRIO:") + 1, data.indexOf("‚Ä¢ TELEFONES COMERCIAIS:")) || [];
        const parentesIndex = data.indexOf("‚Ä¢ POSS√çVEIS PARENTES:");
        const vizinhosIndex = data.indexOf("‚Ä¢ POSS√çVEIS VIZINHOS:");
        const parentes = parentesIndex !== -1 && vizinhosIndex !== -1 ? data.slice(parentesIndex + 1, vizinhosIndex) : [];

        let resposta =
            `üîç *CONSULTA DE CPF* üîç\n` +
            `‚Ä¢ Nome: ${nome}\n` +
            `‚Ä¢ CPF: ${cpf}\n` +
            `‚Ä¢ Nascimento: ${nascimento} (Idade: ${idade})\n` +
            `‚Ä¢ M√£e: ${mae}\n` +
            `‚Ä¢ Pai: ${pai}\n` +
            `‚Ä¢ Profiss√£o: ${profissao}\n` +
            `‚Ä¢ Renda Presumida: R$ ${renda}\n` +
            `‚Ä¢ Score: ${score}\n` +
            `‚Ä¢ Status Receita Federal: ${status}\n\n` +
            `*E-mails encontrados:*\n${emails.join('\n') || 'Nenhum'}\n\n` +
            `*Endere√ßos:*\n${enderecos.join('\n') || 'Nenhum'}\n\n` +
            `*Telefones:*\n${telefones.join('\n') || 'Nenhum'}\n\n` +
            `*Parentes:*\n${parentes.join('\n') || 'Nenhum'}\n\n` +
            `‚Ä¢ Usu√°rio: ${pushname}\n` +
            `‚Ä¢ Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro na consulta cpf3:", err);
        reply("Erro ao consultar o CPF. Tente novamente mais tarde.");
    }
}
break;
        
case "cpf6":
{
  if (!q) {
    return blackmd.sendMessage(
      from,
      { text: `Por favor, forne√ßa um CPF v√°lido. Exemplo: ${prefix}cpfcompleto 16982570746` },
      { quoted: info }
    );
  }

  try {
    const response = await axios.get(`https://scraper.mdzapis.com/consultar/mdz?type=cpf&data=${encodeURIComponent(q)}&base=COMPLETA&apikey=freemdz15days`);

    if (!response.data || !response.data.resultado) {
      return blackmd.sendMessage(from, { text: "Erro: N√£o foi poss√≠vel obter os dados para este CPF." }, { quoted: info });
    }

    const dados = response.data.resultado;

    let msg = `üîç *Consulta de CPF Completo*\n\n`;
    msg += `üë§ *Nome:* ${dados.match(/NOME:\s(.*?)\n/)?.[1] || "N√£o encontrado"}\n`;
    msg += `üÜî *CPF:* ${dados.match(/CPF:\s(.*?)\n/)?.[1] || "N√£o encontrado"}\n`;
    msg += `üìä *Situa√ß√£o Cadastral:* ${dados.match(/SITUA√á√ÉO CADASTRAL:\s(.*?)\n/)?.[1] || "N√£o encontrado"}\n`;
    msg += `üéÇ *Nascimento:* ${dados.match(/NASCIMENTO:\s(.*?)\n/)?.[1] || "N√£o encontrado"}\n`;
    msg += `üßë‚Äçüéì *Escolaridade:* ${dados.match(/ESCOLARIDADE:\s(.*?)\n/)?.[1] || "N√£o encontrado"}\n`;
    msg += `üë©‚Äçüë¶ *Nome da M√£e:* ${dados.match(/M√ÉE:\s(.*?)\n/)?.[1] || "N√£o encontrado"}\n`;
    msg += `üë® *Nome do Pai:* ${dados.match(/PAI:\s(.*?)\n/)?.[1] || "N√£o encontrado"}\n`;
    msg += `üí∞ *Renda:* R$ ${dados.match(/RENDA:\s(.*?)\n/)?.[1] || "N√£o encontrado"}\n`;
    msg += `üìâ *Poder Aquisitivo:* ${dados.match(/PODER AQUISITIVO:\s(.*?)\n/)?.[1] || "N√£o encontrado"}\n`;

    const telefones = dados.match(/(\d{11})\nTIPO:\s(.*?)\nOPERADORA:\s(.*?)\n/g);
    if (telefones) {
      msg += `üìû *Telefones:* \n`;
      telefones.forEach((tel, i) => {
        const match = tel.match(/(\d{11})\nTIPO:\s(.*?)\nOPERADORA:\s(.*?)\n/);
        msg += `   üìå ${i + 1}: ${match[1]} (${match[2]}) - ${match[3]}\n`;
      });
    }

    const emailMatch = dados.match(/EMAIL:\s(.*?)\n/);
    if (emailMatch) {
      msg += `üìß *Email:* ${emailMatch[1]}\n`;
    }

    const enderecos = dados.match(/CEP:\s(.*?)\s-\sESTADO:\s(.*?)\s-\sMUNIC√çPIO:\s(.*?)\s-\sLOGRADOURO:\s(.*?)\s-\sBAIRRO:\s(.*?)\s-\sCOMPLEMENTO:\s(.*?)\s-\sN√öMERO:\s(.*?)\n/g);
    if (enderecos) {
      msg += `üìç *Endere√ßos:* \n`;
      enderecos.forEach((end, i) => {
        const match = end.match(/CEP:\s(.*?)\s-\sESTADO:\s(.*?)\s-\sMUNIC√çPIO:\s(.*?)\s-\sLOGRADOURO:\s(.*?)\s-\sBAIRRO:\s(.*?)\s-\sCOMPLEMENTO:\s(.*?)\s-\sN√öMERO:\s(.*?)\n/);
        msg += `   üìå ${i + 1}: ${match[4]}, ${match[7]}, ${match[5]}, ${match[3]}/${match[2]} - CEP: ${match[1]}\n`;
      });
    }

    blackmd.sendMessage(from, { text: msg }, { quoted: info });

  } catch (error) {
    console.error('Erro ao buscar CPF:', error);
    blackmd.sendMessage(from, { text: "Ocorreu um erro ao processar a solicita√ß√£o." }, { quoted: info });
  }
}
break;

case "cpf7":
{
  if (!q) {
    return blackmd.sendMessage(
      from,
      { text: `Por favor, forne√ßa um CPF v√°lido. Exemplo: ${prefix}cpffull 56256337972` },
      { quoted: info }
    );
  }

  try {
    const response = await axios.get(`https://ghostapis.com.br/api.php?token=758a8326817da871e9a2713e2c684c5d&cpf_completo=${encodeURIComponent(q)}`);

    if (!response.data || response.data.CPF !== q) {
      return blackmd.sendMessage(from, { text: "Erro: N√£o foi poss√≠vel obter os dados para este CPF." }, { quoted: info });
    }

    const dados = response.data;

    let msg = `üîç *Consulta de CPF*\n\n`;
    msg += `üë§ *Nome:* ${dados.NOME || "N√£o encontrado"}\n`;
    msg += `üÜî *CPF:* ${dados.CPF || "N√£o encontrado"}\n`;
    msg += `üéÇ *Nascimento:* ${dados.NASCIMENTO || "N√£o encontrado"}\n`;
    msg += `üë®‚Äçüë©‚Äçüëß‚Äçüë¶ *Nome da M√£e:* ${dados.NOME_MAE || "N√£o encontrado"}\n`;
    msg += `üë® *Nome do Pai:* ${dados.NOME_PAI || "N√£o encontrado"}\n`;
    msg += `üí≥ *RG:* ${dados.RG || "N√£o encontrado"}\n`;
    msg += `üìä *Estado Civil:* ${dados.ESTADO_CIVIL || "N√£o encontrado"}\n`;

    if (dados.LISTA_TELEFONE && dados.LISTA_TELEFONE.length > 0) {
      msg += `üìû *Telefones:* ${dados.LISTA_TELEFONE.map(t => t.NUMBER).join(", ")}\n`;
    }

    if (dados.LISTA_EMAIL && dados.LISTA_EMAIL.length > 0) {
      msg += `üìß *Emails:* ${dados.LISTA_EMAIL.map(e => e.EMAIL).join(", ")}\n`;
    }

    if (dados.ENDERECO && dados.ENDERECO.length > 0) {
      msg += `üìç *Endere√ßos:* \n`;
      dados.ENDERECO.forEach((end, i) => {
        msg += `   üìå ${i + 1}: ${end.LOGRADOURO}, ${end.LOGRADOURO_NUMERO}, ${end.BAIRRO}, ${end.CIDADE}/${end.UF} - CEP: ${end.CEP}\n`;
      });
    }

    if (dados.VAZAMENTOS_SENHA_CPF && dados.VAZAMENTOS_SENHA_CPF.length > 0) {
      msg += `üîì *Senha vazada:* ${dados.VAZAMENTOS_SENHA_CPF.map(v => v.SENHA).join(", ")}\n`;
    }

    blackmd.sendMessage(from, { text: msg }, { quoted: info });

  } catch (error) {
    console.error('Erro ao buscar CPF:', error);
    blackmd.sendMessage(from, { text: "Ocorreu um erro ao processar a solicita√ß√£o." }, { quoted: info });
  }
}
break;
case "cpf8": {
    if (!q) {
        return reply("Voc√™ precisa fornecer um CPF para consulta.");
    }

    try {
        const { data } = await axios.get(`https://api-bruxel4s.shop/api/consulta/cpf?query=${encodeURIComponent(q)}`);

        const r = data.resultado;
        if (!r || r.nome === "undefined") {
            return reply("CPF n√£o encontrado ou inv√°lido.");
        }

        let resposta =
            `üîç *CONSULTA CPF 8* üîç\n\n` +
            `‚Ä¢ Nome: ${r.nome || "N√£o informado"}\n` +
            `‚Ä¢ CPF: ${r.cpf || "N√£o informado"}\n` +
            `‚Ä¢ Nascimento: ${r.nascimento || "N√£o informado"}\n` +
            `‚Ä¢ Sexo: ${r.sexo || "N√£o informado"}\n` +
            `‚Ä¢ M√£e: ${r.mae || "N√£o informado"}\n` +
            `‚Ä¢ Pai: ${r.pai || "N√£o informado"}\n\n` +
            `*Endere√ßo:*\n` +
            `${r.endereco?.logradouro || "Desconhecido"}, ${r.endereco?.numero || "S/N"}\n` +
            `${r.endereco?.bairro || "Bairro n√£o informado"}\n` +
            `${r.endereco?.municipio || "Munic√≠pio n√£o informado"} - CEP: ${r.endereco?.cep || "Desconhecido"}\n\n` +
            `*Documentos:*\n` +
            `‚Ä¢ RG: ${r.documentos?.rgNumero || "N√£o encontrado"}\n` +
            `‚Ä¢ √ìrg√£o Emissor: ${r.documentos?.rgOrgaoEmisor || "N√£o encontrado"}\n` +
            `‚Ä¢ UF: ${r.documentos?.rgUf || "N√£o encontrado"}\n` +
            `‚Ä¢ Emiss√£o: ${r.documentos?.rgDataEmissao || "N√£o encontrado"}\n` +
            `‚Ä¢ CNS: ${r.documentos?.cns || "N√£o encontrado"}\n\n` +
            `*Contatos:*\n` +
            `‚Ä¢ Telefone: ${r.contatos?.telefone || "N√£o encontrado"}\n` +
            `‚Ä¢ Telefone 2: ${r.contatos?.telefoneSecundario || "N√£o encontrado"}\n\n` +
            `‚Ä¢ Usu√°rio: ${pushname}\n` +
            `‚Ä¢ Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro na consulta cpf6:", err);
        reply("Erro ao consultar o CPF na base cpf6. Tente novamente mais tarde.");
    }
}
break;
case "placa": {
    if (!q) {
        return reply("Voc√™ precisa fornecer uma placa para consulta.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/placa2?q=${encodeURIComponent(q)}`);

        if (Array.isArray(data) && data[0]?.includes("PLACA INV√ÅLIDA")) {
            return reply(data[0]);
        }

        const extrair = (chave) => {
            const item = data.find(x => x.startsWith(chave));
            return item ? item.replace(chave, "").trim() : "N√£o informado";
        };

        const placa = extrair("‚Ä¢ PLACA:");
        const situacao = extrair("‚Ä¢ SITUA√á√ÉO:");
        const marca = extrair("‚Ä¢ MARCA:");
        const modelo = extrair("‚Ä¢ MODELO:");
        const cor = extrair("‚Ä¢ COR:");
        const anoFab = extrair("‚Ä¢ ANO - FABRICA√á√ÉO:");
        const anoMod = extrair("‚Ä¢ ANO - MODELO:");
        const municipio = extrair("‚Ä¢ MUNICIPIO:");
        const estado = extrair("‚Ä¢ ESTADO:");
        const chassi = extrair("‚Ä¢ CHASSI:");
        const renavam = extrair("‚Ä¢ RENAVAM:");
        const segmento = extrair("‚Ä¢ SEGMENTO:");
        const subSegmento = extrair("‚Ä¢ SUB SEGMENTO:");
        const grupo = extrair("‚Ä¢ GRUPO:");
        const combustivel = extrair("‚Ä¢ COMBUSTIVEL:");
        const tipoVeiculo = extrair("‚Ä¢ TIPO DE VEICULO:");
        const especie = extrair("‚Ä¢ ESPECIE:");
        const passageiros = extrair("‚Ä¢ QUANTIDADE DE PASSAGEIROS:");
        const crv = extrair("‚Ä¢ EMISS√ÉO ULTIMO CRV:");
        const atualizado = extrair("‚Ä¢ ULTIMA ATUALIZA√á√ÉO:");

        let resposta =
            `üîç *CONSULTA DE PLACA* üîç\n` +
            `‚Ä¢ Placa: ${placa}\n` +
            `‚Ä¢ Situa√ß√£o: ${situacao}\n` +
            `‚Ä¢ Marca/Modelo: ${marca} / ${modelo}\n` +
            `‚Ä¢ Cor: ${cor}\n` +
            `‚Ä¢ Ano: ${anoFab} / ${anoMod}\n` +
            `‚Ä¢ Munic√≠pio/UF: ${municipio} - ${estado}\n` +
            `‚Ä¢ Chassi: ${chassi}\n` +
            `‚Ä¢ Renavam: ${renavam}\n\n` +
            `‚Ä¢ Segmento: ${segmento}\n` +
            `‚Ä¢ Sub Segmento: ${subSegmento}\n` +
            `‚Ä¢ Grupo: ${grupo}\n` +
            `‚Ä¢ Combust√≠vel: ${combustivel}\n` +
            `‚Ä¢ Tipo: ${tipoVeiculo}\n` +
            `‚Ä¢ Esp√©cie: ${especie}\n` +
            `‚Ä¢ Passageiros: ${passageiros}\n` +
            `‚Ä¢ √ölt. CRV: ${crv}\n` +
            `‚Ä¢ Atualiza√ß√£o: ${atualizado}\n\n` +
            `‚Ä¢ Usu√°rio: ${pushname}\n` +
            `‚Ä¢ Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro na consulta placa2:", err);
        reply("Erro ao consultar a placa. Tente novamente mais tarde.");
    }
}
break;
case "placa3": {
    if (!q) {
        return reply("Voc√™ precisa fornecer uma placa para consulta.");
    }

    try {
        const placa = q.toUpperCase().replace(/\s/g, '');
        if (placa.length !== 7) {
            return reply("Por favor, forne√ßa uma placa v√°lida com 7 caracteres.");
        }

        const { data } = await axios.get(`https://mdzapis.com/api/placanew?placa=${placa}`);
        
        if (!data || !data.status || !data.resultado) {
            return reply("N√£o consegui obter os resultados, tente novamente mais tarde.");
        }

        const resultado = data.resultado;
        const situacao = resultado.situacao || "Desconhecida";
        const placaVeiculo = resultado.placa || "Desconhecida";
        const chassi = resultado.chassi || "Desconhecido";
        const renavam = resultado.renavam || "Desconhecido";
        const numMotor = resultado.numMotor || "Desconhecido";
        const combustivel = resultado.combustivel || "Desconhecido";
        const marcaModelo = resultado.marcaModelo || "Desconhecido";
        const cor = resultado.cor || "Desconhecida";
        const anoFabricacao = resultado.anoFabricacao || "Desconhecido";
        const anoModelo = resultado.anoModelo || "Desconhecido";
        const restricoes = resultado.restricoes?.join(", ") || "Sem restri√ß√µes";
        const multas = resultado.multas?.comentario || "Sem informa√ß√µes sobre multas";
        const proprietario = resultado.proprietario?.nome || "Desconhecido";
        const endereco = resultado.enderecos?.logradouro || "Desconhecido";
        const cidade = resultado.enderecos?.municipio || "Desconhecida";
        const uf = resultado.enderecos?.uf || "Desconhecido";

        const usuario = pushname || "Desconhecido";
        const bot = NomeDoBot || "Desconhecido";

        const message = `*Informa√ß√µes do ve√≠culo com placa ${placa}:*\n` +
                        `- Situa√ß√£o: ${situacao}\n` +
                        `- Placa: ${placaVeiculo}\n` +
                        `- Chassi: ${chassi}\n` +
                        `- Renavam: ${renavam}\n` +
                        `- N√∫mero do Motor: ${numMotor}\n` +
                        `- Combust√≠vel: ${combustivel}\n` +
                        `- Marca/Modelo: ${marcaModelo}\n` +
                        `- Cor: ${cor}\n` +
                        `- Ano de Fabrica√ß√£o: ${anoFabricacao}\n` +
                        `- Ano do Modelo: ${anoModelo}\n` +
                        `- Restri√ß√µes: ${restricoes}\n` +
                        `- Multas: ${multas}\n` +
                        `- Propriet√°rio: ${proprietario}\n` +
                        `- Endere√ßo: ${endereco}, ${cidade} - ${uf}\n` +
                        `- Usu√°rio: ${pushname}\n` +
                        `- Bot: ${NomeDoBot}`;

        reply(message);
    } catch (error) {
        console.error("Erro ao processar a solicita√ß√£o:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o. Por favor, tente novamente mais tarde.");
    }
}
break;
case "placa4": {
    if (!q) {
        return reply("Voc√™ precisa fornecer uma placa para consulta.");
    }

    try {
        const { data } = await axios.get(`https://api-bruxel4s.shop/api/consulta/placa?query=${encodeURIComponent(q)}`);

        const r = data.resultado;
        if (!r || !r.placa) {
            return reply("Placa n√£o encontrada ou inv√°lida.");
        }

        const d = r.detalhes || {};

        let resposta =
            `üöò *CONSULTA DE PLACA* üöò\n\n` +
            `‚Ä¢ Placa: ${r.placa || "N√£o informado"}\n` +
            `‚Ä¢ Chassi: ${r.chassi || "N√£o informado"}\n\n` +
            `*Detalhes do Ve√≠culo:*\n` +
            `‚Ä¢ Marca/Modelo: ${d.marcaModelo || "Desconhecido"}\n` +
            `‚Ä¢ Ano de Fabrica√ß√£o: ${d.anoFabricacao || "Desconhecido"}\n` +
            `‚Ä¢ Ano do Modelo: ${d.anoModelo || "Desconhecido"}\n` +
            `‚Ä¢ Tipo do Ve√≠culo: ${d.tipoVeiculo || "Desconhecido"}\n` +
            `‚Ä¢ Esp√©cie: ${d.especieVeiculo || "Desconhecido"}\n` +
            `‚Ä¢ Cor: ${d.corVeiculo || "Desconhecida"}\n` +
            `‚Ä¢ Combust√≠vel: ${d.combustivel || "Desconhecido"}\n` +
            `‚Ä¢ Capacidade de Carga: ${d.capacidadeCarga || "0"}\n` +
            `‚Ä¢ Passageiros: ${d.quantidadePassageiro || "0"}\n` +
            `‚Ä¢ Peso Bruto Total: ${d.pesoBrutoTotal || "0"}\n` +
            `‚Ä¢ Munic√≠pio: ${d.municipio || "Desconhecido"}\n` +
            `‚Ä¢ Estado (UF): ${d.ufPlaca || "Desconhecido"}\n\n` +
            `‚Ä¢ Usu√°rio: ${pushname}\n` +
            `‚Ä¢ Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro na consulta placa6:", err);
        reply("Erro ao consultar a placa. Tente novamente mais tarde.");
    }
}
break;
case "score":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer um n√∫mero de CPF para consulta.");
    }

    try {
        const cpf = q.replace(/\D/g, '');
        if (cpf.length !== 11) {
            return reply("Por favor, forne√ßa um CPF v√°lido com 11 d√≠gitos.");
        }

        const { data } = await axios.get(`https://mdzapis.com/api/score?cpf=${cpf}`);  

        if (!data || !data.status || !data.resultado) {  
            return reply("N√£o consegui obter os resultados, tente novamente mais tarde.");  
        }  

        const resultado = data.resultado;  
        const nome = resultado.nome || "Desconhecido";  
        const nascimento = resultado.nascimento || "Desconhecido";  
        const sexo = resultado.sexo || "Desconhecido";  
        const mae = resultado.mae || "Desconhecida";  
        const pai = resultado.pai || "Desconhecido";  
        const estadoCivil = resultado.estadoCivil || "Desconhecido";  
        const profissao = resultado.profissao || "Desconhecido";  
        const renda = resultado.renda || "Desconhecido";  
        const poderAquisitivo = resultado.poderAquisitivo || "Desconhecido";  
        const scoreCsb = resultado.scoreCsb || "Desconhecido";  
        const scoreCsba = resultado.scoreCsba || "Desconhecido";  
        const telefone = resultado.telefones?.[0]?.telefone || "Desconhecido";  
        const email = resultado.emails?.[0]?.email || "Desconhecido";  

        const message = `*Informa√ß√µes do CPF ${cpf}:*\n` +  
                        `- Nome: ${nome}\n` +  
                        `- Nascimento: ${nascimento}\n` +  
                        `- Sexo: ${sexo}\n` +  
                        `- M√£e: ${mae}\n` +  
                        `- Pai: ${pai}\n` +  
                        `- Estado Civil: ${estadoCivil}\n` +  
                        `- Profiss√£o: ${profissao}\n` +  
                        `- Renda: ${renda}\n` +  
                        `- Poder Aquisitivo: ${poderAquisitivo}\n` +  
                        `- Score CSB: ${scoreCsb}\n` +  
                        `- Score CSBA: ${scoreCsba}\n` +  
                        `- Telefone: ${telefone}\n` +  
                        `- Email: ${email}\n` +  
                        `- Usu√°rio: ${pushname}\n` +  
                        `- Bot: ${NomeDoBot}`;  

        reply(message);

    } catch (error) {
        console.error("Erro ao processar a solicita√ß√£o:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o. Por favor, tente novamente mais tarde.");
    }

} break;

case "cpf4": {
    if (!q) {
        return reply("Voc√™ precisa fornecer um n√∫mero de CPF para consulta.");
    }

    try {  
        const cpf = q.replace(/\D/g, '');  
        if (cpf.length !== 11) {  
            return reply("Por favor, forne√ßa um CPF v√°lido com 11 d√≠gitos.");  
        }  

        const { data } = await axios.get(`https://mdzapis.com/api/cpffree?cpf=${cpf}`);  

        if (!data || !data.status || !data.resultado) {  
            return reply("N√£o consegui obter os resultados, tente novamente mais tarde.");  
        }  

        const resultado = data.resultado;  
        const nome = resultado.nome || "Desconhecido";  
        const nascimento = resultado.nascimento || "Desconhecido";  
        const sexo = resultado.sexo || "Desconhecido";  
        const mae = resultado.mae || "Desconhecida";  
        const pai = resultado.pai || "Desconhecido";  
        const estadoCivil = resultado.estadoCivil || "Desconhecido";  
        const profissao = resultado.profissao || "Desconhecido";  
        const renda = resultado.renda || "Desconhecido";  
        const poderAquisitivo = resultado.poderAquisitivo || "Desconhecido";  
        const scoreCsb = resultado.scoreCsb || "Desconhecido";  
        const scoreCsba = resultado.scoreCsba || "Desconhecido";  
        const descricaoMosaic = resultado.descricaoMosaic || "Desconhecido";  
        const classeMosaic = resultado.classeMosaic || "Desconhecida";  
        const telefone = resultado.telefones?.[0]?.telefone || "Desconhecido";  
        const email = resultado.emails?.[0]?.email || "Desconhecido";  
        const beneficios = resultado.beneficios?.map(b => `- ${b.beneficio}: ${b.totalRecebido}`).join("\n") || "Sem informa√ß√µes";  

        const usuario = pushname || "Desconhecido";  
        const bot = NomeDoBot || "Desconhecido";  

        const message = `*Informa√ß√µes do CPF ${cpf}:*\n` +  
                        `- Nome: ${nome}\n` +  
                        `- Nascimento: ${nascimento}\n` +  
                        `- Sexo: ${sexo}\n` +  
                        `- M√£e: ${mae}\n` +  
                        `- Pai: ${pai}\n` +  
                        `- Estado Civil: ${estadoCivil}\n` +  
                        `- Profiss√£o: ${profissao}\n` +  
                        `- Renda: ${renda}\n` +  
                        `- Poder Aquisitivo: ${poderAquisitivo}\n` +  
                        `- Score CSB: ${scoreCsb}\n` +  
                        `- Score CSBA: ${scoreCsba}\n` +  
                        `- Descri√ß√£o Mosaic: ${descricaoMosaic}\n` +  
                        `- Classe Mosaic: ${classeMosaic}\n` +  
                        `- Telefone: ${telefone}\n` +  
                        `- Email: ${email}\n` +  
                        `- Benef√≠cios:\n${beneficios}\n` +  
                        `- Usu√°rio: ${pushname}\n` +  
                        `- Bot: ${NomeDoBot}`;  

        reply(message);  
    } catch (error) {  
        console.error("Erro ao processar a solicita√ß√£o:", error);  
        return reply("Ocorreu um erro ao processar a solicita√ß√£o. Por favor, tente novamente mais tarde.");  
    }

} break;
case "telefone3": {
    if (!q) {
        return reply("Voc√™ precisa fornecer um n√∫mero de telefone para consulta.");
    }

    try {
        const telefone = q.replace(/\D/g, '');
        if (telefone.length !== 11) {
            return reply("Por favor, forne√ßa um n√∫mero de telefone v√°lido.");
        }

        const { data } = await axios.get(`https://mdzapis.com/api/telsis?telefone=${telefone}`);
        
        if (!data || !data.status || !data.resultado || data.resultado.length === 0) {
            return reply("N√£o consegui obter os resultados, tente novamente mais tarde.");
        }

        const resultado = data.resultado[0];
        const nome = resultado.nome || "Desconhecido";
        const cpfCnpj = resultado.cpfCnpj || "Desconhecido";
        const endereco = resultado.endereco || {};
        const rua = endereco.logradouro || "Desconhecido";
        const numero = endereco.numero || "Desconhecido";
        const bairro = endereco.bairro || "Desconhecido";
        const cidade = endereco.cidade || "Desconhecida";
        const cep = endereco.cep || "Desconhecido";

        const dadosCompletos = resultado.dadosCompletos?.resultado || {};
        const nomePessoa = dadosCompletos.nome || "Desconhecido";
        const nascimento = dadosCompletos.data_nascimento?.data || "Desconhecida";
        const idade = dadosCompletos.data_nascimento?.idade || "Desconhecida";
        const nacionalidade = dadosCompletos.nacionalidade || "Desconhecida";
        const nomeMae = dadosCompletos.nome_mae || "Desconhecida";
        const nomePai = dadosCompletos.nome_pai || "Desconhecido";

        const message = `*Informa√ß√µes sobre o telefone ${telefone}:*\n` +
                        `- Nome: ${nome}\n` +
                        `- CPF/CNPJ: ${cpfCnpj}\n` +
                        `- Endere√ßo: ${rua}, ${numero}, ${bairro}, ${cidade} - CEP: ${cep}\n` +
                        `- Nome Completo: ${nomePessoa}\n` +
                        `- Data de Nascimento: ${nascimento} (Idade: ${idade})\n` +
                        `- Nacionalidade: ${nacionalidade}\n` +
                        `- Nome da M√£e: ${nomeMae}\n` +
                        `- Nome do Pai: ${nomePai}`;

        reply(message);
    } catch (error) {
        console.error("Erro ao processar a solicita√ß√£o:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o. Por favor, tente novamente mais tarde.");
    }
}
break;

case "parentes": {
    if (!q) return reply("Voc√™ precisa fornecer um CPF para consulta.");

    const cpf = q.replace(/\D/g, '');
    if (cpf.length !== 11) return reply("Por favor, forne√ßa um CPF v√°lido.");

    try {
        const { data } = await axios.get(`https://mdzapis.com/api/parentes?cpf=${cpf}`);
        const lista = data?.resultado?.parentes;

        if (!lista || lista.total === 0) return reply("N√£o consegui obter os resultados, tente novamente mais tarde.");

        let message = `*Parentes do CPF ${cpf}:*\n\n`;
        lista.itens.forEach((p, i) => {
            message += `*${i + 1}.*\n- Nome: ${p.nome}\n- CPF: ${p.cpf}\n- V√≠nculo: ${p.vinculo}\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar parentes:", error);
        reply("Ocorreu um erro ao processar a solicita√ß√£o. Por favor, tente novamente mais tarde.");
    }
} break;

//case de ip

case "telefone2": {
    if (!q) return reply("Voc√™ precisa fornecer um n√∫mero de telefone para consulta.");

    try {
        const telefone = q.replace(/\D/g, '');
        if (telefone.length < 10 || telefone.length > 11)
            return reply("Por favor, forne√ßa um n√∫mero de telefone v√°lido com 10 ou 11 d√≠gitos.");

        const res = await fetchJson(`https://world-ecletix.onrender.com/api/consultas?type=telefone&query=${telefone}`);
        
        if (!res || !res.status || !res.resultado)
            return reply("Nenhum dado encontrado para o telefone fornecido.");

        const { telefone: telefoneInfo, nome, operadora, "cpf/cnpj": cpfInfo } = res.resultado;

        const message = `*Informa√ß√µes do Telefone ${telefoneInfo}:*\n` +
                        `- Nome: ${nome}\n` +
                        `- CPF/CNPJ: ${cpfInfo}\n` +
                        `- Operadora: ${operadora || "Desconhecida"}\n` +
                        `- Usu√°rio: ${pushname || "Desconhecido"}\n` +
                        `- Bot: ${NomeDoBot || "Desconhecido"}`;

        reply(message);
    } catch (error) {
        console.error("Erro ao processar a solicita√ß√£o:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o. Por favor, tente novamente mais tarde.");
    }
}
break;
case "nome": {
    if (!q) return reply("Voc√™ precisa fornecer um nome para consulta.");

    try {
        const nome = q.trim();
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/consultas?type=nome&query=${encodeURIComponent(nome)}`);
        
        if (!res || !res.status || !res.resultado)
            return reply("Nenhum dado encontrado para o nome fornecido.");

        const { cpf, nome: nomeCompleto, sexo, nascimento } = res.resultado;

        const message = `*Informa√ß√µes sobre o nome ${nomeCompleto}:*\n` +
                        `- CPF: ${cpf || "N√£o dispon√≠vel"}\n` +
                        `- Data de Nascimento: ${nascimento || "N√£o dispon√≠vel"}\n` +
                        `- Sexo: ${sexo || "N√£o especificado"}\n` +
                        `- Usu√°rio: ${pushname || "Desconhecido"}\n` +
                        `- Bot: ${NomeDoBot || "Desconhecido"}`;

        reply(message);
    } catch (error) {
        console.error("Erro ao processar a solicita√ß√£o:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o. Por favor, tente novamente mais tarde.");
    }
}
break;
case 'infosite':
case "whois": {
    if (!q) {
        return reply("Voc√™ precisa fornecer um dom√≠nio para consultar.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/whois/${q}`);

        if (!data || !data.WhoisRecord) {
            return reply("‚ö†Ô∏è Dom√≠nio n√£o encontrado ou inv√°lido.");
        }

        const registro = data.WhoisRecord;

        let resposta =
            `üîç *CONSULTA WHOIS* üîç\n` +
            `‚Ä¢ Dom√≠nio: ${registro.domainName || "N√£o informado"}\n` +
            `‚Ä¢ Status: ${registro.status || "N√£o informado"}\n` +
            `‚Ä¢ Servidores DNS: ${registro.nameServers?.hostNames?.join(", ") || "N√£o informado"}\n` +
            `‚Ä¢ Criado em: ${registro.createdDate || "N√£o informado"}\n` +
            `‚Ä¢ Atualizado em: ${registro.updatedDate || "N√£o informado"}\n` +
            `‚Ä¢ Expira em: ${registro.expiresDate || "N√£o informado"}\n` +
            `‚Ä¢ Registrante: ${registro.registrant?.name || "N√£o informado"}\n` +
            `‚Ä¢ Email: ${registro.contactEmail || "N√£o informado"}\n\n` +
            `‚Ä¢ Usu√°rio: ${pushname}\n` +
            `‚Ä¢ Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro ao consultar dom√≠nio:", err);
        reply("Erro ao consultar o dom√≠nio. Tente novamente mais tarde.");
    }
}
break;
case "ip": {
    if (!q) return reply("Voc√™ precisa fornecer um IP para consulta.");

    try {
        const ip = q.trim();
        const res = await fetchJson(`https://ipwhois.app/json/${ip}`);

        if (!res || !res.success)
            return reply("Nenhum dado encontrado para o IP fornecido.");

        const {
            ip: ipInfo, continent, country, country_code, region, city, latitude, longitude,
            asn, org, isp, timezone, currency, currency_code, currency_symbol
        } = res;

        const message = `*Informa√ß√µes do IP ${ipInfo}:*\n` +
                        `- Continente: ${continent}\n` +
                        `- Pa√≠s: ${country} (${country_code})\n` +
                        `- Regi√£o: ${region}\n` +
                        `- Cidade: ${city}\n` +
                        `- Latitude: ${latitude}\n` +
                        `- Longitude: ${longitude}\n` +
                        `- ASN: ${asn}\n` +
                        `- Organiza√ß√£o: ${org}\n` +
                        `- ISP: ${isp}\n` +
                        `- Fuso Hor√°rio: ${timezone}\n` +
                        `- Moeda: ${currency} (${currency_code})\n` +
                        `- S√≠mbolo da Moeda: ${currency_symbol}\n` +
                        `- Usu√°rio: ${pushname}\n` +
                        `- Bot: ${NomeDoBot}`;

        reply(message);
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;

case "cnpj":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer um CNPJ para consulta.");
    }

    try {
        const cnpj = q.replace(/\D/g, '');
        if (cnpj.length !== 14) {
            return reply("Por favor, forne√ßa um CNPJ v√°lido com 14 d√≠gitos.");
        }

        const res = await fetchJson(`https://brasilapi.com.br/api/cnpj/v1/${cnpj}`);
        //by luan

        if (!res || !res.cnpj) {
            return reply("Nenhum dado encontrado para o CNPJ fornecido.");
        }

        const {
            razao_social, nome_fantasia, cnpj: cnpjResult, logradouro, numero, bairro,
            municipio, uf, cep, ddd_telefone_1, email, capital_social,
            natureza_juridica, descricao_situacao_cadastral, qsa
        } = res;

        let sociosInfo = qsa.map(socio =>
            `- Nome do s√≥cio: ${socio.nome_socio}\n  Qualifica√ß√£o: ${socio.qualificacao_socio}`
        ).join('\n');

        const message = `*Informa√ß√µes do CNPJ ${cnpjResult}:*\n` +
                        `- Raz√£o Social: ${razao_social}\n` +
                        `- Nome Fantasia: ${nome_fantasia || "N√£o informado"}\n` +
                        `- Logradouro: ${logradouro}, ${numero}\n` +
                        `- Bairro: ${bairro}\n` +
                        `- Cidade: ${municipio} - ${uf}\n` +
                        `- CEP: ${cep}\n` +
                        `- Telefone: ${ddd_telefone_1}\n` +
                        `- Email: ${email || "N√£o informado"}\n` +
                        `- Capital Social: R$ ${capital_social.toFixed(2)}\n` +
                        `- Natureza Jur√≠dica: ${natureza_juridica}\n` +
                        `- Situa√ß√£o Cadastral: ${descricao_situacao_cadastral}\n\n` +
                        `*Quadro Societ√°rio:*\n${sociosInfo}\n` +
                        `- Usu√°rio: ${pushname}\n` +
                        `- Bot: ${NomeDoBot}`;

        reply(message);
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;

case "cpf5":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer um CPF para consulta.");
    }

    try {
        // Remove caracteres n√£o num√©ricos do CPF fornecido
        const cpf = q.replace(/\D/g, '');
        if (cpf.length !== 11) {
            return reply("Por favor, forne√ßa um CPF v√°lido com 11 d√≠gitos.");
        }

        // Faz a requisi√ß√£o para a API de consulta por CPF
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/consultas?type=cpf&query=${cpf}`);
        //by luan

        // Verifica se a resposta cont√©m dados esperados
        if (!res || !res.status) {
            return reply("Nenhum dado encontrado para o CPF fornecido.");
        }

        // Extrai as informa√ß√µes da resposta
        const { "üßë‚Äçüíº nome": nome, "üöª sexo": sexo, "üéÇ nascimento": nascimento, "üë©‚Äçüëß m√£e": mae, "üÜî cpf": cpfFormatado } = res.resultado;

        // Prepara a mensagem com as informa√ß√µes do CPF
        const message = `*Informa√ß√µes do CPF ${cpfFormatado}:*\n` +
                        `- Nome: ${nome}\n` +
                        `- Sexo: ${sexo}\n` +
                        `- Nascimento: ${nascimento}\n` +
                        `- M√£e: ${mae}\n` +
                        `- CPF: ${cpfFormatado}`;

        reply(message);
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "ddd":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer um DDD para consulta.");
    }

    try {
        const ddd = q.replace(/\D/g, '');
        if (ddd.length !== 2) {
            return reply("Por favor, forne√ßa um DDD v√°lido com 2 d√≠gitos.");
        }

        const res = await fetchJson(`https://brasilapi.com.br/api/ddd/v1/${ddd}`);
        //by luan

        if (!res || !res.state) {
            return reply("Nenhum dado encontrado para o DDD fornecido.");
        }

        const { state, cities } = res;

        const message = `*Informa√ß√µes do DDD ${ddd}:*\n` +
                        `- Estado: ${state}\n` +
                        `- Cidades:\n${cities.join(', ')}`;

        reply(message);
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;

case "cep":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer um CEP para consulta.");
    }

    try {
        // Remove caracteres n√£o num√©ricos do CEP fornecido
        const cepInput = q.replace(/\D/g, '');
        if (cepInput.length !== 8) {
            return reply("Por favor, forne√ßa um CEP v√°lido com 8 d√≠gitos.");
        }

        const res = await fetchJson(`https://brasilapi.com.br/api/cep/v2/${cepInput}`);
        //by luan

        // Verifica se a resposta cont√©m dados esperados
        if (!res || !res.cep) {
            return reply("Nenhum dado encontrado para o CEP fornecido.");
        }

        // Extrai as informa√ß√µes da resposta
        const { cep: cepResult, street, neighborhood, city, state } = res;

        // Prepara a mensagem com as informa√ß√µes do CEP
        const message = `*Informa√ß√µes do CEP ${cepResult}:*\n` +
                        `- Rua: ${street}\n` +
                        `- Bairro: ${neighborhood}\n` +
                        `- Cidade: ${city}\n` +
                        `- Estado: ${state}`;

        reply(message);
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
		
case 'cep2': {
    if (!q) return reply('Por favor, forne√ßa um CEP para consulta. Exemplo: !cep 01001000');

    const cep = q.trim();

    try {
        const apiUrl = `https://viacep.com.br/ws/${cep}/json/`;
        const response = await fetch(apiUrl);
        const data = await response.json();

        if (data.erro) {
            return reply('CEP n√£o encontrado. Verifique o n√∫mero e tente novamente.');
        }

        const result = `
            *üîçConsulta de CEPüîé*
            
            CEP: ${data.cep}
            Logradouro: ${data.logradouro}
            Complemento: ${data.complemento}
            Bairro: ${data.bairro}
            Cidade: ${data.localidade}
            Estado: ${data.uf}
        `;
        
        return reply(result);
    } catch (error) {
        console.log(error);
        return reply('Ocorreu um erro ao consultar o CEP. Tente novamente mais tarde.');
    }
}
break; 
case "placa2":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer uma placa para consulta.");
    }

    try {
        const placa = q.toUpperCase().replace(/\s+/g, ''); // Normaliza o formato da placa
        if (placa.length !== 7) {
            return reply("Por favor, forne√ßa uma placa v√°lida com 7 caracteres.");
        }

        const res = await fetchJson(`https://world-ecletix.onrender.com/api/consultas?type=placa&query=${placa}`);
        //by luan

        if (!res || !res.status) {
            return reply("Nenhum dado encontrado para a placa fornecida.");
        }

        const {
            "- placa": placaInfo,
            "- marca": marcaInfo,
            "- modelo": modeloInfo,
            "- ano": anoInfo,
            "- cor": corInfo,
            "- chassi": chassiInfo,
            "- munic√≠pio": municipioInfo,
            "- uf": ufInfo,
            "- combust√≠vel": combustivelInfo,
            "- cilindradas": cilindradasInfo,
            "- segmento": segmentoInfo
        } = res.resultado;

        // Monta a mensagem excluindo dados irrelevantes
        const message = `*Informa√ß√µes do Ve√≠culo - Placa ${placaInfo}:*\n` +
                        `- Marca: ${marcaInfo}\n` +
                        `- Modelo: ${modeloInfo}\n` +
                        `- Ano: ${anoInfo}\n` +
                        `- Cor: ${corInfo}\n` +
                        `- Chassi: ${chassiInfo}\n` +
                        `- Munic√≠pio: ${municipioInfo}\n` +
                        `- UF: ${ufInfo}\n` +
                        `- Combust√≠vel: ${combustivelInfo}\n` +
                        `- Cilindradas: ${cilindradasInfo}\n` +
                        `- Segmento: ${segmentoInfo}\n\n` +
                        `- Usu√°rio: ${pushname}\n` +
                        `- Bot: ${NomeDoBot}`;

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a placa:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "operadora3": {
    if (!q) {
        return reply("Voc√™ precisa fornecer um n√∫mero para consultar.");
    }

    try {
        const { data } = await axios.get(`https://blacksystemofc.com.br/api/operadora?numero=${encodeURIComponent(q)}&apikey=black`);
        
        if (!data?.resultado) {
            return reply("N√£o foi poss√≠vel encontrar informa√ß√µes sobre o n√∫mero.");
        }

        const { telefone, operadora, dispositivo, estado } = data.resultado;

        let resposta =
            `üì± *CONSULTA DE OPERADORA* üì±\n` +
            `‚Ä¢ Telefone: ${telefone}\n` +
            `‚Ä¢ Operadora: ${operadora}\n` +
            `‚Ä¢ Tipo: ${dispositivo}\n` +
            `‚Ä¢ Estado: ${estado}\n\n` +
            `‚Ä¢ Usu√°rio: ${pushname}\n` +
            `‚Ä¢ Bot: ${NomeDoBot}`;

        reply(resposta);
    } catch (err) {
        console.error("Erro ao consultar operadora3:", err);
        reply("Erro ao consultar a operadora. Tente novamente mais tarde.");
    }
}
break;

case "operadora": {
    if (!q) {
        return reply("Voc√™ precisa fornecer um n√∫mero para consultar.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/operadora?numero=${encodeURIComponent(q)}`);
        
        if (!data?.mensagem) {
            return reply("N√£o foi poss√≠vel identificar a operadora.");
        }

        let resposta =
            `üì≤ *CONSULTA DE OPERADORA* üì≤\n` +
            `‚Ä¢ Resultado: ${data.mensagem}\n\n` +
            `‚Ä¢ Usu√°rio: ${pushname}\n` +
            `‚Ä¢ Bot: ${NomeDoBot}`;

        reply(resposta);
    } catch (err) {
        console.error("Erro ao consultar operadora:", err);
        reply("Erro ao consultar a operadora. Tente novamente mais tarde.");
    }
}
break;
case "operadora2":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer um n√∫mero de telefone para consulta.");
    }

    try {
        const telefone = q.replace(/\D/g, ''); // Remove caracteres n√£o num√©ricos
        if (telefone.length < 10 || telefone.length > 11) {
            return reply("Por favor, forne√ßa um n√∫mero de telefone v√°lido com 10 ou 11 d√≠gitos.");
        }

        const res = await fetchJson(`https://api.zero-two.online/api/operadora?numero=55${telefone}&apikey=alucard`);
        //by luan

        if (!res || res.status !== 200) {
            return reply("Nenhum dado encontrado para o telefone fornecido.");
        }

        const { telefone: telefoneInfo, operadora: operadoraInfo, dispositivo: dispositivoInfo, estado: estadoInfo } = res.resultado;

        const message = `*Informa√ß√µes do Telefone ${telefoneInfo}:*\n` +
                        `- Operadora: ${operadoraInfo}\n` +
                        `- Dispositivo: ${dispositivoInfo}\n` +
                        `- Estado: ${estadoInfo}\n\n` +
                        `- Usu√°rio: ${pushname}\n` +
                        `- Bot: ${NomeDoBot}`;

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a operadora:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
// fim das consultas 
//===========(ADMS-FUN√á√ïES-AKI)=========\\

case 'raizq': case 'raizquadrada':
if(!Number(q.replace("‚àö", ""))) return reply("Retorne ap√≥s o comando o n√∫mero que voc√™ quer encontrar a raiz quadrada")
radical = Number(q.replace("‚àö", ""))
if(!raiz(radical)) {
  divi = divisores(radical)
  if(divi.length <= 0) return reply("Nenhum divisor encontrado...")
  primeiro = []
  for(a of divi) {
    if(raiz(a)) primeiro.push({search: a, resultado: findRaiz(a)})
  }
  if(primeiro.length <= 0) return reply("Nenhuma raiz encontrada...")
  result_x = primeiro[primeiro.length - 1].resultado
  resto = radical / primeiro[primeiro.length - 1].search
  dividir = divisores(resto)
  if(divisores.length > 0) {
    segundo = []
    for(b of dividir) {
      if(raiz(b)) segundo.push({search: b, resultado: findRaiz(b)})
    }
    if(segundo.length > 0) {
      result_x *= segundo[segundo.length - 1].resultado
      result_x += `‚àö` + (resto / segundo[segundo.length - 1].search)
    } else result_x += `‚àö` + resto
  } else result_x += `‚àö` + resto
} else result_x = findRaiz(radical)
reply(`üßÆ _Segundo meus c√°lculos, a ‚àö${q.replace("‚àö", "")} √© -> *"${result_x}"*_ „ÉÖ`)
break

case 'bhaskara':
if(!q) return reply(`Retorne a equa√ß√£o quadr√°tica ap√≥s o comando (use a vari√°vel "x", exemplo: ${prefix+command} 2x¬≤+4x+2 = 0)`)
a = Number(q.replace("x¬≤", "x2").split("x2")[0])
b = Number(q.replace("x¬≤", "x2").split("x2")[1].split("x")[0])
c = Number(q.split("x")[2].split("=")[0])
txt = `‚àÜ = b¬≤ - 4 ‚Ä¢ a ‚Ä¢ c
‚àÜ = ${b}¬≤ - 4 ‚Ä¢ ${a} ‚Ä¢ ${c}
‚àÜ = ${b*b} ${Number(-4*a*c) >= 0 ? `+${-4*a*c}` : -4*a*c}
‚àÜ = ${Number(b*b) + Number(-4*a*c)}
`
delta = Number(b*b) + Number(-4*a*c)
if(delta < 0) return reply("A equa√ß√£o n√£o possui raiz")
raiz = []
for(i = 0; i < Number(delta/2); i++) {
if(Number(i*i) === delta) {
raiz.push(i)
}
}
if(delta != 0 && raiz.length <= 0) return reply(`‚àö${delta} n√£o encontrada`)
txt += `
x = -b ¬±‚àö‚àÜ
         2 ‚Ä¢ a
x = -(${b}) ¬±‚àö${delta}
         2 ‚Ä¢ ${a}
`
if(delta > 0) {
txt += `
x = ${b*Number(-1)} ¬±${raiz[0]}
         ${a*2}
x' = ${b*Number(-1)} + ${raiz[0]}
         ${a*2}
x' = ${Number(b*Number(-1)) + Number(raiz[0])}
         ${a*2}
x' = ${Number(Number(b*Number(-1)) + Number(raiz[0])) / Number(a*2)}

x'' = ${b*Number(-1)} - ${raiz[0]}
         ${a*2}
x'' = ${Number(b*Number(-1)) - Number(raiz[0])}
         ${a*2}
x'' = ${Number(Number(b*Number(-1)) - Number(raiz[0])) / Number(a*2)}

$ = {${Number(Number(b*Number(-1)) + Number(raiz[0])) / Number(a*2)}, ${Number(Number(b*Number(-1)) - Number(raiz[0])) / Number(a*2)}}`
} else {
txt += `x = ${b*Number(-1)}
       ${a*2}
x = ${Number(b*Number(-1)) / Number(a*2)}
`
}
reply(txt)
break

case 'calculadora':
case 'calcular':  
case 'calc':
case 'math':
if(!q) return reply(`KD a conta matem√°tica p√° eu fazer ?`)
rsp = q.replace("x", "*").replace('"', ":").replace(new RegExp("[()abcdefghijklmnopqrstwuvxyz]", "gi"), "").replace("√∑", "/")
return reply(JSON.stringify(eval(rsp, null,'\t')))
break 

case 'nomegp':
setTimeout(() => {reagir(from, react2)}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!q) return reply(`Escreva o novo nome do grupo`)
blat = args.join(" ")
blackmd.groupUpdateSubject(from, `${blat}`)
blackmd.sendMessage(from, {text: `üôáüèª‚Äç‚ôÇÔ∏è *Ok alteza, o nome do grupo foi alterado para:* ${q}`}, {quoted: seloctt})
break

case 'chatblack':
reagir(from, react2)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
blackmd.groupUpdateSubject(from, `‡ºí …ì‚ÑìŒ±‡´Æ“° …ìœÉ∆≠ ‡´Æ…¶Œ±∆≠ ‡ºí`)
blackmd.sendMessage(from, {text: `*_Nome do chat atualizado ‚úÖ_*`}, {quoted: seloctt})
break

case 'descgp':
case 'descri√ß√£ogp':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.adm)
if(!q) return reply(`Escreva a nova bio do grupo`)
blabla = args.join(" ")
blackmd.groupUpdateDescription(from, `${blabla}`)
blackmd.sendMessage(from, {text: 'Sucesso, alterou a descri√ß√£o do grupo'}, {quoted: seloctt})
break

case 'setfotogp':
case 'fotogp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isQuotedImage) return reply(`Use: ${prefix + command} <Marque uma foto>`)
ftgp = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(ftgp.mimetype))
buffimg = await getFileBuffer(ftgp, 'image')
fs.writeFileSync(rane, buffimg)
medipp = rane 
blackmd.updateProfilePicture(from, {url: medipp})
reply(`Foto do grupo alterada com sucesso`) 
break

case 'linkgp':
case 'linkgrupo':
reagir(from, "‚úÖ")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
try {
var matheuzinho = await blackmd.profilePictureUrl(from, 'image')
} catch {
var matheuzinho = `https://telegra.ph/file/6ca032835ed7a16748b6f.jpg`
}
linkgc = await blackmd.groupInviteCode(from)
blackmd.sendMessage(from, {text: '*_Aqui est√° o link do grupo‚ßΩ_*\n\nhttps://chat.whatsapp.com/'+linkgc, contextInfo: {
  externalAdReply: {
    title: groupName,
    body: ``,
    thumbnail: await getBuffer(matheuzinho),
    mediaType: 1,
    showAdAttribution: true,
    sourceUrl: 'https://chat.whatsapp.com/'+linkgc
  }
}}, {quoted: seloctt})
break

case 'novolink':
case 'nlink':
case 'redefinir':
setTimeout(() => {reagir(from, "üßµ")}, 300)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isGroup) return reply(enviar.msg.grupo)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
try {
await blackmd.groupRevokeInvite(from)
await sleep(1000)
link = await blackmd.groupInviteCode(from)
sendButton(from, {text: `[‚ùó] link redefinido com sucesso üí¢`, footer: NomeDoBot}, blackmd, sender, [{type: `copy_text`, text: `ü•è ùôáùôÑùôâùôÜ ùòºùôåùôêùôÑ üé≥`, url: `https://chat.whatsapp.com/`+link}], seloctt)
} catch(e) { console.log(e)
reply("Erro ao tentar redefinir o link") }
break

case 'recrutar': case 'convidar':
setTimeout(() => {reagir(from, "ü´°")}, 300)
if(!isGroupAdmins || !isVip) return reply("[ ‚ùó ] *precisa ser ADM e VIP* ‚ùå")
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!marc_tds) return reply(`Marque um usu√°rio com o comando ${prefix+command}, a mensagem, o @ ou o n√∫mero.`)
try {
getlink = `https://chat.whatsapp.com/` + (await blackmd.groupInviteCode(from))
} catch(e) {console.log(e)
return reply(`N√£o foi poss√≠vel pegar o link do grupo...`)}
try { ftgpcmd = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(from, 'image'))}`)).data
} catch { ftgpcmd = semfoto }
if(command == `convidar` && botoes) {
try { ftusu = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(marc_tds.split('@')[0]+`@c.us`, 'image'))}`)).data
} catch(e) { ftusu = semfoto }
img = `https://blacksystemofc.com.br/api/canvas/jxr/welcome?nome=${getname(marc_tds)}&guilda=${groupName}&perfil=${ftgpcmd}&membro=${groupMembers.length + 1}&avatar=${ftusu}&fundo=`+dataGp[0].wellcome[0].fundobemvindo
} else { img = ftgpcmd }
txt = `${tempo} @${marc_tds.split(`@`)[0]}, o ${isGroupAdmins ? `ADM` : `membro VIP`} @${sender.split(`@`)[0]} te convidou para entrar no grupo ${groupName}... Clique no link acima/abaixo caso queira participar ü•∞`
enviado = `${command == `recrutar` ? `Recrutamento` : `Convite`} para se juntar ao grupo ${groupName} enviado no PV do @${marc_tds.split("@")[0]} com sucesso ‚úî`
if(!botoes) { sendUrlText(marc_tds, txt, groupName, ``, img, getlink)
await sleep(1000)
return mention(enviado) }
try { linkgp = (await axios.get(`https://tinyurl.com/api-create.php?url=${getlink}`)).data
} catch(e) {console.log(e)
return reply(`N√£o foi poss√≠vel converter o link do grupo...`)}
sendButton(marc_tds, {image: {url: img}, caption: txt, footer: NomeDoBot, mentions: [marc_tds, sender]}, blackmd, sender, [{type: `copy_url`, text: `CLIQUE AQUI ü•è`, url: linkgp}])
await sleep(1000)
mention(enviado)
break

case 'listatm':
if(!isOwner) return reply(enviar.msg.dono)
rgp = JSON.parse(fs.readFileSync("./basedefuncionamento/TMGP.json"))
if(rgp.length == 0) return reply(`N√£o cont√©m nenhum registro de transmiss√£o, utilize ${prefix}rgtm no grupo que deseja que ele receba as transmiss√µes do bot..`)
bl = `‚úßÕ°Õú“âùôÇùôçùôêùôãùôäùôé-ùôçùôÄùôÇùôÑùôéùôèùôçùòºùòøùôäùôé
________________________________________\n\n`;
for ( i = 0; i < rgp.length; i++) {
bl += `¬ª${i+1}¬´
‡≥à·çùÕ°ÕúùôÑùòø: ${rgp[i].id}
‡≥à·çùÕ°ÕúùôâùôäùôàùôÄ: ${rgp[i].infonome}
________________________________________\n\n`
}
bl += `*By:* ${NomeDoBot}`
reply(bl)
break

case 'rgtm':
if(!isOwner) return reply(enviar.msg.dono)
rgp = JSON.parse(fs.readFileSync("./basedefuncionamento/TMGP.json"))
if(JSON.stringify(rgp).includes(from)) return reply("Mas eu j√° registrei esse grupo ;-;") 
rgp.push({id: from, infonome: `${isGroup ? groupName: pushname}`})
fs.writeFileSync("./basedefuncionamento/TMGP.json", JSON.stringify(rgp))
reply("*Grupo registrado com sucesso meu mestre* üôáüèª‚Äç‚ôÇÔ∏è")
break

case 'tirardatm':
case 'deltm':
if(!isOwner) return reply(enviar.msg.dono)
rgp = JSON.parse(fs.readFileSync("./basedefuncionamento/TMGP.json"))
if(q.trim().length > 4) {
var ustm = rgp.map(i => i.id).indexOf(q.trim())
} else {
var ustm = rgp.map(i => i.id).indexOf(from)
}
if(!JSON.stringify(rgp).includes(ustm)) return reply("N√£o tem como eu tirar da lista um grupo que n√£o est√° na lista ;-;")
rgp.splice(ustm, 1)
fs.writeFileSync("./basedefuncionamento/TMGP.json", JSON.stringify(rgp))
reply("*Ok mestre... Este grupo n√£o ser√° mais notificado em transmiss√µes futuras* ü´°")
break

case 'fazertm':
case 'tm':
if(!isOwner) return reply(enviar.msg.dono)
var rgp = JSON.parse(fs.readFileSync("./basedefuncionamento/TMGP.json"))
if(rgp.length == 0) return reply("N√£o cont√©m nenhum grupo registrado para realizar transmiss√£o") 
await sleep(1000);
var DFC = "";
var rsm = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var pink = isQuotedImage ? rsm?.imageMessage: info.message?.imageMessage
var blue = isQuotedVideo ? rsm?.videoMessage: info.message?.videoMessage
var red = isQuotedMsg ? rsm?.textMessage: info.message?.textMessage
var purple = isQuotedDocument ? rsm?.documentMessage: info.message?.documentMessage
var yellow = isQuotedDocW ? rsm?.documentWithCaptionMessage?.message?.documentMessage: info.message?.documentWithCaptionMessage?.message?.documentMessage
var aud_d = isQuotedAudio ? rsm.audioMessage : ""
var figu_d = isQuotedSticker ? rsm.stickerMessage : ""
var red = isQuotedMsg && !aud_d &&!figu_d && !pink && !blue&& !purple && !yellow? "‚ö†Ô∏è *TRANSMISS√ÉO DO BLACK* ‚ö†Ô∏è\n\n"+rsm.conversation: info.message?.conversation
var green = isQuotedMsg2 && !aud_d &&!figu_d && !red && !pink && !blue && !purple && !yellow ? "‚ö†Ô∏è *TRANSMISS√ÉO DO BLACK* ‚ö†Ô∏è\n\n"+rsm.extendedTextMessage?.text : info?.message?.extendedTextMessage?.text
/*var MRC_TD = groupMembers.map(i => i.id)*/
if(pink) {
var DFC = pink
pink.caption = q.length > 1 ? "‚ö†Ô∏è *TRANSMISS√ÉO DO BLACK* ‚ö†Ô∏è\n\n"+q : pink.caption.replace(new RegExp(prefix+command, "gi"), `‚ö†Ô∏è *TRANSMISS√ÉO DO BLACK* ‚ö†Ô∏è\n\n`)
pink.image = {url: pink.url}
} else if(blue) {
var DFC = blue  
blue.caption = q.length > 1 ? "‚ö†Ô∏è *TRANSMISS√ÉO DO BLACK* ‚ö†Ô∏è\n\n"+q : blue.caption.replace(new RegExp(prefix+command, "gi"), `‚ö†Ô∏è *TRANSMISS√ÉO DO BLACK* ‚ö†Ô∏è\n\n`)
blue.video = {url: blue.url}
} else if(red) {
black = {}
black.text = red.replace(new RegExp(prefix+command, "gi"), `‚ö†Ô∏è *TRANSMISS√ÉO DO BLACK* ‚ö†Ô∏è\n\n`)
/*black.mentions = MRC_TD*/
var DFC = black
} else if(!aud_d && !figu_d && green) {
brown = {}
brown.text = green.replace(new RegExp(prefix+command, "gi"), `‚ö†Ô∏è *TRANSMISS√ÉO DO BLACK* ‚ö†Ô∏è\n\n`)
var DFC = brown
} else if(purple) {
var DFC = purple
purple.document = {url: purple.url} 
} else if(yellow) {
var DFC = yellow 
yellow.caption = q.length > 1 ? "‚ö†Ô∏è *TRANSMISS√ÉO DO BLACK* ‚ö†Ô∏è\n\n"+q : yellow.caption.replace(new RegExp(prefix+command, "gi"), `‚ö†Ô∏è *TRANSMISS√ÉO DO BLACK* ‚ö†Ô∏è\n\n`)
yellow.document = {url: yellow.url}  
} else if(figu_d) {
var DFC = figu_d
figu_d.sticker = {url: figu_d.url}
} else if(aud_d) {
var DFC = aud_d
aud_d.audio = {url: aud_d.url}
}
for (i = 0; i < rgp.length; i++) {
blackmd.sendMessage(rgp[i].id, DFC)}
reply(`*Mensagem enviada para todos os ${rgp.length} grupos presentes na lista* ü´°`)
break

case 'abrirgp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return (enviar.msg.Badmin)
if(!q) return reply(`Retorne ap√≥s o comando o tempo em que o grupo abrir√°, seguindo os exemplos:
${prefix+command} 12:00 _(hor√°rio exato)_
ou
${prefix+command} 4h _(daqui a 4 horas a frente)_`)
letra = q.slice(q.length - 1, q.length).toLowerCase()
if(letra == `s`) {
  nmr = Number(q.slice(0, q.length - 1))
  mention(`*Sucesso @${sender.split("@")[0]}, o grupo ${groupName} ser√° aberto em ${q}* ‚úî`)
  setTimeout(async() => {
    blackmd.groupSettingUpdate(from, 'not_announcement')
    await sleep(2500)
    blackmd.sendMessage(from, {text: `[‚ùï] *O grupo foi aberto com sucesso ap√≥s ${q}* ‚úî`})
  }, nmr * 1000);
} else {
  addOpenCloseGP(from, q, sender, `open`)
  last = getLastOpenCloseGP(from)
  day = last.dias
  mention(`*Sucesso @${sender.split("@")[0]}, o grupo ${groupName} ser√° aberto ${last.dias > 0 ? sendFutureTime([{valor: last.dias, type: `days`}]).toLowerCase().split(` `)[0] + ` ` : ``}√†s ${last.hora}* ‚úî`)
}
break

case 'fechargp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return (enviar.msg.Badmin)
if(!q) return reply(`Retorne ap√≥s o comando o tempo em que o grupo fechar√°, seguindo os exemplos:
${prefix+command} 12:00 _(hor√°rio exato)_
ou
${prefix+command} 4h _(daqui a 4 horas a frente)_`)
letra = q.slice(q.length - 1, q.length).toLowerCase()
if(letra == `s`) {
  nmr = Number(q.slice(0, q.length - 1))
  mention(`*Sucesso @${sender.split("@")[0]}, o grupo ${groupName} ser√° fechado em ${q}* ‚úî`)
  setTimeout(async() => {
    blackmd.groupSettingUpdate(from, 'announcement')
    await sleep(2500)
    blackmd.sendMessage(from, {text: `[‚ùó] *O grupo foi fechado com sucesso ap√≥s ${q}* ‚ùå`})
  }, nmr * 1000);
} else {
  addOpenCloseGP(from, q, sender, `close`)
  last = getLastOpenCloseGP(from)
  day = last.dias
  mention(`*Sucesso @${sender.split("@")[0]}, o grupo ${groupName} ser√° fechado ${last.dias > 0 ? sendFutureTime([{valor: last.dias, type: `days`}]).toLowerCase().split(` `)[0] + ` ` : ``}√†s ${last.hora}* ‚è±`)
}
break
case 'clima2':
case 'Cuaca':
case 'cuaca':
    if (!q) {
        return blackmd.sendMessage(from, { text: '[‚öôÔ∏è] Por favor, envie o nome da cidade. Exemplo: !clima Fortaleza' }, { quoted: info });
    }

    const cidadeClima = encodeURIComponent(q);
    const apiClima = `https://api.ownblox.biz.id/api/cuaca?kota=${cidadeClima}`;

    try {
        const responseClima = await axios.get(apiClima);

        if (responseClima.data.status === 200 && responseClima.data.result) {
            const clima = responseClima.data.result;
            let mensagemClima = `üåé Clima para: ${clima.kota}\n\n`;
            mensagemClima += `üïê Zona Hor√°ria: ${clima.zona_waktu}\n`;
            mensagemClima += `üå°Ô∏è Temperatura: ${clima.suhu}\n`;
            mensagemClima += `üåßÔ∏è Condi√ß√£o: ${clima.kondisi}\n`;
            mensagemClima += `üíß Umidade: ${clima.kelembaban}\n`;
            mensagemClima += `üí® Vento: ${clima.angin}\n`;
            mensagemClima += `‚öôÔ∏è Press√£o: ${clima.tekanan !== "undefined mb" ? clima.tekanan : "Indefinido"}\n`;

            blackmd.sendMessage(from, { text: mensagemClima.trim() }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o consegui obter informa√ß√µes do clima.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao consultar clima:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao tentar consultar o clima.' }, { quoted: info });
    }
    break;
case 'clima':
clime = [ "‚òÅÔ∏è", "‚õÖ", "‚õàÔ∏è", "üå§Ô∏è", "üå•Ô∏è", "üå¶Ô∏è", "üåßÔ∏è", "üå®Ô∏è", "üå©Ô∏è"]
setTimeout(() => {reagir(from, clime[Math.floor(Math.random() * clime.length)])}, 300)
if (!q) return reply(`Use ${prefix + command} cidade`)
reply(`Pesquisando clima de ${q} ${clime[Math.floor(Math.random() * clime.length)]}`)
qq = q.normalize('NFD').replace(/[\u0300-\u036f]/g, "").toLowerCase().trim()
clima = await axios.get(`https://api.openweathermap.org/data/2.5/weather?q=${qq}&appid=1d0bdf08a222f8f2da252ef8921ff4ab&units=metric&lang=pt_br`)
if (clima.error) return reply(clima.error)
hora1 = moment.tz('America/Sao_Paulo').format('HH:mm');
date10 = moment.tz('America/Sao_Paulo').format('DD/MM');
if(isGroup) {
climanmr = groupMembers.length * groupAdmins.length + somembros.length
} else {
climanmr = 0.4
}
matheuzinho = `
üå™Ô∏è _CLIMA_ üå™Ô∏è
*‚ñß‚ÉØ‚ÉüüìÖ‚É§ Data:* ${date10}
*‚ñß‚ÉØ‚Éüüåé‚É§ Cidade:* ${clima.data.name}
*‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê*
*‚îÇ‚ñß‚ÉØ‚Éüüå°Ô∏è‚É§ Temperatura:* ${clima.data.main.temp.toFixed()}¬∫C
*‚îÇ‚ñß‚ÉØ‚Éüüî∫‚É§ Temp. Max:* ${clima.data.main.temp_max.toFixed()}¬∫C
*‚îÇ‚ñß‚ÉØ‚Éüüîª‚É§ Temp. Min:* ${clima.data.main.temp_min.toFixed()}¬∫C
*‚îÇ‚ñß‚ÉØ‚Éüüå¶Ô∏è‚É§ Clima:* ${clima.data.weather[0].description}
*‚îÇ‚ñß‚ÉØ‚Éüüíß‚É§ Umidade: ${clima.data.main.humidity}%*
*‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚É§*
„Ö§„Ö§„Ö§„Ö§„Äò ${hora1}h „Äô
`
await blackmd.sendMessage(from, {
   document: Buffer.from('oi curioso'),
   caption: matheuzinho,
   mimetype: 'application/pdf', // Formato
   fileName: `PREV. DO TEMPO ${clime[Math.floor(Math.random() * clime.length)]}`,
   fileLength: 100000000 * climanmr, // Tamanho (250mb)
   contextInfo: {
    externalAdReply: {
      title: NomeDoBot,
      body: '',
      mediaType: 1,
      thumbnail: await getBuffer(logoslink.menu), // s√≥ pega imagens at√© 300x300 
      showAdAttribution: true, // Coloca true para enviada como an√∫ncio 
      renderLargerThumbnail: true, // Deixa a imagem grande
      sourceUrl: '${site}' // Link que aparece quando aperta
    }
  }
})
break

case 'grupo': case 'gp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!q) return sendListB(from, {text: `*Selecione abaixo a op√ß√£o para abrir/fechar o grupo* ${groupName} üôèüèºüòî`, footer: `_Clique na lista abaixo para selecionar..._`}, blackmd, sender, `‚ô®Ô∏è CLIQUE AQUI ‚ô®Ô∏è`, [{title: `O grupo ${groupName} est√° ${groupMetadata.announce ? "fechado" : "aberto"}...`, options: [
{title: "ABRIR GRUPO üîì", body: NomeDoBot, command: prefix+command+" a"},
{title: "FECHAR GRUPO üîí", body: NomeDoBot, command: prefix+command+" f"}
]}], seloctt)
if(args[0] === 'a') {
if(!groupMetadata.announce) return reply(`O grupo j√° est√° aberto...`)
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
reply(`*GRUPO ABERTO COM SUCESSO* ‚úÖ`)
abrirgp(from) } else if(args[0] === 'f') {
if(groupMetadata.announce) return reply(`O grupo j√° est√° fechado...`)
setTimeout(() => {reagir(from, "‚ùå")}, 300)
reply(`*GRUPO FECHADO COM SUCESSO* ‚ùå`)
fechargp(from) }
break

case 'revelafoto':
case 'rft':
setTimeout(() => {reagir(from, "üïµüèª‚Äç‚ôÇÔ∏è")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
try {
var rft = await blackmd.profilePictureUrl(from, 'image')
} catch {
var rft = `https://telegra.ph/file/6ca032835ed7a16748b6f.jpg`
}
blackmd.sendMessage(from, {image: {url: rft}, caption: groupName}, {quoted: seloctt})
break

case 'grupoinfo':
case 'infogrupo':
case 'infogp':  
case 'gpinfo':  
case 'regras':
setTimeout(() => {reagir(from, "üí¨")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
try {ppUrl = await blackmd.profilePictureUrl(from, 'image')
} catch {ppUrl = semfoto}
grupodb = await blackmd.groupMetadata(from)
txt = `üí¨ *NOME ‚Ü¥*
„Äé ${groupName} „Äè
üß∏ *MEMBROS:* ¬ª${groupMembers.length}¬´
‚öúÔ∏è *ADMs:* ¬ª${groupAdmins.length}¬´

_DADOS EM GERAL_
üîí ¬ª GRUPO EST√Å *${grupodb.announce ? `FECHADO` : `ABERTO`}* ¬´
üñç ¬ª MEMBROS *${grupodb.restrict ? `N√ÉO ` : ``}PODEM* EDITAR OS DADOS DO GRUPO ¬´
üë• ¬ª GRUPO *${grupodb.isCommunity ? `` : `N√ÉO `}EST√Å* EM COMUNIDADE ¬´
‚úÖ ¬ª APROVA√á√ÉO DE ADMINS PARA ENTRAR NO GRUPO *${grupodb.joinApprovalMode ? `` : `DES`}ATIVADA* ¬´
üì§ ¬ª MEMBROS *${grupodb.memberAddMode ? `` : `N√ÉO `}PODEM* ADICIONAR NOVOS USU√ÅRIOS ¬´

‚úíÔ∏è *DESCRI√á√ÉO ‚Ü¥*
${groupDesc || `\"n√£o listada\"`}`
blackmd.sendMessage(from, {image: {url: ppUrl}, caption: txt, contextInfo: {forwardingScore: Number(sendHours(`HHmm`)), isForwarded: true}}, {quoted: seloblk})
break

case 'totag':
case 'cita':
case 'hidetag':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!menc_prt && !q) return reply("Marque uma imagem, v√≠deo, √°udio ou escreva algo para p bot retornar a mesma mensagem marcando todos os membros do grupo")
var DFC = "";
var rsm = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var pink = isQuotedImage ? rsm?.imageMessage: info.message?.imageMessage
var blue = isQuotedVideo ? rsm?.videoMessage: info.message?.videoMessage
var purple = isQuotedDocument ? rsm?.documentMessage: info.message?.documentMessage
var yellow = isQuotedDocW ? rsm?.documentWithCaptionMessage?.message?.documentMessage: info.message?.documentWithCaptionMessage?.message?.documentMessage
var aud_d = isQuotedAudio ? rsm.audioMessage : ""
var figu_d = isQuotedSticker ? rsm.stickerMessage : ""
var red = isQuotedMsg && !aud_d && !figu_d && !pink && !blue&& !purple && !yellow? rsm.conversation: info.message?.conversation
var green = rsm?.extendedTextMessage?.text || info?.message?.extendedTextMessage?.text
var MRC_TD = groupMembers.map(i => i.id)
if(pink && !aud_d && !purple) {
var DFC = pink
pink.caption = q.length > 1 ? q :pink.caption.replace(new RegExp(prefix+command, "gi"), ``)
pink.image = {url: pink.url}
pink.mentions = MRC_TD
} else if(blue && !aud_d && !purple) {
var DFC = blue  
blue.caption = q.length > 1 ? q.trim() :blue.caption.replace(new RegExp(prefix+command, "gi"), ``).trim()
blue.video = {url: blue.url}
blue.mentions = MRC_TD
} else if(red && !aud_d && !purple) {
black = {}
black.text = red.replace(new RegExp(prefix+command, "gi"), ``).trim()
black.mentions = MRC_TD
var DFC = black
} else if(!aud_d && !figu_d && green && !purple && !purple) {
brown = {}
brown.text = green.replace(new RegExp(prefix+command, "gi"), ``).trim()
brown.mentions = MRC_TD
var DFC = brown
} else if(purple) {
var DFC = purple
purple.document = {url: purple.url}
purple.mentions = MRC_TD
} else if(yellow && !aud_d) {
var DFC = yellow 
yellow.caption = q.length > 1 ? q.trim() :yellow.caption.replace(new RegExp(prefix+command, "gi"), ``).trim()
yellow.document = {url: yellow.url}
yellow.mentions = MRC_TD
} else if(figu_d && !aud_d) {
var DFC = figu_d
figu_d.sticker = {url: figu_d.url}
figu_d.mentions = MRC_TD
} else if(aud_d) {
var DFC = aud_d
aud_d.audio = {url: aud_d.url}
aud_d.mentions = MRC_TD
aud_d.ptt = true
}
blackmd.sendMessage(from, DFC).catch(e => {
console.log(e)
})
break

case 'marcar': case 'marcar2': case 'marcarwa':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
come = command == "marcarwa" ? "wa.me/" : "</> @"
if(somembros.length <= 0) return reply(`${tempo} ${pushname}

_N√£o foram encontrados membros no grupo_„Äé ${groupName} „Äè... _Apenas_ [ *ADMINISTRADORES* ]
_Caso queira marcar os adms, use_ ${prefix}adms`)
txt = q ? q+`\n\n` : ``
txt += somembros.map(i => come+i.split("@")[0]).join("\n")
if(command == "marcar2") sendAudio(from, `./database/audios/marcar/${alerandom(3)+1}.m4a`, `audio/mp4`, seloctt)
await sleep(700)
mention(txt)
break

case 'reviverqr':
case 'limparqr':
if(!isOwner) return reply(enviar.msg.dono)
qrpath = "./basededados/BLACKMD-QR"
fs.readdir(qrpath, (err, files) => {
  if(err) {
    console.error("Erro ao listar arquivos:", err);
    reply("Erro ao listar arquivos.");
  } else {
    let count = 0;
    files.forEach((file) => {
      if(file.startsWith("pre-key") || file.startsWith("sender-key") || file.startsWith("session-")) {
        fs.unlink(path.join(qrpath, file), (err) => {
          if(err) {
            console.error(`Erro ao excluir ${file}:`, err);
          } else {
            console.log(`${file} exclu√≠do com sucesso.`);
            count++;
          }
        });
      }
    });
    reply("*PODE DEIXAR MESTRE*üéñÔ∏è\n\n‚áí Reiniciando..")
    setTimeout(async () => {
      process.exit()
    }, 1000)
  }
});
break

case 'reviver':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(`T√° afim de banir o n√∫mero do bot √© ?`)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('Marque uma mensagem do alvo!')
sleep(5000)
response2 = await blackmd.groupParticipantsUpdate(from, [menc_prt], "add" )
reply(`Usu√°rio revivido com sucesso... üò∞`)
break

case 'add':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(`T√° afim de banir o n√∫mero do bot √© ?`)
if(!q) return reply("KD o n√∫mero do indiv√≠duo ?")
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
try {
usu = q + "@s.whatsapp.net"
blackmd.groupParticipantsUpdate(from, [usu], "add" )
reply("‚úÖ Usu√°rio adicionado ao grupo com sucesso...")
} catch {
reply("Erro 404")
}
break

case 'addgp':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`Hmmm`)
if(!Number(q)) return reply("Apenas n√∫meros")
reagir(from, "üôÇ")
var getGroups = await blackmd.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
var ingfoo = groups.map(v => v)
try {
blackmd.groupParticipantsUpdate(ingfoo[q].id, [nmrdn], "add" )
setTimeout(() => {
blackmd.groupParticipantsUpdate(ingfoo[q].id, [nmrdn], "promote")
blackmd.sendMessage(ingfoo[q].id, {text: "*Bem vindo meu senhor* üôáüèª‚Äç‚ôÇÔ∏è"})
}, 5000)
} catch(erro) {
reply(String(erro))
}
break

case 'sairgp':
case 'sair':
if(isGroup && !isOwner && !info.key.fromMe) return reply("Este comando s√≥ o bot ou o dono pode executar..")
try {
blackmd.groupLeave(from)
} catch(erro) {
reply(String(erro))
}
break

case 'seradm':
setTimeout(() => {reagir(from, "ü´°")}, 300)
if(!isOwner && !isnit) return reply(enviar.msg.dono)
mentions(`Ok meu senhor @${sender.split("@")[0]}, agora voc√™ √© um ADM do grupo üôáüèª‚Äç‚ôÇÔ∏è`, [sender], true)
blackmd.groupParticipantsUpdate(from, [sender], "promote")
break

case 'sermembro':
setTimeout(() => {reagir(from, "ü•≤")}, 300)
if(!isOwner && !isnit) return reply(enviar.msg.dono)
mentions(`Pronto mestre @${sender.split("@")[0]}, rebaixei o senhor para membro comum no grupo ${groupName} ü•π`, [sender], true)
blackmd.groupParticipantsUpdate(from, [sender], "demote")
break

case 'advertir':
case 'adverter': 
case 'adv':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!menc_os2) return reply("Marque o alvo que voc√™ deseja advertir")
if(menc_os2 == botNumber) return reply("N√£o pode advertir o pr√≥prio bot...");
if(menc_os2 == nmrdn) return reply("N√£o pode advertir o pr√≥prio dono do bot");
if(groupAdmins.includes(menc_os2)) return reply("N√£o pode advertir ADMS..");
AB = ADVT.map(i => i.id).indexOf(menc_os2)
if(AB >= 0) {
  if(ADVT[AB].adv < 2) {
    ADVT[AB].adv += 1
    setGp(dataGp)
    return mention(`[‚ùó] Aten√ß√£o @${menc_os2.split("@")[0]}, voc√™ j√° foi advertido ${ADVT[AB].adv} vezes... Na pr√≥xima √© ban ‚ùå`)
  } else {
    mention(`Este foi seu aviso final @${menc_os2.split(`@`)[0]}... Por n√£o atentar as suas advert√™ncias, te darei um ban de presente ü•∞`)
    ADVT.splice(AB, 1)
    setGp(dataGp)
    await sleep(3000)
    return remover(from, menc_os2)
  }
} else {
  ADVT.push({id: menc_os2, adv: 1})
  setGp(dataGp)
  return mention(`[‚ùó] Aten√ß√£o @${menc_os2.split("@")[0]}, voc√™ foi advertido... Tome cuidado, pois 3 adv resultar√£o em banimento ‚ùå`)
}
break

case 'rmadv':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!marc_tds) return reply("KD o alvo que voc√™ deseja retirar a advert√™ncia")
AB = ADVT.map(i => i.id).indexOf(marc_tds)
if(AB < 0) return reply("N√£o h√° advert√™ncias neste usu√°rio")
ADVT.splice(AB, 1)
setGp(dataGp)
reply("Advert√™ncia retirada com sucesso...")
break

case 'advlist':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(ADVT.length <= 0) return reply(`N√£o h√° membros com advert√™ncia neste grupo...`)
mention(`üóÇ Lista de usu√°rios com advt neste grupo:
${ADVT.map(i => `¬ª${ADVT.map(a => a.id).indexOf(i.id) + 1}¬´
üë§ *Usu√°rio:* @${i.id.split("@")[0]}
‚ö† *Advert√™ncia:* ${i.adv}`).join(`\n-\n`)}`)
break

//======‚â†(INFOS/EXECU√á√ÉO/DONO)‚â†=========\\

case 'apresentar':
case 'apr':  
if(!isGroupAdmins) return reply(enviar.msg.adm)
inff = `Bem vindo(a) ao grupo : ${groupName}


üëæ ‚Ä¢ùë¨ùëµùëªùëπùë∂ùëº ùë∫ùë¨ ùë®ùë∑ùëπùë¨ùë∫ùë¨ùëµùëªùë®‚Ä¢
üì∏ ‚Ä¢Fùú£Tùú£
üëª ‚Ä¢Nùú£ME
üìå ‚Ä¢CID‚àÜDE
üóìÔ∏è ‚Ä¢ID‚àÜDE
‚ö†Ô∏è ‚Ä¢LEI‚àÜ ‚àÜS REGR‚àÜS Dùú£ GRUPùú£

*APROVEITE O GRUPO!*`
blackmd.sendMessage(from, {text: inff}, {quoted: selo})
break

case 'papof':
case 'regraspp':  
if(!isGroupAdmins) return reply(enviar.msg.adm)
txtz = `„Äê·ØΩíã®üì∑:ùëÜùëí ùëéùëùùëüùëíùë†ùëíùëõùë°ùëíùëö ùëôùëñùë•ùëúùë†üåö¬ª¬∞„Äë
íã®Œá‡£≠‡£™Ãáüî•…¥·¥è·¥ç·¥á:
íã®Œá‡£≠‡£™Ãáüî•…™·¥Ö·¥Ä·¥Ö·¥á:
íã®Œá‡£≠‡£™Ãáüî• Ä·¥Ä ô·¥Ä:
*A·¥ò Ä·¥ás·¥á…¥·¥õ·¥á-s·¥á s·¥á «´·¥ú…™s·¥á Ä.*
ùôèùòºùôÇùôé‚û≠◊Ç·úî‡†≠ ‚Å∏‚Çà‚Å∏|ùüñùüñùüñ|ùü†ùü†ùü†| ‡Ω∫‡Ω≤‚Å∏‚Å∏‚Å∏
 ‚îÄ‚îÄ‚ïå‚ïå‚ïå‚îà‚ä∞‚òÖ‚ä±‚îà‚ïå‚ïå‚ïå‚îà‚îÄ
‚ùå ENTROU NO 
GRUPO INTERAJA, N√ÉO PRECISAMOS DE ENFEITES,INATIVOS SERAO REMOVIDOS ‚ùå* 

/Ôπã<,Ô∏ª‚ï¶‚ï§‚îÄ “â - -----üí• 
/Ôπã üÖ¥ üÖ±üÖ¥üÖº üÜÖüÖ∏üÖΩüÖ≥üÖæ üÜÇüÖ¥üÜÑüÜÇ üÖµüÖ∏üÖªüÖ∑üÖæüÜÇ üÖ≥üÖ∞ üÖøüÜÑüÜÉüÖ∞`
blackmd.sendMessage(from, {text: txtz}, {quoted: selo})
break

case 'digt':
if(!isGroupAdmins) return reply(enviar.msg.adm)
bla = `üî•‚ÜØùêâùêÄ ùêÑùêçùêìùêëùêÄ ùêÉùêàùêÜùêàùêìùêÄùêçùêÉùêé ùöΩùêà ‚ÜØ¬∞üåöüíï
           ‡Ω≤‚ãÆ ‡æÄüå¥‚èù ‡Ω≤‚ãÆ ‡æÄüö∏ ‡Ω≤‚ãÆ ‡æÄ‚èùüå¥ ‡Ω≤‚ãÆ ‡æÄ 

üêºüçß‚ÜØùñ†ùñ∞ùñ¥ùñ® ùñµùñÆùñ¢ùñ§ÃÇ ùñØùñÆùñ£ùñ§ ùñ≤ùñ§ùñ±‚ÜØüçßüêª
„Ö§„Ö§„Ö§„Ö§  ‚óç€´‚ùÄ‚Éò‡£≠‡£≠‡£≠‡£≠ŸúÍî∑‚Éî‡ªë‡£≠‡£≠Ÿú‚üÖ‚óåŸúüõ∏‚óå‚üÜ‡£≠‡£≠Ÿú‡ªë‚ÉïÍî∑‚Éò‡£≠‡£≠‡£≠‡£≠Ÿú‚ùÄ€´‚óç‡£≠‡£≠‡£≠‡£≠‡Ω≤ ‡Ω¥
    „Äê‚úî„Äë·¥ò Ä·¥á·¥õ·¥Äüë©üèæ‚Äçü¶± „Äê‚úî„Äë ô Ä·¥Ä…¥·¥Ñ·¥Äüë©üèº
    „Äê‚úî„Äë·¥ç·¥Ä…¢ Ä·¥Äüçß„Äê‚úî„Äë…¢·¥è Ä·¥Ö·¥Äüçø
    „Äê‚úî„Äë·¥ò·¥è ô Ä·¥áü™ô „Äê‚úî„Äë Ä…™·¥Ñ·¥Äüí≥
    „Äê‚úî„Äë ô·¥Ä…™·¥Ä…¥·¥Äüíå„Äê‚úî„Äë·¥ç·¥Ä·¥Ñ·¥è…¥ ú·¥á…™ Ä·¥ÄüçÅ
    „Äê‚úî„Äë·¥è·¥õ·¥Ä·¥ã·¥úüßß„Äê‚úî„Äë·¥á-…¢…™ Ä üü¶Ñ
    „Äê‚úî„Äë ü·¥è ü…™üç≠    „Äê‚úî„Äë…¢·¥Ä·¥Ö·¥èüêÉ
    „Äê‚úî„Äë…¢·¥Ä èüè≥Ô∏è‚Äçüåà     „Äê‚úî„Äë ü·¥ás ô…™·¥Ñ·¥Ä‚úÇÔ∏è
    „Äê‚úî„Äë·¥†·¥Ä·¥Ö…™·¥ÄüíÑ  „Äê‚úî„Äë·¥õ Ä·¥Ä·¥†·¥á·¥Ñ·¥èüçå
                „Äê‚úî„Äë…¥…™…¥…¢·¥ú·¥á·¥ç  ü…™…¢·¥Äüìµ
. ‚ò™Ô∏é ‚Ä¢ ‚òÅÔ∏é. . ‚Ä¢.
„Äê ùêïùêÑùêå ùêÜùêÄùêãùêÑùêëùêÄ, ùêíùêÑ ùêÉùêàùêïùêÑùêëùêìùêàùêë ùêÑ ùêÖùêÄùêôùêÑùêë ùêèùêÄùêëùêìùêÑ ùêÉùêÄ ùêÖùêÄùêåùêàùêãùêàùêÄ.„Äëü•Ç`
blackmd.sendMessage(from, {text: bla}, {quoted: selo})
break

case 'wlcm':
if(!isGroupAdmins) return reply(enviar.msg.adm)
reply(`‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà WÃ∑EÃ∑LÃ∑CÃ∑OÃ∑MÃ∑EÃ∑ ‚ñà‚ñá‚ñÜ‚ñÖ‚ñÑ‚ñÉ‚ñÇ‚ñÅ
üëª ‚è§ÕüÕûÕüÕû Í¶øùô¥ùöóùöùùöõùöòùöû ùôπ√° ùô≤ùöëùöéùöêùöä ùöÇùöé ùô∞ùöôùöõùöéùöúùöéùöóùöùùöäùöóùöçùöò ùô∞√≠ #numerodele#
üì∏‚É§ ùôÅùôäùôèùôä
‚úçüèº‚É§ ùôâùôäùôàùôÄ
üß∏‚É§ ùôÑùòøùòºùòøùôÄ
üèòÔ∏è‚É§ ùòæùôÑùòøùòºùòøùôÄ
üíû‚É§ ùôçùôÄùôáùòºùòæùôÑùôäùôâùòºùôàùôÄùôâùôèùôä

‚ñß‚ÉØ‚Éü‚ö†Ô∏è ›á›à‚îÄ ùô∞ùöùùöéùöó√ß√£ùöò ùô∞ùöú ùöÅùöéùöêùöõùöäùöú ùôΩùöä ùô±ùöíùöò ùô≥ùöò ùô∂ùöõùöûùöôùöò ùôæùöû ùöÖùöäùöí ùô≤ùöòùöóùöëùöéùöåùöéùöõ ùôæ ùôµùöäùöñùöòùöúùöò ü§≠`)
break

case 'joingp':
if(!isOwner) return reply('```SOMENTE MEU DONO LIND√ÉO```')
if(!JSON.stringify(bcgp).includes("mensagem")) {
  bcgp.push({tipo: "mensagem", msg: []})
  fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
}
if(!JSON.stringify(bcgp).includes("grupos")) {
  bcgp.push({tipo: "grupos", gps: []})
  fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
}
var [linkM4, msgM4] = q.split('|')
if(!linkM4) return reply('Insira um link de convite ao lado do comando.')
if(!msgM4) return reply(`Vejo que voc√™ n√£o inseriu a mensagem que ser√° enviada... Fa√ßa assim:\n${prefix+command} link do grupo/mensagem para enviar`)
var getGroups = await blackmd.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
var ingfoo = groups.map(v => v)
ingfoo.sort((a, b) => (a[0] < b.length))
if(!linkM4.includes('chat.whatsapp.com/')) return reply('Ops, verifique o link que voc√™ inseriu.')
link = linkM4.split('app.com/')[1]
AB = bcgp.map(i => i.tipo).indexOf("mensagem")
AC = bcgp.map(i => i.tipo).indexOf("grupos")
try {
for(i = 0; i < ingfoo.length; i++) {
  bcgp[AC].gps.push({groupId: ingfoo[i].id})
  fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
}
bcgp[AB].msg.push({txt: msgM4, cobrado: false})
fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
blackmd.groupAcceptInvite(`${link}`)
return reply(`Todos os grupos da lista foram salvos na pasta... Qualquer grupo que esteja fora da lista ser√° tratado como indigno e r√©u de receber uma mensagem no PV de cada um dos seus membros`)
} catch(erro) {
if(String(erro).includes('not-authorized') ) {
reply('N√£o foi poss√≠vel entrar no grupo.\nMotivo: Banimento.')
}
}
break

case 'delgp':
if(!isOwner) return reply("S√≥ meu dono")
if(bcgp.length <= 0) return reply(`N√£o h√° mensagens salvas...`)
AB = bcgp.map(i => i.tipo).indexOf("mensagem")
matheuzinho = bcgp[AB].msg
if(matheuzinho.length <= 0) return reply(`N√£o h√° mensagens salvas...`)
if(!Number(args[0]) || Number(args[0]) < 1 || Number(args[0]) > matheuzinho.length) return reply("Olhe no comando "+prefix+"gplist e escolha o n√∫mero correspondente a mensagem para deletar")
BC = Number(args[0]) - 1
matheuzinho.splice(BC, 1)
fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
reply("Mensagem da lista deletada com sucesso ‚úÖ")
break

case 'gplist':
if(!isOwner) return reply("S√≥ meu dono")
if(bcgp.length <= 0) return reply(`N√£o h√° mensagens salvas...`)
AB = bcgp.map(i => i.tipo).indexOf("mensagem")
if(bcgp[AB].msg.length <= 0) return reply(`N√£o h√° mensagens salvas...`)
resp = `*Mensagens salvas para envio:*`
matheuzinho = bcgp[AB].msg
for(i = 0; i < matheuzinho.length; i++) {
  resp += `\n‚Ä¢ ${i+1} -> ${matheuzinho[i].txt}`
}
reply(resp)
break

case 'listagp':
setTimeout(() => {reagir(from, "üé≤")}, 300)
if(!isOwner) return reply(enviar.msg.dono)
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
gptt = []
for(i of allGroups) {
  try { getlink = `https://chat.whatsapp.com/${(await blackmd.groupInviteCode(i.id))}`
  } catch { getlink = `"link indispon√≠vel"` }
  nmr = 0
  for(p of i.participants) {
    if(p.admin != null) nmr += 1
  }
  gptt.push({
    id: i.id,
    contador: allGroups.map(a => a.id).indexOf(i.id) + 1,
    nome: i.subject,
    criador: i?.subjectOwner || i?.owner ? getname(i?.owner || i?.subjectOwner).replace(`usu√°rio`, `wa.me/${(i?.subjectOwner || i?.owner).split(`@`)[0]}`) : `"n√£o listado"`,
    admins: nmr,
    membros: i.participants.length - nmr,
    link: getlink
  })
}
if(gptt.length < 0) return reply(`N√£o h√° grupos salvos...`)
reply(`üé≠ *Exibindo ${gptt.length > 1 ? `todos os ${gptt.length} grupos` : `o √∫nico grupo`} da lista ‚Ü¥*
${gptt.map(i => `¬ª${i.contador}¬´
‚ôü *Nome:* ${i.nome}
üéÆ *Criador/a do grupo:* ${i.criador}
üïπ *Total de admins:* ${i.admins}
üé± *Total de membros:* ${i.membros} ${isPrivateChat ? `
üï∂ *ID do grupo:* ${i.id}
‚öô *Link do grupo:* ${i.link}` : ``}`).join(`\n\n`)}`)
break

case 'iddogp':
setTimeout(() => {reagir(from, "üßµ")}, 300)
if(!isOwner)return reply(enviar.msg.dono)
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
but = []
for(i of allGroups) {
  but.push({title: i.subject || `"N√£o listado"`, body: `${i.participants.length} membro${i.participants.length != 1 ? `s` : ``} ao todo`, command: prefix+command+` `+i.id})
}
if(!q || allGroups.map(a => a.id).indexOf(q) < 0) {
  if(isGroup) reply(`Chega PV üî∞`)
  try { ppUrl = await blackmd.profilePictureUrl(from, 'image')
  } catch { ppUrl = semfoto }
  return sendRouletteButton(sender, {image: {url: ppUrl}, caption: `Olhe na lista abaixo e selecione o grupo que voc√™ deseja puxar o ID:`, footer: NickDono}, blackmd, sender, [{type: `list`, title: `„Äò ùóöùó•ùó®ùó£ùó¢ùó¶ ùóîùó§ùó®ùóú „Äô`, rowId: [{title: `Listando ${allGroups.length > 1 ? `todos os ${allGroups.length} grupos` : `o √∫nico grupo`} da lista...`, options: but}]}], seloctt)
}
AB = allGroups.map(a => a.id).indexOf(q)
grupo = allGroups[AB]
reply(`_ID do grupo ${grupo.subject} ‚Ü¥_`)
await sleep(700)
sendMess(from, grupo.id)
break

case 'linkdogp': {
setTimeout(() => {reagir(from, "üß∂")}, 300)
if(!isOwner)return reply(enviar.msg.dono)
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
but = []
for(i of allGroups) {
  but.push({title: i.subject || `"N√£o listado"`, body: `${i.participants.length} membro${i.participants.length != 1 ? `s` : ``} ao todo`, command: prefix+command+` `+i.id})
}
if(!q || allGroups.map(a => a.id).indexOf(q) < 0) {
  if(isGroup) reply(`Chega PV üî∞`)
  try { ppUrl = await blackmd.profilePictureUrl(from, 'image')
  } catch { ppUrl = semfoto }
  return sendRouletteButton(sender, {image: {url: ppUrl}, caption: `Olhe na lista abaixo e selecione o grupo que voc√™ deseja puxar o link:`, footer: NickDono}, blackmd, sender, [{type: `list`, title: `„Äò ùóöùó•ùó®ùó£ùó¢ùó¶ ùóîùó§ùó®ùóú „Äô`, rowId: [{title: `Listando ${allGroups.length > 1 ? `todos os ${allGroups.length} grupos` : `o √∫nico grupo`} da lista...`, options: but}]}], seloctt)
}
let { key } = await blackmd.sendMessage(from, {text: `_Buscando grupo_ üîé`}, {quoted: info})
await sleep(1000)
AB = allGroups.map(a => a.id).indexOf(q)
grupo = allGroups[AB]
try { getlink = `https://chat.whatsapp.com/${(await blackmd.groupInviteCode(grupo.id))}`
} catch { return await blackmd.sendMessage(from, {text: `N√£o foi poss√≠vel puxar o link... √â poss√≠vel que o bot n√£o seja adm neste grupo üò•`, edit: key }, {quoted: info}) }
await blackmd.sendMessage(from, {text: `_Link do grupo ${grupo.subject} ‚Ü¥_
${getlink}`, edit: key }, {quoted: info}) }
break

case 'sairdogp': {
setTimeout(() => {reagir(from, "üß¶")}, 300)
if(!isOwner)return reply(enviar.msg.dono)
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
but = []
for(i of allGroups) {
  but.push({title: i.subject || `"N√£o listado"`, body: `${i.participants.length} membro${i.participants.length != 1 ? `s` : ``} ao todo`, command: prefix+command+` `+i.id})
}
if(!q || allGroups.map(a => a.id).indexOf(q) < 0) {
  if(isGroup) reply(`Chega PV üî∞`)
  try { ppUrl = await blackmd.profilePictureUrl(from, 'image')
  } catch { ppUrl = semfoto }
  return sendRouletteButton(sender, {image: {url: ppUrl}, caption: `Olhe na lista abaixo e selecione o grupo que voc√™ quer que o bot saia:`, footer: NickDono}, blackmd, sender, [{type: `list`, title: `„Äò ùóöùó•ùó®ùó£ùó¢ùó¶ ùóîùó§ùó®ùóú „Äô`, rowId: [{title: `Listando ${allGroups.length > 1 ? `todos os ${allGroups.length} grupos` : `o √∫nico grupo`} da lista...`, options: but}]}], seloctt)
}
AB = allGroups.map(a => a.id).indexOf(q)
let { key } = await blackmd.sendMessage(from, {text: `üíÜüèª‚Äç‚ôÇÔ∏è Saindo do grupo ${allGroups[AB].subject} üö∂üèª‚Äç‚ôÇÔ∏è`}, {quoted: info})
await sleep(2000)
blackmd.groupLeave(q)
await sleep(1000)
await blackmd.sendMessage(from, {text: `üôáüèª‚Äç‚ôÇÔ∏è Pronto chefe, miss√£o dada √© miss√£o cumprida üíÅüèª‚Äç‚ôÇÔ∏è`, edit: key}, {quoted: info})
}
break

case 'delfilegp': {
setTimeout(() => {reagir(from, "üìÇ")}, 300)
if(!isOwner) return reply(enviar.msg.dono)
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
but = []
for(i of allGroups) {
  but.push({title: i.subject || `"N√£o listado"`, body: `${i.participants.length} membro${i.participants.length != 1 ? `s` : ``} ao todo`, command: prefix+command+` `+i.id})
}
if(!q || allGroups.map(a => a.id).indexOf(q) < 0) {
  if(isGroup) reply(`Chega PV üî∞`)
  try { ppUrl = await blackmd.profilePictureUrl(from, 'image')
  } catch { ppUrl = semfoto }
  return sendRouletteButton(sender, {image: {url: ppUrl}, caption: `Olhe na lista abaixo e selecione o grupo que voc√™ deseja deletar a dB de arquivos:`, footer: NickDono}, blackmd, sender, [{type: `list`, title: `„Äò ùóöùó•ùó®ùó£ùó¢ùó¶ ùóîùó§ùó®ùóú „Äô`, rowId: [{title: `Listando ${allGroups.length > 1 ? `todos os ${allGroups.length} grupos` : `o √∫nico grupo`} da lista...`, options: but}]}], seloctt)
}
caminho = `./basededados/grupos/${q}.json`
if(!fs.existsSync(caminho)) {
  console.log(`ID: ${q}\n\n"${caminho}" n√£o existe`)
  return reply(`Grupo n√£o existente ‚ùå`)
}
AB = allGroups.map(a => a.id).indexOf(q)
grupo = {id: q, name: allGroups[AB].subject}
DLT_FL(caminho)
reply(`_Grupo ${grupo.name} por ID *${grupo.id}* deletado da dB com sucesso_ ‚úî`)
await sleep(700)
console.log(colors.green(`Restart necess√°rio para save de dados..`))
process.exit()
}
break

case 'limpardb':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = countMessage.map(i => i.groupId).indexOf(from)
total = countMessage[AB].participants.length
caixa = []
for(i = 0; i < countMessage[AB].participants.length; i++) {
  if(isJsonIncludes(groupMembers, countMessage[AB].participants[i].id)) {
    caixa.push(countMessage[AB].participants[i])
  }
}
pack = total - caixa.length
if(pack <= 0) return reply("*Todos os ghosts da data base j√° foram deletados...*")
countMessage[AB].participants = caixa
saveJSON(countMessage, "./basededados/countmsg.json")
reply(`${pack} n√∫meros foram deletados da pasta com sucesso ‚úÖ`)
break

case 'addglobalmessage': case 'addgbmsg':
if(!isOwner) return reply(enviar.msg.dono)
var [h, m1] = q.replace("/ ", "/").replace(" /", "/").replace(" / ", "/").split("/")
if(!h || !m1) return reply(`Retone ap√≥s o comando o hor√°rio e a mensagem que voc√™ quer enviar quando o sistema estiver ativado, ex:
${prefix+command} 18:00/se a vida te der um lim√£o, desconfie, pq nada √© de gra√ßa`)
t = h.split(":")[0]
if(Number(t) < 0 || Number(t) > 24 || t.includes('.')) return reply("Formato de hora inv√°lido... S√≥ existem horas entre 00 e 24 ü§°")
c = h.includes(":") ? `` : `:00`
p = h + c
x = p.split(":")[1]
if(Number(x) < 0 || Number(x) > 60 || x.includes('.')) return reply("Formato de hora inv√°lido... S√≥ minutos entre 00 e 60 ü§°")
horacerta = `${Number(p.split(":")[0]) >= 10 ? Number(p.split(":")[0]) : `0${Number(p.split(":")[0])}`}:${Number(p.split(":")[1]) >= 10 ? Number(p.split(":")[1]) : `0${Number(p.split(":")[1])}`}`
if(isJsonIncludes(gbmsg[1].msg, horacerta)) {
AB = gbmsg[1].msg.map(i => i.time).indexOf(horacerta)
gbmsg[1].msg.splice(AB, 1)
saveJSON(gbmsg, "./basededados/gbmsg.json")
}
faq = m1
gbmsg[1].msg.push({time: horacerta, frase: faq, save: "00"})
saveJSON(gbmsg, "./basededados/gbmsg.json")
reply(`A mensagem "${faq}" foi definida com sucesso √†s ${horacerta}h... Para ativar no grupo, use ${prefix}gbmsg`)
break

case 'removeglobalmessage': case 'rmgbmsg':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`Para melhor precis√£o, retorne ap√≥s o comando, o hor√°rio que voc√™ deseja deletar... Caso esteja em d√∫vida, olhe no comando ${prefix}lista-gbmsg todos os hor√°rios registrados.`)
t = q.split(":")[0]
if(Number(t) < 0 || Number(t) > 24 || t.includes('.')) return reply("Formato de hora inv√°lido... S√≥ existem horas entre 00 e 24 ü§°")
c = q.includes(":") ? `` : `:00`
p = q + c
x = p.split(":")[1]
if(Number(x) < 0 || Number(x) > 60 || x.includes('.')) return reply("Formato de hora inv√°lido... S√≥ minutos entre 00 e 60 ü§°")
horacerta = `${Number(p.split(":")[0]) >= 10 ? Number(p.split(":")[0]) : `0${Number(p.split(":")[0])}`}:${Number(p.split(":")[1]) >= 10 ? Number(p.split(":")[1]) : `0${Number(p.split(":")[1])}`}`
AB = gbmsg[1].msg.map(i => i.time).indexOf(horacerta)
if(AB < 0) return reply("Hor√°rio n√£o registrado")
gbmsg[1].msg.splice(AB, 1)
saveJSON(gbmsg, "./basededados/gbmsg.json")
reply("Hor√°rio deletado com sucesso ‚úÖ")
break

case 'lista-globalmessage': case 'lista-gbmsg':
if(!isOwner) return reply(enviar.msg.dono)
if(gbmsg[1].msg.length <= 0) return reply("N√£o h√° hor√°rios definidos...")
reply(`üì® *Lista de mensagens e hor√°rios..*
üìñ *Total:* ${gbmsg[1].msg.length}

${gbmsg[1].msg.map(i => `‚Ä¢ *Hor√°rio:* ${i.time}h
‚Ä¢ *Mensagem:* ${i.frase}`).join("\n-\n")}`)
break

case 'globalmessage': case 'gbmsg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isJsonIncludes(gbmsg[0].gp, from)) {
  gbmsg[0].gp.push({id: from})
  saveJSON(gbmsg, "./basededados/gbmsg.json")
  return reply(`*Ativada fun√ß√£o de mensagens programadas neste grupo com sucesso* ‚úÖ`)
} else {
  AB = gbmsg[0].gp.map(i => i.id).indexOf(from)
  gbmsg[0].gp.splice(AB, 1)
  saveJSON(gbmsg, "./basededados/gbmsg.json")
  return reply(`Sucesso, voc√™ desativou as mensagens programadas deste grupo...`)
}
break

case 'atividade':
case 'atividades':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = countMessage.map(a => a.groupId).indexOf(from)
if(AB < 0) return reply(`N√£o h√° dados de mensagens deste grupo salvos na database do bot...`)
grupo = countMessage[AB].participants
if(grupo.length <= 0) return reply(`N√£o h√° membros suficientes no grupo...`)
txt = `ü•è *_Atividade dos membros deste grupo:_*
${grupo.map(g => `*Usu√°rio:* @${g.id.split("@")[0]}
*Menssagens:* ${g.mensagens}
*Comandos:* ${g.comandos}`).join(`\n\n`)}`
mention(txt)
break

case 'inativos':
case 'inativo':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(isNaN(q)) return reply(`Retorne ap√≥s o comando a quantidade de mensagens que voc√™ quer puxar...`)
AB = countMessage.map(a => a.groupId).indexOf(from)
if(AB < 0) return reply(`N√£o h√° dados de mensagens deste grupo salvos na database do bot...`)
grupo = countMessage[AB].participants
caixa = []
for(i of grupo) {
  if(i.mensagens <= Number(q)) caixa.push(i.id)
}
if(caixa.length == 0) return reply(`N√£o h√° pessoas com ${q} msg..`)
txt = `_Usu√°rios com ${q.trim()} msg ou menos..._
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
${caixa.map(c => `‚ïü ¬ª${caixa.indexOf(c) + 1}¬´ @${c.split("@")[0]}`).join(`
‚ïë
`)}
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£ ${NomeDoBot}`
mention(txt)
break

case 'banghost': case 'banghosts':
if(!isGroup) return reply(enviar.msg.grupo)  
if(!isOwner) return reply(enviar.msg.dono)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!q || !Number(q) < 0) return reply(`Retorne ap√≥s o comando a quantidade m√≠nima de mensagens que os usu√°rios devem ter para n√£o serem banidos... Qualquer usu√°rio com mensagens abaixo disso ir√¢o de submarino.
Ex: ${prefix+command} 5`)
hehe = []
AB = countMessage.map(i => i.groupId).indexOf(from)
nmr = 0
for(a of countMessage[AB].participants) {
  if(a.mensagens <= Number(q)) {
    if(!nmrdn.includes(a.id) && !botNumber.includes(a.id)) {
      if(isJsonIncludes(groupMembers, a.id)) hehe.push(a.id)
      if(!isJsonIncludes(groupAdmins, a.id)) nmr += 1
    }
  }
}
if(nmr <= 0) return reply(`Todos os usu√°rios com essa quantidade de mensagens j√° foram removidos..`)
ativado = isWelkom3
fechargp(from)
await sleep(1000)
reply(`Grupo fechado para limpeza üóë`)
if(ativado) {
dataGp[0].wellcome[2].bemvindo3 = false
setGp(dataGp)
}
limpeza = 0
total = hehe.length
for(h of hehe) {
  await sleep(1400)
  if(isJsonIncludes(groupAdmins, h)) {
    blackmd.sendMessage(from, {text: `Usu√°rio @${h.split("@")[0]} foi poupado do banimento por ser admin üëë`, mentions: [h]})
  } else if(isOnlyVip(h)) {
    blackmd.sendMessage(from, {text: `Usu√°rio @${h.split("@")[0]} foi poupado do banimento por ser VIP ‚öú`, mentions: [h]})
  } else {
    remover(from, h)
  }
  limpeza += 1
}
if(limpeza >= total) {
  await sleep(1000)
  abrirgp(from)
  await sleep(1000)
  sendMess(from, `Todos os usu√°rios com ${q} msg ou menos foram removidos com sucesso üóë`)
  if(ativado) {
    dataGp[0].wellcome[2].bemvindo3 = true
    setGp(dataGp)
  }
}
break

case 'verificarnmr':
if(!isOwner) return reply(enviar.msg.dono)
const [result] = await blackmd.onWhatsApp(q)
if(result == undefined) {
reply("Este usu√°rio n√£o √© existente no WhatsApp")
} else {
reply(`-> ${sla} N√∫mero inserido √© existente no WhatsApp.\n\ncom o id:`)
setTimeout(() => {
blackmd.sendMessage(from, {text: result.jid})
}, 1100)
}
break

case 'wame':
barra = q.replace(" |", "|").replace("| ", "|").replace(" | ", "|")
var [nmr, msg] = barra.split('|')
if(!nmr) return reply("KD o n√∫mero de wpp?")
me = nmr.includes('@') ? nmr.split('@')[1] : nmr.toLowerCase() == "me" ? sender.split('@')[0] : nmr.toLowerCase() == "bot" ? botNumber.split('@')[0] : nmr.toLowerCase() == "dono" ? nmrdn.split('@')[0] : nmr
txt = `wa.me/`+me.replace(new RegExp("[()+-/ +/]", "gi"), "")
if(msg) txt += `?text=`+encodeURI(msg)
reply(txt)
break



case 'correio':
setTimeout(() => {reagir(from, "‚úâÔ∏è")}, 300)
var [txt1, txt2] = q.split('/')
if(!txt1) return reply(`KD o n√∫mero da pessoa ?`)
if(!txt2) return reply(`Separe o n√∫mero da pessoa e a mensagem com uma /

Ex: ${sender.split('@')[0]}/oi vida`)
if(txt1.includes("@")) return reply(`N√£o inclua @ no n√∫mero...`)
msg_ = `*Correio enviado...* ‚úâÔ∏è

*Para mais d√∫vidas, digite:* ${prefix}infocorreio`
reply(msg_)
bla = 
`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïü ùô≤ùöòùöõùöõùöéùöíùöò ùô∞ùöó√¥ùöóùöíùöñùöò ü§´
‚ïë
‚ï©„Ö§‚áíùôºùöéùöóùöúùöäùöêùöéùöñ: ${txt2}
________________________________________

${NomeDoBot} ‚úâÔ∏è`
blackmd.sendMessage(txt1.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net`, {text: bla})
break

case 'correio2':
setTimeout(() => {reagir(from, "‚úâÔ∏è")}, 300)
var [txt1, txt2] = q.split('/')
if(!txt1) return reply(`KD o n√∫mero da pessoa ?`)
if(!txt2) return reply(`Separe o n√∫mero da pessoa e a mensagem com uma /

Ex: ${sender.split('@')[0]}/oi vida`)
if(!txt1.startsWith("55") && !txt1.startsWith("+55")) return reply(`N√£o se esque√ßa do 55 na frente`)
if(txt1.includes("@")) return reply(`N√£o inclua @ no n√∫mero...`)
msg_ = `*Correio enviado...* ‚úâÔ∏è

*Para mais d√∫vidas, digite:* ${prefix}infocorreio`
reply(msg_)
bla = 
`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïü ${pushname} Te Enviou Uma Msg
‚ïë
‚ï©„Ö§‚áíùôºùöéùöóùöúùöäùöêùöéùöñ: ${txt2}
________________________________________

‡≥à·çùÕ°Õú‚úâÔ∏è wa.me/${sender.split('@')[0]}`
blackmd.sendMessage(txt1.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net`, {text: bla})
break

case 'infocorreio':
setTimeout(() => {reagir(from, "üì©")}, 300)
infocarta = `*${tempo} ${pushname}, h√° duas formas de correio:*

[ ${prefix}correio ]
A primeira forma de correio ir√° enviar uma mensagem para o remetente de forma totalmente an√¥nima...

[ ${prefix}correio2 ]
J√° a segunda forma de correio, ir√° p√¥r o seu n√∫mero na carta... Isto √©, caso voc√™ queira se identificar, ou mesmo, para o remetente entrar em contato com voc√™.

-----------------------------------------------------------

*Em ambas as formas, √© necess√°rio p√¥r o n√∫mero de forma correta, na seguinte ordem:*
-> Comando+55+DDD+n√∫mero do indiv√≠duo+/+sua mensagem para ele

_*Nota:* N√£o pode conter o 9 na frente do n√∫mero_
‚ùå 9xxxx-xxxx
‚úÖ xxxx-xxxx
_(N√£o √© necess√°rio p√¥r o "+", nem o "-")_

*Exemplo:*
-> ${prefix}correio 556481310187/oi gstz
-> ${prefix}correio2 556481310187/salve meu pit

*Bjs de luz, Estev√£o Ferreira* ‚ú®`
blackmd.sendMessage(from, {image: {url: `https://telegra.ph/file/87aeadc7997d9eb91bfcb.jpg`}, caption: infocarta}, {quoted: seloctt})
break

case 'msgpv':
reagir(from, "‚úÖ")
if(!isOwner) return reply("A vontade de banir pessoas assim n√£o √© pouca... üòí")
if(!isMsgPV) {
obrigadoEXT.msgpv = true
setObg(obrigadoEXT)
reply(`‚úîÔ∏è A mensagem no PV foi ativada para todos os comandos que necessitem dela „Ä∞Ô∏è`)
} else {
obrigadoEXT.msgpv = false
setObg(obrigadoEXT)
reply(`‚úñÔ∏è A mensagem no PV foi desativada... Alguns comandos n√£o enviar√£o avisos no PV, mas continuar√£o funcionando ‚ûø`)
}
break

case 'nome-bot':
if(!isOwner  && !ischyt && !info.key.fromMe) return reply(enviar.msg.dono)  
NomeDoBot = q.trim()
setting.NomeDoBot = q.trim()
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, 2))
reply(`Ok ${NickDono}, agora eu me chamo ${q}`)
break

case 'nick-dono':
if(!isOwner  && !ischyt && !info.key.fromMe) return reply(enviar.msg.dono) 
setting.NickDono = q.trim()
NickDono = setting.NickDono
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, 2))
reply(`O Nick Do Dono foi alterado para:
> ${q}`)
break

case 'numero-dono':
if(!isOwner && !ischyt && !info.key.fromMe) return reply(enviar.msg.dono)
if(!q) return reply("KD o n√∫mero de WhatsApp")
if(q.match(/[a-z]/i)) return reply("√â apenas n√∫meros..")
reply(`Ok ${pushname}, transfer√™ncia de dono feita para wa.me/${q} com sucesso...`)
setting.numerodono = q.trim().replace(new RegExp("[()+-/ +/]", "gi"), "");
numerodono[0] = setting.numerodono
numerodn = setting.numerodono
numerodono_ofc = setting.numerodono
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, 2))
break

case 'fotomenu':
case 'fundomenu':
if(!isOwner) return reply(enviar.msg.dono)
if(!isQuotedImage) return reply("Marque uma imagem")
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) { 
reply(`Calma ae, tem muitos comandos usando essa foto... T√¥ trocando aqui`)
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
logoslink.logo = res
fs.writeFileSync('./basededados/logos.json', JSON.stringify(logoslink, null, 2))
reply(`A foto do menu foi alterada com sucesso para: ${logoslink.logo}`)
} else {
reply(`Mande uma imagem com o comando ${prefix + command} para trocar a foto de todos menu...`)
}
break

case 'logomenu':
if(!isOwner) return reply(enviar.msg.dono)
if(!isQuotedImage) return reply("Marque uma imagem")
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) { 
reply(`Calma ae, tem muitos comandos usando essa foto... T√¥ trocando aqui`)
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
logoslink.menu = res
fs.writeFileSync('./basededados/logos.json', JSON.stringify(logoslink, null, 2))
reply(`A foto do menu principal foi alterada com sucesso para: ${logoslink.menu}`)
} else {
reply(`Mande uma imagem com o comando ${prefix + command} para trocar a foto do menu principal...`)
}
break

case 'logoping': case 'fundoping':
if(!isOwner) return reply(enviar.msg.dono)
if(!isQuotedImage) return reply("Marque uma imagem")
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) { 
reply(`Calma ae, j√° t√¥ trocando...`)
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
logoslink.ping = res
fs.writeFileSync('./basededados/logos.json', JSON.stringify(logoslink, null, 2))
reply(`A foto do ping foi alterada com sucesso para: ${logoslink.ping}`)
} else {
reply(`Mande uma imagem com o comando ${prefix + command} para trocar a foto do ping...`)
}
break

case 'prefixo-bot':
case 'setprefixs':
case 'setprefixo':
case 'setprefix':
case 'novoprefixo':
if(args.length < 1) return
if(!isOwner  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.dono)
setting.prefix = args[0]
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, 2))
reply(`Novo prefixo definido ( ${args[0]} )`)
break

case 'nomegp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
blackmd.groupUpdateSubject(from, `${body.slice(9)}`)
blackmd.sendMessage(from, {text: 'Sucesso, alterou o nome do grupo'}, {quoted: seloctt})
break

case 'fotobot':
if(!isOwner  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.dono)
if(!isQuotedImage) return reply(`Envie fotos com legendas ${prefix}fotobot ou tags de imagem que j√° foram enviadas`)
buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage, 'image')
blackmd.updateProfilePicture(botNumber, buff)
reply('Obrigado pelo novo perfilüòó')
break

case 'clonar':
if(!isOwner  && !isnit && !issupre && !ischyt) return reply('Voc√™ quem √© o propriet√°rio?')
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('Marque a pessoa que voc√™ quer clonar\n\n*EXEMPLO:* clone @')
if(!menc_jid2[0] || menc_jid2[1]) return reply("Marque o @ do usu√°rio para roubar a foto do perfil dele, para a do bot..")
let { jid, id, notify } = groupMembers.find(x => x.id === menc_jid2[0])
try {
pp = await blackmd.profilePictureUrl(id)
buffer = await getBuffer(pp)
blackmd.updateProfilePicture(botNumber, buffer)
mentions(`Foto do perfil atualizada com sucesso, usando a foto do perfil @${id.split('@')[0]}`, [id], true)
} catch (e) {
reply('Putz, deu erro, a pessoa deve estar sem foto üòî')
}
break

case 'envmsg':
if(!isOwner && !isnit) return
var [tx1, tx2] = q.split("/")
blackmd.sendMessage(tx1, {text: tx2})
break

case 'bcgp':
case 'bcgc':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply('Cade o texto?')
for(i of groupMembers) {
await sleep(1000)
var txt = `*${tempo.toUpperCase()}* ${getname(i.id)}

-> ${q}`
sendMess(i.id, txt)
}
break

case 'setpgp': case 'setcofc':
if(!isOwner) return reply(enviar.msg.dono)
if(command == "setpgp") {
obrigadoEXT.idprivategp = from
setObg(obrigadoEXT)
reply("Grupo privado atualizado ‚úÖ")
} else {
obrigadoEXT.idchatofc = from
setObg(obrigadoEXT)
reply("Chat oficial atualizado ‚úÖ")
}
break

case 'dono1':
case 'defcon5':
if(args.length < 1) return
if(!sender.includes(nmrdn) && !sender.includes(botNumber) && !ischyt) return reply(enviar.msg.dono)
if(q.length > 8) {
resp = "*„Äé DEFCON 5 ATIVADO „Äè* \n\n‚ö†Ô∏è *N√≠vel de seguran√ßa:* 1\nü§ç *Status de seguran√ßa:* ```Seguro```"
} else {
resp = "*„Äé DEFCON 5 DESATIVADO „Äè*"
}
obrigadoEXT.dono1 = q.trim()
dono1 = obrigadoEXT.dono1
setObg(obrigadoEXT)
reply(resp)
break

case 'dono2':
case 'defcon4':
if(args.length < 1) return
if(!sender.includes(nmrdn) && !sender.includes(botNumber) && !ischyt) return reply(enviar.msg.dono)
if(q.length > 8) {
resp = "*„Äé DEFCON 4 ATIVADO „Äè* \n\n‚ö†Ô∏è *N√≠vel de seguran√ßa:* 2\nüíö *Status de seguran√ßa:* ```Est√°vel```"
} else {
resp = "*„Äé DEFCON 4 DESATIVADO „Äè*"
}
obrigadoEXT.dono2 = q.trim()
dono2 = obrigadoEXT.dono2
setObg(obrigadoEXT)
reply(resp)
break

case 'dono3':
case 'defcon3':
if(args.length < 1) return
if(!sender.includes(nmrdn) && !sender.includes(botNumber) && !ischyt) return reply(enviar.msg.dono)
if(q.length > 8) {
resp = "*„Äé DEFCON 3 ATIVADO „Äè* \n\n‚ö†Ô∏è *N√≠vel de seguran√ßa:* 3\nüíõ *Status de seguran√ßa:* ```Alarmante```"
} else {
resp = "*„Äé DEFCON 3 DESATIVADO „Äè*"
}
obrigadoEXT.dono3 = q.trim()
dono3 = obrigadoEXT.dono3
setObg(obrigadoEXT)
reply(resp)
break

case 'dono4':
case 'defcon2':
if(args.length < 1) return
if(!sender.includes(nmrdn) && !sender.includes(botNumber) && !ischyt) return reply(enviar.msg.dono)
if(q.length > 8) {
resp = "*„Äé DEFCON 2 ATIVADO „Äè* \n\n‚ö†Ô∏è *N√≠vel de seguran√ßa:* 4\n‚ù§Ô∏è *Status de seguran√ßa:* ```Um passo da guerra```"
} else {
resp = "*„Äé DEFCON 2 DESATIVADO „Äè*"
}
obrigadoEXT.dono4 = q.trim()
dono4 = obrigadoEXT.dono4
setObg(obrigadoEXT)
reply(resp)
break

case 'dono5':
case 'defcon1':
if(args.length < 1) return
if(!sender.includes(nmrdn) && !sender.includes(botNumber) && !ischyt) return reply(enviar.msg.dono)
if(q.length > 8) {
resp = "*„Äé DEFCON 1 ATIVADO „Äè* \n\n‚ö†Ô∏è *N√≠vel de seguran√ßa:* 5\nüñ§ *Status de seguran√ßa:* ```Guerra nuclear```"
} else {
resp = "*„Äé DEFCON 1 DESATIVADO „Äè*"
}
obrigadoEXT.dono5 = q.trim()
dono5 = obrigadoEXT.dono5
setObg(obrigadoEXT)
reply(resp)
break

case 'dono6':
case 'defcon':
if(args.length < 1) return
if(!sender.includes(nmrdn) && !sender.includes(botNumber) && !ischyt) return reply(enviar.msg.dono)
if(q.length > 8) {
resp = `‚ö†Ô∏è *Ativa√ß√£o de DEFCONs confirmada...*
ü´° *Bem vindo (a)* wa.me/${q}`
} else {
resp = `‚ö†Ô∏è *Desativa√ß√£o de DEFCONs confirmada...*`
}
obrigadoEXT.dono6 = q.trim()
dono6 = obrigadoEXT.dono6
setObg(obrigadoEXT)
reply(resp)
break

case 'getquoted':
reply(JSON.stringify(info.message.extendedTextMessage.contextInfo, null, 3))
break

case 'donos':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
donos = `üëë ùôºùô¥ùöÇùöÉùöÅùô¥ ùöÇùöÑùôøùöÅùô¥ùôºùôæ ‚Ü¥
wa.me/${numerodono_ofc}

√ó DŒûF·èüœ¥Œù 5‚áí ${dono1}
√ó DŒûF·èüœ¥Œù 4‚áí ${dono2}
√ó DŒûF·èüœ¥Œù 3‚áí ${dono3}
√ó DŒûF·èüœ¥Œù 2‚áí ${dono4}
√ó DŒûF·èüœ¥Œù 1‚áí ${dono5}
√ó L√çDŒûR SUPŒûRIœ¥R ‚Ü¥
wa.me/${dono6}`
ttgp = isGroup ? groupMembers.length * groupAdmins.length + somembros.length : 6
horar = moment.tz('America/Sao_Paulo').format('HH:mm');
datar = moment.tz('America/Sao_Paulo').format('DD/MM');
sendUrlDoc(from, donos, 'application/pdf', `${horar}H ‚îã ${datar} üìÜ`, ttgp, NomeDoBot, '', 'https://telegra.ph/file/adad9b9a3606857e380be.jpg', `https://instagram.com/m4thxyz_`, seloctt)
break

case 'adms':
case 'admins':
case 'chamaradms':
setTimeout(() => {reagir(from, react2)}, 300)
blackmd.sendMessage(from, {text: `‚ö†Ô∏è *CHAMANDO TODOS OS ADMINS...*
${pushname} *solicita a vossa presen√ßa* üëÄ${q ? `\n\n*-> Recado:* _"${q}"_` : ``}`, mentions: groupAdmins}, {quoted: info})
break

case 'cases':
if(!isOwner) return reply("Voc√™ n√£o √© dono para utilizar este comando...")
try {
const listCases = () => {
const fileContent = fs.readFileSync("index.js").toString();
const caseNames = fileContent.match(/case\s+'(.+?)'/g);
if(caseNames) {
return caseNames.map((caseName, index) => `‚Ä¢ ${index + 1} -> ${caseName.match(/'(.+?)'/)[1]}`).join('\n');
} else {
reply("Nenhuma case encontrada.") } }
blackmd.sendMessage(from, { text: listCases() }, { quoted: seloctt });
} catch (e) {
console.log(e)
reply('Ocorreu um erro ao obter as cases.') }
break

case 'totalcmd':
try {
tc = "./database/data/totalcmd.json"
totalcmd = JSON.parse(fs.readFileSync(tc))
const fileContent = fs.readFileSync("index.js").toString();
const caseNames = fileContent.match(/case\s+'(.+?)'/g);
cont = caseNames.length
totalcmd[0].totalcmd = cont
saveJSON(totalcmd, tc)
reply(`üé≤ O bot possui atualmente ${cont} comandos „ÉÖ`)
} catch { reply("[ ‚ùó ] Erro ao obter o total de comandos ‚ùå") }
break

case 'criartabela': case 'criartbl': case 'criartab':
if(!isGroupAdmins && !isOwner) return reply("S√≥ adm ou dono pode utilizar este comando.")
if(!q.trim()) return reply("Digite o que deseja colocar na tabela do grupo..")
msgz = args.join(" ")
msgtmpol = moment.tz('America/Sao_Paulo').format('HH:mm:ss');
datinhaofc = moment.tz('America/Sao_Paulo').format('DD/MM/YY');
fs.writeFileSync(`./basedefuncionamento/tabela/tabela-${from}.json`,
JSON.stringify({Horario: msgtmpol, Data: datinhaofc, Tabela: msgz}, null, 2));
reply(`Tabela do grupo foi criada com sucesso..`)
break

case 'tabelagp': case 'tabeladogp': case 'tabelinha': 
if(!fs.existsSync(`./basedefuncionamento/tabela/tabela-${from}.json`)) {
reply(`Cade a tabela, cria ela com o comando\nExemplo : ${prefix}criartabela lindas do grupo : e etc ..`)
}
const tabelagpofc = JSON.parse(fs.readFileSync(`./basedefuncionamento/tabela/tabela-${from}.json`)); 
blity = `- ‚è∞ Hor√°rio que criou a Tabela : ${tabelagpofc.Horario}\n\n- üóìÔ∏è Data que criou a Tabela : ${tabelagpofc.Data}\n\n - Tabela : ${tabelagpofc.Tabela}`
mention(blity)
break

case 'infovip':
reply(`Ol√° ${pushname}, ${tempo.toLowerCase()}... J√° se perguntou como se tornar vip e ter acesso a√≠ comandos do menu vip exclusivamente pra vc ??

Bom, para tal fa√ßanha, √© necess√°rio pagar um valor de R$ ${Number(valoresVIP.vip).toFixed(2)} que ser√° referente a 30 dias de VIP. Voc√™ ter√° os seguintes direitos:
‚Ä¢ uso dos comandos do ${prefix}menuvip
‚Ä¢ uso do PV do bot quando o mesmo estiver bloqueado
‚Ä¢ alguns poderes de ADM
‚Ä¢ uso do gpt no PV
‚Ä¢ ${prefix}docfake em qualquer canto
‚Ä¢ fazer figurinha sem legenda
‚Ä¢ uso do menu +18 e seus comandos no PV
‚Ä¢ ganho de moedas no RPG

Caso se interessar, favor chamar meu dono no comando ${prefix}dono`)
break

case 'startpaid': case 'stoppaid':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.advip)
horarios2 = getGroupInPaid(from)
if(horarios2.start) {
horarios2.start = false
savePaid()
return reply(`O sistema de hor√°rios foi desativado com sucesso neste grupo üêÖ`)
} else {
horarios2.start = true
savePaid()
return reply(`O sistema de hor√°rios foi ativado com sucesso neste grupo üêØ`)
}
break

case 'addhorarios': case 'addhorario': case 'addpaid':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.advip)
if(!getGroupInPaid(from).start) return reply(`O sistema de hor√°rios est√° desativado... Caso queira usar, primeiro ligue eles usando ${prefix}startpaid üêØ`)
if(!q) return reply(`Retorne ap√≥s o comando o intervalo de tempo entre cada envio de slot, ex:
${prefix+command} 30m
ou
${prefix+command} 1h`)
nmr = q.slice(0, q.length - 1)
letra = q.slice(q.length - 1, q.length).toLowerCase()
if(letra != `h` && letra != `m`) return reply(`Use apenas horas ou minutos, ex: 30m ou 1h`)
if(!Number(nmr)) return reply(`"${nmr}" precisa ser um n√∫mero maior que zero`)
addPaid(from, q)
reply(`Hor√°rio pagante definido com sucesso üêØ`)
break

case 'fundohorario': case 'fundohorarios': case 'fundopaid':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.advip)
if(!getGroupInPaid(from).start) return reply(`O sistema de hor√°rios est√° desativado... Caso queira usar, primeiro ligue eles usando ${prefix}startpaid üêØ`)
ggip = getGroupInPaid(from)
if(!q || Number(q) !== 0) {
  if(!isImage && !isQuotedImage) return reply(`Marque uma image com o comando ${prefix+command}`)
  try {
    getinfoimg = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
    getfl = await getFileBuffer(getinfoimg, 'image')
    //fs.writeFileSync(`./basedefuncionamento/horarios/${from}.jpg`, getfl)
    uptele = await upload(getfl)
    ggip.fundoperso = true
    ggip.url = uptele//`./basedefuncionamento/horarios/${from}.jpg`
    savePaid()
    return reply(`O fundo dos hor√°rios foi atualizado para ${uptele} com sucesso ‚úî`)
    //return reply(`O fundo dos hor√°rios foi atualizado com sucesso ‚úî`)
  } catch(e) {
    console.log(e)
    reply(`N√£o foi poss√≠vel salvar a imagem... Tente novamente üêØ`)
  }
} else {
  if(Number(q) === 0) {
    ggip.fundoperso = false
    savePaid()
    rmGroupLinkInPaid(from)
    return reply(`O fundo personalizado dos hor√°rios foi deletado com sucesso ‚úî`)
  } else return reply(`Use ${prefix+command} [marque uma imagem] para personalizar o fundo dos hor√°rios pagantes e ${prefix+command} 0 para deletar a imagem salva.`)
}
break

case 'rmhorarios': case 'rmhorario': case 'rmpaid':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.advip)
if(!getGroupInPaid(from).start) return reply(`O sistema de hor√°rios est√° desativado... Caso queira usar, primeiro ligue eles usando ${prefix}startpaid üêØ`)
if(!q) return reply(`Retorne ap√≥s o comando o ID do hor√°rio pagante que voc√™ quer deletar`)
if(!isIDinPaid(from, q)) return reply(enviar.msg.notusu.replace(`usu√°rio`, `hor√°rio`))
rmPaid(from, q)
reply(`Hor√°rio pagante deletado com sucesso üêÖ`)
break

case 'listahorarios': case 'listahorario': case 'listpaid': case 'paidlist':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.advip)
if(!getGroupInPaid(from).start) return reply(`O sistema de hor√°rios est√° desativado... Caso queira usar, primeiro ligue eles usando ${prefix}startpaid üêØ`)
horarios2 = getGroupInPaid(from).horarios
if(horarios2.length <= 0) return reply(`N√£o h√° hor√°rios pagantes definidos neste grupo üêØ`)
reply(`üêØ *_Hor√°rios pagantes do grupo ${groupName}:_*
${horarios2.map(i => `üÜî *ID:* ${i.id}
‚è≥ *Intervalo de tempo:* ${String(i.nmr) + i.letra}
üçÄ *Pr√≥ximo hor√°rio:* ${i.tempo}`).join(`\n\n`)}`)
break

case 'attgrouplink': case 'atualizarfotoshorarios':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.advip)
if(!getGroupInPaid(from).start) return reply(`O sistema de hor√°rios est√° desativado... Caso queira usar, primeiro ligue eles usando ${prefix}startpaid üêØ`)
horarios3 = []
for(glp of groupLinkPaid) {
  if(!isJsonIncludes(horarios3, glp.id)) horarios3.push(glp)
}
saveJSON(horarios3, `./basedefuncionamento/horarios/grouplink.json`)
reply(`Database de fotos dos grupos/slots atualizada com sucesso üêØ`)
await sleep(700)
console.log(colors.green(`Restart necess√°rio para save de dados..`))
process.exit()
break

case 'attpaid': case 'atualizarhorarios':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.advip)
if(!getGroupInPaid(from).start) return reply(`O sistema de hor√°rios est√° desativado... Caso queira usar, primeiro ligue eles usando ${prefix}startpaid üêØ`)
horarios4 = []
for(p of paidHours) {
  if(p.horarios.length > 0) horarios4.push(p)
}
saveJSON(horarios4, `./basedefuncionamento/horarios/horarios.json`)
saveJSON([], `./basedefuncionamento/horarios/grouplink.json`)
reply(`Pasta de slots limpa e atualizada com sucesso üêØ`)
await sleep(700)
console.log(colors.green(`Restart necess√°rio para save de dados..`))
process.exit()
break

case 'ausente': case 'afk':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOnlyVip(sender)) return reply(enviar.msg.vip)
if(!q) return reply("Digite ap√≥s o comando o seu motivo de aus√™ncia")
if(JSON.stringify(ausentes).includes(sender)) {
AB = ausentes.map(i => i.id).indexOf(sender)
ausentes.splice(AB, 1)
saveJSON(ausentes, './basededados/ausentes.json')
}
await sleep(500)
ausentes.push({
id: sender,
nome: pushname,
dono: isOwner ? true : false,
motivo: q,
data: sendHours('DD/MM'),
hora: sendHours('HH:mm')
})
saveJSON(ausentes, './basededados/ausentes.json')
reply(`Ok ${isOwner ? 'mestre' : 'oh grande ser'}, a partir de agora ${isOwner ? 'o senhor' : 'voc√™'} est√° "${q}" üôáüèª‚Äç‚ôÇÔ∏è`)
break

case 'voltei': case 'on': case 'ativo': case 'acordei':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOnlyVip(sender)) return reply(enviar.msg.vip)
if(!JSON.stringify(ausentes).includes(sender)) return reply("N√£o h√° registros de aus√™ncia de sua parte")
AB = ausentes.map(i => i.id).indexOf(sender)
ausentes.splice(AB, 1)
saveJSON(ausentes, './basededados/ausentes.json')
reply("Bem vindo de volta üôáüèª‚Äç‚ôÇÔ∏è")
break

case 'servip':
if(!isOwner && !isSesc) return reply(enviar.msg.dono)
if(isJsonIncludes(vip, sender)) return reply(`Mas vc j√° √© VIP meu mestre üôáüèª‚Äç‚ôÇÔ∏è`)
addVip(sender, 0, true)
mention(`*Prontinho @${sender.split('@')[0]}... Agora voc√™ se tornou [ VIP ] meu mestre* üòç`)
break

case 'reagir':
const reactionMessage = {
react: {
text: "üíñ",
key: info.key
}
}
sendMsg = await blackmd.sendMessage(from, reactionMessage)
break

case 'addvip':
reagir(from, "ü§ë")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
barra = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/")
var [nmr, tempo50, mod] = barra.split('/')
if(!nmr || !tempo50) return reply(`Coloque o n√∫mero do indiv√≠duo e uma barra logo depois (/), ap√≥s isso, coloque a quantidade de dias que este ser√° VIP...
Ex: ${prefix+command} ${nmrdn.split('@')[0]}/30
Ou
Ex: ${prefix+command} ${nmrdn.split('@')[0]}/30/puxadas`)
usu = identArroba(nmr)
if(isInfinityVip(usu)) return reply(`N√£o ser√° poss√≠vel adicionar dias ao VIP deste usu√°rio, pois o mesmo possui o _"INFINITY VIP"_`)
isPux = mod && (mod.toLowerCase() === `puxadas` || mod.toLowerCase() === `consultas` || mod.toLowerCase() === `vip`) ? true : false
mention(Number(tempo50) > 0 ? isOnlyVip(usu) ?
`üëë ${tempo50} dia${Number(tempo50) > 1 ? `s` : ``} fo${Number(tempo50) > 1 ? `ram` : `i`} adicionado${Number(tempo50) > 1 ? `s` : ``} ao usu√°rio @${usu.split("@")[0]}` :
`üëë @${usu.split("@")[0]} foi adicionado √† lista VIP com sucesso...` :
`üëë @${usu.split("@")[0]} foi agraciado com o benef√≠cio do VIP infinito...`)
addVip(usu, tempo50, isPux)
break

case 'delvip':
reagir(from, "üòë")
if(!isOwner) return reply(enviar.msg.dono)
if(!marc_tds) return reply(`Marque o usu√°rio que deseja tirar da lista VIP ü§∑üèª‚Äç‚ôÇÔ∏è`)
if(!isOnlyVip(marc_tds)) return reply("*Este n√∫mero n√£o est√° incluso na lista vip..*")
delVip(marc_tds)
await sleep(500)
mention(`@${marc_tds.split("@")[0]} foi retirado da lista VIP... ü•≤`)
break

case 'addvipgp':
reagir(from, "ü§ë")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`Coloque a quantidade de dias que ser√° adicionado o VIP aos membros desse grupo
Ex: ${prefix+command} 30
Ou
Ex: ${prefix+command} 30/puxadas`)
if(isInfinityGroupVip(from)) return reply(`N√£o ser√° poss√≠vel adicionar dias ao VIP deste grupo, pois o mesmo possui o _"INFINITY VIP"_`)
var [dias, mod] = q.split("/")
i = Number(dias)
//if(!i) return reply(dias+" n√£o √© n√∫mero...")
if(i < 0) return reply("Retorne um n√∫mero maior que zero...")
isPux = mod && (mod.toLowerCase() === `puxadas` || mod.toLowerCase() === `consultas` || mod.toLowerCase() === `vip`) ? true : false
reply(i > 0 ? isOnlyGroupVip(from) ?
`+${i} dia${i > 1 ? "s" : ""} adicionado${i > 1 ? "s" : ""} ao VIP deste grupo üëë` :
`O grupo ${groupName} acaba de se tornar VIP por ${i} dia${i > 1 ? "s" : ""} üëë` :
`O grupo ${groupName} acaba de se tornar VIP infinitamente üëë`)
addGroupVip(from, i, isPux)
break

case 'delvipgp':
reagir(from, "üòë")
if(!isOwner) return reply(enviar.msg.dono)
grupo = q.length > 5 ? q : from
if(!isOnlyGroupVip(grupo)) return reply("*Este grupo n√£o est√° incluso na lista vip..*")
delGroupVip(grupo)
reply(`Coroa VIP retirada deste grupo ü•≤`)
break

//auto dw system

case 'autodw': case 'autodl':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
usu = getUsuAutoDW(sender).platforms
blackmd.sendMessage(from, {text:
`\t\t\t\tüì• *AUTO-DOWNLOAD* üì•

üë§ *Usu√°rio:* @${sender.split(`@`)[0]}
üéØ *Sistema Ativo (${getUsuAutoDW(sender).active ? `‚úÖ` : `‚ùå`})*
üîÅ *Multi Download (${getUsuAutoDW(sender).multidl ? `‚úÖ` : `‚ùå`})*

üìΩ *V√çDEO/√ÅUDIO* üéµ
‚õî *Youtube (${usu[0].youtube ? `‚úÖ` : `‚ùå`}) ‚îã √Åudio (${usu[0].audio ? `‚úÖ` : `‚ùå`})*
üöÆ *Facebook (${usu[1].facebook ? `‚úÖ` : `‚ùå`}) ‚îã √Åudio (${usu[1].audio ? `‚úÖ` : `‚ùå`})*
‚ò∏ *Instagram (${usu[2].instagram ? `‚úÖ` : `‚ùå`}) ‚îã √Åudio (${usu[2].audio ? `‚úÖ` : `‚ùå`})*
üï∂ *Tiktok (${usu[3].tiktok ? `‚úÖ` : `‚ùå`}) ‚îã √Åudio (${usu[3].audio ? `‚úÖ` : `‚ùå`})*
üïä *Twitter (${usu[4].twitter ? `‚úÖ` : `‚ùå`}) ‚îã √Åudio (${usu[4].audio ? `‚úÖ` : `‚ùå`})*

üìÉ *DOCUMENTO-VARIADO* üìÉ
‚ñ∂ *Mediafire (${usu[5].mediafire ? `‚úÖ` : `‚ùå`})*
üê± *Github (${usu[6].github ? `‚úÖ` : `‚ùå`})*
üîû *Xvideos (${usu[7].xvideos ? `‚úÖ` : `‚ùå`})*
üöª *XNXX (${usu[8].xnxx ? `‚úÖ` : `‚ùå`})*`, contextInfo: {mentionedJid: [sender], isForwarded: true, forwardingScore: 999}}, {quoted: seloctt})
break

case 'startautodl': case 'startautodw': case 'stopautodl': case 'stopautodw':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(getUsuAutoDW(sender).active) {
getUsuAutoDW(sender).active = false
saveAutoDW()
return reply(`*AUTODW* do usu√°rio desativado com sucesso ‚úñ`)
} else {
getUsuAutoDW(sender).active = true
saveAutoDW()
return reply(`*AUTODW* do usu√°rio ativado com sucesso ‚úî`)
}
break

case 'multidw': case 'multidl':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`√â necess√°rio ativar o auto dw primeiro... Use ${prefix}startautodw`)
if(getUsuAutoDW(sender).multidl) {
getUsuAutoDW(sender).multidl = false
saveAutoDW()
return reply(`*MULTIDL* do sistema de auto download desativado com sucesso ‚úñ`)
} else {
getUsuAutoDW(sender).multidl = true
saveAutoDW()
return reply(`*MULTIDL* do sistema de auto download ativado com sucesso ‚úî`)
}
break

case 'configautodw': case 'configautodl':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
usu = getUsuAutoDW(sender).platforms
botaoblk = [
  {title: `V√çDEO/√ÅUDIO`, options: [
    {name: `‚õî YOUTUBE`, title: `${!usu[0].youtube ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwyoutube`},
    {title: usu[0].audio ? `MUDAR PARA MODO V√çDEO` : `MUDAR PARA MODO √ÅUDIO`, body: `‚Ü™ Programado atualmente para enviar ${usu[0].audio ? `√°udio` : `v√≠deo`}...`, command: prefix+`audiodwyoutube`},
    {name: `üöÆ FACEBOOK`, title: `${!usu[1].facebook ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwfacebook`},
    {title: usu[1].audio ? `MUDAR PARA MODO V√çDEO` : `MUDAR PARA MODO √ÅUDIO`, body: `‚Ü™ Programado atualmente para enviar ${usu[1].audio ? `√°udio` : `v√≠deo`}...`, command: prefix+`audiodwfacebook`},
    {name: `‚ò∏ INSTAGRAM`, title: `${!usu[2].instagram ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwinstagram`},
    {title: usu[2].audio ? `MUDAR PARA MODO V√çDEO` : `MUDAR PARA MODO √ÅUDIO`, body: `‚Ü™ Programado atualmente para enviar ${usu[2].audio ? `√°udio` : `v√≠deo`}...`, command: prefix+`audiodwinstagram`},
    {name: `üï∂ TIKTOK`, title: `${!usu[3].tiktok ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwtiktok`},
    {title: usu[3].audio ? `MUDAR PARA MODO V√çDEO` : `MUDAR PARA MODO √ÅUDIO`, body: `‚Ü™ Programado atualmente para enviar ${usu[3].audio ? `√°udio` : `v√≠deo`}...`, command: prefix+`audiodwtiktok`},
    {name: `üïä TWITTER`, title: `${!usu[4].twitter ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwtwitter`},
    {title: usu[4].audio ? `MUDAR PARA MODO V√çDEO` : `MUDAR PARA MODO √ÅUDIO`, body: `‚Ü™ Programado atualmente para enviar ${usu[4].audio ? `√°udio` : `v√≠deo`}...`, command: prefix+`audiodwtwitter`}
  ]},
  {title: `DOCUMENTO-VARIADO`, options: [
    {name: `‚ñ∂ MEDIAFIRE`, title: `${!usu[5].mediafire ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwmediafire`},
    {name: `üê± GITHUB`, title: `${!usu[6].github ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwgithub`},
    {name: `üîû XVIDEOS`, title: `${!usu[7].xvideos ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwxvideos`},
    {name: `üöª XNXX`, title: `${!usu[8].xnxx ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwxnxx`}
  ]}
]
try { img = await blackmd.profilePictureUrl(from, 'image')
} catch { img = semfoto }
if(isGroup) reply(`Enviando PV üî∞`)
sendRouletteButton(sender, {image: {url: img}, caption: `Configura√ß√£o de downloads do sistema abaixo:`, footer: `Todos os downloads do bot...`}, blackmd, sender, [{type: `list`, title: `üí¢ CLIQUE AQUI üí¢`, rowId: botaoblk}], seloctt)
break

case 'autodwyoutube':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`√â necess√°rio ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[0].youtube) {
usu[0].youtube = false
saveAutoDW()
return reply(`AUTO DW do youtube DESATIVADO com sucesso ‚õî`)
} else {
usu[0].youtube = true
saveAutoDW()
return reply(`AUTO DW do youtube ATIVADO com sucesso ‚õî`)
}
break

case 'audiodwyoutube':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`√â necess√°rio ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[0].audio) {
usu[0].audio = false
saveAutoDW()
return reply(`AUTO DW do youtube definido para envio de V√çDEO ‚õî`)
} else {
usu[0].audio = true
saveAutoDW()
return reply(`AUTO DW do youtube definido para envio de √ÅUDIO ‚õî`)
}
break

case 'autodwfacebook':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`√â necess√°rio ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[1].facebook) {
usu[1].facebook = false
saveAutoDW()
return reply(`AUTO DW do facebook DESATIVADO com sucesso üöÆ`)
} else {
usu[1].facebook = true
saveAutoDW()
return reply(`AUTO DW do facebook ATIVADO com sucesso üöÆ`)
}
break

case 'audiodwfacebook':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`√â necess√°rio ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[1].audio) {
usu[1].audio = false
saveAutoDW()
return reply(`AUTO DW do facebook definido para envio de V√çDEO üöÆ`)
} else {
usu[1].audio = true
saveAutoDW()
return reply(`AUTO DW do facebook definido para envio de √ÅUDIO üöÆ`)
}
break

case 'autodwinstagram':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`√â necess√°rio ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[2].instagram) {
usu[2].instagram = false
saveAutoDW()
return reply(`AUTO DW do instagram DESATIVADO com sucesso ‚ò∏`)
} else {
usu[2].instagram = true
saveAutoDW()
return reply(`AUTO DW do instagram ATIVADO com sucesso ‚ò∏`)
}
break

case 'audiodwinstagram':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`√â necess√°rio ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[2].audio) {
usu[2].audio = false
saveAutoDW()
return reply(`AUTO DW do instagram definido para envio de V√çDEO ‚ò∏`)
} else {
usu[2].audio = true
saveAutoDW()
return reply(`AUTO DW do instagram definido para envio de √ÅUDIO ‚ò∏`)
}
break

case 'autodwtiktok':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`√â necess√°rio ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[3].tiktok) {
usu[3].tiktok = false
saveAutoDW()
return reply(`AUTO DW do tiktok DESATIVADO com sucesso üï∂`)
} else {
usu[3].tiktok = true
saveAutoDW()
return reply(`AUTO DW do tiktok ATIVADO com sucesso üï∂`)
}
break

case 'audiodwtiktok':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`√â necess√°rio ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[3].audio) {
usu[3].audio = false
saveAutoDW()
return reply(`AUTO DW do tiktok definido para envio de V√çDEO üï∂`)
} else {
usu[3].audio = true
saveAutoDW()
return reply(`AUTO DW do tiktok definido para envio de √ÅUDIO üï∂`)
}
break

case 'limpar2':
setTimeout(() => {reagir(from, "üóëÔ∏è")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
clearcmd = `üóëÔ∏è\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nüóëÔ∏è\n‚ù≤‚ùó‚ù≥ *L…™·¥ç·¥ò·¥á·¥¢·¥Ä ·¥Ö·¥á C ú·¥Ä·¥õ C·¥è…¥·¥Ñ ü·¥ú…™ÃÅ·¥Ö·¥Ä* ‚úÖ`
blackmd.sendMessage(from, {text: clearcmd}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
break

case 'limpar':
setTimeout(() => {reagir(from, "üóëÔ∏è")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
clear = `„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§
\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§
Ô∏è`
clear2 = `„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nüóëÔ∏è\n‚ù≤‚ùó‚ù≥ *L…™·¥ç·¥ò·¥á·¥¢·¥Ä ·¥Ö·¥á C ú·¥Ä·¥õ C·¥è…¥·¥Ñ ü·¥ú…™ÃÅ·¥Ö·¥Ä* ‚úÖ`
reply(`*GRUPO FECHADO PARA LIMPEZA* üóëÔ∏è`)
blackmd.groupSettingUpdate(from, 'announcement')
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 1000)//msg 1
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 4000)//msg 2
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 7000)//msg 3
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 10000)// msg 4
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 13000)//msg 5
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 16000)//msg 6
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 19000)//msg 7
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 22000)//msg 8
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 25000)//msg 9
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear2})
}, 28000)//msg 10
setTimeout(async() => {
blackmd.sendMessage(from, {text: `*LIMPEZA CONCLU√çDA* ‚úÖ`})
blackmd.groupSettingUpdate(from, 'not_announcement')
}, 30000)
break

case 'deletar': case 'delete': case 'd':
setTimeout(() => {reagir(from, "üóëÔ∏è")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins && !isVip) return reply(`Mensagem apagada com sucesso... Somente voc√™ est√° vendo agora ${pushname} üòâ`)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!menc_prt) return reply("Marque a mensagem do usu√°rio que deseja apagar, do bot ou de algu√©m..")
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.message.extendedTextMessage.contextInfo.stanzaId, participant: menc_prt}})
break

case 'deletareu': case 'deleteandme': case 'dam':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins && !isVip) return reply("[ ‚ùó ] S√≥ ADM ou VIP ‚ùå")
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!menc_prt) return reply("Marque a mensagem do usu√°rio que deseja apagar, do bot ou de algu√©m..")
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.message.extendedTextMessage.contextInfo.stanzaId, participant: menc_prt}})
setTimeout(async() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1000)
break

case 'fundobemvindo':
case 'fundobv':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedVideo ) && !q.length <= 1) {
boij = isQuotedImage || isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
dataGp[0].wellcome[0].fundobemvindo = res
setGp(dataGp)
txt = `üôáüèª‚Äç‚ôÇÔ∏è *Chefia que manda... O fundo do bemvindo foi alterado com sucesso para ‚Ü¥*

${res}`
sendUrlText(from, txt, NomeDoBot, ``, res, res, seloctt)
} else reply('Voc√™ deve marcar uma imagem com esse comando, se n√£o for de primeira, tente novamente, ok? ')
break

case 'fundosaiu':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedVideo ) && !q.length <= 1) {
boij = isQuotedImage || isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
dataGp[0].wellcome[0].fundosaiu = res
setGp(dataGp)
txt = `üôáüèª‚Äç‚ôÇÔ∏è *Chefia que manda... O fundo de sa√≠da foi alterado com sucesso para ‚Ü¥*

${res}`
sendUrlText(from, txt, NomeDoBot, ``, res, res, seloctt)
} else reply('Voc√™ deve marcar uma imagem com esse comando, se n√£o for de primeira, tente novamente, ok? ')
break

case 'fundobemvindo5':
case 'fundobv5':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if((isMedia && info.message.videoMessage.seconds < 30 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 30) && !q.length <= 1) { 
boij = isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.videoMessage : info.message.videoMessage
owgi = await getFileBuffer(boij, 'video')
res = await upload(owgi)
dataGp[0].wellcome[4].fundobemvindo = res
setGp(dataGp)
txt = `üôáüèª‚Äç‚ôÇÔ∏è *Chefia que manda... O fundo do bemvindo5 foi alterado com sucesso para:* ${res}`
} else reply('Voc√™ deve marcar um v√≠deo de at√© 30s com esse comando... Se n√£o for de primeira, tente novamente, ok? ')
break

case 'fundosaiu5':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if((isMedia && info.message.videoMessage.seconds < 30 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 30) && !q.length <= 1) { 
boij = isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.videoMessage : info.message.videoMessage
owgi = await getFileBuffer(boij, 'video')
res = await upload(owgi)
dataGp[0].wellcome[4].fundosaiu = res
setGp(dataGp)
txt = `üôáüèª‚Äç‚ôÇÔ∏è *Chefia que manda... O fundo de sa√≠da5 foi alterado com sucesso para:* ${res}`
} else reply('Voc√™ deve marcar um v√≠deo de at√© 30s com esse comando... Se n√£o for de primeira, tente novamente, ok? ')
break

case 'anticall':
case 'antiligar':
case 'antiligacao':  
case 'antiliga√ß√£o':  
if(!isOwner) return reply(enviar.msg.dono)
if(!isAnticall) {
obrigadoEXT.anticall = true
setObg(obrigadoEXT)
reply(`üìû *ANTI CALL* foi ativado... Qualquer usu√°rio que ligar pro bot ser√° bloqueado üìµ`)
} else if(isAnticall) {
obrigadoEXT.anticall = false
setObg(obrigadoEXT)
reply(`üìû modo *ANTI CALL* desativado com sucesso üìµ`)
}
break

case 'antipv':  
if(!isOwner) return reply(enviar.msg.dono)
if(!isAntiPv) {
obrigadoEXT.antipv = true
setObg(obrigadoEXT)
reply(`‚ô®Ô∏è Modo *ANTI PV BLOCK* ativado... Usu√°rios ser√£o bloqueados caso mandem mensagem no PV do bot üòà`)
} else if(isAntiPv) {
obrigadoEXT.antipv = false
setObg(obrigadoEXT)
reply(`üöø Modo *ANTI PV BLOCK* desativado... Usu√°rios j√° podem enviar mensagem no PV do bot normalmente üòá`)
}
break

case 'antipv2':
if(!isOwner) return reply(enviar.msg.dono)
if(!isAntiPv2) {
obrigadoEXT.antipv2 = true
setObg(obrigadoEXT)
reply("‚úÖ Modo anti PV ativado com sucesso... Quem tentar usar o PV receber√° um aviso ‚ö†Ô∏è")
} else if(isAntiPv2) {
obrigadoEXT.antipv2 = false
setObg(obrigadoEXT)
reply("üö´ Modo anti PV desativado... O PV est√° liberado ao uso de usu√°rios comuns üòÇ")
}
break

case 'whatsblock':
if(!isOwner) return reply(enviar.msg.dono)
if(menc_os2.includes(sender)) return
blackmd.updateBlockStatus(menc_os2, 'block')
reply('Usu√°rio bloqueado com sucesso!')
break

case 'whatsunblock':
if(!isOwner) return reply(enviar.msg.dono)
if(menc_os2.includes(sender)) return
blackmd.updateBlockStatus(menc_os2, 'unblock')
reply('Usu√°rio desbloqueado com sucesso!')
break

case 'block': case 'bloquear':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`Marque o usu√°rio que voc√™ bloquear de usar o bot, exemplo: ${prefix+command} ${addNumberMais(sender)}

Se fores bloquear o usu√°rio por um tempo limitado, defina o tempo ap√≥s a barra, ex: ${prefix+command} ${addNumberMais(sender)}/1d`)
var [idusu, tempoblock] = q.split(`/`)
usu = identArroba(idusu)
if(tempoblock) {
letra = tempoblock.slice(tempoblock.length - 1, tempoblock.length).toLowerCase()
nmr = tempoblock.slice(0, tempoblock.length - 1)
if(letra != `m` && letra != `h` && letra != `d`) return reply(`Use um tempo v√°lido, h, m ou d, ex: ${prefix+command} ${addNumberMais(sender)}/12h`)
if(Number(nmr) <= 0) return reply(`Apenas n√∫meros`)
}
banirUsuario(usu, tempoblock)
mention(`O usu√°rio @${usu.split("@")[0]} foi bloqueado ${tempoblock && Number(nmr) > 0 ? `por *${tempoblock}*` : `para *sempre*`} de usar os comandos do bot üö´`)
break

case 'unblock': case 'desbloquear':
if(!isOwner) return reply(enviar.msg.dono)
if(!marc_tds) return reply(`Marque o usu√°rio que voc√™ desbloquear para usar o bot, exemplo: ${prefix+command} ${addNumberMais(sender)}`)
if(!isBanned(marc_tds)) return reply(`Este usu√°rio n√£o est√° bloqueado...`)
desbanirUsuario(marc_tds)
mention(`O usu√°rio @${marc_tds.split("@")[0]} foi desbloqueado com sucesso para usar os comandos do bot ‚úî`)
break

case 'blocklist':
if(!isOwner) return reply(enviar.msg.dono)
if(banned.length <= 0) return reply(`N√£o h√° usu√°rios bloqueados... Caso queira bloquar algu√©m use ${prefix}block`)
mention(`üö´ *_Lista de usu√°rios bloqueados no bot:_*
${banned.map(i => `üë§ *Usu√°rio:* @${i.id.split(`@`)[0]}
‚è≥ *Tempo:* ${i.infinity ? `bloqueado para sempre` : `bloqueado por ${i.tempo > 1440 ? `${(i.tempo / 1440).toFixed(0)}d` : i.tempo > 60 ? `${(i.tempo / 60).toFixed(0)}h` : `${i.tempo}m`}`}`).join(`\n\n`)}`)
break

case 'execut':
if(!isOwner  && !isnit && !issupre && !ischyt) return
try{
return eval(`(async() => { ${args.join(' ')}})()`)
} catch (e) {
blackmd.sendMessage(from, {text:`${e}`})
}
break

case 'exec':
if(!isOwner  && !isnit && !issupre && !ischyt) return
try{
paramsQuoted = info.message.extendedTextMessage.contextInfo.quotedMessage.conversation || info.message.extendedTextMessage.contextInfo.quotedMessage.extendedTextMessage.text;	
return eval(`${paramsQuoted}`)
console.log(`[EXEC]~> ${paramsQuoted}`)
}catch(e){
reply(e)
}
break

case 'contar':
if(!q.includes("/")) return reply(`Ex: ${prefix+command} 01/01/2025`)
replicar = ``
for(i of q) {
  if(i != " ") replicar += i
}
if(!Number(contarDias(replicar))) return reply(contarDias(replicar))
day = contarDias(replicar) - contarDias(sendHours("DD/MM/YYYY"))
if(day == 0) return reply(`‚ùå _Erro, √© necess√°rio ao menos 1 dia de diferen√ßa..._`)
if(day < 0) {
nmr = day + ((0 - day) * 2)
reply(`‚ú® _A diferen√ßa de tempo entre ${replicar} e ${sendHours("DD/MM/YYYY")} √© de ‚Ü¥_
_‚áí ${nmr > 1 ? converterDias(nmr) : sendTimeDay(nmr)}_`)
} else reply(`‚ú® _A diferen√ßa de tempo entre ${sendHours("DD/MM/YYYY")} e ${replicar} √© de ‚Ü¥_
_‚áí ${day > 1 ? converterDias(day) : sendTimeDay(day)}_`)
break

case 'morse': case 'morsa':
if(!isGroup) return reply(enviar.msg.grupo)
if(!q) return reply(`Digite uma frase para transformar em c√≥digo morse`)
if(antiModLetra(q)) return reply("N√£o pode letras modificadas nem emoji..")
if(q.length > 40) return reply(`Texto grande demais`)
reply(`${morse(q)}`)
break

case 'sender':
bla = isGroup ? info.key.participant : info.key.remoteJid
reply(bla)
break

case 'meunumero':
case 'meunmr':
setTimeout(() => {reagir(from, react2)}, 300)
reply(`${sender.split('@')[0]}`)
break

case 'meunmrwa':
setTimeout(() => {reagir(from, react2)}, 300)
reply(`wa.me/${sender.split('@')[0]}`)
break

case 'meunome':
setTimeout(() => {reagir(from, react2)}, 300)
reply(pushname)
break

case 'abc':
  blackmd.sendMessage(from, {image: {url: './basededados/imagem/imgmenu.jpg'}, caption: 'caso queira uma descri√ß√£o'}, {quoted: seloctt})
break

case 'figuteste':
blackmd.sendMessage(from, {sticker: {url: './database/logos/figu1.webp'}}, {quoted: seloctt})
break

case 'figuteste2':
enviarfigu(`./database/figu/teste.webp`)
break

case 'txt1':
reply(args[0])
break

case 'txt2':
reply(args[1])
break

case 'txt3':
reply(args[2])
break

case 'mark1':
if(!isOwner) return reply(enviar.msg.dono)
if(!menc_os2) return reply(`Marque algu√©m`)
blackmd.sendMessage(from, {text: `${tempo} @${menc_os2.split('@')[0]}`, mentions: [menc_os2]})
break

case 'mark2':
if(!isOwner) return reply(enviar.msg.dono)
if(!menc_prt) return reply(`Marque algu√©m`)
blackmd.sendMessage(from, {text: `${tempo} @${menc_prt.split('@')[0]}`, mentions: [menc_prt]})
break

case 'mark3':
if(!isOwner) return reply(enviar.msg.dono)
blackmd.sendMessage(from, {text: `${tempo} @${sender_ou_n.split('@')[0]}`, mentions: [sender_ou_n]})
break

case 'doc':
if(!isOwner) return reply(`Ainda n√£o `)
blackmd.sendMessage(from, {
   document: Buffer.from('oi curioso'),
   caption: 'Coloca texto do menu aqui',
   mimetype: 'application/vnd.openxmlformats-officedocument.presentationml.presentation', // Formato
   fileLength: 1000000 * 250, // Tamanho (250mb)
   jpegThumbnail: await getBuffer('https://paginalixo.com/wp-content/uploads/2021/08/hqdefault.jpg'), // Outra foto
   contextInfo: {
    externalAdReply: {
      title: 'Titulo',
      body: 'Nome em baixo',
      mediaType: 1,
      thumbnail: await getBuffer('https://paginalixo.com/wp-content/uploads/2021/08/hqdefault.jpg'), // s√≥ pega imagens at√© 300x300 
      showAdAttribution: false, // Coloca true para enviada como an√∫ncio 
      renderLargerThumbnail: true, // Deixa a imagem grande
      sourceUrl: 'https://chat.whatsapp.com/HPnSch30OWiBCCLH4ysDvj' // Link que aparece quando aperta
    }
  }
}, {quoted:selo})
break
case 'transcrever':
case 'totext': {//Adapted By Gerson
  var quotedMessage = info?.message?.extendedTextMessage?.contextInfo?.quotedMessage;
  if(!quotedMessage || !quotedMessage?.audioMessage) return reply("Por favor, marque um √°udio e depois envie o comando para realizar a transcri√ß√£o.");

  // Verifica o tamanho do arquivo de √°udio (limite de 2MB)
  if(quotedMessage.audioMessage.fileLength > 2100000) return reply("S√≥ transcrevo √°udios de at√© 2MB. Por favor, envie um √°udio menor.");

  // Notifica o usu√°rio que o √°udio est√° sendo transcrito
  let { key } = await blackmd.sendMessage(from, {text: `‚úçüèΩ _Transcrevendo √°udio... Aguarde um momento_ ‚è±Ô∏è`}, {quoted: info});

  try {
    // Obtendo o buffer do √°udio citado
    var mediaData = await downloadContentFromMessage(quotedMessage.audioMessage, 'audio');
    let bufferArray = [];
    for await (var chunk of mediaData) {
      bufferArray.push(chunk);
    }
    var audioBuffer = Buffer.concat(bufferArray);

    // Escreve o arquivo de √°udio no sistema de arquivos tempor√°rio
    var audioFilePath = `./armor/assets/translate/totext-${sender}.mp3`;
    fs.writeFileSync(audioFilePath, audioBuffer);

    // Upload do arquivo de √°udio
    var uploadResponse = await axios.post('https://api.assemblyai.com/v2/upload', audioBuffer, {
      headers: {
        'authorization': assemblyApiKey,
        'content-type': 'application/octet-stream'
      }
    });

    var audioUrl = uploadResponse.data.upload_url;

    // Solicitar a transcri√ß√£o do √°udio em portugu√™s
    var transcriptResponse = await axios.post('https://api.assemblyai.com/v2/transcript', {
      audio_url: audioUrl,
      speaker_labels: true,
      language_code: 'pt'  // Define o idioma como portugu√™s
    }, {
      headers: {
        'authorization': assemblyApiKey,
        'content-type': 'application/json'
      }
    });

    var transcriptId = transcriptResponse.data.id;

    // Verificar o status da transcri√ß√£o
    let transcriptStatus = 'processing';
    let transcriptData;
    while(transcriptStatus === 'processing') {
      var statusResponse = await axios.get(`https://api.assemblyai.com/v2/transcript/${transcriptId}`, {
        headers: {
          'authorization': assemblyApiKey
        }
      });

      transcriptData = statusResponse.data;
      transcriptStatus = transcriptData.status;

      if(transcriptStatus === 'failed') {
        throw new Error("A transcri√ß√£o falhou.");
      }

      // Espera alguns segundos antes de verificar o status novamente
      if(transcriptStatus === 'processing') {
        await new Promise(resolve => setTimeout(resolve, 3000));
      }
    }

    // Responde ao usu√°rio com a transcri√ß√£o
    if(transcriptData.text) {
      blackmd.sendMessage(from, {text: transcriptData.text, edit: key}, {quoted: info})
    }
  } catch (error) {
    console.error("Erro ao transcrever o √°udio:", error);
    blackmd.sendMessage(from, {text: `[‚ùó] Erro, n√£o foi poss√≠vel transcrever o √°udio ‚ùå`, edit: key}, {quoted: info})
    reply("Houve um erro ao transcrever o √°udio. Tente novamente mais tarde.");
  } }
  break;

case 'ping':
  reagir(from, "‚ö°");
  r = (Date.now() / 1000) - info.messageTimestamp;
  uptime = process.uptime();
  ping = r.toFixed(3);
  
  if(ping < 0) stts = `lento`;
  if(ping >= 0) stts = `est√°vel`;
  if(ping >= 1) stts = `bom`;
  if(ping >= 3) stts = `ruim`;
  if(ping >= 10) stts = `extremamente lento`;

  try { 
    ppimg = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image'))}`)).data;
  } catch(e) { 
    ppimg = semfoto;
  }

  hex = `FF0000`;
  host = `TERMUX / HOST WEB`;
  img = `https://blacksystemofc.com.br/api/canvas/welcomify/welcome?`;
  img += `title=${encodeURI(`THE EVOLUTION`)}&`;
  img += `nome=${encodeURI(`¬ª ${String(ping)} ¬´`)}&hex=${hex}&`;
  img += `perfil=${ppimg}&`;
  img += `message=${encodeURI(`Lady bot v5`)}&fundo=` + logoslink.ping;

  txt = `‚ö° ùöÖùöéùöïùöòùöåùöíùöçùöäùöçùöé„Äò ${String(ping)} „Äô
  ‚úçüèΩ ùôøùöíùöóùöê‚áí ${stts}
  üíª ùöÇùöéùöõùöüùöíùöçùöòùöõ‚áí ${host}
  üóìÔ∏è ùô≥ùöäùöùùöä & ùô∑ùöòùöõùöä
  ‚áí${sendHours("DD/MM/YYYY")}„Ö§‚îã„Ö§${sendHours("HH:mm:ss")}
  ‚åö ùöÉùöéùöñùöôùöò ùô∞ùöùùöíùöüùöò
  ‚áí${kyun(uptime)}`;

  sendImage(from, img, txt, seloblk);
  break;

case 'ping2': 
const os = require("os");
{
blackmd.sendMessage(from, { react: { text: `‚ö°`, key: info.key }})
r = (Date.now() / 1000) - info.messageTimestamp
uptime = process.uptime()
var getGroups = await asuna.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
const ingfoo = groups.map(v => v)
respon = `‚ö° *Velocidade:* ${String(r.toFixed(3))} _ms_\n‚è±Ô∏è *Uptime:* ${kyun(uptime)}\nüíª *Sistema:* ${os.type()}\nüìÅ *Vers√£o:* ${os.release()}\n‚ÑπÔ∏è *Total de Grupos:* ${ingfoo.length}\nüíæ *Memoria RAM total:* ${(os.totalmem()/Math.pow(1024, 3)).toFixed(2)}GB\nüíæ *RAM dispon√≠vel:* ${(os.freemem()/Math.pow(1024, 3)).toFixed(2)}GB\nüìâ *Uso de mem√≥ria RAM:* ${((os.totalmem() - os.freemem()) / os.totalmem() * 100).toFixed(2)}%\nüìà *Uso da CPU (atual):* ${os.loadavg()[0].toFixed(2)}%`.trim()
await blackmd.sendMessage(from, { image: { url: `https://oillater.sirv.com/Picsart_23-12-03_22-49-09-032.jpg?text.0.text=${String(r.toFixed(3))}&text.0.position.gravity=northwest&text.0.position.x=12%25&text.0.position.y=65%25&text.0.size=29&text.0.color=ffffff&text.0.font.family=Teko&text.0.font.weight=600&text.0.background.opacity=100` }, caption: respon}, {quoted: info}) 
}
break

case 'gtts':
try {
if (args.length < 1) return blackmd.sendMessage(from,{text: `Cade o texto?, digite algo Exemplo:\n${prefix}gtts PT Oi`}, {quoted: seloctt})
const gtts = require('./armor/funcoes/gtts')(args[0])
if (args.length < 2) return blackmd.sendMessage(from, {text: 'Falta colocar o c√≥digo do idioma!'}, {quoted: seloctt})
dtt = body.slice(8)
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
if(dtt.length > 200) return reply('Para reduzir spam o m√°ximo de letras permitidas s√£o 200!')
gtts.save(ranm, dtt, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
blackmd.sendMessage(from, {audio: fs.readFileSync(ranm), ptt:true, mimetype: "audio/mp4"}, {quoted: seloctt}).catch(e => {
return reply("Erro..")
})
DLT_FL(ranm)
DLT_FL(rano)
})
})
} catch {
return reply("Erro..")
}
break

case 'tagme':
mention(`@${sender.split("@")[0]} ‚ú®`)
break

case 'addstopcmd':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply("KD o comando que tu quer enviar pro block global?")
if(q.includes(prefix)) return reply(`Ex: ${prefix+command} menu`)
qp = rmLetras(q)
if(isBlockGlobalCmd(qp)) return reply(enviar.stopcmd.isblock)
addStopCmd(qp)
reply(`O comando„Äé ${prefix+qp} „Äèfoi adicionado a lista com sucesso... Caso queira bloquear/desbloquear os comandos da lista, use ${prefix}stopcmd`)
break

case 'rmstopcmd':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply("KD o comando que tu quer remover do block global?")
qp = rmLetras(q)
if(!isBlockGlobalCmd(qp)) return reply(enviar.stopcmd.notblock)
rmStopCmd(qp)
reply(`O comando„Äé ${prefix+qp} „Äèfoi removido da lista com sucesso... Caso queira bloquear/desbloquear os comandos da lista, use ${prefix}stopcmd`)
break

case 'stopcmd':
if(!isOwner) return reply(enviar.msg.dono)
if(isStopCmd) {
obrigadoEXT.stopcmdlist = true
setObg(obrigadoEXT)
reply(`‚ô®Ô∏è Bloqueio de comandos ativado üòà`)
} else {
obrigadoEXT.stopcmdlist = false
setObg(obrigadoEXT)
reply(`‚ô®Ô∏è Bloqueio de comandos desativado üòá`)
}
break

case 'stopcmdlist':
if(!isOwner) return reply(enviar.msg.dono)
txt = `üñêüèΩüò™ _Lista de comandos bloqueados globalmente:_`
for(i of stopcmd) {
txt += `\n${prefix+i}`
}
txt += `\n\n*Total:* ${stopcmd.length}`
reply(txt)
break

case 'addlimitcmd':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(contar(q, `|`) != 1) return reply("KD o comando que tu quer enviar pro limite? Ex:\n"+prefix+command+" totag|10")
if(q.includes(prefix)) return reply(`Ex: ${prefix+command} sticker|20`)
var [a, b] = q.replace(`| `, `|`).replace(` |`, `|`).replace(` | `, `|`).split(`|`)
qp = rmLetras(a)
if(Number(b) <= 0) return reply(`A quantidade de uso do comando precisa ser maior que 0`)
txt = isLimitCmd(from, qp).boolean ? `+${b} de limite foi adc ao comando *${prefix+a}* com sucesso ü•∞` : `O comando *${prefix+a}* foi adicionado a lista de limite com sucesso ü•∞`
addLimitCmd(from, qp, b)
reply(txt)
break

case 'rmlimitcmd':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!q) return reply("KD o comando que tu quer enviar pro limite? Ex:\n"+prefix+command+" totag")
qp = rmLetras(q)
if(!isLimitCmd(from, qp).boolean) return reply(`Este comando n√£o est√° na lista...`)
rmLimitCmd(from, qp);
reply(`Comando removido da lista com sucesso...`)
break

case 'addlimitallcmd':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(Number(q) <= 0) return reply(`EX: ${prefix+command} 10`)
nmr = 0
for(i of allCases) {
  if(i.length < 20) addLimitCmd(from, i, q)
  nmr += 1
}
reply(`Todos os ${largeNumber(nmr)} comandos do bot foram adc a lista de limitcmd com um limite de um ${q} usos por dia...`)
break

case 'rmlimitallcmd':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
rmLimitAllCmd(from)
reply(`A lista de comandos limitados deste grupo foi zerada com sucesso...`)
break

case 'limitcmdlist':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
data = getLimitCmd(from)
if(data.length <= 0) return reply(`N√£o h√° comandos na lista...`)
txt = `üé≤ *Total:* ${data.length}

üßÆ *Lista:*
${data.map(i => `‚Ä¢ *Comando:* ${prefix+i.nome}
‚Ä¢ *Usado:* ${i.usado}/${i.max}`).join(`\n-\n`)}`
reply(txt)
break

case 'modoaluguel':
if(!isOwner) return reply(enviar.msg.dono)
if(!isModRent) {
obrigadoEXT.modoaluguel = true
setObg(obrigadoEXT)
reply(`‚úîÔ∏è Modo aluguel ativado com sucesso... Sairei dos grupos que n√£o estiverem salvos „Ä∞Ô∏è`)
} else {
obrigadoEXT.modoaluguel = false
setObg(obrigadoEXT)
reply(`‚úñÔ∏è Modo aluguel desativado com sucesso... Assino minha perman√™ncia nos grupos ‚ûø`)
}
break

case 'blockcmd':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner  && !isnit) return reply(enviar.msg.dono)
tp = args.join(" ")
if(tp.includes("blockcmd blockcmd") || (tp.includes("blockcmd  blockcmd"))) return reply(`T√° louco maluco?, Quer banir o comando de bloquear comando?`)
if(getComandoBlock(from).includes(args[0]))return reply('Este comando j√° est√° blockeado')
addComandos(from, args[0])
reply(`*O comando„Äé* ${args[0]} *„Äèfoi bloqueado com sucesso... Usu√°rios est√£o proibidos de usar o mesmo* ü´°`)
break

case 'unblockcmd':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner  && !isnit) return reply(enviar.msg.dono)
tp = args.join(" ")
if(tp.includes("blockcmd unblockcmd") || (tp.includes("blockcmd  unblockcmd"))) return reply(`T√° louco maluco?, Quer banir o comando de desbloquear comando?`)  
if(!getComandoBlock(from).includes(args[0]))return reply('Este comando j√° est√° desbloqueado')
deleteComandos(from, args[0])
reply(`*O comando„Äé* ${args[0]} *„Äèfoi desbloqueado com sucesso... Agora todos os usu√°rios poder√£o usar o mesmo* üòÉ`)
break

case 'listacomandos':
setTimeout(() => {reagir(from, "üö´")}, 300)
tkks = `üö´ *Comandos bloqueados no grupo ‚Ü¥*
‚áí ${groupName}\n\n`
for (let V of getComandoBlock(from)) {
tkks += `√ó ${prefix+V}\n`
}
tkks += `\n„Ö§ _Total:_ ${getComandoBlock(from).length}\n„Ö§„Ö§ *By:* ${NomeDoBot}`
blackmd.sendMessage(from, {text: tkks.trim()}, {quoted: seloctt})
break

case 'globalblacklist':
setTimeout(() => {reagir(from, "üö´")}, 300)
gcmd = JSON.parse(fs.readFileSync("./dono/necessario.json"))
if(!gcmd.listanegraG) return reply(`N√£o h√° ningu√©m na lista...`)
tkks = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n‚ïü ‚Ä¢ _Usu√°rios bloqueados globalmente_\n‚ïë\n`
for (let V of gcmd.listanegraG) {
tkks += `‚ïü ‡≥à·çùÕ°Õúüö´ ${V} \n‚ïë\n`
}
tkks += `‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£ *_Total:_* ${gcmd.listanegraG.length} üò°`
blackmd.sendMessage(from, {text: tkks.trim()}, {quoted: seloctt})
break

case 'avalie': case 'avaliacao':
reagir(from, "‚ú®")
but = [{title: `‚ú¶‚ú¶‚ú¶‚ú¶‚ú¶`, body: `Perfeito`, command: prefix+command+` 5`},
{title: `‚ú¶‚ú¶‚ú¶‚ú¶‚úß`, body: `Muito bom`, command: prefix+command+` 4`},
{title: `‚ú¶‚ú¶‚ú¶‚úß‚úß`, body: `Bom`, command: prefix+command+` 3`},
{title: `‚ú¶‚ú¶‚úß‚úß‚úß`, body: `Ruim`, command: prefix+command+` 2`},
{title: `‚ú¶‚úß‚úß‚úß‚úß`, body: `Muito ruim`, command: prefix+command+` 1`},
{title: `‚úß‚úß‚úß‚úß‚úß`, body: `P√©ssimo`, command: prefix+command+` 0`}]
if(!q || Number(q) < 1 || Number(q) > 5 || q.includes(".")) return sendListB(from, {text: `${tempo} @${sender.split("@")[0]}, est√° gostando dos nossos servi√ßos?`, mentions: [sender], footer: NomeDoBot}, blackmd, sender, `„Äò ùóîùó©ùóîùóüùóúùóò „Äô`, [{title: `Avalie o bot de 0-5`, options: but}], seloctt)
star = `‚ú¶`.repeat(6 - Number(q)) + `‚úß`.repeat(Number(q) - 1)
txt = `[ Avalia√ß√£o ]
*De:* wa.me/${sender.split("@s.whatsapp.net")[0]}
${pushname} *avaliou seu bot ‚Ü¥*
‚áí ${q} estrela${Number(q) !== 1 ? `s` : ``}`
sendMess(nmrdn, txt)
await sleep(1000)
reply("Mensagem enviada ao meu dono, obrigado pela avalia√ß√£o, iremos melhorar a cada dia...")
break

case 'bug':
setTimeout(() => {reagir(from, "üíæ")}, 300)
const bug = body.slice(5)
if(args.length <= 1) return reply(`Exemplo: ${prefix}bug "ocorreu um erro no comando sticker"`)
if(args.length >= 800) return blackmd.sendMessage(from, {text: 'M√°ximo 800 caracteres'}, {quoted: seloctt})
var nomor = info.participant
teks1 = `[ Problema ]
*De:* wa.me/${sender.split("@s.whatsapp.net")[0]}
${pushname} *no ${isGroup ? "grupo* "+groupName : "meu privado*"} *relatou ‚Ü¥*
‚áí ${bug}`
blackmd.sendMessage(nmrdn, {text: teks1}, {quoted: seloctt})
reply("Seu bug foi relatado ao meu dono, em breve o mesmo deve ser resolvido")
break

case 'sugest√£o':
case 'sugestao':
  setTimeout(() => {reagir(from, "üí°")}, 300)
const sugestao = body.slice(10)
if(args.length <= 1) return reply(`Exemplo: ${prefix}sugestao "Opa, crie um comando tal, que ele funcione de tal maneira, isso ser√° muito bom, n√£o s√≥ pra mim, mas pra v√°rios fazer isso.."`)
if(args.length >= 800) return blackmd.sendMessage(from, {text: 'M√°ximo 800 caracteres'}, {quoted: seloctt})
var nomor = info.participant
sug = `[ Sugest√µes ]
*De:* wa.me/${sender.split("@s.whatsapp.net")[0]}
${pushname} *no ${isGroup ? "grupo* "+groupName : "meu privado*"} *sugeriu ‚Ü¥*
${sugestao}`
blackmd.sendMessage(nmrdn, {text: sug}, {quoted: seloctt})
reply("Sua sugest√£o foi enviada ao meu dono... N√£o necessariamente a mesma ser√° implantada no bot, mas √© poss√≠vel que algo seja utilizado")
break

case 'help':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
reply(`*Aqui est√£o alguns dos comandos mais usados pelos usu√°rios...*

> ${prefix}menu
_Este comando ir√° abrir a base de todos os comandos dispon√≠veis no bot_

> ${prefix}s
_Este comando serve para fazer figurinhas... Basta voc√™ enviar uma imagem ou v√≠deo com este comando na legenda._

> ${prefix}f
_Este comando tbm faz figurinha, por√©m, com um formato diferente._

> ${prefix}roubar
_Este comando serve para voc√™ renomear figurinhas do jeito que quiser._

> ${prefix}flady
_Para usu√°rios que tem dificuldade no comando acima, marque uma figurinha, e este ir√° adicionar o simples nome do bot na legenda... Voc√™ tbm pode alugar um comando de roubar figurinha com seu nome, se quiser *(${prefix}alugar).*_

> ${prefix}play
_Use este comando para pedir m√∫sicas... Exemplo: *${prefix}play wanna be yours*_

> ${prefix}calvo
_Este comando faz parte do *${prefix}menuzoeira,* onde neste menu, est√£o presente v√°rias outras brincadeiras para serem utilizadas em grupos..._

> ${prefix}ping
_Este comando serve para puxar a velocidade do bot... Assim, voc√™ saber√° quando ele estiver lento ou n√£o._

> ${prefix}bug
_Este comando serve para voc√™ reportar qualquer tipo de bug no bot_

> ${prefix}sugest√£o
_O mesmo √© para caso voc√™ tenha alguma sugest√£o para melhorar nosso servi√ßo... Estamos sempre ouvindo a opini√£o do p√∫blico._

> ${prefix}suporte
_Diferente dos dois comandos acima, neste voc√™ ter√° resposta em 100% das vezes... Use esse comando para reportar qualquer coisa, desde a d√∫vida mas besta at√© uma de suma import√¢ncia._

> ${prefix}alugar
_Este comando ir√° mostrar todos os pre√ßos dispon√≠veis de alugu√©is para voc√™... Caso se interesse em algum, use o comando *${prefix}dono,* e feche contrato com o nosso servi√ßo._

üî• ${NomeDoBot} üî•`)
break

case 'suporte':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
if(!q) return reply(`*Use o suporte para reportar qualquer tipo de d√∫vida sobre o bot... Ex:*

${prefix+command} seu nome/sua msg para o suporte`)
var [s1, s2] = q.split("/")
if(!s1) return reply(`Digite seu nome de usu√°rio antes da barra (/)

${prefix+command} ${pushname+q}`)
if(!s2) return reply(`Ponha uma barra (/) ap√≥s seu nome de usu√°rio, e em seguida, escreva a mensagem √† ser enviada para o suporte`)
if(Number(s1.length) > 12) return reply(`_"${s1}"_ √© seu nome ? Use apenas o seu primeiro nome pfvr...`)
suportemsg = `„Äé ${s1} „Äè
*Usu√°rio:* wa.me/${sender.split("@s.whatsapp.net")[0]}

> ${s2}`
blackmd.sendMessage(nmrdn, {text: suportemsg}, {quoted: info})
reply(`Sua mensagem foi enviada para o suporte com sucesso... Voc√™ deve receber resposta em at√© 24h. ü´°

Agrademos a sua paci√™ncia ${s1}`)
break

case 'rsuport':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
if(!isOwner) return reply(`;-;`)
if(!q) return reply(`*Ex:* ${prefix+command} n√∫mero/msg que ele enviou/sua resposta`)
var [rs1, rs2, rs3] = q.split("/")
if(!rs1) return reply('Falta o n√∫mero do indiv√≠duo')
if(!rs2) return reply('Preciso da mensagem enviada para o suporte...')
if(!rs3) return reply(`${tempo} suporte... Digite sua resposta para eu enviar ao indiv√≠duo`)
carta = `„Äé *SUPORTE RECEBIDO* „Äè

‚úâÔ∏è‚ßΩ ${rs2}
________________________________________

„Äé *RESPOSTA DO SUPORTE* „Äè

üì©‚ßΩ ${rs3}`
blackmd.sendMessage(`${rs1}@s.whatsapp.net`, {text: carta})
reply(`*Resposta enviada...* ‚úâÔ∏è`)
break

case 'rs4321':
setTimeout(() => {reagir(from, "üòÉ")}, 300)
reply(`*üòÉüëçüèΩ*`)
blackmd.sendMessage(`120363128721181293@g.us`, {text: `${pushname} agradece`})
break

//==========(BAIXAR/PESQUISAS)==========\\

case "portalzacarias":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer um termo para a pesquisa.");
    }

    try {
        const termo = encodeURIComponent(q.trim()); // Sanitizando a entrada do usu√°rio

        const { data: res } = await axios.get(`https://kamuiapi.shop/api/pesquisa/portalzacarias?apikey=YT8q4bUNXV&q=${termo}`);

        if (!res || res.length === 0) {
            return reply("Nenhum resultado encontrado para o termo fornecido.");
        }

        let message = `*Resultados da pesquisa sobre "${q}":*\n\n`;

        res.forEach(item => {
            message += `üì∞ *T√≠tulo:* ${item.titulo}\n`;
            message += `üîó *Link:* ${item.link}\n`;
            message += `üñºÔ∏è *Imagem:* ${item.imagem || "Imagem n√£o dispon√≠vel"}\n\n`;
        });

        reply(message.trim());
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "dafont":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer um nome de fonte para pesquisa.");
    }

    try {
        const fonteNome = encodeURIComponent(q.trim()); // Sanitizando a entrada do usu√°rio

        const { data: res } = await axios.get(`https://world-ecletix.onrender.com/api/dafont?query=${fonteNome}`);

        if (!res || res.length === 0) {
            return reply("Nenhuma fonte encontrada com o nome fornecido.");
        }

        let message = `*Resultados da pesquisa sobre "${q}":*\n\n`;

        res.forEach(item => {
            message += `üî§ *Fonte:* ${item.titulo}\n`;
            message += `üñãÔ∏è *Estilo:* ${item.estilo}\n`;
            message += `üîó *Link:* ${item.link}\n`;
            message += `üìä *Total de fontes:* ${item.total}\n\n`;
        });

        reply(message.trim());
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "apkgara":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer um nome de aplicativo para a pesquisa.");
    }

    try {
        const nomeApp = encodeURIComponent(q.trim()); // Sanitizando a entrada do usu√°rio

        const { data: res } = await axios.get(`https://kamuiapi.shop/api/pesquisa/apkgara?nome=${nomeApp}&apikey=YT8q4bUNXV`);

        if (!res || res.length === 0) {
            return reply("Nenhum resultado encontrado para o nome de aplicativo fornecido.");
        }

        let message = `*Resultados da pesquisa sobre "${q}":*\n\n`;

        res.forEach(item => {
            message += `üì± *Nome:* ${item.nome}\n`;
            message += `üî¢ *Vers√£o:* ${item.versao}\n`;
            message += `üñºÔ∏è *Capa:* ${item.capa}\n`;
            message += `üîó *Link:* ${item.link}\n\n`;
        });

        reply(message.trim());
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "gpwhatsapp":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer um nome para pesquisa.");
    }

    try {
        const nomeGrupo = encodeURIComponent(q.trim()); // Sanitizando a entrada do usu√°rio

        const { data: res } = await axios.get(`https://kamuiapi.shop/api/pesquisa/gpwhatsapp?nome=${nomeGrupo}&apikey=YT8q4bUNXV`);

        if (!res || res.length === 0) {
            return reply("Nenhum grupo encontrado com o nome fornecido.");
        }

        let message = `*Resultados da pesquisa sobre "${q}":*\n\n`;

        res.forEach(item => {
            message += `üë• *Grupo:* ${item.nome}\n`;
            message += `üîó *Link:* ${item.link}\n`;
            message += `üìù *Descri√ß√£o:* ${item.descri√ß√£o}\n\n`;
        });

        reply(message.trim());
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;

case 'videourl':
case 'gerarlink':
case 'videopralink':
case 'imgpralink':
try {
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) { 
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
return sendUrlText(from, res, `Link da imagem gerado com sucesso ‚Ü¥`, ``, res, res, seloctt)
} else if((isMedia && info.message.videoMessage.seconds < 30 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 30) && !q.length <= 1) { 
reply(`Gerando link do v√≠deo pra voc√™...`)
boij = isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.videoMessage : info.message.videoMessage
owgi = await getFileBuffer(boij, 'video')
res = await upload(owgi)
return sendUrlText(from, res, `Link do v√≠deo gerado com sucesso ‚Ü¥`, ``, logoslink.menu, res, seloctt)
} else {
reply("Voc√™ deve marcar uma imagem, ou um v√≠deo de at√© 30 segundos..")
}
} catch {
reply('Ocorreu algum Erro, desculpe üòî/ O limite do tamanho de v√≠deo que gero o link, √© at√© 30 segundos.')
}
break

case 'linkimg55':
if(!q) return reply(`KD o link fi de quenga ?`)
try {
setTimeout(() => {reagir(from, "üì∑")}, 300)
blackmd.sendMessage(from, {image: {url: q}, caption: `@${sender.split('@')[0]} \`\`\`aqui est√°\`\`\` ‚úÖ`, mentions: [sender]})
} catch (e) {
reply(`N√£o consegui carregar o link...`) }
break

case 'linkmp435':
if(!q) return reply(`KD o link fi de quenga ?`)
try {
setTimeout(() => {reagir(from, "üé•")}, 300)
blackmd.sendMessage(from, {video: {url: q}, gifPlayback: false, caption: `@${sender.split('@')[0]} \`\`\`aqui est√°\`\`\` ‚úÖ`, mentions: [sender]})
} catch (e) {
reply(`N√£o consegui carregar o link...`) }
break


// NOT√çCIAS 
case 'cnnbrasil':
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/cnnbrasil');
        
        if (data.status === 200 && data.resultado && data.resultado.length > 0) {
            let cnnbrasilMensagem = 'üì∞ *√öltimas not√≠cias da CNN Brasil:*\n\n';

            data.resultado.slice(0, 5).forEach((noticia, index) => {
                cnnbrasilMensagem += `*${index + 1}. ${noticia.noticia}*\n` +
                                     `üîó ${noticia.link || 'Link indispon√≠vel'}\n\n`;
            });

            if (data.resultado[0].imagem) {
                await blackmd.sendMessage(from, { 
                    image: { url: data.resultado[0].imagem }, 
                    caption: cnnbrasilMensagem 
                }, { quoted: info });
            } else {
                await blackmd.sendMessage(from, { text: cnnbrasilMensagem }, { quoted: info });
            }
        } else {
            reply('Nenhuma not√≠cia dispon√≠vel no momento.');
        }
    } catch (error) {
        console.error('Erro ao buscar not√≠cias da CNN Brasil:', error);
        reply('Ops, ocorreu um erro ao buscar as not√≠cias.');
    }
    break;

	case 'exame':
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/exame');
        
        if (data.status === 200 && data.resultado && data.resultado.length > 0) {
            let exameMensagem = 'üì∞ *√öltimas not√≠cias da Exame:*\n\n';

            data.resultado.slice(0, 5).forEach((noticia, index) => {
                exameMensagem += `*${index + 1}. ${noticia.noticia}*\n` +
                                 `üîó ${noticia.link || 'Link indispon√≠vel'}\n\n`;
            });

            // Enviar com imagem, se dispon√≠vel
            if (data.resultado[0].imagem && !data.resultado[0].imagem.startsWith('data:image/gif')) {
                await blackmd.sendMessage(from, { 
                    image: { url: data.resultado[0].imagem }, 
                    caption: exameMensagem 
                }, { quoted: info });
            } else {
                await blackmd.sendMessage(from, { text: exameMensagem }, { quoted: info });
            }
        } else {
            reply('Nenhuma not√≠cia dispon√≠vel no momento.');
        }
    } catch (error) {
        console.error('Erro ao buscar not√≠cias da Exame:', error);
        reply('Ops, ocorreu um erro ao buscar as not√≠cias.');
    }
    break;
case 'metropoles':
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/metropoles');

        if (data && data.length > 0) {
            let metropolesMensagem = 'üì∞ *√öltimas not√≠cias do Metr√≥poles:*\n\n';

            data.slice(0, 5).forEach((noticia, index) => {
                metropolesMensagem += `*${index + 1}. ${noticia.title || 'T√≠tulo indispon√≠vel'}*\n` +
                                      `üìÇ Categoria: ${noticia.category || 'Indispon√≠vel'}\n` +
                                      `üîó ${noticia.link || 'Link indispon√≠vel'}\n\n`;
            });

            // Enviar com imagem, se dispon√≠vel e v√°lida
            if (data[0].imageUrl && !data[0].imageUrl.startsWith('data:image/gif')) {
                await blackmd.sendMessage(from, { 
                    image: { url: data[0].imageUrl }, 
                    caption: metropolesMensagem 
                }, { quoted: info });
            } else {
                await blackmd.sendMessage(from, { text: metropolesMensagem }, { quoted: info });
            }
        } else {
            reply('Nenhuma not√≠cia dispon√≠vel no momento.');
        }
    } catch (error) {
        console.error('Erro ao buscar not√≠cias do Metr√≥poles:', error);
        reply('Ops, ocorreu um erro ao buscar as not√≠cias.');
    }
    break;
case 'oglobo':
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/oglobo');

        if (data && data.length > 0) {
            let ogloboMensagem = 'üì∞ *√öltimas not√≠cias de O Globo:*\n\n';

            data.slice(0, 5).forEach((noticia, index) => {
                ogloboMensagem += `*${index + 1}. ${noticia.title || 'T√≠tulo indispon√≠vel'}*\n` +
                                  `‚úçÔ∏è Autor: ${noticia.author || 'Indispon√≠vel'}\n` +
                                  `üîó ${noticia.link || 'Link indispon√≠vel'}\n\n`;
            });

            await blackmd.sendMessage(from, { text: ogloboMensagem }, { quoted: info });
        } else {
            reply('Nenhuma not√≠cia dispon√≠vel no momento.');
        }
    } catch (error) {
        console.error('Erro ao buscar not√≠cias de O Globo:', error);
        reply('Ops, ocorreu um erro ao buscar as not√≠cias.');
    }
    break;
		
case 'folha':
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/folha');

        if (data && data.length > 0) {
            let folhaMensagem = 'üì∞ *√öltimas not√≠cias da Folha de S.Paulo:*\n\n';

            data.slice(0, 5).forEach((noticia, index) => {
                folhaMensagem += `*${index + 1}. ${noticia.title || 'T√≠tulo indispon√≠vel'}*\n` +
                                 `üîó ${noticia.link || 'Link indispon√≠vel'}\n\n`;
            });

            await blackmd.sendMessage(from, { text: folhaMensagem }, { quoted: info });
        } else {
            reply('Nenhuma not√≠cia dispon√≠vel no momento.');
        }
    } catch (error) {
        console.error('Erro ao buscar not√≠cias da Folha:', error);
        reply('Ops, ocorreu um erro ao buscar as not√≠cias.');
    }
    break;		
		
case 'noticias_ciberneticas':
case 'newscibernetico':
case 'cisoadvisor': 
    try {
        const { data: nunucucisohtml } = await axios.get('https://www.cisoadvisor.com.br/arquivo-categorias/')
        const nunucucisoparser = cheerio.load(nunucucisohtml)
        let nunucucisonoticias = []
        
        nunucucisoparser('.elementor-post').each((index, nunucucisopost) => {
            const nunucucisotitle = nunucucisoparser(nunucucisopost).find('.elementor-post__title a').text().trim()
            const nunucucisosummary = nunucucisoparser(nunucucisopost).find('.elementor-post__excerpt p').text().trim()
            const nunucucisolink = nunucucisoparser(nunucucisopost).find('.elementor-post__title a').attr('href')
            const nunucucisoimage = nunucucisoparser(nunucucisopost).find('.elementor-post__thumbnail img').attr('src')
            
            if (nunucucisotitle && nunucucisolink) {
                nunucucisonoticias.push({
                    nunucucisotitle,
                    nunucucisosummary,
                    nunucucisolink,
                    nunucucisoimage
                })
            }
        })

        nunucucisonoticias = nunucucisonoticias.slice(0, 5)
        
        let nunucucisomensagem = 'üõ°Ô∏è *√öltimas Not√≠cias de Seguran√ßa Cibern√©tica:*\n\n'
        nunucucisonoticias.forEach((nunucucisoitem, index) => {
            nunucucisomensagem += `*${index + 1}. ${nunucucisoitem.nunucucisotitle}*\n` +
                                  `üìã ${nunucucisoitem.nunucucisosummary}\n` +
                                  `üîó ${nunucucisoitem.nunucucisolink}\n\n`
        })

        if (nunucucisonoticias.length > 0 && nunucucisonoticias[0].nunucucisoimage) {
            await blackmd.sendMessage(from, { 
                image: { url: nunucucisonoticias[0].nunucucisoimage }, 
                caption: nunucucisomensagem 
            }, { quoted: info })
        } else {
            await blackmd.sendMessage(from, { text: nunucucisomensagem }, { quoted: info })
        }
    } catch (nunucucisoerro) {
        console.error('Erro ao buscar not√≠cias do CISO Advisor:', nunucucisoerro)
        reply('‚ö†Ô∏è N√£o foi poss√≠vel buscar as not√≠cias do CISO Advisor no momento.')
    }
    break//nunu dia das crian√ßa
case 'news':
    const apiUrl = 'https://world-ecletix.onrender.com/api/ultimasnoticias';

    try {
        // Requisi√ß√£o para a API de √∫ltimas not√≠cias
        const response = await axios.get(apiUrl);
        const noticias = response.data;

        // Verificar se a resposta cont√©m not√≠cias
        if (noticias && noticias.length > 0) {
            // Limitar o n√∫mero de not√≠cias exibidas
            const limit = 5; // N√∫mero de not√≠cias para exibir
            let message = 'üì∞ √öltimas Not√≠cias:\n\n';

            noticias.slice(0, limit).forEach((noticia, index) => {
                const { titulo, link } = noticia;

                // Adicionar a not√≠cia √† mensagem
                message += `${index + 1}. *${titulo}*\nLeia mais: ${link}\n\n`;
            });

            // Enviar a mensagem com as not√≠cias
            await blackmd.sendMessage(from, { text: message }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel encontrar as √∫ltimas not√≠cias.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao fazer a requisi√ß√£o √† API de not√≠cias:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao buscar as √∫ltimas not√≠cias.' }, { quoted: info });
    }
    break;
case 'noticia': 
    try {
        if (!q) return reply(`Informe um tema para realizar a pesquisa de suas not√≠cias!`);
        
        const theNews = await axios.get(`https://newsapi.org/v2/everything?q=${encodeURIComponent(q)}&sortBy=publishedAt&language=pt&apiKey=9dc1dde158804756ae9b33dd8d71f7a1`);
        
        const newsSends = theNews.data.articles.map(d => 
            `${d.publishedAt.split('T').join(' - ').split('Z')[0]}\n\n` +
            `${d.title} - ${d.author} [${d.source.name}]\n\n` +
            `${d.description}\n\n` +
            `${d.url}\n\n` +
            `${d.content}\n\n` +
            `--------------------------- * ---------------------------\n\n`
        ).join('');
        
        reply(newsSends);
    } catch (e) {
        console.log(e);
        reply('Erro ao buscar as not√≠cias. Tente novamente mais tarde.');
    }
    break;
  case 'jovempan': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/jovempan');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma not√≠cia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.noticia) {
                mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                                   `üîó [Leia mais](${noticia.link})\n` +
                                   `${noticia.imagem ? `![Imagem](${noticia.imagem})\n` : ''}\n`; // Incluindo a imagem aqui
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma not√≠cia dispon√≠vel no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar not√≠cias do Jovem Pan:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as not√≠cias do Jovem Pan.' }, { quoted: info });
    }
    break;
}

case 'uol': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/uol');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma not√≠cia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.noticia) {
                mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                                   `üîó [Leia mais](${noticia.link})\n` +
                                   `${noticia.imagem ? `![Imagem](${noticia.imagem})\n` : ''}\n`; // Incluindo a imagem aqui
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma not√≠cia dispon√≠vel no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar not√≠cias da UOL:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as not√≠cias da UOL.' }, { quoted: info });
    }
    break;
}

case 'estadao': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/estadao');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma not√≠cia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.noticia) {
                mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                                   `üîó [Leia mais](${noticia.link})\n` +
                                   `${noticia.imagem ? `![Imagem](${noticia.imagem})\n` : ''}\n`; // Incluindo a imagem aqui
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma not√≠cia dispon√≠vel no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar not√≠cias do Estad√£o:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as not√≠cias do Estad√£o.' }, { quoted: info });
    }
    break;
}

case 'terra': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/terra');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma not√≠cia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.noticia) {
                mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                                   `üîó [Leia mais](${noticia.link})\n` +
                                   `${noticia.imagem ? `![Imagem](${noticia.imagem})\n` : ''}\n`;
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma not√≠cia dispon√≠vel no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar not√≠cias do Terra:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as not√≠cias do Terra.' }, { quoted: info });
    }
    break;
}
case 'aominuto': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/aominuto');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma not√≠cia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.noticia) {
                mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                                   `üìÖ Postado: ${noticia.postado}\n` +
                                   `üóÇ Categoria: ${noticia.categoria}\n` +
                                   `üîó [Leia mais](${noticia.link})\n\n`;
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma not√≠cia dispon√≠vel no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar not√≠cias do A O Minuto:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as not√≠cias do A O Minuto.' }, { quoted: info });
    }
    break;
}
case 'vejaabril': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/vejaabril');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma not√≠cia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.noticia) {
                mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                                   `üñºÔ∏è [Imagem](${noticia.imagem})\n` +
                                   `üóÇ Categoria: ${noticia.categoria}\n` +
                                   `üîó [Leia mais](${noticia.link})\n\n`;
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma not√≠cia dispon√≠vel no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar not√≠cias da Veja:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as not√≠cias da Veja.' }, { quoted: info });
    }
    break;
}
case 'agazeta': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/agazeta');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma not√≠cia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.link) { // Verifica se h√° um link dispon√≠vel
                mensagemNoticias += `*Not√≠cia ${index + 1}*\n` +
                                   `üñºÔ∏è [Imagem](${noticia.imagem})\n` +
                                   `üóÇ Categoria: ${noticia.categoria}\n` +
                                   `üîó [Leia mais](${noticia.link})\n\n`;
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma not√≠cia dispon√≠vel no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar not√≠cias da A Gazeta:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as not√≠cias da A Gazeta.' }, { quoted: info });
    }
    break;
}
case 'fut': {
    try {
        const { data: futebolnunuakake } = await axios.get('https://ge.globo.com/')
        const fut$ = cheerio.load(futebolnunuakake)
        let noticiadofut = []

        fut$('.feed-post-body').each((index, futelement) => {
            if (index < 7) {
                const titulodofutebol = fut$(futelement).find('.feed-post-link').text().trim()
                const linkfutebol = fut$(futelement).find('.feed-post-link').attr('href')
                const futimagem = fut$(futelement).find('.bstn-fd-picture-image').attr('src')

                if (titulodofutebol && linkfutebol) {
                    noticiadofut.push({
                        titulodofutebol,
                        linkfutebol,
                        futimagem
                    })
                }
            }
        })

        let futmensagem = ' '
        noticiadofut.forEach((futnoticia, index) => {
            futmensagem += `*${index + 1}. ${futnoticia.titulodofutebol}*\n` +
                           `üîó ${futnoticia.linkfutebol}\n\n`
        })

        if (noticiadofut.length > 0 && noticiadofut[0].futimagem) {
            await blackmd.sendMessage(from, {
                image: { url: noticiadofut[0].futimagem },
                caption: futmensagem
            }, { quoted: info })
        } else {
            await blackmd.sendMessage(from, { text: futmensagem }, { quoted: info })
        }
    } catch (futerro) {
        console.error('erro:', futerro)
        reply('ops foi de f.')
    }
    break
			}
			case 'fisiculturista': 
    try {
        const { data: nunufisudata } = await axios.get('https://www.cnnbrasil.com.br/tudo-sobre/fisiculturismo/')
        const nunufisu$ = cheerio.load(nunufisudata)
        let nunufisunoticias = []
        nunufisu$('.home__list__item').each((index, nunufisuelement) => {
            const nunufisuezbt = nunufisu$(nunufisuelement).find('.news-item-header__title').text().trim()
            const nunufisulink = nunufisu$(nunufisuelement).find('a').attr('href')
            const nunufisuimg = nunufisu$(nunufisuelement).find('img').attr('src')
            const nunufisudate = nunufisu$(nunufisuelement).find('.home__title__date').text().trim()

            if (nunufisuezbt && nunufisulink) {
                nunufisunoticias.push({
                    nunufisuezbt,
                    nunufisulink,
                    nunufisuimg,
                    nunufisudate
                })
            }
        })

        nunufisunoticias = nunufisunoticias.slice(0, 5)
        
        let nunufisumensagem = 'üèÜ *√öltimas:*\n\n'
        nunufisunoticias.forEach((nunufisunoticia, index) => {
            nunufisumensagem += `*${index + 1}. ${nunufisunoticia.nunufisuezbt}*\n` +
                                `üóìÔ∏è ${nunufisunoticia.nunufisudate}\n` +
                                `üîó ${nunufisunoticia.nunufisulink}\n\n`
        })
        
        if (nunufisunoticias.length > 0 && nunufisunoticias[0].nunufisuimg) {
            await blackmd.sendMessage(from, { 
                image: { url: nunufisunoticias[0].nunufisuimg }, 
                caption: nunufisumensagem 
            }, { quoted: info })
        } else {
            await blackmd.sendMessage(from, { text: nunufisumensagem }, { quoted: info })
        }
    } catch (nunufisuerro) {
        console.error('Erro ao buscar not√≠cias de fisiculturismo:', nunufisuerro)
        reply('ops foi de f.')
    }
    break;
    
    case 'time': {
    if (!text) {
        return reply(`Por favor, forne√ßa o nome do time. Exemplo: ${prefix}time fortaleza`);
    }

    const clube = text.trim(); // O nome do time √© obtido a partir da entrada do usu√°rio

    try {
        const { data: timeData } = await axios.get(`https://world-ecletix.onrender.com/api/times?clube=${encodeURIComponent(clube)}`);
        let noticiastime = [];

        // Filtra as not√≠cias que t√™m t√≠tulo e link
        timeData.forEach((noticia) => {
            if (noticia.title && noticia.link) {
                noticiastime.push({
                    title: noticia.title,
                    link: noticia.link,
                    imgSrc: noticia.imgSrc,
                    date: noticia.date
                });
            }
        });

        let timeMensagem = '';
        noticiastime.forEach((timeNoticia, index) => {
            timeMensagem += `*${index + 1}. ${timeNoticia.title}*\n` +
                            `üîó ${timeNoticia.link}\n` +
                            `üóìÔ∏è ${timeNoticia.date}\n\n`;
        });

        // Envia a mensagem, se houver not√≠cias
        if (noticiastime.length > 0) {
            const primeiraImagem = noticiastime[0].imgSrc ? { image: { url: noticiastime[0].imgSrc } } : {};
            await blackmd.sendMessage(from, {
                ...primeiraImagem,
                caption: timeMensagem
            }, { quoted: info });
        } else {
            reply('Nenhuma not√≠cia encontrada.');
        }
    } catch (timeErro) {
        console.error('erro:', timeErro);
        reply('Ops, houve um erro ao buscar as not√≠cias do time.');
    }
    break;
}
case 'genoticias': {
    if (!text) {
        return blackmd.sendMessage(
            from,
            { text: `Por favor, forne√ßa um termo para busca. Exemplo: ${prefix}genoticias fifa` },
            { quoted: info }
        );
    }

    const termoBusca = text.trim();

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/genoticias?termo=${encodeURIComponent(termoBusca)}`);
        
        if (!data.sucesso || !data.dados || data.dados.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma not√≠cia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.dados.forEach((noticia, index) => {
            mensagemNoticias += `*${index + 1}. ${noticia.titulo}*\n` +
                               `üì∞ ${noticia.trechoManchete}\n` +
                               `üïí ${noticia.horarioPostagem}\n` +
                               `üîó [Leia mais](${noticia.linkNoticia})\n` +
                               `${noticia.linkImagem ? `![Imagem](${noticia.linkImagem})\n` : ''}\n`; // Incluindo a imagem aqui
        });

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar not√≠cias:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as not√≠cias.' }, { quoted: info });
    }
    break;
}
case 'g1': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/g1');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma not√≠cia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                               `üìù ${noticia.desc ? noticia.desc : 'Sem descri√ß√£o'}\n` +
                               `üïí ${noticia.postado}\n` +
                               `üîó [Leia mais](${noticia.link})\n` +
                               `${noticia.imagem ? `![Imagem](${noticia.imagem})\n` : ''}\n`; // Incluindo a imagem aqui
        });

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar not√≠cias do G1:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as not√≠cias do G1.' }, { quoted: info });
    }
    break;
}

case 'poder360': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/poder360');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma not√≠cia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.noticia) {
                mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                                   `üîó [Leia mais](${noticia.link})\n` +
                                   `${noticia.imagem ? `![Imagem](${noticia.imagem})\n` : ''}\n`; // Incluindo a imagem aqui
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma not√≠cia dispon√≠vel no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar not√≠cias do Poder360:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as not√≠cias do Poder360.' }, { quoted: info });
    }
    break;
}
case 'noticia2': 
try {
if (!q) return reply(`Informe um tema para realizar a pesquisa de suas not√≠cias!`)
theNews = await axios.get(`https://newsapi.org/v2/everything?q=${encodeURIComponent(q)}&sortBy=publishedAt&language=pt&apiKey=9dc1dde158804756ae9b33dd8d71f7a1`);
newsSends = theNews.data.articles.map(d => `${d.publishedAt.split('T').join(' - ').split('Z')[0]}\n\n${d.title} - ${d.author} [${d.source.name}]\n\n${d.description}\n\n${d.url}\n\n${d.content}\n\n--------------------------- * ---------------------------\n\n`).join('');
reply(newsSends).catch(() => {
return console.log(e)
})
} catch (e) {
return console.log(e)
}
break
case 'vasconews': 
    try {
        var nunudatav = await axios.get('https://vasco.com.br/noticias-home/')
        var nunu$v = cheerio.load(nunudatav.data)
        var nununoticiasv = []
        nunu$v('.box-noticias').each((index, nunulementv) => {
            var nunuezbtv = nunu$v(nunulementv).find('h3').text().trim()
            var nunugdv = nunu$v(nunulementv).find('.btn').text().trim()
            var nunulinkv = nunu$v(nunulementv).find('a').attr('href')
            var nunuimagev = nunu$v(nunulementv).find('img').attr('src')

            if (nunuezbtv && nunulinkv) {
                nununoticiasv.push({
                    nunuezbtv,
                    nunugdv: nunugdv.replace('Leia mais', ''),
                    nunulinkv: `${nunulinkv}`,
                    nunuimagev
                })
            }
        })

        nununoticiasv = nununoticiasv.slice(0, 5)

        var nunumensagemv = '‚öΩ *√öltimas Not√≠cias do Vasco:*\n\n'
        nununoticiasv.forEach((nununoticia, index) => {
            nunumensagemv += `*${index + 1}. ${nununoticia.nunuezbtv}*\n` +
                            `üìù ${nununoticia.nunugdv}\n` +
                            `üõï ${nununoticia.nunulinkv}\n`
            nunumensagemv += '\n'
        })
        if (nununoticiasv.length > 0 && nununoticiasv[0].nunuimagev) {
            await blackmd.sendMessage(from, { 
                image: { url: nununoticiasv[0].nunuimagev }, 
                caption: nunumensagemv 
            }, { quoted: info })
        } else {
            await blackmd.sendMessage(from, { text: nunumensagemv }, { quoted: info })
        }
    } catch (nunuerrov) {
        console.error('Erro ao buscar not√≠cias do Vasco', nunuerrov)
        reply('‚ö†Ô∏è N√£o foi poss√≠vel buscar as not√≠cias do Vasco no momento')
    }
    break
case 'volei': 
    try {
        const { data: nunuvoleicudataxw } = await axios.get('https://webvolei.com.br/')
        const nunuvoleicuhtmlkl = cheerio.load(nunuvoleicudataxw)
        let nunuvoleiculistgp = []
        nunuvoleicuhtmlkl('li.articles-box-item').each((index, nunuvoleicuelementovb) => {
            const nunuvoleicutitulorb = nunuvoleicuhtmlkl(nunuvoleicuelementovb).find('h3.article-title a').text().trim()
            const nunuvoleicudescxv = nunuvoleicuhtmlkl(nunuvoleicuelementovb).find('.article-meta-info .date').text().trim()
            const nunuvoleiculinkbw = nunuvoleicuhtmlkl(nunuvoleicuelementovb).find('h3.article-title a').attr('href')
            const nunuvoleicuimgmr = nunuvoleicuhtmlkl(nunuvoleicuelementovb).find('.article-thumb img').attr('src')

            if (nunuvoleicutitulorb && nunuvoleiculinkbw) {
                nunuvoleiculistgp.push({
                    nunuvoleicutitulorb,
                    nunuvoleicudescxv,
                    nunuvoleiculinkbw: `${nunuvoleiculinkbw}`,
                    nunuvoleicuimgmr
                })
            }
        })

        nunuvoleiculistgp = nunuvoleiculistgp.slice(0, 5)
        
        let nunuvoleicumsgqk = 'üèê *√öltimas Not√≠cias do V√¥lei:*\n\n'
        nunuvoleiculistgp.forEach((nunuvoleicunoticiasbx, index) => {
            nunuvoleicumsgqk += `*${index + 1}. ${nunuvoleicunoticiasbx.nunuvoleicutitulorb}*\n` +
                            `üìÖ ${nunuvoleicunoticiasbx.nunuvoleicudescxv}\n` +
                            `üîó ${nunuvoleicunoticiasbx.nunuvoleiculinkbw}\n`
            nunuvoleicumsgqk += '\n'
        })
        if (nunuvoleiculistgp.length > 0 && nunuvoleiculistgp[0].nunuvoleicuimgmr) {
            await blackmd.sendMessage(from, { 
                image: { url: nunuvoleiculistgp[0].nunuvoleicuimgmr }, 
                caption: nunuvoleicumsgqk 
            }, { quoted: info })
        } else {
            await blackmd.sendMessage(from, { text: nunuvoleicumsgqk }, { quoted: info })
        }
    } catch (nunuvoleicuerrordk) {
        console.error('Erro ao buscar not√≠cias de V√¥lei:', nunuvoleicuerrordk)
        reply('‚ö†Ô∏è N√£o foi poss√≠vel buscar as not√≠cias de V√¥lei no momento')
    }
    break
 case 'basquetenews': 
    try {
        const { data: nunucubasquetehtmlakjs } = await axios.get('https://noticiasdebasquete.com.br/noticias-basquete/')
        const nunucubasqueteparserzzx = cheerio.load(nunucubasquetehtmlakjs)
        let nunucubasquetenoticiasqfj = []
        
        nunucubasqueteparserzzx('.listing-item').each((index, nunucubasquetenoticiaxfz) => {
            const nunucubasquetetitlezby = nunucubasqueteparserzzx(nunucubasquetenoticiaxfz).find('.post-title').text().trim()
            const nunucubasquetesummaryczx = nunucubasqueteparserzzx(nunucubasquetenoticiaxfz).find('.post-summary').text().trim()
            const nunucubasquetelinkqvf = nunucubasqueteparserzzx(nunucubasquetenoticiaxfz).find('a').attr('href')
            const nunucubasqueteimagecss = nunucubasqueteparserzzx(nunucubasquetenoticiaxfz).find('.img-holder').css('background-image')

            let nunucubasqueteimagecbv = ''
            if (nunucubasqueteimagecss && nunucubasqueteimagecss.match(/urlÓÄÅ(.*?)ÓÄÅ/)) {
                nunucubasqueteimagecbv = nunucubasqueteimagecss.match(/urlÓÄÅ(.*?)ÓÄÅ/)[1]
            }

            if (nunucubasquetetitlezby && nunucubasquetelinkqvf) {
                nunucubasquetenoticiasqfj.push({
                    nunucubasquetetitlezby,
                    nunucubasquetesummaryczx,
                    nunucubasquetelinkqvf: `${nunucubasquetelinkqvf}`,
                    nunucubasqueteimagecbv
                })
            }
        })

        nunucubasquetenoticiasqfj = nunucubasquetenoticiasqfj.slice(0, 5)
        
        let nunucubasquetemensagemazw = 'üèÄ *√öltimas Not√≠cias do Basquete:*\n\n'
        nunucubasquetenoticiasqfj.forEach((nunucubasqueteitemwby, index) => {
            nunucubasquetemensagemazw += `*${index + 1}. ${nunucubasqueteitemwby.nunucubasquetetitlezby}*\n` +
                            `üîó ${nunucubasqueteitemwby.nunucubasquetelinkqvf}\n\n`
        })

        if (nunucubasquetenoticiasqfj.length > 0 && nunucubasquetenoticiasqfj[0].nunucubasqueteimagecbv) {
            await blackmd.sendMessage(from, { 
                image: { url: nunucubasquetenoticiasqfj[0].nunucubasqueteimagecbv }, 
                caption: nunucubasquetemensagemazw 
            }, { quoted: info })
        } else {
            await blackmd.sendMessage(from, { text: nunucubasquetemensagemazw }, { quoted: info })
        }
    } catch (nunucubasqueteerroqwe) {
        console.error('Erro ao buscar not√≠cias do Basquete:', nunucubasqueteerroqwe)
        reply('‚ö†Ô∏è N√£o foi poss√≠vel buscar as not√≠cias de basquete no momento.')
    }
    break;
    case 'sbt':
    case 'sbtnews':
    case "SBT": {
    try {
        // by: luanzn_fe

        const obterNoticiasSBT = async () => {
            try {
                const res = await axios.get('https://www.sbt.com.br/');
                const $ = cheerio.load(res.data);
                const noticias = [];
                
                $('.news-card').each((i, e) => {
                    const titulo = $(e).find('.news-card-title').text().trim();
                    const link = $(e).find('a').attr('href');
                    const resumo = $(e).find('.news-card-summary').text().trim();
                    const imagem = $(e).find('img').attr('src');

                    if (titulo && link) {
                        noticias.push({
                            titulo,
                            link,
                            resumo: resumo || 'Sem resumo dispon√≠vel.',
                            imagem: imagem || 'Sem imagem dispon√≠vel.'
                        });
                    }
                });
                return noticias;
            } catch (error) {
                throw new Error(`Erro ao buscar not√≠cias do SBT: ${error.message}`);
            }
        };

        const enviarNoticias = async (noticias) => {
            if (noticias.length === 0) {
                return reply('Desculpe, n√£o encontrei not√≠cias para enviar.');
            }

            for (const noticia of noticias.slice(0, 5)) {
                const mensagem = `
üì∞ *Not√≠cias do SBT* üì∞
üîπ *T√≠tulo:* ${noticia.titulo}
üîπ *Resumo:* ${noticia.resumo}
üîπ *Link:* ${noticia.link}
üîπ *Imagem:* ${noticia.imagem}
`;

                try {
                    await blackmd.sendMessage(from, { text: mensagem }, { quoted: info });
                } catch (error) {
                    console.log(`Erro ao enviar a mensagem: ${error.message}`);
                }
            }
        };

        // Obtendo not√≠cias
        const noticias = await obterNoticiasSBT();

        if (noticias.length === 0) {
            return reply('Desculpe, n√£o encontrei not√≠cias recentes.');
        }

        // Enviando not√≠cias para o usu√°rio
        await enviarNoticias(noticias);

        // Rea√ß√£o de sucesso
        await blackmd.sendMessage(from, { react: { text: '‚úÖÔ∏è', key: info.key } });

    } catch (error) {
        console.error('Erro inesperado:', error);
        reply(`Ocorreu um erro inesperado: ${error.message}`);
    }
    break;
}
case 'globo':{
    try {
        reply('Aguarde, estou obtendo as √∫ltimas not√≠cias do g1...');               
        const { data } = await axios.get('https://g1.globo.com/');
        const $ = cheerio.load(data);
        let noticias = [];
        $('.feed-post-link').each((index, element) => {
            const titulo = $(element).text().trim();
            const url = $(element).attr('href');
            noticias.push({ titulo, url });
        });
        let mensagem = 'üì∞ √öltimas not√≠cias do g1:\n\n';
        noticias.slice(0, 10).forEach((noticia, index) => {
            mensagem += `${index + 1}. ${noticia.titulo}\nüîó ${noticia.url}\n\n`;
        });
        reply(mensagem);
    } catch (error) {
        console.error(error);
        reply('Desculpe, houve um erro ao obter as not√≠cias.');
    }
break;
}
// FERRAMENTAS

case 'proximojogo':
case 'jogosfuturos': {
    if (!q) return reply("Envie o nome de um time para consultar os pr√≥ximos jogos.");

    try {
        const { data } = await axios.get(`https://kamuiapi.shop/api/outros/proximos_jogos?query=${encodeURIComponent(q)}&apikey=YT8q4bUNXV`);

        if (!Array.isArray(data) || !data.length) {
            return reply("ok");
        }

        let mensagem = `‚öΩ *PR√ìXIMOS JOGOS - ${q.toUpperCase()}* ‚öΩ\n\n`;
        for (const jogo of data) {
            mensagem += `üèÜ *${jogo.liga}*\n`;
            mensagem += `üìÖ ${jogo.data}\n`;
            mensagem += `üè† ${jogo.timeCasa} vs ${jogo.timeVisitante}\n\n`;
        }

        mensagem += `‚Ä¢ Bot: ${NomeDoBot}`;
        reply(mensagem.trim());

    } catch (error) {
        console.error("Erro ao consultar jogos futuros:", error);
        return reply("ok");
    }
    break;
}
case 'rastrearshop':
case 'rastrearshoppe': {
    if (!q) return reply("Envie o c√≥digo de rastreio para continuar.");

    try {
        const { data } = await axios.get(`https://kamuiapi.shop/api/outros/rastrear/shoppee?id=${encodeURIComponent(q)}&apikey=YT8q4bUNXV`);

        if (!Array.isArray(data) || !data.length || (!data[0].info && !data[0].infopro)) {
            return reply("ok");
        }

        const info = data[0].info || "N√£o informado";
        const detalhes = data[0].infopro || "N√£o informado";

        const message =
            `üì¶ *RASTREAMENTO SHOPEE* üì¶\n\n` +
            `‚Ä¢ C√≥digo: ${q}\n` +
            `‚Ä¢ Info: ${info}\n` +
            `‚Ä¢ Detalhes: ${detalhes}\n` +
            `‚Ä¢ Bot: ${NomeDoBot}`;

        reply(message);

    } catch (error) {
        console.error("Erro ao consultar rastreio Shopee:", error);
        return reply("ok");
    }
    break;
}

case 'fakemail': {
  try {
    const { data } = await axios.get('https://api.vreden.my.id/api/tools/fakemail/create');
    if (data.status !== 200) return reply("Erro ao criar e-mail tempor√°rio.");

    const email = data.result.addresses[0].address;
    const id = data.result.id;
    const expira = data.result.expiresAt;

    const msg = `üïµÔ∏è *Email Tempor√°rio Criado!*\n\n` +
                `üìß *Email:* ${email}\n` +
                `üÜî *ID:* ${id}\n` +
                `‚è≥ *Expira em:* ${expira}\n\n` +
                `Use esse ID para consultar a caixa de entrada futuramente.`;

    reply(msg);
  } catch (e) {
    reply("Erro ao gerar o e-mail tempor√°rio.");
  }
  break;
}
case 'fakemail-msg': {
  try {
    const emailId = '066sy257qr@spymail.one';  // Insira o ID do e-mail que voc√™ deseja verificar
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/fakemail/message?id=${emailId}`);
    
    if (data.status !== 200) return reply("Erro ao consultar as mensagens.");

    if (data.result === null) {
      reply("N√£o h√° mensagens recebidas para este e-mail tempor√°rio.");
    } else {
      // Processa e exibe as mensagens, caso existam
      const messages = data.result.map(msg => `*Assunto:* ${msg.subject}\n*De:* ${msg.from}\n*Data:* ${msg.date}\n\n`);
      reply(`üì• *Mensagens Recebidas:*\n\n${messages.join('\n')}`);
    }
  } catch (e) {
    reply("Erro ao acessar as mensagens do e-mail tempor√°rio.");
  }
  break;
}
case 'numerofake-paises': {
  try {
    const { data } = await axios.get('https://api.vreden.my.id/api/tools/fakenumber/country');

    if (data.status !== 200) return reply("Erro ao obter a lista de pa√≠ses.");

    const lista = data.result.map(p => `- ${p.title} (${p.id})`).join('\n');
    reply(`üåç *Pa√≠ses dispon√≠veis para n√∫mero fake:*\n\n${lista}`);
  } catch (e) {
    reply("Erro ao buscar os pa√≠ses para n√∫mero fake.");
  }
  break;
}
case 'numerofake-lista': {
  if (!q) return reply("Informe o ID do pa√≠s. Ex: br, us, fr...");

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/fakenumber/listnumber?id=${q}`);

    if (data.status !== 200 || !data.result.length) return reply("Nenhum n√∫mero encontrado para esse pa√≠s.");

    const numeros = data.result.map((n, i) => `${i + 1}. ${n.number}`).join('\n');
    reply(`üì± *N√∫meros fake dispon√≠veis (${data.result[0].country}):*\n\n${numeros}`);
  } catch (e) {
    reply("Erro ao buscar os n√∫meros fake.");
  }
  break;
}
case 'numerofake-msg': {
  if (!q) return reply("Informe o n√∫mero fake. Ex: +556231810448");

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/fakenumber/message?nomor=${encodeURIComponent(q)}`);

    if (data.status !== 200 || !data.result.length) return reply("Nenhuma mensagem encontrada para esse n√∫mero.");

    const mensagens = data.result.map((msg, i) => {
      return `üì© *Mensagem ${i + 1}*\nüë§ De: ${msg.from}\nüïí ${msg.time_wib}\nüí¨ ${msg.content}`;
    }).join("\n\n");

    reply(`üì® *Mensagens recebidas por ${q}:*\n\n${mensagens}`);
  } catch (e) {
    reply("Erro ao buscar mensagens do n√∫mero.");
  }
  break;
}

case 'dnscheck': {
  if (!args[0]) return reply(`Informe uma URL para verificar.\nEx: ${prefix + command} https://vreden.my.id`);
  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/check-dns?url=${encodeURIComponent(args[0])}`);
    if (data.status !== 200) return reply("N√£o foi poss√≠vel verificar o DNS.");

    let msg = `*DNS Check para:* ${args[0]}\n\n`;
    for (const res of data.result) {
      const s = res.server;
      const d = res.dns_check;
      msg += `üåê *Servidor:* ${s.host} (${s.city}, ${s.country})\n`;
      msg += `üìå *IP:* ${s.ip}\n`;
      msg += `üß≠ *IPv4:* ${d.ipv4.join(', ')}\n`;
      msg += `üß¨ *IPv6:* ${d.ipv6.join(', ')}\n`;
      msg += `‚è± *TTL:* ${d.ttl}\n`;
      msg += `‚úÖ *Status:* ${d.result}\n\n`;
    }
    reply(msg.trim());
  } catch (e) {
    reply("Erro ao consultar o DNS.");
  }
  break;
}
case 'tcpcheck': {
  if (!args[0]) return reply(`Informe uma URL para verificar a conex√£o TCP.\nEx: ${prefix + command} https://vreden.my.id`);
  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/check-tcp?url=${encodeURIComponent(args[0])}`);
    if (data.status !== 200) return reply("N√£o foi poss√≠vel realizar o TCP Check.");

    let msg = `*TCP Check para:* ${args[0]}\n\n`;
    for (const res of data.result) {
      const s = res.server;
      const t = res.tcp_check;

      msg += `üåê *Servidor:* ${s.host} (${s.city}, ${s.country})\n`;
      msg += `üìå *IP do servidor:* ${s.ip}\n`;
      msg += `üß≠ *Host verificado:* ${t.host}\n`;
      msg += `üì∂ *IP da web:* ${t.ip_web || 'N√£o encontrado'}\n`;
      msg += `‚è± *Tempo de resposta:* ${t.time || 'Indefinido'}\n`;
      msg += `‚úÖ *Status:* ${t.result}\n\n`;
    }
    reply(msg.trim());
  } catch (e) {
    reply("Erro ao consultar o TCP Check.");
  }
  break;
}
case 'chekhost':
try {
  if (!q) return reply('Digite a URL que deseja verificar!\nEx: .chekhost https://www.vreden.my.id');
  reagir(from, "üåê");

  let res = await fetchJson(`https://api.vreden.my.id/api/tools/cekhost?url=${encodeURIComponent(q)}`);
  let data = res.result.checks;

  let texto = `üåç *Resultado da verifica√ß√£o de host:*\n`;
  texto += `üîó URL: ${q}\n`;
  texto += `üÜî Request ID: ${res.result.request_id}\n`;
  texto += `‚úÖ Status geral: ${res.result.status ? 'Online' : 'Offline'}\n\n`;

  data.forEach((check, i) => {
    texto += `üåê *Servidor ${i + 1}*\n`;
    texto += `- Pa√≠s: ${check.server.country} (${check.server.city})\n`;
    texto += `- IP do servidor: ${check.server.ip}\n`;
    texto += `- Host: ${check.http_check.host}\n`;
    texto += `- IP Web: ${check.http_check.ip_web}\n`;
    texto += `- Ping: ${check.http_check.ping}s\n`;
    texto += `- C√≥digo HTTP: ${check.http_check.status_code}\n`;
    texto += `- Resultado: ${check.http_check.result}\n\n`;
  });

  await blackmd.sendMessage(from, {text: texto}, {quoted: info});
} catch (error) {
  console.log(error);
  return reply('Deu um erro ao verificar o host, tente novamente mais tarde!');
}
break;
case "jogador":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer o nome de um jogador para consulta.");
    }

    try {
        const jogador = encodeURIComponent(q.trim()); // Sanitizando a entrada do usu√°rio

        const { data: res } = await axios.get(`https://world-ecletix.onrender.com/api/jogador/${jogador}`);
        
        if (!res || !res.nome) {
            return reply("Nenhum dado encontrado para o jogador fornecido.");
        }

        // Desestruturando os dados do jogador
        const { nome, time, idade, posicao, pais, altura, peso, numeroCamisa } = res;

        const message = `*Informa√ß√µes do Jogador ${nome}:*\n` +
                        `- Time: ${time}\n` +
                        `- Idade: ${idade} anos\n` +
                        `- Posi√ß√£o: ${posicao}\n` +
                        `- Pa√≠s: ${pais}\n` +
                        `- Altura: ${altura}\n` +
                        `- Peso: ${peso}\n` +
                        `- N√∫mero da Camisa: ${numeroCamisa}`;

        reply(message);
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case 'codificar':
  try {
    const query = q[1]; // O texto a ser codificado
    if (!query) return reply("Por favor, forne√ßa o texto para codifica√ß√£o.");

    // Enviando a requisi√ß√£o para a API de codifica√ß√£o
    const res = await axios.get(`https://api.nexfuture.com.br/api/outros/codificar?query=${query}`);
    
    if (res.data.status) {
      const encodedMessage = res.data.codificado;
      return reply(`A mensagem codificada √©: *${encodedMessage}*`);
    } else {
      return reply("Ocorreu um erro ao tentar codificar a mensagem.");
    }
  } catch (e) {
    console.log("Erro no codificar:", e);
    reply("Erro ao processar a codifica√ß√£o.");
  }
  break;
  case 'decodificar':
  try {
    const query = q[1]; // O c√≥digo bin√°rio a ser decodificado
    if (!query) return reply("Por favor, forne√ßa o c√≥digo bin√°rio para decodifica√ß√£o.");

    // Enviando a requisi√ß√£o para a API de decodifica√ß√£o
    const res = await axios.get(`https://api.nexfuture.com.br/api/outros/decodificar?query=${query}`);
    
    if (res.data.status) {
      const decodedMessage = res.data.decodificado;
      return reply(`A mensagem decodificada √©: *${decodedMessage}*`);
    } else {
      return reply("Ocorreu um erro ao tentar decodificar a mensagem.");
    }
  } catch (e) {
    console.log("Erro no decodificar:", e);
    reply("Erro ao processar a decodifica√ß√£o.");
  }
  break;
  case 'dicionario':
try {
if (!q) return reply('Coloque a palavra que deseja consultar no dicion√°rio!');
reagir(from, "üìç");
let dicio = await fetchJson(`https://api.nexfuture.com.br/api/pesquisas/dicionario?query=${encodeURIComponent(q)}`);

await blackmd.sendMessage(from, 
{image: {url: dicio.resultado.imagem}, 
caption: dicio.resultado.significado}, {quoted: info});
} catch (error) {
console.log(error);
return reply('Deu um pequeno erro, tente novamente mais tarde!');
}
break
 case 'printsite': 
try {
if(!q) return reply('Coloque o URL do site que deseja obter o print!');
reply('Buscando print do site...')

await blackmd.sendMessage(from, {image: 
{url: `https://api.nexfuture.com.br/api/outros/printsite?url=${q}`}}, 
{quoted: info});
} catch (error) {
console.log(error);
return reply('Deu um pequeno erro, tente novamente mais tarde!');
}
break;
  case 'morse':
  try {
    const texto = q[1]; // O texto a ser codificado em Morse
    if (!texto) return reply("Por favor, forne√ßa o texto para codificar em Morse.");
    
    // Enviando a requisi√ß√£o para a API de codifica√ß√£o Morse
    const res = await axios.get(`https://api.nexfuture.com.br/api/outros/morse?query=${encodeURIComponent(texto)}`);
    
    if (res.data.status) {
      const morseCode = res.data.resultado;
      reply(`Texto em Morse: ${morseCode}`);
    } else {
      reply("N√£o foi poss√≠vel codificar o texto em Morse.");
    }
  } catch (e) {
    console.log("Erro no morse:", e);
    reply("Erro ao codificar o texto em Morse.");
  }
  break;
case 'linkimg3':
try {
  if (!isQuotedImage) return reply(`${pushname}, marque uma imagem para gerar o link.`);
  setTimeout(() => { reagir(from, "üì∑") }, 300);

  const boij = JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.imageMessage;
  const buffer = await getFileBuffer(boij, "image");

  const FormData = require('form-data');
  const form = new FormData();
  form.append('reqtype', 'fileupload');
  form.append('fileToUpload', buffer, { filename: 'imagem.png' });

  const res = await axios.post("https://catbox.moe/user/api.php", form, {
    headers: form.getHeaders()
  });

  const link = res.data;
  if (!link.startsWith('https://')) throw new Error('Resposta inv√°lida do Catbox');

  return sendUrlText(from, link, `Link da imagem gerado com sucesso ‚Ü¥`, ``, link, link, seloctt);

} catch (e) {
  console.log("Erro no linkimg3:", e);
  reply("Erro ao gerar link da imagem.");
}
break;
case 'linkmp4':
case 'linkvideo2':
try {
  if (!(isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 31))
    return reply(`${pushname}, marque um v√≠deo de at√© 30 segundos.`);

  setTimeout(() => { reagir(from, "üé•") }, 300);

  const boij = JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.videoMessage;
  const buffer = await getFileBuffer(boij, "video");

  const FormData = require('form-data');
  const form = new FormData();
  form.append('reqtype', 'fileupload');
  form.append('fileToUpload', buffer, { filename: 'video.mp4' });

  const res = await axios.post("https://catbox.moe/user/api.php", form, {
    headers: form.getHeaders()
  });

  const link = res.data;
  if (!link.startsWith('https://')) throw new Error('Resposta inv√°lida do Catbox');

  return sendUrlText(from, link, `Link do v√≠deo gerado com sucesso ‚Ü¥`, ``, link, link, seloctt);

} catch (e) {
  console.log("Erro no linkmp4:", e);
  reply("Erro ao gerar link do v√≠deo.");
}
break;
case 'linkaudio2':
case 'linkmp3':
try {
  if (!isQuotedAudio) return reply(`${pushname}, marque um √°udio.`);
  setTimeout(() => { reagir(from, "üéß") }, 300);

  const boij = JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.audioMessage;
  const buffer = await getFileBuffer(boij, "audio");

  const FormData = require('form-data');
  const form = new FormData();
  form.append('reqtype', 'fileupload');
  form.append('fileToUpload', buffer, { filename: 'audio.mp3' });

  const res = await axios.post("https://catbox.moe/user/api.php", form, {
    headers: form.getHeaders()
  });

  const link = res.data;
  if (!link.startsWith('https://')) throw new Error('Resposta inv√°lida do Catbox');

  return sendUrlText(from, link, `Link do √°udio gerado com sucesso ‚Ü¥`, ``, link, link, seloctt);

} catch (e) {
  console.log("Erro no linkmp3:", e);
  reply("Erro ao gerar link do √°udio.");
}
break;
case 'linkimg2':
case 'linkfoto2':
try { 
    // essa porra foi criada por mim, entao deixe os cr√©ditos, by: ryuu
    if (isQuotedImage) {
        const boij = isQuotedImage 
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.imageMessage 
        : info;

        const fetch = require('node-fetch');
        const FormData = require('form-data');

        // Fun√ß√£o para fazer upload da imagem no Uguu
        async function uploadImageToUguu(imageBuffer) {
            const form = new FormData();
            form.append('files[]', imageBuffer, { filename: 'image.jpg' });

            const response = await fetch('https://uguu.se/upload', {
                method: 'POST',
                body: form
            });

            const data = await response.json();

            // Verifica se o upload foi bem-sucedido e se a URL foi retornada
            if (response.ok && data.files && data.files[0].url) {
                return data.files[0].url;
            } else {
                throw new Error('Falha ao obter o link da imagem a partir da resposta.');
            }
        }

        // Garante que a fun√ß√£o `getFileBuffer` est√° dispon√≠vel
        const owgi = await getFileBuffer(boij, "image");
        const imageUrl = await uploadImageToUguu(owgi);
        
        const ryuumods = `_*Link gerado com sucesso*_‚ö°Ô∏è\n\n${imageUrl}`;
        reply(ryuumods);

    } else {
        reply(`${pushname}, voc√™ tem que marcar a foto desejada.`);
    }
    
} catch (e) {
    console.log('Detalhes do erro:', e); 
    reply('Erro ao processar a imagem e gerar o link...');
} 
break;
case 'linkfoto4':
case 'linkimg':
try { 
    // essa porra foi criada por mim, entao deixe os cr√©ditos, by: ryuu
    if (isQuotedImage) {
        const boij = isQuotedImage 
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.imageMessage 
        : info;

        const fetch = require('node-fetch');
        const FormData = require('form-data');

        // Fun√ß√£o para fazer upload da imagem no Imgur
        async function uploadImageToImgur(imageBuffer) {
            const form = new FormData();
            form.append('image', imageBuffer, { filename: 'image.jpg' });

            const response = await fetch('https://api.imgur.com/3/image', {
                method: 'POST',
                body: form,
                headers: {
                    'Authorization': 'Client-ID 6c10f331b789cbf'
                }
            });

            const data = await response.json();
            
            // Verifica se o upload foi bem-sucedido e se a URL foi retornada
            if (response.ok && data.data && data.data.link) {
                return data.data.link;
            } else {
                throw new Error('Falha ao obter o link da imagem a partir da resposta.');
            }
        }

        // Garante que a fun√ß√£o `getFileBuffer` est√° dispon√≠vel
        const owgi = await getFileBuffer(boij, "image");
        const imageUrl = await uploadImageToImgur(owgi);
        
        const ryuumods = `_*Link gerado com sucesso*_‚ö°Ô∏è\n\n${imageUrl}`;
        reply(ryuumods);

    } else {
        reply(`${pushname}, voc√™ tem que marcar a foto desejada.`);
    }
    
} catch (e) {
    console.log('Detalhes do erro:', e); 
    reply('Erro ao processar a imagem e gerar o link...');
} 
break;
case 'linkfoto':
try { 
    // Verificando se a imagem foi marcada
    if (isQuotedImage) {
        const boij = isQuotedImage 
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.imageMessage 
        : info;

        const fetch = require('node-fetch');
        const FormData = require('form-data');

        // Fun√ß√£o para fazer upload da imagem no Uguu
        async function uploadImageToUguu(imageBuffer) {
            const form = new FormData();
            form.append('files[]', imageBuffer, { filename: 'image.jpg' });

            const response = await fetch('https://uguu.se/upload', {
                method: 'POST',
                body: form
            });

            const data = await response.json();

            // Verifica se o upload foi bem-sucedido e se a URL foi retornada
            if (response.ok && data.files && data.files[0].url) {
                return data.files[0].url;
            } else {
                throw new Error('Falha ao obter o link da imagem a partir da resposta.');
            }
        }

        // Garante que a fun√ß√£o `getFileBuffer` est√° dispon√≠vel
        const owgi = await getFileBuffer(boij, "image");
        const imageUrl = await uploadImageToUguu(owgi);
        
        const ryuumods = `_*Link gerado com sucesso*_‚ö°Ô∏è\n\n${imageUrl}`;
        reply(ryuumods);

    } else {
        reply(`${pushname}, voc√™ tem que marcar a foto desejada.`);
    }
    
} catch (e) {
    console.log('Detalhes do erro:', e); 
    reply('Erro ao processar a imagem e gerar o link...');
} 
break;

case 'linkvideo':
try { 
    // Verificando se o v√≠deo foi marcado
    if (isQuotedVideo || (isMedia && info.message.videoMessage.seconds < 30)) {
        const boij = isQuotedVideo
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.videoMessage 
        : info.message.videoMessage;

        const fetch = require('node-fetch');
        const FormData = require('form-data');

        // Fun√ß√£o para fazer upload do v√≠deo no Uguu
        async function uploadVideoToUguu(videoBuffer) {
            const form = new FormData();
            form.append('files[]', videoBuffer, { filename: 'video.mp4' });

            const response = await fetch('https://uguu.se/upload', {
                method: 'POST',
                body: form
            });

            const data = await response.json();

            // Verifica se o upload foi bem-sucedido e se a URL foi retornada
            if (response.ok && data.files && data.files[0].url) {
                return data.files[0].url;
            } else {
                throw new Error('Falha ao obter o link do v√≠deo a partir da resposta.');
            }
        }

        // Garante que a fun√ß√£o `getFileBuffer` est√° dispon√≠vel
        const owgi = await getFileBuffer(boij, "video");
        const videoUrl = await uploadVideoToUguu(owgi);
        
        const ryuumods = `_*Link gerado com sucesso*_‚ö°Ô∏è\n\n${videoUrl}`;
        reply(ryuumods);

    } else {
        reply(`${pushname}, voc√™ tem que marcar o v√≠deo (m√°ximo de 30 segundos).`);
    }
    
} catch (e) {
    console.log('Detalhes do erro:', e); 
    reply('Erro ao processar o v√≠deo e gerar o link...');
} 
break;

case 'linkaudio':
try { 
    // Verificando se o √°udio foi marcado
    if (isQuotedAudio || (isMedia && info.message.audioMessage)) {
        const boij = isQuotedAudio
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.audioMessage 
        : info.message.audioMessage;

        const fetch = require('node-fetch');
        const FormData = require('form-data');

        // Fun√ß√£o para fazer upload do √°udio no Uguu
        async function uploadAudioToUguu(audioBuffer) {
            const form = new FormData();
            form.append('files[]', audioBuffer, { filename: 'audio.mp3' });

            const response = await fetch('https://uguu.se/upload', {
                method: 'POST',
                body: form
            });

            const data = await response.json();

            // Verifica se o upload foi bem-sucedido e se a URL foi retornada
            if (response.ok && data.files && data.files[0].url) {
                return data.files[0].url;
            } else {
                throw new Error('Falha ao obter o link do √°udio a partir da resposta.');
            }
        }

        // Garante que a fun√ß√£o `getFileBuffer` est√° dispon√≠vel
        const owgi = await getFileBuffer(boij, "audio");
        const audioUrl = await uploadAudioToUguu(owgi);
        
        const ryuumods = `_*Link gerado com sucesso*_‚ö°Ô∏è\n\n${audioUrl}`;
        reply(ryuumods);

    } else {
        reply(`${pushname}, voc√™ tem que marcar o √°udio.`);
    }
    
} catch (e) {
    console.log('Detalhes do erro:', e); 
    reply('Erro ao processar o √°udio e gerar o link...');
} 
break;
case 'fazerlink2':
case 'linkmidia2':
case 'linkcatbox':
try { 
    const fetch = require('node-fetch');
    const FormData = require('form-data');

    // Fun√ß√£o para fazer upload no Catbox
    async function uploadToCatbox(buffer, filename) {
        const form = new FormData();
        form.append('reqtype', 'fileupload');
        form.append('fileToUpload', buffer, { filename });

        const response = await fetch('https://catbox.moe/user/api.php', {
            method: 'POST',
            body: form
        });

        const text = await response.text();

        if (response.ok && text.startsWith("https://")) {
            return text.trim();
        } else {
            throw new Error('Resposta inv√°lida do Catbox.');
        }
    }

    // Verificando e processando IMAGEM
    if (isQuotedImage || (isMedia && info.message.imageMessage)) {
        const boij = isQuotedImage 
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.imageMessage 
        : info.message.imageMessage;

        const buffer = await getFileBuffer(boij, "image");
        const url = await uploadToCatbox(buffer, "imagem.jpg");
        reply(`_*Link da imagem gerado com sucesso*_‚ö°Ô∏è\n\n${url}`);

    // Verificando e processando V√çDEO
    } else if ((isQuotedVideo && JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.videoMessage.seconds < 30)
        || (isMedia && info.message.videoMessage && info.message.videoMessage.seconds < 30)) {

        const boij = isQuotedVideo 
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.videoMessage 
        : info.message.videoMessage;

        const buffer = await getFileBuffer(boij, "video");
        const url = await uploadToCatbox(buffer, "video.mp4");
        reply(`_*Link do v√≠deo gerado com sucesso*_‚ö°Ô∏è\n\n${url}`);

    // Verificando e processando √ÅUDIO
    } else if (isQuotedAudio || (isMedia && info.message.audioMessage)) {
        const boij = isQuotedAudio 
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.audioMessage 
        : info.message.audioMessage;

        const buffer = await getFileBuffer(boij, "audio");
        const url = await uploadToCatbox(buffer, "audio.mp3");
        reply(`_*Link do √°udio gerado com sucesso*_‚ö°Ô∏è\n\n${url}`);

    } else {
        reply(`${pushname}, voc√™ deve marcar uma imagem, v√≠deo (at√© 30s) ou √°udio.`);
    }

} catch (e) {
    console.log('Erro no linkcatbox:', e); 
    reply('Erro ao gerar o link no Catbox...');
}
break;
case 'fazerlink':
case 'upload':
case 'linkmidia':
try {
    const fetch = require('node-fetch');
    const FormData = require('form-data');

    // Fun√ß√£o para fazer upload no Uguu
    async function uploadToUguu(fileBuffer, filename) {
        const form = new FormData();
        form.append('files[]', fileBuffer, { filename: filename });

        const response = await fetch('https://uguu.se/upload', {
            method: 'POST',
            body: form
        });

        const data = await response.json();

        // Verifica se o upload foi bem-sucedido e se a URL foi retornada
        if (response.ok && data.files && data.files[0].url) {
            return data.files[0].url;
        } else {
            throw new Error('Falha ao obter o link a partir da resposta.');
        }
    }

    // Processando a imagem
    if (isQuotedImage || (isMedia && info.message.imageMessage)) {
        const boij = isQuotedImage
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.imageMessage
        : info.message.imageMessage;

        console.log("Processando imagem...");
        const owgi = await getFileBuffer(boij, "image");
        const imageUrl = await uploadToUguu(owgi, 'image.jpg');
        
        const ryuumods = `_*Link gerado com sucesso*_‚ö°Ô∏è\n\n${imageUrl}`;
        reply(ryuumods);

    // Processando o v√≠deo
    } else if ((isQuotedVideo || (isMedia && info.message.videoMessage)) && info.message.videoMessage.seconds < 30) {
        const boij = isQuotedVideo
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.videoMessage
        : info.message.videoMessage;

        console.log("Processando v√≠deo...");
        const owgi = await getFileBuffer(boij, "video");
        const videoUrl = await uploadToUguu(owgi, 'video.mp4');
        
        const ryuumods = `_*Link gerado com sucesso*_‚ö°Ô∏è\n\n${videoUrl}`;
        reply(ryuumods);

    // Processando o √°udio
    } else if (isQuotedAudio || (isMedia && info.message.audioMessage)) {
        const boij = isQuotedAudio
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.audioMessage
        : info.message.audioMessage;

        console.log("Processando √°udio...");
        const owgi = await getFileBuffer(boij, "audio");
        const audioUrl = await uploadToUguu(owgi, 'audio.mp3');
        
        const ryuumods = `_*Link gerado com sucesso*_‚ö°Ô∏è\n\n${audioUrl}`;
        reply(ryuumods);

    } else {
        reply("Voc√™ deve marcar uma imagem, v√≠deo (m√°ximo de 30 segundos) ou √°udio.");
    }

} catch (e) {
    console.log('Detalhes do erro:', e); 
    reply('Erro ao processar a m√≠dia e gerar o link...');
} 
break;
case 'transcrever2':
case 'transcricao':
case 'transcri√ß√£o':
{
    if (!isGroup) return reply(enviar.msg.grupo);
    if (!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for um, apenas digite ${prefix}modozoeira`);
    
    // Verifica se h√° uma mensagem de √°udio marcada
    if (!info.quoted || info.quoted.mtype !== 'audioMessage') {
        return reply('Marque um √°udio para ser transcrito.');
    }

    try {
        // Obt√©m o URL do √°udio
        const media = await downloadMediaMessage(info.quoted, "buffer", {}, { reuploadRequest: true });
        const filePath = path.join(__dirname, 'temp', `${Date.now()}.mp3`);
        fs.writeFileSync(filePath, media);

        // Envia o √°udio para algum servidor p√∫blico com upload (ex: anonfiles, telegra.ph ou storage pr√≥prio)
        const form = new FormData();
        form.append("file", fs.createReadStream(filePath));

        const uploadRes = await axios.post("https://uguu.se/upload.php", form, {
            headers: form.getHeaders()
        });

        fs.unlinkSync(filePath); // Remove o arquivo local

        const audioUrl = uploadRes.data.files[0].url;

        // Faz a transcri√ß√£o usando a API da NexFuture
        const { data } = await axios.get(`https://api.nexfuture.com.br/api/outros/aspose-transcribe?url=${encodeURIComponent(audioUrl)}&diarization=true&is_multilingual=false`);

        if (!data || !data.result || !data.result.success) {
            return reply("N√£o foi poss√≠vel transcrever o √°udio.");
        }

        const texto = data.result.data;
        reply(`*Transcri√ß√£o do √°udio:*\n\n${texto}`);

    } catch (err) {
        console.error(err);
        reply("Ocorreu um erro ao tentar transcrever o √°udio.");
    }
}
break;

case "audiomeme":
{
    if (!q) {
        return reply(`Por favor, forne√ßa o termo de busca. Exemplo: ${prefix}audio termo_da_busca`);
    }

    try {
        const response = await axios.get(`https://world-ecletix.onrender.com/api/audiomeme?query=${encodeURIComponent(q)}`);
        const result = response.data;

        if (!result || !result.status || !result.results || result.results.length === 0) {
            return reply("N√£o foram encontrados resultados para o termo fornecido.");
        }

        const firstAudio = result.results[0];
        const audioUrl = firstAudio.audio;
        const title = firstAudio.title;
        console.log(`[AUDIO] Primeiro √°udio encontrado: ${title}, URL: ${audioUrl}`);

        const audioResponse = await axios.get(audioUrl, { responseType: 'arraybuffer' });

        if (!audioResponse.data || audioResponse.data.length === 0) {
            throw new Error('√Åudio n√£o foi baixado corretamente.');
        }

        await blackmd.sendMessage(
            from,
            {
                audio: Buffer.from(audioResponse.data),
                mimetype: 'audio/mpeg',
                fileName: `${title}.mp3`,
                ptt: true
            },
            { quoted: info }
        );

    } catch (error) {
        console.error('Erro ao processar a solicita√ß√£o:', error);
        reply("Ocorreu um erro ao processar a solicita√ß√£o. Tente novamente mais tarde.");
    }
}
break;
case "pesq_audios":
case "pesqaudios":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer um termo de busca para consulta.");
    }

    try {
        const query = q.trim();
        if (query.length === 0) {
            return reply("Por favor, forne√ßa um termo v√°lido para a busca.");
        }

        const res = await axios.get(`https://world-ecletix.onrender.com/api/audiomeme?query=${encodeURIComponent(query)}`);
        const result = res.data;

        if (!result || !result.status || !result.results || result.results.length === 0) {
            return reply("Nenhum dado encontrado para o termo de busca fornecido.");
        }

        let message = `*Resultados para a busca "${query}":*\n\n`;
        result.results.forEach((item, index) => {
            message += `${index + 1}. *${item.title}*\nüîä ${item.audio}\n\n`;
        });

        reply(message);

    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case 'fazernick':{ // BY ALIZINDEV //by: ALIZINDEV 
if (!q) return reply(`Exemple\n${prefix+command} AlizinDev`)
let lizink_res = await fetchJson(`https://alizindev-api.onrender.com/api/tools/styletext?text=${q}&apikey=a93e85c1`)
let lizinn = lizink_res.resultado
let alizinnk =`*NICKS*\n\n`
for (let x of lizinn){
alizinnk +=`RESULTADO : ${x.result}\n\n`
}
reply(alizinnk)
}
break
case 'frases': {
    try {
        if (!q.trim()) return reply(`- Exemplo: ${prefix}frases luz`);

        const response = await fetch(`https://world-ecletix.onrender.com/api/pensador?nome=${encodeURIComponent(q)}`);
        if (!response.ok) return reply("Erro ao buscar as frases.");

        const data = await response.json();

        if (!data.length) return reply("Nenhuma frase encontrada.");

        let message = `*Frases sobre ${q}:*\n\n`;

        data.forEach((fraseInfo) => {
            message += `*Frase:* ${fraseInfo.frase}\n` +
                       `*Compartilhamentos:* ${fraseInfo.compartilhamentos}\n` +
                       `*Imagem:* ${fraseInfo.image}\n\n`;
        });

        return reply(message.trim());

    } catch (e) {
        console.log('Erro no bloco try:', e);
        return reply("Erro ao tentar buscar as frases.");
    }
}
break;
case 'pensador': {
    try {
        const response = await fetch(`https://world-ecletix.onrender.com/api/frasespensador`);
        if (!response.ok) return reply("Erro ao buscar as frases.");

        const data = await response.json();

        if (!data.length) return reply("Nenhuma frase encontrada.");

        let message = "*Frases Inspiradoras:*\n\n";

        data.forEach((frase, index) => {
            message += `*${index + 1}.* ${frase}\n\n`;
        });

        return reply(message.trim());

    } catch (e) {
        console.log('Erro no bloco try:', e);
        return reply("Erro ao tentar buscar as frases.");
    }
}
break;
case "signo":
{
    if (!q) {
        return reply("Por favor, informe o signo. Exemplo: !signo touro");
    }

    try {
        const signo = q.trim().toLowerCase();
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/horoscopo/${encodeURIComponent(signo)}`);

        if (!data || !data.horoscopo) {
            return reply("N√£o encontrei informa√ß√µes para o signo informado. Verifique se o nome est√° correto.");
        }

        let msg = `*Hor√≥scopo de ${signo.charAt(0).toUpperCase() + signo.slice(1)}*\n\n`;
        msg += `*Hor√≥scopo:* ${data.horoscopo}\n`;
        msg += `*Palpite:* ${data.palpite}\n`;
        msg += `*Cor:* ${data.cor}\n`;
        msg += `*Elemento:* ${data.elemento}\n`;
        msg += `*Regente:* ${data.regente}\n`;
        msg += `*Flor:* ${data.flor}\n`;
        msg += `*Metal:* ${data.metal}\n`;
        msg += `*Pedra:* ${data.pedra}\n`;
        msg += `*Amuleto:* ${data.amuletos}\n`;
        msg += `*Perfume:* ${data.perfume}\n`;
        msg += `*Anjo:* ${data.anjo}\n`;
        msg += `*Orix√°:* ${data.orixa}\n`;
        msg += `*Santo protetor:* ${data.santoProtetor}\n`;

        reply(msg);

    } catch (error) {
        console.error(error);
        reply("Ocorreu um erro ao buscar o hor√≥scopo. Tente novamente mais tarde.");
    }
}
break;
case 'verhtml':
case "html":
{
    if (!q) {
        return reply("Por favor, informe a URL que deseja visualizar o HTML. Exemplo: !html https://youtube.com");
    }

    try {
        const url = q.trim();
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/verhtml?url=${encodeURIComponent(url)}`);

        if (!data || !data.html) {
            return reply("N√£o foi poss√≠vel obter o HTML da p√°gina informada.");
        }

        // Extrair dom√≠nio e formatar para nome do arquivo
        const { hostname } = new URL(url);
        const domainName = hostname.replace(/\./g, "_"); // Ex: youtube.com -> youtube_com
        const fileName = `${domainName}.html`;

        const htmlBuffer = Buffer.from(data.html, 'utf-8');

        await blackmd.sendMessage(
            from,
            {
                document: htmlBuffer,
                fileName: fileName,
                mimetype: 'text/html'
            },
            { quoted: info }
        );

    } catch (error) {
        console.error(error);
        reply("Ocorreu um erro ao tentar buscar o HTML da p√°gina.");
    }
}
break;
case "traduzir":
{
    if (!q) {
        return reply("Por favor, envie o texto que deseja traduzir. Exemplo: !traduzir love");
    }

    try {
        const texto = q.trim();
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/traduzir?texto=${encodeURIComponent(texto)}`);

        if (!data || !data.translation) {
            return reply("N√£o foi poss√≠vel traduzir o texto informado.");
        }

        const msg = `*Tradu√ß√£o:*\n\nOriginal: ${data.original}\nPortugu√™s: ${data.translation}`;
        reply(msg);

    } catch (error) {
        console.error(error);
        reply("Ocorreu um erro ao tentar traduzir o texto.");
    }
}
break;

// PESQUISAS
case 'pinstalk':
  if (!q) return reply('Me envie o nome de usu√°rio do Pinterest que deseja consultar.');

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/stalk/pinterest?query=${encodeURIComponent(q)}`);

    if (data?.status === 200 && data?.result?.username) {
      const user = data.result;
      const profilePicUrl = user.image.original; // Imagem de perfil
      const followers = user.stats.followers;
      const following = user.stats.following;
      const pins = user.stats.pins;
      const boards = user.stats.boards;
      const bio = user.bio || 'N√£o definida';
      const fullName = user.full_name;
      const username = user.username;
      const profileUrl = user.profile_url;

      // Enviar a imagem e as informa√ß√µes do usu√°rio
      await blackmd.sendMessage(from, 
        { image: { url: profilePicUrl }, caption: `
          *‚Ä¢ Nome Completo*: ${fullName}
          *‚Ä¢ Username*: ${username}
          *‚Ä¢ Seguidores*: ${followers}
          *‚Ä¢ Seguindo*: ${following}
          *‚Ä¢ Pins*: ${pins}
          *‚Ä¢ Boards*: ${boards}
          *‚Ä¢ Biografia*: ${bio}
          *‚Ä¢ Link do Perfil*: ${profileUrl}
        `}, { quoted: info });
    } else {
      reply('N√£o foi poss√≠vel obter informa√ß√µes sobre esse usu√°rio.');
    }
  } catch (err) {
    console.log(err);
    reply('Erro ao consultar informa√ß√µes do Pinterest.');
  }
  break;
  
case 'npmstalk':
  if (!q) return reply('Me envie o nome do pacote NPM que deseja consultar.');

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/npmstalk?query=${encodeURIComponent(q)}`);

    if (data?.status === true && data?.result) {
      const packageInfo = data.result;
      const packageName = packageInfo.name;
      const latestVersion = packageInfo.dist-tags.latest;
      const versions = packageInfo.versions;
      const description = packageInfo.description || 'N√£o h√° descri√ß√£o dispon√≠vel.';
      const repository = packageInfo.repository || 'N√£o dispon√≠vel.';
      const distTarball = packageInfo.versions[latestVersion]?.dist?.tarball;

      reply(`
        *‚Ä¢ Nome do Pacote*: ${packageName}
        *‚Ä¢ Vers√£o mais recente*: ${latestVersion}
        *‚Ä¢ Descri√ß√£o*: ${description}
        *‚Ä¢ Reposit√≥rio*: ${repository}
        *‚Ä¢ Link do pacote*: ${distTarball}
      `);
    } else {
      reply('N√£o foi poss√≠vel obter informa√ß√µes sobre esse pacote NPM.');
    }
  } catch (err) {
    console.log(err);
    reply('Erro ao consultar informa√ß√µes do pacote NPM.');
  }
  break;
  case 'kwaistalk':
  if (!q) return reply('Me envie o nome de usu√°rio do Kwai que deseja consultar.');

  try {
    const { data } = await axios.get(`https://api.nexfuture.com.br/api/outros/kwstalk?query=${encodeURIComponent(q)}`);

    if (data?.status === true && data?.resultado) {
      const user = data.resultado;
      const avatarUrl = user.foto_perfil;
      const bio = user.bio || 'N√£o definida';
      const followers = user.seguidores;
      const following = user.seguindo;
      const likes = user.curtidas;
      const username = user.nome_usuario;
      const kwaiUrl = user.url_perfil;
      const videos = user.videos.slice(0, 3); // Pegar os 3 primeiros v√≠deos

      // Enviar as informa√ß√µes do perfil
      await blackmd.sendMessage(from, {
        image: { url: avatarUrl },
        caption: `
          *‚Ä¢ Nome de Usu√°rio*: ${username}
          *‚Ä¢ Bio*: ${bio}
          *‚Ä¢ Seguidores*: ${followers}
          *‚Ä¢ Seguindo*: ${following}
          *‚Ä¢ Curtidas*: ${likes}
          *‚Ä¢ Link do Perfil*: ${kwaiUrl}
        `
      }, { quoted: info });

      // Enviar v√≠deos
      for (let i = 0; i < videos.length; i++) {
        const video = videos[i];
        await blackmd.sendMessage(from, {
          video: { url: video.url },
          caption: `
            *‚Ä¢ T√≠tulo*: ${video.titulo}
            *‚Ä¢ Descri√ß√£o*: ${video.descricao}
            *‚Ä¢ Curtidas*: ${video.curtidas}
            *‚Ä¢ Coment√°rios*: ${video.comentarios}
            *‚Ä¢ Compartilhamentos*: ${video.compartilhamentos}
            *‚Ä¢ Dura√ß√£o*: ${video.duracao}
            *‚Ä¢ Link do V√≠deo*: ${video.url}
          `
        }, { quoted: info });
      }
    } else {
      reply('N√£o foi poss√≠vel obter informa√ß√µes sobre esse usu√°rio do Kwai.');
    }
  } catch (err) {
    console.log(err);
    reply('Erro ao consultar informa√ß√µes do Kwai.');
  }
  break;
  case 'gitstalk':
 case 'githubStalk':
  case 'githubstalk':
  if (!q) return reply('Me envie o nome de usu√°rio do GitHub que deseja consultar.');

  try {
    const { data } = await axios.get(`https://api.nexfuture.com.br/api/outros/github/stalk?username=${encodeURIComponent(q)}`);

    if (data?.status === true && data?.resultado) {
      const user = data.resultado;
      const avatarUrl = user.avatar_url;
      const bio = user.bio || 'N√£o definida';
      const followers = user.followers;
      const following = user.following;
      const repos = user.public_repos;
      const username = user.login;
      const githubUrl = user.html_url;

      // Enviar as informa√ß√µes e a foto do perfil juntas
      await blackmd.sendMessage(from, {
        image: { url: avatarUrl },
        caption: `
          *‚Ä¢ Nome de Usu√°rio*: ${username}
          *‚Ä¢ Bio*: ${bio}
          *‚Ä¢ Seguidores*: ${followers}
          *‚Ä¢ Seguindo*: ${following}
          *‚Ä¢ Reposit√≥rios P√∫blicos*: ${repos}
          *‚Ä¢ Link do Perfil*: ${githubUrl}
        `
      }, { quoted: info });
    } else {
      reply('N√£o foi poss√≠vel obter informa√ß√µes sobre esse usu√°rio do GitHub.');
    }
  } catch (err) {
    console.log(err);
    reply('Erro ao consultar informa√ß√µes do GitHub.');
  }
  break;
case 'tikstalk':
case 'tiktokStalk':
  if (!q) return reply('Me envie o nome de usu√°rio do TikTok que deseja consultar.');

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tiktokStalk?query=${encodeURIComponent(q)}`);

    if (data?.status === 200 && data?.result?.user) {
      const user = data.result.user;
      const profilePicUrl = user.avatarLarger;
      const followers = data.result.stats.followerCount;
      const following = data.result.stats.followingCount;
      const hearts = data.result.stats.heartCount;
      const videos = data.result.stats.videoCount;
      const signature = user.signature || 'N√£o definida';
      const nickname = user.nickname;
      const username = user.uniqueId;
      const imageUrl = data.result.image;

      // Enviar a imagem e as informa√ß√µes do usu√°rio
      await blackmd.sendMessage(from, 
        { image: { url: profilePicUrl }, caption: `
          *‚Ä¢ Nome*: ${nickname}
          *‚Ä¢ Username*: @${username}
          *‚Ä¢ Seguidores*: ${followers}
          *‚Ä¢ Seguindo*: ${following}
          *‚Ä¢ Curtidas*: ${hearts}
          *‚Ä¢ V√≠deos*: ${videos}
          *‚Ä¢ Biografia*: ${signature}
          *‚Ä¢ Link da Imagem*: ${imageUrl}
        `}, { quoted: info });
    } else {
      reply('N√£o foi poss√≠vel obter informa√ß√µes sobre esse usu√°rio.');
    }
  } catch (err) {
    console.log(err);
    reply('Erro ao consultar informa√ß√µes do TikTok.');
  }
  break;
case 'instalk':
case 'usergram':
case 'igstalk':
  if (!q) return reply('Me envie o nome de usu√°rio do Instagram que deseja consultar.');

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/igstalk?query=${encodeURIComponent(q)}`);
    
    if (data?.status === 200 && data?.result?.user) {
      const user = data.result.user;
      const profilePicUrl = user.profile_pic_url;
      const followers = user.follower_count;
      const following = user.following_count;
      const posts = user.media_count;
      const bio = user.biography || 'N√£o definida';
      const fullName = user.full_name;
      const username = user.username;
      const imageUrl = user.image;
      
      // Enviar a imagem e as informa√ß√µes do usu√°rio
      await blackmd.sendMessage(from, 
        { image: { url: profilePicUrl }, caption: `
          *‚Ä¢ Nome Completo*: ${fullName}
          *‚Ä¢ Username*: ${username}
          *‚Ä¢ Seguidores*: ${followers}
          *‚Ä¢ Seguindo*: ${following}
          *‚Ä¢ Posts*: ${posts}
          *‚Ä¢ Biografia*: ${bio}
          *‚Ä¢ Link da Imagem*: ${imageUrl}
        `}, { quoted: info });
    } else {
      reply('N√£o foi poss√≠vel obter informa√ß√µes sobre esse usu√°rio.');
    }
  } catch (err) {
    console.log(err);
    reply('Erro ao consultar informa√ß√µes do Instagram.');
  }
  break;
case 'gimage':
  if (!q) return reply('Me envie o nome que deseja consultar.');

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/gimage?query=${encodeURIComponent(q)}`);
    
    if (data?.status === 200 && data?.result?.length > 0) {
      const imageUrl = data.result[0]; // Pegando a primeira imagem da lista

      await blackmd.sendMessage(from, { image: { url: imageUrl }, caption: 'Aqui est√° a primeira imagem que encontrei!' }, { quoted: info });
    } else {
      reply('N√£o encontrei nenhuma imagem para essa consulta.');
    }
  } catch (err) {
    console.log(err);
    reply('Erro ao consultar imagens.');
  }
  break;
case 'biblia':
    if (!q) return reply('[üìñ] Por favor, informe o vers√≠culo que deseja buscar. Exemplo: !biblia salmo 91', { quoted: info });

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/biblia?vers=${encodeURIComponent(q)}`);
        if (!data || !data.text) return reply('üö® Vers√≠culo n√£o encontrado!', { quoted: info });

        const versiculos = data.verses.map(v => `*${v.book_name} ${v.chapter}:${v.verse}* ‚Äî ${v.text.trim()}`).join('\n');

        const msg = `üìñ *${data.reference}*\n\n${versiculos}\n\n*Tradu√ß√£o:* ${data.translation_name}`;
        reply(msg, { quoted: info });

    } catch (error) {
        console.error(error);
        reply('üö® Erro ao buscar vers√≠culo. Verifique se escreveu corretamente, ex: !biblia salmo 91', { quoted: info });
    }
    break;
    case 'temporal': {
    try {
        if (!q) return reply('Por favor, forne√ßa o nome de uma cidade.');

        let city = q;
        let response = await fetch(`https://wttr.in/${city}?format=j1`);
        let data = await response.json();

        if (data.error) {
            return reply(`Desculpe, n√£o consegui encontrar a previs√£o do tempo para "${city}".`);
        }

        let weatherDescription = data.current_condition[0].weatherDesc[0].value;
        let temperature = data.current_condition[0].temp_C;
        let feelsLike = data.current_condition[0].FeelsLikeC;
        let humidity = data.current_condition[0].humidity;
        let windSpeed = data.current_condition[0].windspeedKmph;

        let weatherMessage = `Previs√£o do tempo para ${data.nearest_area[0].areaName[0].value}, ${data.nearest_area[0].region[0].value}, ${data.nearest_area[0].country[0].value}:
        üå°Ô∏è Temperatura: ${temperature}¬∞C
        ü§î Sensa√ß√£o t√©rmica: ${feelsLike}¬∞C
        üíß Umidade: ${humidity}%
        üå¨Ô∏è Velocidade do vento: ${windSpeed} km/h
        ‚òÅÔ∏è Condi√ß√µes: ${weatherDescription}`;

        reply(weatherMessage);
    } catch (e) {
        console.error(e);
        reply('Desculpe, ocorreu um erro ao buscar a previs√£o do tempo. Tente novamente mais tarde.');
    }
    break;
}

case 'significado':
    if (args.length == 0) return await reply('Cad√™ o nome o qual voc√™ deseja ver o significado?');
    
    const significado = encodeURIComponent(args.join(' ')); // Nome formatado para a URL
    try {
        const response = await axios.get(`https://world-ecletix.onrender.com/api/significadodonome?nome=${significado}`);
        const res = response.data;

        if (!res.significado) {
            return await reply('Nenhum significado encontrado para o nome fornecido.');
        }

        const { significado, origem, genero, imageUrl } = res;

        // Baixa a imagem do nome como buffer
        const fotoNome = await axios.get(imageUrl, { responseType: 'arraybuffer' });
        const imageBuffer = Buffer.from(fotoNome.data, 'binary');

        // Formata a mensagem com as informa√ß√µes do nome
        const message = `*Nome:* ${nome}\n` +
                        `*Significado:* ${significado}\n` +
                        `*Origem:* ${origem}\n` +
                        `*G√™nero:* ${genero || 'N√£o especificado'}\n`;

        // Envia a imagem com a legenda formatada
        await blackmd.sendMessage(from, { image: imageBuffer, caption: message }).catch((e) => {
            console.log(e);
            return reply('Ocorreu um erro ao enviar a imagem ou as informa√ß√µes.');
        });
    } catch (error) {
        console.error(error);
        return reply('Ocorreu um erro ao processar a solicita√ß√£o.');
    }
break;

case 'feriados':
    if (!q) return reply(`Favor informar o ano desejado.`); 
    try {
    const resposta = await fetch(`https://api.invertexto.com/v1/holidays/${q}?token=5980|9n1NZ449fdM1Hxs8K8urHxDZRVfEznwI&state=br`);
    const feriados = await resposta.json();
    let mensagem = `*‚Ä¢ Feriados para o ano de ${q}*:\n\n`;
    feriados.forEach(({ date, name, type }) => { mensagem += `*‚Ä¢ Data:* _${date}_\n*‚Ä¢ Feriado:* _${name}_\n*‚Ä¢ Tipo:* _${type}_\n*‚Äî*\n`});
    blackmd.sendMessage(from, { text: mensagem }, { quoted: info }) } catch(error) { reply(`Erro ao obter a lista de feriados.`)}
    break;
    case 'receita': // Feito por Slayer
    try {
        let url;
        if (!args[0]) {
            url = 'https://www.themealdb.com/api/json/v1/1/random.php'; // Receita aleat√≥ria
        } else {
            const nomeReceita = args.join(' ');
            url = `https://www.themealdb.com/api/json/v1/1/search.php?s=${encodeURIComponent(nomeReceita)}`;
        }

        const response = await axios.get(url);
        const data = response.data;

        if (!data.meals) {
            return reply('‚ùå Nenhuma receita encontrada! Tente outro nome ou use /receita para uma aleat√≥ria.');
        }

        const receita = data.meals[0];
        const titulo = receita.strMeal;
        const categoria = receita.strCategory || "Desconhecida";
        const instrucoes = receita.strInstructions.length > 500 ? receita.strInstructions.slice(0, 500) + '...' : receita.strInstructions;
        const imagem = receita.strMealThumb;
        const link = receita.strSource || `https://www.themealdb.com/meal/${receita.idMeal}`;

        let ingredientes = '';
        for (let i = 1; i <= 20; i++) {
            if (receita[`strIngredient${i}`]) {
                ingredientes += `üîπ ${receita[`strIngredient${i}`]} - ${receita[`strMeasure${i}`]}\n`;
            }
        }

        const mensagemReceita = `
üçΩ *Receita Encontrada!* üçΩ

üîπ *Nome:* ${titulo}
üîπ *Categoria:* ${categoria}
üîπ *Ingredientes:*  
${ingredientes}
üîπ *Modo de Preparo:*  
${instrucoes}
üîπ *Link Completo:* [Clique Aqui](${link})
        `;

        if (imagem) {
            const buffer = await getBuffer(imagem);
            await blackmd.sendMessage(from, { image: buffer, caption: mensagemReceita }, { quoted: info });
        } else {
            await blackmd.sendMessage(from, { text: mensagemReceita }, { quoted: info });
        }
    } catch (erro) {
        console.error('Erro ao buscar receita:', erro);
        reply('‚ùå Ocorreu um erro ao buscar a receita. Tente novamente mais tarde.');
    }
    break;
case 'endereco':
case 'maps'://slayer
    if (!args[0]) return reply('‚ùå Escreva um endere√ßo para pesquisar no Google Maps.');

    let endereco = args.join(' ');
    let linkMaps = `https://www.google.com/maps/search/${encodeURIComponent(endereco)}`;

    reply(`üó∫ *Local Encontrado:*  
üìç ${endereco}  
üîó [Ver no Google Maps](${linkMaps})`);
    break;
    
    case 'Wikipedia':
    case 'wikipedia': //Wikip√©dia atualizado
    try {
        if (!q) return reply('Insira o termo de busca para Wikip√©dia!');

        // Fun√ß√£o para enviar a imagem e o texto
        const sendImageURL = (texts, url) => {
            const textinhur = `\n${q}\n\n  ‚Ä¢ ${texts}`;
            
            // Envia a imagem e o texto
            blackmd.sendMessage(from, {
                image: {
                    url
                },
                caption: textinhur
            }, {
                quoted: info
            });
        };

        // Define a base URL da Wikipedia
        const base = 'https://pt.m.wikipedia.org';

        // Faz a busca na Wikipedia
        const { data } = await axios.get(`${base}/w/index.php?search=${q}&title=Special:Search&profile=advanced&fulltext=1&ns0=1`);

        const $ = cheerio.load(data);
        const array = [];

        // Captura os links de resultados
        $('.mw-search-result-heading').each(function() {
            const ref = $(this).find('a').attr('href');
            if (ref) {
                array.push(ref);
            }
        });

        // Verifica se h√° resultados na pesquisa
        if (array.length === 0) {
            return reply("Nenhum resultado encontrado para o termo de busca.");
        }

        // Acessa o primeiro link de resultado
        const { data: body } = await axios.get(base + array[0]);
        const $$ = cheerio.load(body);
        
        // Captura a imagem do artigo ou define uma imagem padr√£o
        const image = 'https:' + ($$('a.mw-file-description').find('img').attr('src') || '//pngimg.com/uploads/wikipedia/wikipedia_PNG35.png');

        // Captura o conte√∫do dos par√°grafos
        let contents = '';
        $$('p').each(function() {
            contents += $$(this).text().trim() + '\n';
        });

        // Envia os resultados
        sendImageURL(contents, image);
    } catch (e) {
        console.error(e);
        reply('Erro ao executar o comando.');
    }
    break;
    case 'checkban':
case 'verificarban': {
    try {
        if (!q.trim()) return reply(`- Exemplo: ${prefix}verificarban 168274223`);

        const res = await fetchJson(`https://world-ecletix.onrender.com/api/banido?id=${encodeURIComponent(q)}`);
        
        if (!res || res.status !== "success") {
            return reply("Erro ao processar a resposta da API.");
        }

        const statusBan = res.isBanned === "yes" ? "üö® *Usu√°rio BANIDO!* üö®" : "‚úÖ *Usu√°rio n√£o est√° banido.*";

        return reply(`üîç *Verifica√ß√£o de Banimento*\nüÜî *ID:* ${res.uid}\n${statusBan}`);
        
    } catch (error) {
        console.error("Erro ao verificar banimento:", error);
        return reply("Erro ao tentar verificar o banimento.");
    }
}
break;
case "celular": 
{
    try {
        // Obt√©m o modelo do celular da mensagem do usu√°rio
        const modelo = args.join(" "); // args cont√©m as palavras digitadas pelo usu√°rio
        if (!modelo) {
            return reply("‚ùå Voc√™ precisa informar o modelo do celular. Exemplo: *celular iPhone 15*");
        }

        // Faz a requisi√ß√£o para a API com o modelo informado
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/celular?modelo=${encodeURIComponent(modelo)}`);

        if (!res || !res.specs || Object.keys(res.specs).length === 0) {
            return reply("üîç N√£o foi poss√≠vel encontrar informa√ß√µes sobre este celular no momento.");
        }

        let message = `üì± *Informa√ß√µes do Celular*\n\n`;
        message += `üîπ *Nome:* ${res.name || "Nome n√£o especificado"}\n`;
        message += `üîó *URL:* [Clique aqui para mais detalhes](${res.url})\n\n`;

        const specs = res.specs;

        // Fun√ß√£o para formatar corretamente os textos
        const formatText = (text) => text ? text.replace(/ÔøΩ/g, "").trim() : "N√£o especificado";

        message += `üõ†Ô∏è *Especifica√ß√µes T√©cnicas:*\n`;
        message += `‚Ä¢ *Sistema Operacional:* ${formatText(specs["Sistema Operacional"])}\n`;
        message += `‚Ä¢ *Disponibilidade:* ${formatText(specs["Disponibilidade"])}\n`;
        message += `‚Ä¢ *Dimens√µes:* ${formatText(specs["Dimens√µes"])}\n`;
        message += `‚Ä¢ *Peso:* ${formatText(specs["Peso"])}\n\n`;

        message += `üñ•Ô∏è *Tela:*\n`;
        message += `‚Ä¢ *Tamanho:* ${formatText(specs["Polegadas"])}\n`;
        message += `‚Ä¢ *Resolu√ß√£o:* ${formatText(specs["Resolu√ß√£o"])}\n`;
        message += `‚Ä¢ *FPS:* ${formatText(specs["FPS"])}\n\n`;

        message += `üì∏ *C√¢mera:*\n`;
        message += `‚Ä¢ *Principal:* ${formatText(specs["Megapixel"])}\n`;
        message += `‚Ä¢ *Frontal:* ${formatText(specs["C√¢mera Frontal"])}\n`;
        message += `‚Ä¢ *Estabiliza√ß√£o:* ${formatText(specs["Estabiliza√ß√£o"])}\n`;
        message += `‚Ä¢ *Flash:* ${formatText(specs["Flash"])}\n\n`;

        message += `üöÄ *Desempenho:*\n`;
        message += `‚Ä¢ *Processador:* ${formatText(specs["Processador"])}\n`;
        message += `‚Ä¢ *Chipset:* ${formatText(specs["Chipset"])}\n`;
        message += `‚Ä¢ *GPU:* ${formatText(specs["GPU"])}\n`;
        message += `‚Ä¢ *RAM:* ${formatText(specs["RAM"])}\n`;
        message += `‚Ä¢ *Armazenamento:* ${formatText(specs["Mem√≥ria Max"])}\n`;
        message += `‚Ä¢ *Expans√≠vel:* ${formatText(specs["Mem√≥ria Expans√≠vel"])}\n\n`;

        message += `üîã *Bateria:*\n`;
        message += `‚Ä¢ *Capacidade:* ${formatText(specs["Ampere"])}\n\n`;

        message += `üì° *Conectividade:*\n`;
        message += `‚Ä¢ *Wi-Fi:* ${formatText(specs["Wi-Fi"])}\n`;
        message += `‚Ä¢ *Bluetooth:* ${formatText(specs["Bluetooth"])}\n`;
        message += `‚Ä¢ *USB:* ${formatText(specs["USB"])}\n`;
        message += `‚Ä¢ *GPS:* ${formatText(specs["GPS"])}\n\n`;

        message += `üîí *Seguran√ßa:*\n`;
        message += `‚Ä¢ *Leitor de Impress√£o Digital:* ${formatText(specs["Impresso digital"])}\n`;
        message += `‚Ä¢ *Reconhecimento Facial:* ${formatText(specs["Reconhecimento Facial"])}\n\n`;

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API de celular:", error.message, error.stack);
        return reply("‚ö†Ô∏è Ocorreu um erro ao processar a solicita√ß√£o. Tente novamente mais tarde.");
    }
}
break;
case 'livro':
    if (!q) return reply('[üìö] Por favor, forne√ßa o nome do livro que voc√™ deseja buscar. Exemplo: !livro Titanic', { quoted: info });

    try {
        const { data } = await axios.get(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(q)}`);

        if (!data.items || data.items.length === 0) return reply('üö® Livro n√£o encontrado!', { quoted: info });

        const book = data.items[0].volumeInfo;

        const title = book.title || 'N√£o dispon√≠vel';
        const authors = book.authors ? book.authors.join(', ') : 'Autor desconhecido';
        const publisher = book.publisher || 'Editora desconhecida';
        const publishedDate = book.publishedDate || 'Data n√£o informada';
        const pageCount = book.pageCount || 'N/A';
        const description = book.description ? book.description.substring(0, 1000) + '...' : 'Descri√ß√£o indispon√≠vel.';
        const language = book.language || 'N/A';
        const thumbnail = book.imageLinks?.thumbnail?.replace('http:', 'https:');

        const caption = `*T√≠tulo:* ${title}
*Autores:* ${authors}
*Editora:* ${publisher}
*Publicado em:* ${publishedDate}
*P√°ginas:* ${pageCount}
*Idioma:* ${language}

*Descri√ß√£o:* ${description}`;

        if (thumbnail) {
            const imgBuffer = await getBuffer(thumbnail);
            await blackmd.sendMessage(from, { image: imgBuffer, caption }, { quoted: info });
        } else {
            await reply(caption, { quoted: info });
        }

    } catch (error) {
        console.error(error);
        reply('üö® Erro ao buscar informa√ß√µes do livro.', { quoted: info });
    }
    break;
    case 'cotacao':
    if (!q) return reply('[üí±] Por favor, informe a moeda que deseja consultar. Exemplo: !cotacao USD-BRL ou !cotacao BTC-BRL', { quoted: info });

    try {
        const { data } = await axios.get(`https://economia.awesomeapi.com.br/json/last/${q.toUpperCase()}`);
        const key = Object.keys(data)[0];
        if (!key || !data[key]) return reply('üö® Moeda n√£o encontrada! Use o formato: USD-BRL, EUR-BRL, BTC-BRL...', { quoted: info });

        const moeda = data[key];
        const msg = `üíπ *Cota√ß√£o Atual: ${moeda.name}*

*C√≥digo:* ${moeda.code} ‚ûú ${moeda.codein}
*Maior valor (high):* R$ ${parseFloat(moeda.high).toFixed(2)}
*Menor valor (low):* R$ ${parseFloat(moeda.low).toFixed(2)}
*Valor atual (bid):* R$ ${parseFloat(moeda.bid).toFixed(2)}
*Varia√ß√£o:* ${parseFloat(moeda.pctChange).toFixed(2)}%
*√öltima atualiza√ß√£o:* ${new Date(moeda.timestamp * 1000).toLocaleString('pt-BR')}`;

        reply(msg, { quoted: info });
    } catch (error) {
        console.error(error);
        reply('üö® Erro ao buscar a cota√ß√£o. Verifique se a moeda est√° no formato correto, tipo: USD-BRL, EUR-BRL, BTC-BRL', { quoted: info });
    }
    break;
    
case 'letra':
    if (!q) return reply('[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o nome da m√∫sica que voc√™ deseja buscar. Exemplo: !letra matue 4tal', { quoted: info });

    const texto = encodeURIComponent(q); // Codifica a consulta para a URL
    const apiUrlLetra = `https://world-ecletix.onrender.com/api/letra?texto=${texto}`;

    try {
        // Requisi√ß√£o para a API de letra
        const response = await axios.get(apiUrlLetra);
        const data = response.data;

        // Verificar se a resposta cont√©m informa√ß√µes sobre a m√∫sica
        if (data && data.titulo) {
            const { titulo, artista, letra, imagem } = data;

            // Montar a mensagem com as informa√ß√µes da m√∫sica
            const message = `
                *T√≠tulo:* ${titulo}
                *Artista:* ${artista}
                *Letra:*
                
                ${letra}
            `;

            // Enviar a imagem e a mensagem com a letra da m√∫sica
            if (imagem) {
                const imageResponse = await axios.get(imagem, { responseType: 'arraybuffer' });
                const imageBuffer = Buffer.from(imageResponse.data, 'binary');

                await blackmd.sendMessage(from, { 
                    image: imageBuffer, 
                    caption: message 
                }, { quoted: info });
            } else {
                await blackmd.sendMessage(from, { text: message }, { quoted: info });
            }
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel encontrar a letra da m√∫sica pesquisada.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao fazer a requisi√ß√£o √† API de letra:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao buscar a letra da m√∫sica.' }, { quoted: info });
    }
    break;
    case 'filme':
    if (!q) return reply('[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o nome do filme que voc√™ deseja buscar. Exemplo: !filme Deadpool', { quoted: info });

    try {
        const search = await axios.get(`https://api.themoviedb.org/3/search/movie?api_key=ddfcb99fae93e4723232e4de755d2423&query=${encodeURIComponent(q)}&language=pt`);
        const movie = search.data.results[0];
        if (!movie) return reply('üö® Filme n√£o encontrado!', { quoted: info });

        const imgUrl = `https://image.tmdb.org/t/p/original${movie.backdrop_path}`;
        const imgBuffer = await getBuffer(imgUrl);

        const message = `*Nome do Filme:* ${movie.title}
*Nome original:* ${movie.original_title}
*Data de Lan√ßamento:* ${movie.release_date}
*Avalia√ß√µes:* ${movie.vote_average} - (${movie.vote_count} votos)
*Popularidade:* ${movie.popularity.toFixed(1)}%
*Classifica√ß√£o adulta?* ${movie.adult ? 'Sim' : 'N√£o'}
*Linguagem oficial:* ${movie.original_language}

*Sinopse:* ${movie.overview}`;

        await blackmd.sendMessage(from, { image: imgBuffer, caption: message }, { quoted: info });

    } catch (error) {
        console.error(error);
        reply('üö® Erro ao buscar informa√ß√µes do filme.', { quoted: info });
    }
    break;
case 'serie':
    if (!q) return reply('[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o nome da s√©rie que voc√™ deseja buscar. Exemplo: !serie The Boys', { quoted: info });

    try {
        const search = await axios.get(`https://api.themoviedb.org/3/search/tv?api_key=ddfcb99fae93e4723232e4de755d2423&query=${encodeURIComponent(q)}&language=pt`);
        const serie = search.data.results[0];
        if (!serie) return reply('üö® S√©rie n√£o encontrada!', { quoted: info });

        const imgUrl = `https://image.tmdb.org/t/p/original${serie.backdrop_path}`;
        const imgBuffer = await getBuffer(imgUrl);

        const message = `*Nome da S√©rie:* ${serie.name}
*Nome original:* ${serie.original_name}
*Data de Lan√ßamento:* ${serie.first_air_date}
*Avalia√ß√µes:* ${serie.vote_average} - (${serie.vote_count} votos)
*Popularidade:* ${serie.popularity.toFixed(1)}%
*Classifica√ß√£o adulta?* ${serie.adult ? 'Sim' : 'N√£o'}
*Linguagem oficial:* ${serie.original_language}

*Sinopse:* ${serie.overview}`;

        await blackmd.sendMessage(from, { image: imgBuffer, caption: message }, { quoted: info });

    } catch (error) {
        console.error(error);
        reply('üö® Erro ao buscar informa√ß√µes da s√©rie.', { quoted: info });
    }
    break;
case 'filme2':
    if (!q) return reply('[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o nome do filme que voc√™ deseja buscar. Exemplo: !filme Deadpool', { quoted: info });

    const queryFilme = encodeURIComponent(q); // Codifica a consulta para a URL
    const apiUrlFilme = `https://world-ecletix.onrender.com/api/filme?nome=${queryFilme}`;

    try {
        // Requisi√ß√£o para a API de filmes
        const response = await axios.get(apiUrlFilme);
        const data = response.data;

        // Verificar se a resposta cont√©m informa√ß√µes sobre o filme
        if (data.status === 'online' && data.imagem) {
            const { Nome, Lancamento, Avaliacoes, Popularidade, Classificacao_adulta, Linguagem_oficial, Sinopse, imagem } = data;

            // Montar a mensagem com as informa√ß√µes do filme
            const message = `
                *T√≠tulo:* ${Nome}
                *Lan√ßamento:* ${Lancamento}
                *Avalia√ß√µes:* ${Avaliacoes}
                *Popularidade:* ${Popularidade}
                *Classifica√ß√£o Adulta:* ${Classificacao_adulta}
                *Linguagem Oficial:* ${Linguagem_oficial}
                *Sinopse:* ${Sinopse}
            `;

            // Fun√ß√£o para baixar a imagem
            const getImageBuffer = async (url) => {
                try {
                    const { data } = await axios.get(url, { responseType: 'arraybuffer' });
                    return Buffer.from(data, 'binary');
                } catch (error) {
                    console.error('Erro ao baixar a imagem:', error);
                    return null;
                }
            };

            // Verifica se a URL da imagem √© acess√≠vel e obt√©m o buffer
            const imageBuffer = await getImageBuffer(imagem);

            if (imageBuffer && imageBuffer.length > 0) {
                // Envia a mensagem com a imagem
                await blackmd.sendMessage(
                    from,
                    {
                        image: imageBuffer,
                        caption: message, // Adiciona a mensagem como legenda
                    },
                    { quoted: info }
                );
            } else {
                // Se falhar ao baixar a imagem, envia apenas o texto
                await blackmd.sendMessage(
                    from,
                    {
                        text: `${message}\n\nN√£o foi poss√≠vel baixar a imagem.`,
                    },
                    { quoted: info }
                );
            }
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel encontrar informa√ß√µes para o filme pesquisado.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao fazer a requisi√ß√£o √† API de filmes:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao buscar informa√ß√µes sobre o filme.' }, { quoted: info });
    }
    break;

case 'serie2':
    if (!q) return reply('[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o nome da s√©rie que voc√™ deseja buscar. Exemplo: !serie The Boys', { quoted: info });

    const querySerie = encodeURIComponent(q); // Codifica a consulta para a URL
    const apiUrlSerie = `https://world-ecletix.onrender.com/api/serie?nome=${querySerie}`;

    try {
        // Requisi√ß√£o para a API de s√©ries
        const response = await axios.get(apiUrlSerie);
        const data = response.data;

        // Verificar se a resposta cont√©m informa√ß√µes sobre a s√©rie
        if (data.status === 'online' && data.imagem) {
            const { Nome, Lancamento, Avaliacoes, Popularidade, Classificacao_adulta, Linguagem_oficial, Sinopse, imagem } = data;

            // Montar a mensagem com as informa√ß√µes da s√©rie
            const message = `
                *T√≠tulo:* ${Nome}
                *Lan√ßamento:* ${Lancamento}
                *Avalia√ß√µes:* ${Avaliacoes}
                *Popularidade:* ${Popularidade}
                *Classifica√ß√£o Adulta:* ${Classificacao_adulta}
                *Linguagem Oficial:* ${Linguagem_oficial}
                *Sinopse:* ${Sinopse}
            `;

            // Fun√ß√£o para baixar a imagem
            const getImageBuffer = async (url) => {
                try {
                    const { data } = await axios.get(url, { responseType: 'arraybuffer' });
                    return Buffer.from(data, 'binary');
                } catch (error) {
                    console.error('Erro ao baixar a imagem:', error);
                    return null;
                }
            };

            // Verifica se a URL da imagem √© acess√≠vel e obt√©m o buffer
            const imageBuffer = await getImageBuffer(imagem);

            if (imageBuffer && imageBuffer.length > 0) {
                // Envia a mensagem com a imagem
                await blackmd.sendMessage(
                    from,
                    {
                        image: imageBuffer,
                        caption: message, // Adiciona a mensagem como legenda
                    },
                    { quoted: info }
                );
            } else {
                // Se falhar ao baixar a imagem, envia apenas o texto
                await blackmd.sendMessage(from,
                    {
                        text: `${message}\n\nN√£o foi poss√≠vel baixar a imagem.`,
                    },
                    { quoted: info }
                );
            }
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel encontrar informa√ß√µes para a s√©rie pesquisada.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao fazer a requisi√ß√£o √† API de s√©ries:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao buscar informa√ß√µes sobre a s√©rie.' }, { quoted: info });
    }
    break;
// TABELAS FUTEBOL 
case "tabela_ucl":
{

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-ucl`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inv√°lida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui est√° a tabela atualizada da UCL:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posi√ß√£o: ${team.posicao}, Jogos: ${team.jogos}, Vit√≥rias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "tabela_brasileirao":
{

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-brasileirao`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inv√°lida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui est√° a tabela atualizada do Brasileir√£o:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posi√ß√£o: ${team.posicao}, Jogos: ${team.jogos}, Vit√≥rias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "tabela_premierleague":
{

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-premierleague`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inv√°lida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui est√° a tabela atualizada da Premier League:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posi√ß√£o: ${team.posicao}, Jogos: ${team.jogos}, Vit√≥rias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "tabela_laliga":
{

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-laliga`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inv√°lida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui est√° a tabela atualizada da La Liga:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posi√ß√£o: ${team.posicao}, Jogos: ${team.jogos}, Vit√≥rias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "tabela_bundesliga":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-bundesliga`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inv√°lida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui est√° a tabela atualizada da Bundesliga:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posi√ß√£o: ${team.posicao}, Jogos: ${team.jogos}, Vit√≥rias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "tabela_seriea":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-seriea`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inv√°lida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui est√° a tabela atualizada da S√©rie A:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posi√ß√£o: ${team.posicao}, Jogos: ${team.jogos}, Vit√≥rias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "tabela_ligue1":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-ligue1`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inv√°lida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui est√° a tabela atualizada da Ligue 1:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posi√ß√£o: ${team.posicao}, Jogos: ${team.jogos}, Vit√≥rias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "tabela_portugal":
{

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-portugal`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inv√°lida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui est√° a tabela atualizada da Primeira Liga de Portugal:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posi√ß√£o: ${team.posicao}, Jogos: ${team.jogos}, Vit√≥rias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
// GUIA DE TV
case "guia-filmes":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-filmes`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("üîç N√£o foi poss√≠vel encontrar informa√ß√µes sobre o guia de filmes no momento.");
        }

        let message = "*üé¨ Guia de Filmes - Programa√ß√£o Atual:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programa√ß√£o
            }

            message += `üì∫ *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   üïí *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espa√ßamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-filmes:", error);
        return reply("‚ö†Ô∏è Ocorreu um erro ao processar a solicita√ß√£o. Tente novamente mais tarde.");
    }
}
break;
case "guia-series":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-series`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("üîç N√£o foi poss√≠vel encontrar informa√ß√µes sobre o guia de s√©ries no momento.");
        }

        let message = "*üì∫ Guia de S√©ries - Programa√ß√£o Atual:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programa√ß√£o
            }

            message += `üé• *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   üïí *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espa√ßamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-series:", error);
        return reply("‚ö†Ô∏è Ocorreu um erro ao processar a solicita√ß√£o. Tente novamente mais tarde.");
    }
}
break;
case "guia-esportes":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-esportes`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("üîç N√£o foi poss√≠vel encontrar informa√ß√µes sobre o guia de esportes no momento.");
        }

        let message = "*üèÖ Guia de Esportes - Programa√ß√£o Atual:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programa√ß√£o
            }

            message += `üì∫ *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   üïí *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espa√ßamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-esportes:", error);
        return reply("‚ö†Ô∏è Ocorreu um erro ao processar a solicita√ß√£o. Tente novamente mais tarde.");
    }
}
break;
case "guia-infantil":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-infantil`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("üîç N√£o foi poss√≠vel encontrar informa√ß√µes sobre o guia infantil no momento.");
        }

        let message = "*üé® Guia Infantil - Programa√ß√£o Atual:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programa√ß√£o
            }

            message += `üì∫ *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   üïí *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espa√ßamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-infantil:", error);
        return reply("‚ö†Ô∏è Ocorreu um erro ao processar a solicita√ß√£o. Tente novamente mais tarde.");
    }
}
break;
case "guia-variedades":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-variedades`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("üîç N√£o foi poss√≠vel encontrar informa√ß√µes sobre o guia de variedades no momento.");
        }

        let message = "*üé≠ Guia Variedades - Programa√ß√£o Atual:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programa√ß√£o
            }

            message += `üì∫ *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   üïí *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espa√ßamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-variedades:", error);
        return reply("‚ö†Ô∏è Ocorreu um erro ao processar a solicita√ß√£o. Tente novamente mais tarde.");
    }
}
break;
case "guia-documentarios":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-documentarios`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("üîç N√£o foi poss√≠vel encontrar informa√ß√µes sobre o guia de document√°rios no momento.");
        }

        let message = "*üìö Guia de Document√°rios - Programa√ß√£o Atual:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programa√ß√£o
            }

            message += `üì∫ *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   üïí *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espa√ßamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-documentarios:", error);
        return reply("‚ö†Ô∏è Ocorreu um erro ao processar a solicita√ß√£o. Tente novamente mais tarde.");
    }
}
break;
case "guia-noticias":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-noticias`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("üîç N√£o foi poss√≠vel encontrar informa√ß√µes sobre o guia de not√≠cias no momento.");
        }

        let message = "*üì∞ Guia de Not√≠cias - Programa√ß√£o Atual:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programa√ß√£o
            }

            message += `üì∫ *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   üïí *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espa√ßamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-noticias:", error);
        return reply("‚ö†Ô∏è Ocorreu um erro ao processar a solicita√ß√£o. Tente novamente mais tarde.");
    }
}
break;
case "guia-aberta":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-aberta`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("üîç N√£o foi poss√≠vel encontrar informa√ß√µes sobre o guia de programa√ß√£o aberta no momento.");
        }

        let message = "*üì∫ Guia de Programa√ß√£o Aberta:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programa√ß√£o
            }

            message += `üì∫ *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   üïí *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espa√ßamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-aberta:", error);
        return reply("‚ö†Ô∏è Ocorreu um erro ao processar a solicita√ß√£o. Tente novamente mais tarde.");
    }
}
break;
case "tv":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tv`);
        //by luan

        if (!res || res.length === 0) { // Corrigido de "res" para "res"
            return reply("Nenhuma programa√ß√£o de TV encontrada no momento.");
        }

        let message = "*üì∫ Programa√ß√£o da TV:*\n\n";
        
        res.forEach((programa, index) => { // Corrigido de "res" para "res"
            const { title, link, image } = programa;

            message += `*${index + 1}. ${title}*\n`;
            if (link) message += `üîó *Link:* [Clique aqui](${link})\n`;
            if (image) message += `üñºÔ∏è *Imagem:* ${image}\n`;
            message += "\n"; // Adiciona espa√ßamento entre programas
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API de TV:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "tvfutebol":
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/futebol`);
        //by luan

        if (!res || res.length === 0) {
            return reply("N√£o h√° informa√ß√µes dispon√≠veis no momento.");
        }

        let message = `*üé• Futebol e Esportes Ao Vivo*\n\n`;
        res.forEach((evento, index) => {
            message += `*${index + 1}. ${evento.title}*\n`;
            message += `üîó *Link:* [Clique aqui](${evento.link})\n`;
            message += `üñºÔ∏è *Imagem:* ${evento.image}\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API de futebol:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
break;
case "jogosdodia": 
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/jogosdodia`);
        //by luan

        if (!res || res.length === 0) {
            return reply("N√£o h√° informa√ß√µes de jogos dispon√≠veis no momento.");
        }

        let message = `*üéÆ Jogos do Dia - Ao Vivo*\n\n`;
        res.forEach((jogo, index) => {
            message += `*${index + 1}. ${jogo.title}*\n`;
            message += `üîó *Link:* [Clique aqui](${jogo.link})\n`;
            message += `üñºÔ∏è *Imagem:* ${jogo.image}\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API de jogos do dia:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
break;		
case "ucl": 
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/ucl`);
        //by luan

        if (!res || res.length === 0) {
            return reply("N√£o h√° informa√ß√µes da UCL dispon√≠veis no momento.");
        }

        let message = `*üèÜ Liga dos Campe√µes da UEFA (UCL)*\n\n`;
        res.forEach((jogo, index) => {
            message += `*${index + 1}. ${jogo.match}*\n`;
            message += `üïí *Hor√°rio:* ${jogo.time}\n`;
            message += `üìç *Local:* ${jogo.venue}\n`;
            message += `üîó *Link:* [Clique aqui](${jogo.link})\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API da UCL:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
break;		
case "tvbrasileirao": 
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/brasileirao`);
        //by luan

        if (!res || res.length === 0) {
            return reply("N√£o h√° informa√ß√µes sobre a transmiss√£o do Brasileir√£o dispon√≠veis no momento.");
        }

        let message = `*üì∫ Jogos do Brasileir√£o - Transmiss√£o*\n\n`;
        res.forEach((jogo, index) => {
            message += `*${index + 1}. ${jogo.match}*\n`;
            message += `üïí *Hor√°rio:* ${jogo.time}\n`;
            message += `üì∫ *Canal:* ${jogo.channel}\n`;
            message += `üìç *Local:* ${jogo.venue}\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API do Brasileir√£o:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
break;		
case "nfl": 
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/nfl`);
        //by luan

        if (!res || res.length === 0) {
            return reply("N√£o h√° informa√ß√µes sobre jogos da NFL dispon√≠veis no momento.");
        }

        let message = `*üèà Jogos da NFL*\n\n`;
        res.forEach((jogo, index) => {
            message += `*${index + 1}. ${jogo.match}*\n`;
            message += `üïí *Hor√°rio:* ${jogo.time}\n`;
            message += `üì∫ *Canal:* ${jogo.channel}\n`;
            message += `üìç *Local:* ${jogo.venue}\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API da NFL:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
break;	
		case "ufc":
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/ufc`);
        //by luan

        if (!res || res.length === 0) {
            return reply("N√£o h√° informa√ß√µes do UFC dispon√≠veis no momento.");
        }

        let message = `*ü•ä Ultimate Fighting Championship (UFC)*\n\n`;
        res.forEach((evento, index) => {
            message += `*${index + 1}. ${evento.title}*\n`;
            message += `üîó *Link:* [Clique aqui](${evento.link})\n`;
            message += `üñºÔ∏è *Imagem:* [Ver imagem](${evento.image})\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API do UFC:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
break;
		case "jogosdehoje":
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/jogosdehoje`);
        //by luan

        if (!res || res.length === 0) {
            return reply("N√£o h√° jogos dispon√≠veis no momento.");
        }

        let message = `*‚öΩ Jogos de Hoje*\n\n`;
        res.forEach((jogo, index) => {
            message += `*${index + 1}. ${jogo.time1} x ${jogo.time2}*\n`;
            if (jogo.horario) message += `üïí *Hor√°rio:* ${jogo.horario}\n`;
            message += `üìä *Placar:* ${jogo.placar}\n`;
            if (jogo.status) message += `üìù *Status:* ${jogo.status}\n`;
            message += `\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API de Jogos de Hoje:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
break;
case "basquete": 
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/basquete`);
        //by luan

        if (!res || res.length === 0) {
            return reply("N√£o h√° informa√ß√µes sobre jogos de Basquete dispon√≠veis no momento.");
        }

        let message = `*üèÄ Jogos de Basquete*\n\n`;
        res.forEach((jogo, index) => {
            message += `*${index + 1}. ${jogo.match}*\n`;
            message += `üïí *Hor√°rio:* ${jogo.time}\n`;
            message += `üì∫ *Canal:* ${jogo.channel}\n`;
            message += `üìç *Local:* ${jogo.venue}\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API de Basquete:", error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
break;		
case "esportedodia": 
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/esportedodia`);
        const esporte = await res.json();

        if (!esporte || !esporte.title || !esporte.description || !esporte.url) {
            return reply("üèüÔ∏è N√£o foi poss√≠vel encontrar o esporte do dia no momento.");
        }

        // Mensagem formatada
        let message = `*üèÖ Esporte do Dia*\n\n`;
        message += `*üîπ T√≠tulo:* ${esporte.title}\n`;
        message += `*üìù Descri√ß√£o:* ${esporte.description}\n`;
        message += `*üîó Saiba mais:* [Clique aqui](${esporte.url})\n`;

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API de esporte do dia:", error);
        return reply("‚ö†Ô∏è Ocorreu um erro ao buscar o esporte do dia. Tente novamente mais tarde.");
    }
break;
// WALLPAPERS E ICONS ICONES


case 'aesthetic':
case 'Aesthetic': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/aesthetic"}});
}
break;
case 'gatos':
case 'gato': {
  reply(`Enviando um gatinho fofo pra voc√™, ${pushname}!`);
  
  blackmd.sendMessage(sender, { image: { url: "https://world-ecletix.onrender.com/api/gato" }, caption: "Miau!" });
}
break;

case 'cachorros':
case 'cachorro': {
  reply(`Enviando um doguinho pra voc√™, ${pushname}!`);
  
  blackmd.sendMessage(sender, { image: { url: "https://world-ecletix.onrender.com/api/cachorro" }, caption: "Au au!" });
}
break;
case 'cosplay':
case 'Cosplay': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/cosplay"}});
}
break; 

case 'cosplayloli':
case 'Cosplayloli': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/cosplayloli"}});
}
break;

case 'cosplaysagiri':
case 'Cosplaysagiri': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/cosplaysagiri"}});
}
break;

case 'fotodev':
case 'Fotodev': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/fotodev"}});
}
break;

case 'gameWallp':
case 'GameWallp': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/gameWallp"}});
}
break;

case 'wallpaper_aleatorio':
case 'wall_ale': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/imagens"}});
}
break;

case 'meme':
case 'Meme': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/meme"}});
}
break;

case 'pokemon':
case 'Pokemon': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/pokemon"}});
}
break;

case 'satanic':
case 'Satanic': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/satanic"}});
}
break;

case 'nime':
case 'Nime': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/Nime"}});
}
break;
case 'wallhp2':
case 'Wallhp2': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/wallhp2"}});
}
break;
case 'Montanhas':
case 'montanhas': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/mountain"}});
}
break;

case 'Motos':
case 'motos': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/montor"}});
}
break;

case 'carros':
case 'Carros': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/mobil"}});
}
break;

case 'hakcers':
case 'Hackers': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/hekel"}});
}
break;

case 'Programador':
case 'programador': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/programing"}});
}
break;
case 'pets':
case 'pets': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/anjing"}});
}
break;
case 'Cats':
case 'cats': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/kucing"}});
}
break;
case 'cartun':
case 'Cartun': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/kartun"}});
}
break;
// icone feminino / icon 

case 'elaina':
case 'Elaina': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/elaina  "}});
}
break;  

case 'emilia':
case 'Emilia': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/emilia"}});
}
break;

case 'hinata':
case 'Hinata': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/hinata"}});
}
break;

case 'iconfeminino':
case 'icon_feminino': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/femininotrava"}});
}
break;

case 'erza':
case 'Erza': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/erza"}});
}
break;

case 'mikasa':
case 'Miksasa': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/mikasa"}});
}
break;

case 'rose':
case 'Rose': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/rose"}});
}
break;

case 'Rize':
case 'rize': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/rize"}});
}
break;
case 'nezuko':
case 'Nezuko': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/nezuko"}});
}
break;
case 'sakura':
case 'Sakura': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/sakura"}});
}
break;
case 'sagiri':
case 'Sagiri': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/sagiri"}});
}
break;
case 'tsunade':
case 'Tsunade': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/tsunade"}});
}
break;
case 'waifu':
case 'Waifu': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/waifu"}});
}
break;
case 'waifu2':
case 'Waifu2': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/Waifu2"}});
}
break;
case 'akiyama':
case 'Akiyama': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/akiyama"}});
}
break;

case 'anaicon':
case 'Anaicon': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/ana"}});
}
break;
case 'asuna':
case 'Asuna': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/asuna"}});
}
break;
case 'ayuzawa':
case 'Ayuzawa': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/ayuzawa"}});
}
break;
case 'chitoge':
case 'Chitoge': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/chitoge"}});
}
break;
case 'ebaicon':
case 'Ebaicon': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/eba"}});
}
break;
case 'itori':
case 'itori': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/itori"}});
}
break;
case 'gremory':
case 'Gremory': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/gremory"}});
}
break;
case 'hestia':
case 'Hestia': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/hestia"}});
}
break;
case 'Isuzu':
case 'isuzu': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/isuzu"}});
}
break;
case 'jiso':
case 'Jiso': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/jiso"}});
}
break;
case 'lisakpop':
case 'LisaKpop': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/lisa"}});
}
break;
case 'jeni':
case 'Jeni': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/jeni"}});
}
break;
case 'justina':
case 'Justina': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/justina "}});
}
break;
case 'ryujin':
case 'ryujin': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/ryujin"}});
}
break;
case 'Kpop':
case 'kpop': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/kpop"}});
}
break;
case 'Kotori':
case 'kotori': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/kotori"}});
}
break;
case 'Kaori':
case 'kaori': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/kaori"}});
}
break;  
case 'Kagura':
case 'kagura': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/aesthetic"}});
}
break;
case 'Miku':
case 'miku': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/miku"}});
}
break;
case 'Kurumi':
case 'kurumi': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/kurumi"}});
}
break;
case 'Megumin':
case 'megumin': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/megumin"}});
}
break;
case 'Nekonime':
case 'nekonime': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/nekonime"}});
}
break;
case 'pentol':
case 'Pentol': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/pentol"}});
}
break;
case 'Profil':
case 'profil': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/aesthetic"}});
}
break;

case 'toukachan':
case 'Toukachan': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/toukachan"}});
}
break;

case 'Shinomiya':
case 'shinomiya': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/shinomiya"}});
}
break;
case 'Shinka':
case 'shinka': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/shinka"}});
}
break;
case 'shina':
case 'Shina': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/shina"}});
}
break;
case 'Japinhas':
case 'japinhas': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/yulibocil"}});
}
break;
case 'Tejina':
case 'tejina': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/tejina"}});
}
break;
case 'Tatasurya':
case 'tatasurya': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/tatasurya"}});
}
break;
case 'Shizuka':
case 'shizuka': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/aesthetic"}});
}
break;
case 'Yotsuba':
case 'yotsuba': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/yotsuba"}});
}
break;

// icones masculino // icon masculino
case 'Akira':
case 'akira': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/akira"}});
}
break;
case 'Boruto':
case 'boruto': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/boruto"}});
}
break;
case 'chucky':
case 'Chucky': { 
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/bonek"}});
}
break;
case 'deidara':
case 'deidara': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/deidara"}});
}
break;
case 'Itachi':
case 'itachi': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/aesthetic"}});
}
break;

case 'kakashi':
case 'kakashi': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/minato"}});
}
break;
case 'Naruto':
case 'naruto': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/narutoicon"}});
}
break;
case 'minato':
case 'minato': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/minato"}});
}
break;
case 'sasuke':
case 'sasuke': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/sasuke"}});
}
break;

// EDITS / VIDEOS WALLPAPER 

case 'lomotifs':
case 'lomotif': {
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/editsfeminina"}});
}
break;

case 'futedits':
case 'futeboledits': {
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/futeboledits"}});
}
break;

case 'walnimes':
case 'animedits': {
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/walnimes"}});
}
break;

case 'sololeveling':
case 'soloedits': {
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/soloedits"}});
}
break;

case 'Dragonball':
case 'dragonball': {
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/dragonball"}});
}
break;
case 'Narutoedits':
case 'narutoedits': {
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/narutomp4"}});
}
break;

case 'Kimetsu':
case 'kimetsu': {
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/kimetsu"}});
}
break;

case 'Jujutsu':
case 'jujutsu': {
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/editsfeminina"}});
}
break;

case 'Bleach':
case 'bleach': {
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/bleach"}});
}
break;

case 'chainsaw':
case 'chainsaw': {
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/chainsaw"}});
}
break;

case 'hunterx':
case 'hunterx': {
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/hunterx"}});
}
break;

case 'Editaleatoria':
case 'editaleatoria': {
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/aleatorios"}});
}
break;

// FUN√á√ïES RPG

case 'espada':
case 'comprarespada': {
    if (!isBlackCity) return reply(enviar.rpg.ativar)
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)

    let data = filesDBuserBC(sender)
    const precoEspada = 7000

    if (data.saldo < precoEspada) {
        return reply(`*${pushname} VC N√ÉO TEM DINHEIRO SUFICIENTE PARA COMPRAR UMA ESPADA*\n\n*PRE√áO: R$ ${precoEspada.toFixed(2)}*`)
    }

    if (!q.trim()) {
        return reply(`Cad√™ o espa√ßo mano?\nExemplo: ${prefix + command} comprar`)
    }

    espada.push(sender)
    fs.writeFileSync('./funcoes_rpg/espada/espada.json', JSON.stringify(espada))

    // Desconta o valor da espada do saldo
    let novoSaldo = data.saldo - precoEspada
    saveCityBlackRPG(sender, novoSaldo, data.banco)

    reply(`*ESPADA COMPRADA COM SUCESSO*\n\n*CUSTO üí∞: R$ ${precoEspada.toFixed(2)}*`)
}
break


case 'animal':
  if (!q) {
    reply(`Desculpe, parece que voc√™ n√£o forneceu o nome do animal. Voc√™ pode usar como exemplo: *${prefixo + comando} gato*`);
     } else {
    const animais = [{ "nome": "C√£o", "especie": "Canis lupus familiaris", "habitat": "Dom√©stico", "dieta": "Carn√≠voro" }, { "nome": "Gato", "especie": "Felis catus", "habitat": "Dom√©stico e selvagem", "dieta": "Carn√≠voro" }, { "nome": "Cavalo", "especie": "Equus ferus caballus", "habitat": "Dom√©stico e selvagem", "dieta": "Herb√≠voro" },
  {
    "nome": "Lobo",
    "especie": "Canis lupus",
    "habitat": "Florestas, tundras, montanhas e campos abertos",
    "dieta": "Carn√≠voro"
  },
  {
    "nome": "√Åguia",
    "especie": "Aquila chrysaetos",
    "habitat": "Florestas, montanhas e √°reas costeiras",
    "dieta": "Carn√≠voro"
  },
  {
    "nome": "Macaco",
    "especie": "Macaca fascicularis",
    "habitat": "Florestas tropicais e subtropicais",
    "dieta": "On√≠voro"
  },
  {
    "nome": "Canarinho",
    "especie": "Serinus canaria",
    "habitat": "Ilhas Can√°rias e Madeira",
    "dieta": "Gran√≠voro"
  },
  {
    "nome": "Tubar√£o",
    "especie": "Carcharodon carcharias",
    "habitat": "Oceanos tropicais e subtropicais",
    "dieta": "Carn√≠voro"
  },
  {
    "nome": "Formiga",
    "especie": "Formicidae",
    "habitat": "Todos os continentes, exceto a Ant√°rtida",
    "dieta": "On√≠voro"
  },
  {
  "nome": "Tartaruga",
  "especie": "Testudines",
  "habitat": "Aqu√°tico e terrestre",
  "dieta": "On√≠voro"
},
{
  "nome": "Corvo",
  "especie": "Corvus corax",
  "habitat": "Florestas, campos e cidades",
  "dieta": "Carn√≠voro"
},
{
  "nome": "Girafa",
  "especie": "Giraffa camelopardalis",
  "habitat": "√Åfrica",
  "dieta": "Herb√≠voro"
},
{
  "nome": "Elefante",
  "especie": "Elephas maximus",
  "habitat": "√Åsia e √Åfrica",
  "dieta": "Herb√≠voro"
},
{
  "nome": "Golfinho",
  "especie": "Delphinus delphis",
  "habitat": "Oceanos e mares",
  "dieta": "Carn√≠voro"
},
    {
      "nome": "Le√£o",
      "especie": "Panthera leo",
      "habitat": "√Åfrica subsaariana",
      "dieta": "Carn√≠voro"
    },
    {
      "nome": "Tigre",
      "especie": "Panthera tigris",
      "habitat": "√Åsia",
      "dieta": "Carn√≠voro"
    },
    {
      "nome": "Gorila",
      "especie": "Gorilla gorilla",
      "habitat": "√Åfrica Central e Ocidental",
      "dieta": "Herb√≠voro"
    },
    {
      "nome": "Papagaio",
      "especie": "Psittaciformes",
      "habitat": "Am√©rica do Sul, Am√©rica Central, √Åfrica e Oceania",
      "dieta": "On√≠voro"
    },
    {
      "nome": "Coelho",
      "especie": "Oryctolagus cuniculus",
      "habitat": "Europa, √Åfrica e Austr√°lia",
      "dieta": "Herb√≠voro"
    },
      { "nome": "Vaca", "especie": "Bos taurus", "habitat": "Dom√©stico", "dieta": "Herb√≠voro" }, { "nome": "Porco", "especie": "Sus scrofa domestica", "habitat": "Dom√©stico", "dieta": "On√≠voro" }, { "nome": "Galinha", "especie": "Gallus gallus domesticus", "habitat": "Dom√©stico", "dieta": "On√≠voro" }, { "nome": "Pato", "especie": "Anas platyrhynchos domesticus", "habitat": "Dom√©stico e selvagem", "dieta": "On√≠voro" }, { "nome": "Ganso", "especie": "Anser anser domesticus", "habitat": "Dom√©stico e selvagem", "dieta": "Herb√≠voro" }, { "nome": "Peru", "especie": "Meleagris gallopavo", "habitat": "Dom√©stico", "dieta": "On√≠voro" }, { "nome": "Coelho", "especie": "Oryctolagus cuniculus", "habitat": "Dom√©stico e selvagem", "dieta": "Herb√≠voro" }];
    const animal = animais.find(a => a.nome.toLowerCase() === q.toLowerCase());
       if (animal) {
       reply(`*‚Ä¢ Nome:* ${animal.nome}\n*‚Ä¢ Esp√©cie:* ${animal.especie}\n*‚Ä¢ Habitat:* ${animal.habitat}\n*‚Ä¢ Dieta:* ${animal.dieta}`);
       } else {
       reply("Animal n√£o encontrado.")}}
       break;
case 'gerarcpff': {
    if (!isBlackCity) return reply(enviar.rpg.ativar)
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)

    let data = filesDBuserBC(sender)
    const precoCpf = 4000

    if (data.saldo < precoCpf) {
        return reply(`*${pushname} VC N√ÉO TEM DINHEIRO SUFICIENTE PARA COMPRAR*\n\n*PRE√áO: R$ ${precoCpf.toFixed(2)}*`)
    }

    let cp1 = `${Math.floor(Math.random() * 300) + 600}`
    let cp2 = `${Math.floor(Math.random() * 300) + 600}`
    let cp3 = `${Math.floor(Math.random() * 300) + 600}`
    let cp4 = `${Math.floor(Math.random() * 30) + 60}`
    let cpf = `${cp1}.${cp2}.${cp3}-${cp4}`

    await blackmd.sendMessage(from, {text: `CPF gerado com sucesso: ${cpf}`}, {quoted: info})

    let novoSaldo = data.saldo - precoCpf
    saveCityBlackRPG(sender, novoSaldo, data.banco)
}
break
case 'tagrico': {
    if (!isBlackCity) return reply(enviar.rpg.ativar)
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)

    let data = filesDBuserBC(sender)
    const precoTagrico = 6000

    if (data.saldo < precoTagrico) {
        return reply(`*${pushname} VC N√ÉO TEM DINHEIRO SUFICIENTE PARA COMPRAR A TAG DE RICO*\n\n*PRE√áO: R$ ${precoTagrico.toFixed(2)}*`)
    }

    if (!q.trim()) {
        return reply(`Cad√™ o espa√ßo mano?\nExemplo: ${prefix + command} comprar`)
    }

    tagrico.push(sender)
    fs.writeFileSync('./funcoes_rpg/tagrico/tagrico.json', JSON.stringify(tagrico))

    let novoSaldo = data.saldo - precoTagrico
    saveCityBlackRPG(sender, novoSaldo, data.banco)

    reply(`*TAG DE RICO COMPRADA COM SUCESSO* üí∞üí≤üíµ\n\n*CUSTO üí∞: R$ ${precoTagrico.toFixed(2)}*`)
}
break
case 'capacete': {
    if (!isBlackCity) return reply(enviar.rpg.ativar)
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)

    let data = filesDBuserBC(sender)
    const preco = 30000

    if (data.saldo < preco) {
        return reply(`*${pushname} VC N√ÉO TEM DINHEIRO SUFICIENTE PARA COMPRAR O CAPACETE DE TRABALHO*\n\n*PRE√áO: R$ ${preco.toFixed(2)}*`)
    }

    if (!q.trim()) return reply(`Cad√™ o espa√ßo mano?\nExemplo: ${prefix + command} comprar`)

    carab.push(sender)
    fs.writeFileSync('./funcoes_rpg/carab/carab.json', JSON.stringify(carab))

    let novoSaldo = data.saldo - preco
    saveCityBlackRPG(sender, novoSaldo, data.banco)

    reply(`*CAPACETE COMPRADO COM SUCESSO*\n\n*CUSTO üí∞: R$ ${preco.toFixed(2)}*`)
}
break
case 'calca': case 'cal√ßa':{
    if (!isBlackCity) return reply(enviar.rpg.ativar)
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)

    let data = filesDBuserBC(sender)
    const preco = 3000

    if (data.saldo < preco) {
        return reply(`*${pushname} VC N√ÉO TEM DINHEIRO SUFICIENTE PARA COMPRAR A CAL√áA DE TRABALHO*\n\n*PRE√áO: R$ ${preco.toFixed(2)}*`)
    }

    if (!q.trim()) return reply(`Cad√™ o espa√ßo mano?\nExemplo: ${prefix + command} comprar`)

    caussa.push(sender)
    fs.writeFileSync('./funcoes_rpg/caussa/caussa.json', JSON.stringify(caussa))

    let novoSaldo = data.saldo - preco
    saveCityBlackRPG(sender, novoSaldo, data.banco)

    reply(`*CAL√áA COMPRADA COM SUCESSO*\n\n*CUSTO üí∞: R$ ${preco.toFixed(2)}*`)
}
break
case 'sapato':
case 'sapatos': {
    if (!isBlackCity) return reply(enviar.rpg.ativar)
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)

    let data = filesDBuserBC(sender)
    const preco = 3000

    if (data.saldo < preco) {
        return reply(`*${pushname} VC N√ÉO TEM DINHEIRO SUFICIENTE PARA COMPRAR OS SAPATOS DE TRABALHO*\n\n*PRE√áO: R$ ${preco.toFixed(2)}*`)
    }

    if (!q.trim()) return reply(`Cad√™ o espa√ßo mano?\nExemplo: ${prefix + command} comprar`)

    sapato.push(sender)
    fs.writeFileSync('./funcoes_rpg/sapato/sapato.json', JSON.stringify(sapato))

    let novoSaldo = data.saldo - preco
    saveCityBlackRPG(sender, novoSaldo, data.banco)

    reply(`*SAPATO COMPRADO COM SUCESSO*\n\n*CUSTO üí∞: R$ ${preco.toFixed(2)}*`)
}
break
case 'palitor': {
    if (!isBlackCity) return reply(enviar.rpg.ativar)
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)

    let data = filesDBuserBC(sender)
    const preco = 3000

    if (data.saldo < preco) {
        return reply(`*${pushname} VC N√ÉO TEM DINHEIRO SUFICIENTE PARA COMPRAR O PALITOR DE TRABALHO*\n\n*PRE√áO: R$ ${preco.toFixed(2)}*`)
    }

    if (!q.trim()) return reply(`Cad√™ o espa√ßo mano?\nExemplo: ${prefix + command} comprar`)

    palitor.push(sender)
    fs.writeFileSync('./funcoes_rpg/palitor/palitor.json', JSON.stringify(palitor))

    let novoSaldo = data.saldo - preco
    saveCityBlackRPG(sender, novoSaldo, data.banco)

    reply(`*PALITOR COMPRADO COM SUCESSO*\n\n*CUSTO üí∞: R$ ${preco.toFixed(2)}*`)
}
break

case 'hero':
case 'lot': {
    try {
        let ppimg
        try {
            ppimg = await zenitsu.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image')
        } catch {
            ppimg = 'https://telegra.ph/file/b5427ea4b8701bc47e751.jpg'
        }

        const captionInventario = `
‚îè‚îÅ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ„Äåüï¥Ô∏è„Äç‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÅ‚îì
‚îÇ          *SEU INVENT√ÅRIO*
‚îÇ
‚îÇ *${isCarab ? "‚õëÔ∏è" : "‚ùå"} : CAPACETE*
‚îÇ *${isRoupab ? "üëî" : "‚ùå"} : PALITOR*
‚îÇ *${iscasa ? "üè°" : "‚ùå"} : CASA*
‚îÇ *${isCaussa ? "üëñ" : "‚ùå"} : CAL√áA*
‚îÇ *${isaguacoco ? "üíß" : "‚ùå"} : √ÅGUA DE COCO*
‚îÇ *${isSapato ? "üëû" : "‚ùå"} : SAPATO*
‚îÇ *${isespada ? "‚öîÔ∏è" : "‚ùå"} : ESPADA*
‚îÇ
‚ï†‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚îÇ             *TAGS*
‚ï†‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚îÇ
‚îÇ> RICO: ${istagrico ? "SIM ‚úÖ" : "N√ÉO ‚ùå"}
‚îÇ
‚îó‚îÅ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ„Äåüï¥Ô∏è„Äç‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÅ‚îõ
        `.trim()

        await blackmd.sendMessage(from, {
            video: { url: 'https://telegra.ph/file/b1febb2db7a727eee9d7d.mp4' },
            gifPlayback: true,
            caption: captionInventario
        }, { quoted: info })

    } catch (e) {
        console.error(e)
    }
}
break
case 'tomaraguacoco': {
    if (!aguacoco.includes(sender)) return reply(`VOC√ä N√ÉO TEM √ÅGUA DE COCO INFINITA. USE ${prefix}aguacoco para comprar!`)
    
    const aguadd = Math.floor(Math.random() * 76) + 15 // entre 15% e 90%
    reply(`VOC√ä TOMOU UMA √ÅGUA DE COCO\n\nMATOU [ ${aguadd}% ] DA SUA SEDE!`)
}
break

case 'aguacoco': {
    const dinheiro = checkATMuser(sender)
    if (dinheiro < 30000) return reply(`*${pushname} VOC√ä N√ÉO TEM DINHEIRO SUFICIENTE PARA COMPRAR √ÅGUA DE COCO INFINITA*\n\n*PRE√áO: 30000*`)
    
    if (!q.includes(' ')) return reply(`Cad√™ o espa√ßo mano?\nExemplo: ${prefix + command} comprar`)  

    aguacoco.push(sender)
    fs.writeFileSync('./funcoes_rpg/agua/aguacoco.json', JSON.stringify(aguacoco))
    addKoinUser(sender, -30000)
    reply(`*√ÅGUA DE COCO COMPRADA COM SUCESSO* ü••\n\n*CUSTO üí∞: 30000*`)
}
break

case 'pescar': {
    const lagostas = Math.floor(Math.random() * 105)
    const caranguejos = Math.floor(Math.random() * 105)
    const mexilhao = Math.floor(Math.random() * 105)
    const peixe = Math.floor(Math.random() * 105)

    const totalPescado = lagostas + caranguejos + mexilhao + peixe
    const pescando = totalPescado * 15 // Cada "animal" vale 15R$

    blackmd.sendMessage(from, {
        image: fs.readFileSync('./funcoes_rpg/image/pescar.jpg'),
        caption: `
‚îè‚îÅ‚îÄ‚îÄ *„Äå üé£Ô∏è P E S C A üé£Ô∏è „Äç* ‚îÄ‚îÅ‚îì
‚îÇ‚ñ¢ Lagostas: ${lagostas}
‚îÇ‚ñ¢ Caranguejos: ${caranguejos}
‚îÇ‚ñ¢ Peixes: ${peixe}
‚îÇ‚ñ¢ Mexilh√µes: ${mexilhao}
‚îó‚îÅ‚îÄ‚îÄ *„Äå üé£Ô∏è P E S C A üé£Ô∏è „Äç* ‚îÄ‚îÅ‚îõ

E GANHOU ${pescando}R$ üòâ üé£
        `.trim()
    }, { quoted: info })

    addKoinUser(sender, pescando)
}
break

break

	case 'churrasco': {
	// Verificar se o arquivo JSON existe, e criar se n√£o existir
		if (!fs.existsSync('prenderCooldown.json')) {
			fs.writeFileSync('prenderCooldown.json', JSON.stringify({}));
		}
	
		// Carregar o objeto prenderCooldown do arquivo JSON
		const prenderCooldown = JSON.parse(fs.readFileSync('prenderCooldown.json', 'utf8'));
	
		const currentTimeprender = Date.now();
		const lastprenderTime = prenderCooldown[sender] || 0;
		const timeSinceLastprender = currentTimeprender - lastprenderTime;
		const prenderCooldownTime = 5 * 60 * 1000; // 5 minutos em milissegundos
	
		if (timeSinceLastprender < prenderCooldownTime) {
			const remainingTime = (prenderCooldownTime - timeSinceLastprender) / 1000;
			return reply(`Aguarde ${remainingTime.toFixed(0)} segundos vc estar preso`);
		}
		// Verificar se o arquivo JSON existe, e criar se n√£o existir
		if (!fs.existsSync('./funcoes_rpg/rpg/churrascoCooldown.json')) {
			fs.writeFileSync('./funcoes_rpg/rpg/churrascoCooldown.json', JSON.stringify({}));
		}
	
		// Carregar o objeto churrascoCooldown do arquivo JSON
		const churrascoCooldown = JSON.parse(fs.readFileSync('./funcoes_rpg/rpg/churrascoCooldown.json', 'utf8'));
	
		const currentTimeChurrasco = Date.now();
		const lastChurrascoTime = churrascoCooldown[sender] || 0;
		const timeSinceLastChurrasco = currentTimeChurrasco - lastChurrascoTime;
		const churrascoCooldownTime = 5 * 60 * 1000; // 5 minutos em milissegundos
	
		if (timeSinceLastChurrasco < churrascoCooldownTime) {
			const remainingTime = (churrascoCooldownTime - timeSinceLastChurrasco) / 1000;
			return reply(`Aguarde ${remainingTime.toFixed(0)} segundos antes de fazer outro churrasco.`);
		}
	
		reply(`*OL√Å [ ${pushname} ] AGUARDE 5 SEGUNDOS*`)
		await sleep (5000);
		contrafile = Math.floor((Math.random() * 150) + 50);
		assinhadefrango = Math.floor((Math.random() * 150) + 30);
		filebigno = Math.floor((Math.random() * 150) + 40);
		pikanha = Math.floor((Math.random() * 150) + 50);
		var resultado1 = contrafile + assinhadefrango + filebigno + pikanha;
	
		addFilter(from);
	
		try {
			picc = await zenitsu.profilePictureUrl(m.chat, "image");
		} catch(e) {
			picc = 'https://telegra.ph/file/2bf2e198407f9b8bfbcd0.jpg';
		}
	
		ds = await getBuffer(picc);
	
		let thumbInfo = `
	*‚îè *„ÄåÔ∏èüçñ ùêÇ ùêá ùêî ùêë ùêë ùêÄ ùêí ùêÇ ùêé üçñ„Äç  ‚îì*
	*‚îÇ‚ñ¢ Carne - Picanha Argentina: ${contrafile}*
	*‚îÇ‚ñ¢ Carne - Contra Fil√©: ${assinhadefrango}*
	*‚îÇ‚ñ¢ Carne - Asinhas de Frango: ${filebigno}*
	*‚îÇ‚ñ¢ Carne - Fil√© Mignon: ${pikanha}*
	*‚îó „ÄåÔ∏èüçñ ùêÇ ùêá ùêî ùêë ùêë ùêÄ ùêí ùêÇ ùêé üçñ„Äç  ‚îõ*
	[„ïö] *Foram vendidas hoje por voc√™ em nosso a√ßougue: ${resultado1} pe√ßas de carne por voc√™. Parab√©ns!*
	[„ïö] *Isso significa que foi adicionado em sua carteira R$${resultado1},00 em coins!*
	`;
	
		blackmd.sendMessage(from,  {image: ds, caption: `${thumbInfo}`}, {quoted: info});
		addKoinUser(sender, +resultado1);
	
		// Atualizar o tempo do √∫ltimo churrasco no arquivo JSON
		churrascoCooldown[sender] = currentTimeChurrasco;
		fs.writeFileSync('./funcoes_rpg/rpg/churrascoCooldown.json', JSON.stringify(churrascoCooldown));
	
		break;
	}

case 'casa': {
    if (!isBlackCity) return reply(enviar.rpg.ativar);
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar);

    data = filesDBuserBC(sender);
    const quantidader = 300000;

    if (data.saldo < quantidader) return reply(`*${pushname} VC NAO TEM DINHEIRO SUFICIENTE PARA COMPRAR CASA*\n\n*PRE√áO: R$ ${quantidader.toLocaleString('pt-BR')}*`);

    var [comprar] = q.split("");
    if (!q.includes("")) return reply(`Cade o espa√ßo mano?\nExemplo: ${prefix + command} comprar`);

    casa.push(`${sender}`);
    fs.writeFileSync('./funcoes_rpg/casa/casa.json', JSON.stringify(casa));
    addKoinUser(sender, -quantidader);

    reply(`*CASA COMPRADA COM SUCESSO* üòÉ\n\n*CUSTO üí∞: R$ ${quantidader.toLocaleString('pt-BR')}*`);
}
break;
case 'alugarcasa': {
    if (!isBlackCity) return reply(enviar.rpg.ativar);
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar);

    if (!JSON.stringify(casa).includes(sender)) {
        return reply(`*VOC√ä N√ÉO TEM UMA CASA!*\nUse: ${prefix}casa`);
    }

    casaluge = Math.floor((Math.random() * 10) * 30);
    casapronta = Math.floor((Math.random() * 10) * 500);

    addKoinUser(sender, +casapronta);

    reply(`*VOC√ä ALUGOU A CASA POR ${casaluge} DIAS*\n\n*GANHOU R$ ${casapronta.toLocaleString('pt-BR')}*`);
}
break;

case 'trabalhar': {
    // Calcular a quantidade aleat√≥ria de dinheiro obtido pelo trabalho
    const minerag = Math.floor((Math.random() * 10) * 150);

    // Enviar imagem e mensagem sobre o trabalho
    blackmd.sendMessage(from, {
        image: fs.readFileSync('./funcoes_rpg/image/trabalhar.jpg'),
        caption: `*VC TRABALHOU E GANHOU ${minerag}*`
    }, { quoted: info });

    // Adicionar o valor ao saldo do usu√°rio
    addKoinUser(sender, minerag);

    break;
}

case 'trabalhar': {
    let ganhoTrabalho = Math.floor(Math.random() * 10) * 150;
    blackmd.sendMessage(from, { 
        image: fs.readFileSync('./funcoes_rpg/image/trabalhar.jpg'),
        caption: `*VOC√ä TRABALHOU E GANHOU R$ ${ganhoTrabalho.toLocaleString('pt-BR')}*`
    }, { quoted: info });

    addKoinUser(sender, +ganhoTrabalho);
}
break;
case 'minerar': {
    if (!fs.existsSync('./funcoes_rpg/rpg/pescarCooldown.json')) {
        fs.writeFileSync('./funcoes_rpg/rpg/pescarCooldown.json', JSON.stringify({}));
    }

    const pescarCooldown = JSON.parse(fs.readFileSync('./funcoes_rpg/rpg/pescarCooldown.json', 'utf8'));
    const currentTimePescar = Date.now();
    const lastPescarTime = pescarCooldown[sender] || 0;
    const timeSinceLastPescar = currentTimePescar - lastPescarTime;
    const pescarCooldownTime = 5 * 60 * 1000; // 5 minutos

    if (timeSinceLastPescar < pescarCooldownTime) {
        const remainingTime = (pescarCooldownTime - timeSinceLastPescar) / 1000;
        return reply(`Aguarde ${remainingTime.toFixed(0)} segundos antes de minerar novamente.`);
    }

    reply(`*OL√Å ${pushname}, AGUARDE 5 SEGUNDOS PARA CONCLU√çR A MINERA√á√ÉO*`);
    pescarCooldown[sender] = currentTimePescar;
    fs.writeFileSync('./funcoes_rpg/rpg/pescarCooldown.json', JSON.stringify(pescarCooldown));
    await sleep(5000);

    let pedras = Math.floor(Math.random() * 150) + 40;
    let diamantes = Math.floor(Math.random() * 150) + 30;
    let ouros = Math.floor(Math.random() * 150) + 40;
    let ferro = Math.floor(Math.random() * 150) + 50;
    let totalGanho = pedras + diamantes + ouros + ferro;

    try {
        picc = await loli.profilePictureUrl(m.chat, "image");
    } catch (e) {
        picc = 'https://telegra.ph/file/9651f2a3a24c15ef71dd1.mp4';
    }

    let thumbInfo = `
*‚îè‚îÅ‚îÄ‚îÄ *„ÄåÔ∏è üî∞  MINE  üî∞ „Äç* ‚îÄ‚îÅ‚îì*
‚îÇ‚ñ¢ Pedras: ${pedras}
‚îÇ‚ñ¢ Diamantes: ${diamantes}
‚îÇ‚ñ¢ Ouros: ${ouros}
‚îÇ‚ñ¢ Ferro: ${ferro}
‚îÇ‚ñ¢ *Total: R$ ${totalGanho.toLocaleString('pt-BR')}*
*‚îó‚îÅ‚îÄ‚îÄ *„ÄåÔ∏è üî∞  MINE  üî∞ „Äç* ‚îÄ‚îÅ‚îõ*
[„ïö] *Valor adicionado na carteira!*
    `;

    blackmd.sendMessage(from, { image: await getBuffer(picc), caption: thumbInfo }, { quoted: info });
    addKoinUser(sender, +totalGanho);
}
break;
case 'money': {
    blackmd.sendMessage(from, { react: { text: `üíµ`, key: info.key }});
    blackmd.sendMessage(from, {
        video: { url: `https://telegra.ph/file/7d1a76c9d628836f27e8d.mp4` },
        gifPlayback: true,
        caption: `
‚ï≠‚îÅ‚û™ _MONEY_
‚îÇ‚ó¶‚ûõ Nome : ${pushname}
‚îÇ‚ó¶‚ûõ N√∫mero : ${sender.split("@")[0]}
‚îÇ‚ó¶‚ûõ Dinheiro : R$ ${Number(checkATMuser(sender)).toLocaleString('pt-BR')}
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        `.trim()
    }, { quoted: info });
}
break;
case 'fuguete': {
    if (!isGroup) return reply('Comando apenas para grupo!');
    
    const aposta = Number(args[0]);
    if (!args[0]) return reply(`Qual o valor que voc√™ deseja apostar?`);
    if (isNaN(aposta)) return reply(`Digite "${prefix}fuguete 100" (sem v√≠rgulas ou letras).`);
    if (aposta < 1) return reply(`Aposta m√≠nima √© 1 real.`);

    const saldo = checkATMuser(sender);
    if (saldo < aposta) return reply(`Voc√™ n√£o tem saldo suficiente para apostar R$${aposta}. Seu saldo: R$${saldo}.`);

    const resultado = Math.floor(Math.random() * 6) + 1; // 1 at√© 6
    const ganhoMultiplicador = Math.floor(Math.random() * 7) + 1;
    const perdaMultiplicador = Math.floor(Math.random() * 7) + 1;
    const premio = aposta + (ganhoMultiplicador * 10); // Ganho pequeno a mais

    if ([1,3,5].includes(resultado)) { // Perder
        confirmATM(sender, aposta); // Remove a aposta
        blackmd.sendMessage(from, {
            video: { url: `https://telegra.ph/file/02aee2582cf5c3485b239.mp4` },
            gifPlayback: true,
            caption: `
*Voc√™ perdeu 00.${perdaMultiplicador}.X!*

*Dinheiro perdido:* *R$${aposta}*`
        }, { quoted: info });
    } else { // Ganhar
        addKoinUser(sender, premio); // Adiciona o pr√™mio
        blackmd.sendMessage(from, {
            video: { url: `https://telegra.ph/file/f2aa6670076884015f862.mp4` },
            gifPlayback: true,
            caption: `
*Voc√™ ganhou 00.${ganhoMultiplicador}.X!*

*Dinheiro ganho:* *R$${premio}*`
        }, { quoted: info });
    }
    break;
}

// DOWNLOADS

//comando de bot√£o para usu√°rios de baleia Mods, vulgo Baileys
//J√° com a Key do Channel com +3 k de request




case 'play3':
case 'Playvid2':
case 'playvideo2':
case 'playvid2':
case 'clipe2': {
    try {
        if (!q.trim()) {
            return reply(`- Exemplo: ${prefix}playvideo nome da m√∫sica\nA m√∫sica ser√° baixada, s√≥ basta escolher √°udio ou v√≠deo. Se n√£o baixar, pode ser devido a restri√ß√µes do YouTube.`);
        }

        console.log(`[INFO] Pesquisando v√≠deo: ${q}`);
        const data = await fetchJson(`https://world-ecletix.onrender.com/api/pesquisayt?query=${q}`);

        if (!data || !data.formattedVideos || data.formattedVideos.length === 0) {
            console.log("[ERRO] Nenhum resultado encontrado.");
            return reply("Desculpe, n√£o consegui encontrar o v√≠deo.");
        }

        const firstResult = data.formattedVideos[0];
        console.log("[INFO] V√≠deo encontrado:", firstResult);

        var N_E = "N√£o encontrado.";
        var bla = `
‡πñ€£‚Ä¢ T√≠tulo: ${firstResult.title || N_E}
‡πñ€£‚Ä¢ Tempo: ${firstResult.duration || N_E}
‡πñ€£‚Ä¢ Canal: ${firstResult.channel || N_E}
‡πñ€£‚Ä¢ Visualiza√ß√µes: ${firstResult.views || N_E}
\n‚ñ†‚ñ†‚ñ†‚ñ†‚ñ† 100% \n\nEscolha uma op√ß√£o...\n\nSe desejar baixar o √°udio, use ${prefix}play ${firstResult.link.trim()}`;

        await blackmd.sendMessage(from, { image: { url: firstResult.thumbnail || logoslink?.logo }, caption: bla }, { quoted: info });

        console.log("[INFO] Enviando v√≠deo...");
        await blackmd.sendMessage(from, {
            video: { url: `https://world-ecletix.onrender.com/api/clipe?name=${encodeURIComponent(firstResult.title)}` },
            mimetype: "video/mp4",
            fileName: firstResult.title || "play.mp4"
        }, { quoted: info });

        console.log("[SUCESSO] V√≠deo enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao processar solicita√ß√£o:", e);
        return reply("N√£o foi poss√≠vel baixar ou encontrar esse v√≠deo üêû");
    }
}
break;

case 'play_audio':
case 'play2':
case 'Play2':
case 'PLAY2':
case 'musica2':
case 'm√∫sica2':
case 'music2': {
    try {
        if (!q.trim()) {
            return reply(`- Exemplo: ${prefix}play nome da m√∫sica\nA m√∫sica ser√° baixada, s√≥ basta escolher √°udio ou v√≠deo. Se n√£o baixar, pode ser devido a restri√ß√µes do YouTube.`);
        }

        console.log(`[INFO] Pesquisando m√∫sica: ${q}`);
        const data = await fetchJson(`https://world-ecletix.onrender.com/api/pesquisayt?query=${q}`);

        if (!data || !data.formattedVideos || data.formattedVideos.length === 0) {
            console.log("[ERRO] Nenhum resultado encontrado.");
            return reply("Desculpe, n√£o consegui encontrar a m√∫sica.");
        }

        const firstResult = data.formattedVideos[0];
        console.log("[INFO] M√∫sica encontrada:", firstResult);

        var N_E = "N√£o encontrado.";
        var bla = `
‡πñ€£‚Ä¢ T√≠tulo: ${firstResult.title || N_E}
‡πñ€£‚Ä¢ Tempo: ${firstResult.duration || N_E}
‡πñ€£‚Ä¢ Canal: ${firstResult.channel || N_E}
‡πñ€£‚Ä¢ Visualiza√ß√µes: ${firstResult.views || N_E}
\n‚ñ†‚ñ†‚ñ†‚ñ†‚ñ† 100% \n\nEscolha uma op√ß√£o...\n\nSe desejar baixar o v√≠deo, use ${prefix}play_video ${firstResult.link.trim()}`;

        await blackmd.sendMessage(from, { image: { url: firstResult.thumbnail || logoslink?.logo }, caption: bla }, { quoted: info });

        console.log("[INFO] Enviando √°udio...");
        await blackmd.sendMessage(from, {
            audio: {
                url: `https://world-ecletix.onrender.com/api/musica?name=${encodeURIComponent(firstResult.title)}`
            },
            mimetype: "audio/mpeg",
            fileName: firstResult.title || "play.mp3",
            ptt: true 
        }, { quoted: info });

        console.log("[SUCESSO] √Åudio enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao processar solicita√ß√£o:", e);
        return reply("N√£o foi poss√≠vel baixar ou encontrar esse √°udio üêû");
    }
}
break;
case 'play4': {
    try {
        if (!q.trim()) {
            return reply(`- Exemplo: ${prefix}play2 nome da m√∫sica\n\nA m√∫sica ser√° baixada automaticamente em √°udio. Se n√£o baixar, pode ser devido a restri√ß√µes do YouTube.`);
        }

        console.log(`[INFO] Pesquisando m√∫sica: ${q}`);
        const data = await fetchJson(`https://api.vreden.my.id/api/ytplaymp3?query=${encodeURIComponent(q)}`);

        if (!data || !data.result || data.result.status !== true) {
            console.log("[ERRO] Nenhum resultado encontrado.");
            return reply("Desculpe, n√£o consegui encontrar a m√∫sica.");
        }

        const metadata = data.result.metadata;
        const download = data.result.download;
        console.log("[INFO] M√∫sica encontrada:", metadata);

        var N_E = "N√£o encontrado.";
        var resposta = `
‡πñ€£‚Ä¢ T√≠tulo: ${metadata.title || N_E}
‡πñ€£‚Ä¢ Tempo: ${metadata.duration?.timestamp || N_E}
‡πñ€£‚Ä¢ Canal: ${metadata.author?.name || N_E}
‡πñ€£‚Ä¢ Visualiza√ß√µes: ${metadata.views?.toLocaleString() || N_E}
‡πñ€£‚Ä¢ Publicado: ${metadata.ago || N_E}
\n‚ñ†‚ñ†‚ñ†‚ñ†‚ñ† 100% \n\nBaixando √°udio para voc√™...`;

        await blackmd.sendMessage(from, { image: { url: metadata.thumbnail || logoslink?.logo }, caption: resposta }, { quoted: info });

        console.log("[INFO] Enviando √°udio...");
        await blackmd.sendMessage(from, {
            audio: {
                url: download.url
            },
            mimetype: "audio/mpeg",
            fileName: download.filename || "play.mp3",
            ptt: true 
        }, { quoted: info });

        console.log("[SUCESSO] √Åudio enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao processar solicita√ß√£o:", e);
        return reply("N√£o foi poss√≠vel baixar ou encontrar esse √°udio üêû");
    }
}
break;
case 'play5':
case 'Play5':
case 'PLAY5':
case 'musica5':
case 'm√∫sica5':
case 'music5': {
    try {
        if (!q.trim()) {
            return reply(`- Exemplo: ${prefix}play5 nome da m√∫sica\n\nO v√≠deo ser√° baixado automaticamente. Se n√£o baixar, pode ser devido a restri√ß√µes do YouTube.`);
        }

        console.log(`[INFO] Pesquisando v√≠deo: ${q}`);
        const data = await fetchJson(`https://api.vreden.my.id/api/ytplaymp4?query=${encodeURIComponent(q)}`);

        if (!data || !data.result || data.result.status !== true) {
            console.log("[ERRO] Nenhum resultado encontrado.");
            return reply("Desculpe, n√£o consegui encontrar o v√≠deo.");
        }

        const metadata = data.result.metadata;
        const download = data.result.download;
        console.log("[INFO] V√≠deo encontrado:", metadata);

        var N_E = "N√£o encontrado.";
        var resposta = `
‡πñ€£‚Ä¢ T√≠tulo: ${metadata.title || N_E}
‡πñ€£‚Ä¢ Tempo: ${metadata.duration?.timestamp || N_E}
‡πñ€£‚Ä¢ Canal: ${metadata.author?.name || N_E}
‡πñ€£‚Ä¢ Visualiza√ß√µes: ${metadata.views?.toLocaleString() || N_E}
‡πñ€£‚Ä¢ Publicado: ${metadata.ago || N_E}
\n‚ñ†‚ñ†‚ñ†‚ñ†‚ñ† 100% \n\nBaixando v√≠deo para voc√™...`;

        await blackmd.sendMessage(from, { image: { url: metadata.thumbnail || logoslink?.logo }, caption: resposta }, { quoted: info });

        console.log("[INFO] Enviando v√≠deo...");
        await blackmd.sendMessage(from, {
            video: {
                url: download.url
            },
            mimetype: "video/mp4",
            fileName: download.filename || "play.mp4",
            caption: metadata.title || "",
        }, { quoted: info });

        console.log("[SUCESSO] V√≠deo enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao processar solicita√ß√£o:", e);
        return reply("N√£o foi poss√≠vel baixar ou encontrar esse v√≠deo üêû");
    }
}
break;
case 'play6':
case 'Play6':
case 'PLAY6':
case 'musica6':
case 'm√∫sica6':
case 'music6': {
    try {
        if (!q.trim()) {
            return reply(`- Exemplo: ${prefix}play6 link_do_youtube\n\nMande o link do YouTube para baixar o v√≠deo.`);
        }

        console.log(`[INFO] Buscando v√≠deo pelo link: ${q}`);
        const data = await fetchJson(`https://api.vreden.my.id/api/ytmp4?url=${encodeURIComponent(q)}`);

        if (!data || !data.result || data.result.status !== true) {
            console.log("[ERRO] Nenhum v√≠deo encontrado.");
            return reply("Desculpe, n√£o consegui encontrar ou baixar este v√≠deo.");
        }

        const metadata = data.result.metadata;
        const download = data.result.download;
        console.log("[INFO] V√≠deo encontrado:", metadata);

        var resposta = `
‡πñ€£‚Ä¢ T√≠tulo: ${metadata.title || "N√£o encontrado"}
‡πñ€£‚Ä¢ Tempo: ${metadata.duration?.timestamp || "N√£o encontrado"}
‡πñ€£‚Ä¢ Canal: ${metadata.author?.name || "N√£o encontrado"}
‡πñ€£‚Ä¢ Visualiza√ß√µes: ${metadata.views?.toLocaleString() || "N√£o encontrado"}
‡πñ€£‚Ä¢ Publicado: ${metadata.ago || "N√£o encontrado"}
\n‚ñ†‚ñ†‚ñ†‚ñ†‚ñ† 100% \n\nBaixando v√≠deo para voc√™...`;

        await blackmd.sendMessage(from, { image: { url: metadata.thumbnail || logoslink?.logo }, caption: resposta }, { quoted: info });

        console.log("[INFO] Enviando v√≠deo...");
        await blackmd.sendMessage(from, {
            video: { url: download.url },
            mimetype: "video/mp4",
            fileName: download.filename || "video.mp4",
            caption: metadata.title || "",
        }, { quoted: info });

        console.log("[SUCESSO] V√≠deo enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao buscar v√≠deo:", e);
        return reply("N√£o foi poss√≠vel baixar esse v√≠deo üêû");
    }
}
break;

case 'play7':
case 'Play7':
case 'PLAY7':
case 'musica7':
case 'm√∫sica7':
case 'music7': {
    try {
        if (!q.trim()) {
            return reply(`- Exemplo: ${prefix}play7 link_do_youtube\n\nMande o link do YouTube para baixar o √°udio.`);
        }

        console.log(`[INFO] Buscando √°udio pelo link: ${q}`);
        const data = await fetchJson(`https://api.vreden.my.id/api/ytmp3?url=${encodeURIComponent(q)}`);

        if (!data || !data.result || data.result.status !== true) {
            console.log("[ERRO] Nenhum √°udio encontrado.");
            return reply("Desculpe, n√£o consegui encontrar ou baixar este √°udio.");
        }

        const metadata = data.result.metadata;
        const download = data.result.download;
        console.log("[INFO] √Åudio encontrado:", metadata);

        var resposta = `
‡πñ€£‚Ä¢ T√≠tulo: ${metadata.title || "N√£o encontrado"}
‡πñ€£‚Ä¢ Tempo: ${metadata.duration?.timestamp || "N√£o encontrado"}
‡πñ€£‚Ä¢ Canal: ${metadata.author?.name || "N√£o encontrado"}
‡πñ€£‚Ä¢ Visualiza√ß√µes: ${metadata.views?.toLocaleString() || "N√£o encontrado"}
‡πñ€£‚Ä¢ Publicado: ${metadata.ago || "N√£o encontrado"}
\n‚ñ†‚ñ†‚ñ†‚ñ†‚ñ† 100% \n\nBaixando √°udio para voc√™...`;

        await blackmd.sendMessage(from, { image: { url: metadata.thumbnail || logoslink?.logo }, caption: resposta }, { quoted: info });

        console.log("[INFO] Enviando √°udio...");
        await blackmd.sendMessage(from, {
            audio: { url: download.url },
            mimetype: "audio/mpeg",
            fileName: download.filename || "audio.mp3",
            ptt: true
        }, { quoted: info });

        console.log("[SUCESSO] √Åudio enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao buscar √°udio:", e);
        return reply("N√£o foi poss√≠vel baixar esse √°udio üêû");
    }
}
break;

case 'play': case 'Play': case 'PLAY': case 'musica': case 'm√∫sica': case 'music': {
    try {
        if (!q.trim()) return reply(`- Exemplo: ${prefix}play nome da m√∫sica`);
        
        // Enviar apenas o √°udio usando a API diretamente
        blackmd.sendMessage(from, { 
            audio: { 
                url: `https://world-ecletix.onrender.com/api/musica?name=${encodeURIComponent(q)}` 
            }, 
            mimetype: "audio/mpeg",
            fileName: q || "play.mp3",
            ptt: true 
        }, { quoted: info }).catch(e => reply("Erro ao tentar baixar a m√∫sica."));

    } catch (e) {
        console.log(e);
        return reply("N√£o foi poss√≠vel baixar ou encontrar esse √°udio.");
    }
}
break;
case 'Playvid': case 'playvideo': case 'playvid': case 'clipe': {
    try {
        if (!q.trim()) return reply(`- Exemplo: ${prefix}playvideo nome da m√∫sica\na m√∫sica ser√° baixada, s√≥ basta escolher √°udio ou v√≠deo, se n√£o baixar, o YouTube privou de n√£o baixarem, ou algo do tipo..`);
        
        // Nova API para download de v√≠deo
        blackmd.sendMessage(from, { video: { url: `https://world-ecletix.onrender.com/api/clipe?name=${encodeURIComponent(firstResult.title)}` }, mimetype: "video/mp4", fileName: firstResult.title || "play.mp4" }, { quoted: info }).catch(e => {
            return reply("Erro ao tentar baixar o v√≠deo.");
        });
    } catch (e) {
        console.log(e);
        return reply("n√£o foi poss√≠vel baixar ou encontrar esse videoüêû");
    }
}
break;
case 'Playlink': 
case 'playlink': 
case 'ytbmp3': {
    try {
        if (!q.trim()) {
            console.log("[ERRO] Nenhum texto fornecido para pesquisa.");
            return reply(`- Exemplo: ${prefix}playlink nome da m√∫sica\na m√∫sica ser√° baixada, s√≥ basta escolher √°udio ou v√≠deo.`);
        }

        console.log(`[INFO] Pesquisando m√∫sica: ${q}`);
        const data = await fetchJson(`https://world-ecletix.onrender.com/api/pesquisayt?query=${q}`);

        if (!data || !data.formattedVideos || data.formattedVideos.length === 0) {
            console.log("[ERRO] Nenhum resultado encontrado.");
            return reply("Desculpe, n√£o consegui encontrar a m√∫sica.");
        }

        const firstResult = data.formattedVideos[0];
        console.log("[INFO] M√∫sica encontrada:", firstResult);

        var N_E = " N√£o encontrado.";
        var bla = `
        ‡πñ€£‚Ä¢ Titulo: ${firstResult.title || N_E}
        ‡πñ€£‚Ä¢ Tempo: ${firstResult.duration || N_E}
        ‡πñ€£‚Ä¢ Canal: ${firstResult.channel || N_E}
        ‡πñ€£‚Ä¢ Visualiza√ß√µes: ${firstResult.views || N_E}

        ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ† 100% 

        E·•â·•¥·•Ü·•£h·•≤ ·•ôÍßë·•≤ ·•ÜœÅ·•¥·•≤·•Ü...

        Se desejar baixar o v√≠deo, use ${prefix}videolink ${firstResult.link.trim()}
        `;

        await blackmd.sendMessage(from, { 
            image: { url: firstResult.thumbnail || logoslink?.logo }, 
            caption: bla 
        }, { quoted: info });

        console.log("[INFO] Enviando √°udio...");
        await blackmd.sendMessage(from, { 
            audio: { url: `https://world-ecletix.onrender.com/api/linkmp3?url=${encodeURIComponent(firstResult.link)}` }, 
            mimetype: "audio/mpeg", 
            fileName: firstResult.title || "play.mp3",
            ptt: true
        }, { quoted: info });

        console.log("[SUCESSO] √Åudio enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao processar solicita√ß√£o:", e);
        return reply("Seja mais espec√≠fico, n√£o deu pra encontrar com apenas isto... / Erro");
    }
}
break;

case 'clipelink': 
case 'videolink': 
case 'ytbmp4': {
    try {
        if (!q.trim()) {
            console.log("[ERRO] Nenhum texto fornecido para pesquisa.");
            return reply(`- Exemplo: ${prefix}videolink nome da m√∫sica\na m√∫sica ser√° baixada, s√≥ basta escolher √°udio ou v√≠deo.`);
        }

        console.log(`[INFO] Pesquisando v√≠deo: ${q}`);
        const data = await fetchJson(`https://world-ecletix.onrender.com/api/pesquisayt?query=${q}`);

        if (!data || !data.formattedVideos || data.formattedVideos.length === 0) {
            console.log("[ERRO] Nenhum resultado encontrado.");
            return reply("Desculpe, n√£o consegui encontrar a m√∫sica.");
        }

        const firstResult = data.formattedVideos[0];
        console.log("[INFO] V√≠deo encontrado:", firstResult);

        var N_E = " N√£o encontrado.";
        var bla = `
        ‡πñ€£‚Ä¢ Titulo: ${firstResult.title || N_E}
        ‡πñ€£‚Ä¢ Tempo: ${firstResult.duration || N_E}
        ‡πñ€£‚Ä¢ Postado: ${firstResult.creator || N_E}
        ‡πñ€£‚Ä¢ Descri√ß√£o: ${firstResult.channel || N_E}
        ‡πñ€£‚Ä¢ Visualiza√ß√µes: ${firstResult.views || N_E}

        ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ† 100% 

        E·•â·•¥·•Ü·•£h·•≤ ·•ôÍßë·•≤ ·•ÜœÅ·•¥·•≤·•Ü...

        Se desejar baixar a m√∫sica, use ${prefix}playlink ${firstResult.link.trim()}
        `;

        await blackmd.sendMessage(from, {image: {url: firstResult.thumbnail || logoslink?.logo}, caption: bla}, {quoted: info});
        
        console.log("[INFO] Enviando v√≠deo...");
        await blackmd.sendMessage(from, {
            video: { url: `https://world-ecletix.onrender.com/api/linkmp4?url=${encodeURIComponent(firstResult.link)}` },
            mimetype: "video/mp4",
            fileName: firstResult.title || "video.mp4"
        }, { quoted: info });

        console.log("[SUCESSO] V√≠deo enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao processar solicita√ß√£o:", e);
        return reply("Seja mais espec√≠fico, n√£o deu pra encontrar com apenas isto... / Erro");
    }
}
break;

case 'playdoc': 
case 'Playdoc': {
    try {
        if (!q.trim()) {
            console.log("[ERRO] Nenhum texto fornecido para pesquisa.");
            return reply(`- Exemplo: ${prefix}playdoc nome da m√∫sica\na m√∫sica ser√° baixada, s√≥ basta escolher √°udio ou v√≠deo.`);
        }

        console.log(`[INFO] Pesquisando m√∫sica para download como documento: ${q}`);
        const data = await fetchJson(`https://world-ecletix.onrender.com/api/pesquisayt?query=${q}`);

        if (!data || !data.formattedVideos || data.formattedVideos.length === 0) {
            console.log("[ERRO] Nenhum resultado encontrado.");
            return reply("Desculpe, n√£o consegui encontrar a m√∫sica.");
        }

        const firstResult = data.formattedVideos[0];
        console.log("[INFO] M√∫sica encontrada:", firstResult);

        var N_E = " N√£o encontrado.";
        var bla = `
        ‡πñ€£‚Ä¢ Titulo: ${firstResult.title || N_E}
        ‡πñ€£‚Ä¢ Tempo: ${firstResult.duration || N_E}
        ‡πñ€£‚Ä¢ Canal: ${firstResult.channel || N_E}
        ‡πñ€£‚Ä¢ Visualiza√ß√µes: ${firstResult.views || N_E}

        ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ† 100% 

        E·•â·•¥·•Ü·•£h·•≤ ·•ôÍßë·•≤ ·•ÜœÅ·•¥·•≤·•Ü...

        Se desejar baixar o v√≠deo, use ${prefix}play_video ${firstResult.link.trim()}
        `;

        console.log("[INFO] Enviando imagem com detalhes da m√∫sica...");
        await blackmd.sendMessage(from, { image: { url: firstResult.thumbnail || logoslink?.logo }, caption: bla }, { quoted: info });

        const audioUrl = `https://world-ecletix.onrender.com/api/musica?name=${encodeURIComponent(firstResult.title)}`;
        console.log("[INFO] URL do √°udio gerada:", audioUrl);

        console.log("[INFO] Enviando m√∫sica como documento...");
        await blackmd.sendMessage(from, {
            document: { url: audioUrl },
            mimetype: "audio/mpeg",
            fileName: `${firstResult.title || 'play'}.mp3`
        }, { quoted: info });

        console.log("[SUCESSO] M√∫sica enviada como documento.");
    } catch (e) {
        console.error("[ERRO] Falha ao processar solicita√ß√£o:", e);
        return reply("N√£o foi poss√≠vel baixar ou encontrar esse √°udio üêû");
    }
}
break;
case 'audio':
try {
    if (!q) return reply(`Informe o nome da m√∫sica ou o link`);
    await reagir(from, '‚è≥');

    let play2;

    // Verifica se o usu√°rio enviou um link
    if (q.includes('youtube.com') || q.includes('youtu.be')) {
        // Se for link, faz a busca diretamente pela URL
        play2 = await fetchJson(`https://api.nexfuture.com.br/api/pesquisas/youtube?query=${encodeURIComponent(q)}`);
    } else {
        // Caso contr√°rio, pesquisa pela string
        play2 = await fetchJson(`https://api.nexfuture.com.br/api/pesquisas/youtube?query=${encodeURIComponent(q)}`);
    }

    await blackmd.sendMessage(from, {
        audio: { url: `https://api.nexfuture.com.br/api/downloads/youtube/mp3-2?url=${play2.resultado.url}` },
        fileName: play2.resultado.titulo + '.mpeg',
        mimetype: "audio/mpeg",
        contextInfo: { 
            externalAdReply: {
                title: play2.resultado.titulo,
                body: `‚åó Lady Bot a melhorüêû ‚åó`,
                mediaType: 1,
                reviewType: "PHOTO",
                thumbnailUrl: play2.resultado.imagem,
                showAdAttribution: true,
                renderLargerThumbnail: true,
            },
        },
    }, { quoted: info });

} catch (error) {
    console.log(error);
    return reply('Ocorreu um erro, tente novamente mais tarde!');
}
break;

case 'video':
try {
    if (!q) return reply(`Informe o nome do v√≠deo ou o link`);
    await reagir(from, '‚è≥');

    let play2;

    // Verifica se o usu√°rio enviou um link
    if (q.includes('youtube.com') || q.includes('youtu.be')) {
        // Se for link, faz a busca diretamente pela URL
        play2 = await fetchJson(`https://api.nexfuture.com.br/api/pesquisas/youtube?query=${encodeURIComponent(q)}`);
    } else {
        // Caso contr√°rio, pesquisa pela string
        play2 = await fetchJson(`https://carisys.online/api/pesquisas/youtube?query=${encodeURIComponent(q)}`);
    }

    await blackmd.sendMessage(from, {
        video: { url: `https://api.nexfuture.com.br/downloads/youtube/mp4?url=${play2.resultado.url}` },
        fileName: play2.resultado.titulo + '.mp4',
        mimetype: "video/mp4",
        contextInfo: { 
            externalAdReply: {
                title: play2.resultado.titulo,
                body: `‚åó Lady Bot a melhorüêû ‚åó`,
                mediaType: 1,
                renderLargerThumbnail: true,
                thumbnailUrl: play2.resultado.imagem,
                showAdAttribution: true,
            },
        },
    }, { quoted: info });

} catch (error) {
    console.log(error);
    return reply('Ocorreu um erro, tente novamente mais tarde!');
}
break;
case 'Spotify':
case 'spotify':
case 'spo':
case 'spotify2': {
    try {
        if (!q.trim()) {
            return reply(`Por favor, informe o nome da m√∫sica.\n\nExemplo: ${prefix}spotify nome da m√∫sica`);
        }

        const audioUrl = `https://world-ecletix.onrender.com/api/spotify2?name=${encodeURIComponent(q)}`;

        await blackmd.sendMessage(from, { 
            audio: { url: audioUrl }, 
            mimetype: 'audio/mpeg',
            fileName: `${q}.mp3`,
            ptt: true 
        }, { quoted: info });

    } catch (e) {
        console.error("Erro ao enviar √°udio do Spotify:", e);
        return reply("Desculpe, n√£o foi poss√≠vel baixar ou encontrar essa m√∫sica.");
    }
}
break;

case "Instagram3":
case "igaudii":
case "igaud":
case "ig3":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer o URL de qualquer v√≠deo, postagem, rolo ou imagem do Instagram.");
    }
    
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/insta?url=${q}`);
        // by luan
        
        // Verifica se a resposta cont√©m dados e se 'data' √© um array
        if (!res || !res.data || !Array.isArray(res.data.data)) {
            return reply("Nenhum v√≠deo ou imagem encontrado ou resposta inv√°lida da API.");
        }
        
        const mediaArray = res.data.data;

        // Verifica se h√° pelo menos um item no array
        if (mediaArray.length < 1) {
            return reply("N√£o h√° v√≠deo dispon√≠vel para esta postagem.");
        }

        // Pega o primeiro item (√≠ndice 0) para a URL do v√≠deo
        const videoData = mediaArray[0];
        const mediaURL = videoData.url;

        // Baixa o v√≠deo da URL como √°udio
        const { data: videoBuffer } = await axios.get(mediaURL, { responseType: 'arraybuffer' });

        // Envia o v√≠deo como √°udio para o usu√°rio
        await blackmd.sendMessage(
            from,
            {
                audio: Buffer.from(videoBuffer),
                mimetype: 'audio/mpeg',
                fileName: "audio.mp3",
                ptt: false // Define `true` se quiser enviar como √°udio de voz (PTT)
            },
            { quoted: info }
        );

        // Se houver uma URL de √°udio para baixar
        if (audioUrl) {
            // Baixa o √°udio da URL
            const { data: audioBuffer } = await axios.get(audioUrl, { responseType: 'arraybuffer' });

            // Envia o √°udio para o usu√°rio
            await blackmd.sendMessage(
                from,
                {
                    audio: Buffer.from(audioBuffer),
                    mimetype: 'audio/mpeg',
                    fileName: "audio.mp3",
                    ptt: false // Define `true` se quiser enviar como √°udio de voz (PTT)
                },
                { quoted: info }
            );
        }

    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;

case "instagram2":
case "igvideo":
case "igvid":
case "ig2":
{
    if(!q) {
        return reply("Voc√™ precisa fornecer o URL de qualquer v√≠deo, postagem, rolo ou imagem do Instagram.");
    }
    
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/insta?url=${q}`);
        //by luan
        
        // Verifica se a resposta cont√©m dados e se 'data' √© um array
        if (!res || !res.data || !Array.isArray(res.data.data)) {
            return reply("Nenhum v√≠deo ou imagem encontrado ou resposta inv√°lida da API.");
        }
        
        const mediaArray = res.data.data;

        // Verifica se h√° pelo menos um item no array
        if (mediaArray.length < 1) {
            return reply("N√£o h√° v√≠deo dispon√≠vel para esta postagem.");
        }

        // Pega o primeiro item (√≠ndice 0) para a URL do v√≠deo
        const videoData = mediaArray[0];
        const mediaURL = videoData.url;

        // Envia o v√≠deo usando a URL
        const cap = "aqui seu video";
        blackmd.sendMessage(from, { video: { url: mediaURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;

case "capcut2": case "capcutaudio": case "cpaud": case "cap2": { if (!q) { return reply("Voc√™ precisa fornecer o URL de um v√≠deo do CapCut."); }

try {
    const res = await fetchJson(`https://world-ecletix.onrender.com/api/capcut?url=${q}`);
    
    // Verifica se a resposta cont√©m dados v√°lidos
    if (!res || !res.result || !res.result.status || !res.result.url) {
        return reply("Nenhum v√≠deo encontrado ou resposta inv√°lida da API.");
    }
    
    const videoURL = res.result.url;
    const caption = res.result.title || "Aqui est√° seu v√≠deo do CapCut.";
    
    // Baixa o v√≠deo da URL como √°udio
    const { data: videoBuffer } = await axios.get(videoURL, { responseType: 'arraybuffer' });

    // Envia o v√≠deo como √°udio para o usu√°rio
    await blackmd.sendMessage(
        from,
        {
            audio: Buffer.from(videoBuffer),
            mimetype: 'audio/mpeg',
            fileName: "audio.mp3",
            ptt: false // Define `true` se quiser enviar como √°udio de voz (PTT)
        },
        { quoted: info }
    );
} catch (error) {
    console.error(error);
    return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
}

} break;
case "drivevideo": case "drivevid": case "dvideo": case "dvid": { if (!q) { return reply("Voc√™ precisa fornecer a URL de um arquivo do Google Drive."); }

try {
    const res = await fetchJson(`https://api.vreden.my.id/database/gdrive?url=${q}`);
    
    if (!res || !res.result || !res.result.status || !res.result.downloadUrl) {
        return reply("Nenhum v√≠deo encontrado ou resposta inv√°lida da API.");
    }
    
    const videoURL = res.result.downloadUrl;
    const caption = res.result.fileName || "Aqui est√° seu v√≠deo do Google Drive.";
    
    blackmd.sendMessage(from, { video: { url: videoURL }, caption: caption }, { quoted: info });
} catch (error) {
    console.error(error);
    return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
}

} break;

case "driveaudio": case "driveaud": case "daudio": case "daud": { if (!q) { return reply("Voc√™ precisa fornecer a URL de um arquivo do Google Drive."); }

try {
    const res = await fetchJson(`https://api.vreden.my.id/database/gdrive?url=${q}`);
    
    if (!res || !res.result || !res.result.status || !res.result.downloadUrl) {
        return reply("Nenhum √°udio encontrado ou resposta inv√°lida da API.");
    }
    
    const audioURL = res.result.downloadUrl;
    
    const { data: audioBuffer } = await axios.get(audioURL, { responseType: 'arraybuffer' });
    
    await blackmd.sendMessage(
        from,
        {
            audio: Buffer.from(audioBuffer),
            mimetype: 'audio/mpeg',
            fileName: "audio.mp3",
            ptt: false 
        },
        { quoted: info }
    );
} catch (error) {
    console.error(error);
    return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
}

} break;

case "capcut": { if (!q) { return reply("Voc√™ precisa fornecer o URL de um v√≠deo do CapCut."); }

try {
    const res = await fetchJson(`https://world-ecletix.onrender.com/api/capcut?url=${q}`);
    
    // Verifica se a resposta cont√©m dados v√°lidos
    if (!res || !res.result || !res.result.status || !res.result.url) {
        return reply("Nenhum v√≠deo encontrado ou resposta inv√°lida da API.");
    }
    
    const videoURL = res.result.url;
    const caption = res.result.title || "Aqui est√° seu v√≠deo do CapCut.";
    
    // Envia o v√≠deo
    blackmd.sendMessage(from, { video: { url: videoURL }, caption: caption }, { quoted: info });
} catch (error) {
    console.error(error);
    return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
}

} break;

case "tiktokad":
case "tiktokaud":
case "tiktokmp3":
case "tiktok_audio":
{
  if (!q) {
    return blackmd.sendMessage(
      from,
      { text: `Por favor, forne√ßa o link do v√≠deo TikTok.\nExemplo: ${prefix}tiktok_audio https://www.tiktok.com/@granitayt/video/7383381752024272133` },
      { quoted: info }
    );
  }

  try {
    // Solicita o √°udio da API
    const { data: result } = await axios.get(`https://world-ecletix.onrender.com/api/tiktok?query=${encodeURIComponent(q)}`);

    if (!result || !result.audio) {
      return blackmd.sendMessage(from, { text: "N√£o foi poss√≠vel obter o √°udio do TikTok. Tente outro link." }, { quoted: info });
    }

    // Extrai a URL do √°udio
    const audioUrl = result.audio;

    // Baixa o √°udio da URL
    const { data: audioBuffer } = await axios.get(audioUrl, { responseType: 'arraybuffer' });

    // Envia o √°udio para o usu√°rio
    await blackmd.sendMessage(
      from,
      {
        audio: Buffer.from(audioBuffer),
        mimetype: 'audio/mpeg',
        fileName: "audio.mp3",
        ptt: false // Define `true` se quiser enviar como √°udio de voz (PTT)
      },
      { quoted: info }
    );

  } catch (error) {
    console.error('Erro ao baixar/enviar o √°udio:', error);
    blackmd.sendMessage(from, { text: "Erro ao processar a solicita√ß√£o. Tente novamente mais tarde." }, { quoted: info });
  }
}
break;
case "tiktokvid":
case "tiktokmp4":
case "tiktokvd":
case "tiktok_video":
{
  if(!q) {
    return blackmd.sendMessage(
      from,
      { text: `Por favor, forne√ßa o link do v√≠deo TikTok. Exemplo: ${prefix}tiktok_video https://www.tiktok.com/@granitayt/video/7383381752024272133` },
      { quoted: info }
    );
  }

  try {
    // Solicitar o v√≠deo diretamente da API
    const response = await axios.get(`https://world-ecletix.onrender.com/api/tiktok?query=${encodeURIComponent(q)}`);
    const result = response.data;

    // Verificar se a resposta cont√©m a URL do v√≠deo
    if (!result || !result.videoOriginal) {
      return blackmd.sendMessage(from, { text: "N√£o foi poss√≠vel obter o v√≠deo do TikTok." }, { quoted: info });
    }

    // Extrair a URL do v√≠deo
    const videoUrl = result.videoOriginal;

    // Baixar o v√≠deo do link
    const { data: videoBuffer } = await axios.get(videoUrl, { responseType: 'arraybuffer' });

    // Enviar o v√≠deo baixado
    await blackmd.sendMessage(
      from,
      {
        video: Buffer.from(videoBuffer),  // Certifique-se de que o v√≠deo est√° sendo enviado como Buffer
        mimetype: 'video/mp4',
        fileName: `video.mp4`
      },
      { quoted: info }
    );

  } catch (error) {
    console.error('Erro ao baixar e enviar o v√≠deo:', error);
    blackmd.sendMessage(from, { text: "Ocorreu um erro ao processar a solicita√ß√£o." }, { quoted: info });
  }
}
break;
case "instagram":
case "igimage":
case "igimg":
case "ig":
{
    if(!q) {
        return reply("Voc√™ precisa fornecer o URL de qualquer v√≠deo, postagem, rolo ou imagem do Instagram.");
    }
    
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/insta?url=${q}`);
        //by luan
        
        // Verifica se a resposta cont√©m dados e se 'data' √© um array
        if (!res || !res.data || !Array.isArray(res.data.data)) {
            return reply("Nenhum v√≠deo ou imagem encontrado ou resposta inv√°lida da API.");
        }
        
        const mediaArray = res.data.data;

        // Itera sobre cada item no array de m√≠dias
        for (const mediaData of mediaArray) {
            const mediaType = mediaData.url.endsWith('.mp4') ? 'video' : 'image'; // Determina o tipo com base na URL
            const mediaURL = mediaData.url;
            let cap = `aqui sua foto! ${mediaType.toUpperCase()}`;
            
            if (mediaType === "video") {
                blackmd.sendMessage(from, { video: { url: mediaURL }, caption: cap }, { quoted: info });
            } else if (mediaType === "image") {
                blackmd.sendMessage(from, { image: { url: mediaURL }, caption: cap }, { quoted: info });
            }
        }
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "pin_audio":
case "pinterest_audio":
{
    if(!q) {
        return reply("Voc√™ precisa fornecer o URL de qualquer v√≠deo do Pinterest.");
    }

    try {
        const res = await fetchJson(`https://api-pinterest-y7jx.onrender.com/api/vid2?url=${q}`);
        //by luan

        if (!res || !res.video_url) {
            return reply("Nenhum v√≠deo encontrado ou resposta inv√°lida da API.");
        }

        // Extrair a URL do √°udio
    const videoURL = res.video_url;

    // Baixar o √°udio do link
    const { data: audioBuffer } = await axios.get(videoURL, { responseType: 'arraybuffer' });

    // Enviar o √°udio baixado
    await blackmd.sendMessage(
      from,
      {
        audio: Buffer.from(audioBuffer),  // Certifique-se de que o √°udio est√° sendo enviado como Buffer
        mimetype: 'audio/mpeg',
        fileName: `audio.mp3`,
        ptt: true
      },
      { quoted: info }
    );

  } catch (error) {
    console.error('Erro ao baixar e enviar o √°udio:', error);
    blackmd.sendMessage(from, { text: "Ocorreu um erro ao processar a solicita√ß√£o." }, { quoted: info });
  }
}
break;
case "pin_video":
case "pinterest_video":
{
    if(!q) {
        return reply("Voc√™ precisa fornecer o URL de qualquer v√≠deo do Pinterest.");
    }

    try {
        const res = await fetchJson(`https://api-pinterest-y7jx.onrender.com/api/vid2?url=${q}`);
        //by luan

        if (!res || !res.video_url) {
            return reply("Nenhum v√≠deo encontrado ou resposta inv√°lida da API.");
        }

        const videoURL = res.video_url;
        let cap = `aqui est√°!!!`;
        blackmd.sendMessage(from, { video: { url: videoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "kwai_audio":
{
    if(!q) {
        return reply("Voc√™ precisa fornecer o URL de qualquer v√≠deo do Kwai.");
    }

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/kwai?url=${q}`);
        //by luan

        if (!res || !res.videoUrl) {
            return reply("Nenhum v√≠deo encontrado ou resposta inv√°lida da API.");
        }

        // Extrair a URL do √°udio
    const videoURL = res.videoUrl;

    // Baixar o √°udio do link
    const { data: audioBuffer } = await axios.get(videoURL, { responseType: 'arraybuffer' });

    // Enviar o √°udio baixado
    await blackmd.sendMessage(
      from,
      {
        audio: Buffer.from(audioBuffer),  // Certifique-se de que o √°udio est√° sendo enviado como Buffer
        mimetype: 'audio/mpeg',
        fileName: `audio.mp3`,
        ptt: true
      },
      { quoted: info }
    );

  } catch (error) {
    console.error('Erro ao baixar e enviar o √°udio:', error);
    blackmd.sendMessage(from, { text: "Ocorreu um erro ao processar a solicita√ß√£o." }, { quoted: info });
  }
}
break;

case "kwai_video":
{
    if(!q) {
        return reply("Voc√™ precisa fornecer o URL de qualquer v√≠deo do Kwai.");
    }

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/kwai?url=${q}`);
        //by luan

        if (!res || !res.videoUrl) {
            return reply("Nenhum v√≠deo encontrado ou resposta inv√°lida da API.");
        }

        const videoURL = res.videoUrl;
        let cap = `Aqui est√° o v√≠deo do Kwai!`;
        blackmd.sendMessage(from, { video: { url: videoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case 'twitter_video':
try {
reply("baixando...")
blackmd.sendMessage(from, {video: {url: `https://api.bronxyshost.com.br/api-bronxys/${command}?url=${q}&apikey=Yuta-Channel`}, mimetype: "video/mp4"}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break;

case 'twitter_audio':
try {
reply("baixando..")
blackmd.sendMessage(from, {audio: {url: `https://api.bronxyshost.com.br/api-bronxys/${command}?url=${q}&apikey=Yuta-Chanel`}, mimetype: "audio/mpeg"}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break;


case 'pinterest':
    if (!q) return reply(`*_‚ùïColoque a busca que voc√™ deseja!_*\n- *üßë‚Äçüè´ Por exemplo:* ${prefix + command} goku`);

    const searchQueryPinterest = encodeURIComponent(q);
    const pinterestApiUrl = `https://world-ecletix.onrender.com/api/pinterest?termo=${searchQueryPinterest}`;

    reply("üîÑ Buscando imagens...");

    try {
        const response = await fetch(pinterestApiUrl);

        if (!response.ok) {
            throw new Error('Erro na resposta da API');
        }

        const urls = await response.json();

        if (!Array.isArray(urls) || urls.length === 0) {
            return reply("Nenhuma imagem encontrada para a pesquisa.");
        }

        const randomIndex = Math.floor(Math.random() * urls.length);
        const randomUrl = urls[randomIndex];

        // Faz a requisi√ß√£o da imagem
        const imageResponse = await fetch(randomUrl);
if (!imageResponse.ok) {
    throw new Error('Erro ao buscar a imagem.');
}

const imageArrayBuffer = await imageResponse.arrayBuffer();  // Usando .arrayBuffer() para obter a imagem

// Envia a imagem diretamente do ArrayBuffer
await blackmd.sendMessage(from, { image: Buffer.from(imageArrayBuffer), caption: `Aqui est√° a imagem: ${q}` });

    } catch (error) {
        console.error("Erro ao obter a imagem:", error);
        reply("üö® N√£o foi poss√≠vel buscar a imagem. Tente novamente mais tarde.");
    }
break;

case "pin_foto":
case "pinterest_foto":
{
    if(!q) {
        return reply("Voc√™ precisa fornecer o URL de qualquer foto do Pinterest.");
    }

    try {
        const res = await fetchJson(`https://api-pinterest-y7jx.onrender.com/api/img2?url=${q}`);
        //by luan

        if (!res || !res.image_url) {
            return reply("Nenhuma foto encontrada ou resposta inv√°lida da API.");
        }

        const imageURL = res.image_url;
        let cap = `aqui est√°!!!`;
        blackmd.sendMessage(from, { image: { url: imageURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "face_video":
case "facebook_video": {
    if (!q) {
        return reply("Voc√™ precisa fornecer o URL de um v√≠deo do Facebook.");
    }
    
    try {
        const res = await fetchJson(`${site}/api/facebook?link=${q}`);
        
        if (!res || !res.data || !res.data.hd_url) {
            return reply("Nenhum v√≠deo encontrado ou resposta inv√°lida da API.");
        }
        
        const videoURL = res.data.hd_url;
        let caption = "Aqui est√° seu v√≠deo do Facebook!";
        
        blackmd.sendMessage(from, { video: { url: videoURL }, caption: caption }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "face_audio":
case "fbaudio":
case "facebookmp3":
case "facebook_audio":
{
  if (!q) {
    return blackmd.sendMessage(
      from,
      { text: `Por favor, forne√ßa o link do v√≠deo do Facebook. Exemplo: ${prefix}fbaudio https://www.facebook.com/watch/?v=123456789` },
      { quoted: info }
    );
  }

  try {
    // Solicitar o √°udio diretamente da API do Facebook
    const response = await axios.get(`https://api.vreden.my.id/api/fbdl?url=${encodeURIComponent(q)}`);
    const res = response.data;

    // Verificar se a resposta cont√©m a URL do √°udio
    if (!res || !res.data || !res.data.hd_url) {
      return blackmd.sendMessage(from, { text: "Nenhum √°udio encontrado ou resposta inv√°lida da API." }, { quoted: info });
    }

    // Extrair a URL do √°udio
    const videoURL = res.data.hd_url;

    // Baixar o √°udio do link
    const { data: audioBuffer } = await axios.get(videoURL, { responseType: 'arraybuffer' });

    // Enviar o √°udio baixado
    await blackmd.sendMessage(
      from,
      {
        audio: Buffer.from(audioBuffer),  // Certifique-se de que o √°udio est√° sendo enviado como Buffer
        mimetype: 'audio/mpeg',
        fileName: `audio.mp3`,
        ptt: true
      },
      { quoted: info }
    );

  } catch (error) {
    console.error('Erro ao baixar e enviar o √°udio:', error);
    blackmd.sendMessage(from, { text: "Ocorreu um erro ao processar a solicita√ß√£o." }, { quoted: info });
  }
}
break;
case "xvdow":
case "xvdow_video":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer o URL de qualquer v√≠deo do Xvideos.");
    }

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/xvideosdow?url=${q}`);
        //by luan

        if (!res || !res.videoUrl) {
            return reply("Nenhum v√≠deo encontrado ou resposta inv√°lida da API.");
        }

        const videoURL = res.videoUrl;
        const thumbnailURL = res.thumbnail[0];
        const title = res.name;
        const description = res.description;
        const uploadDate = res.uploadDate;
        const duration = res.duration;

        // Cria uma legenda com as informa√ß√µes
        let cap = `T√≠tulo: ${title}\nDescri√ß√£o: ${description}\nData de Upload: ${uploadDate}\nDura√ß√£o: ${duration}`;
        
        // Envia o v√≠deo com a miniatura e a legenda
        blackmd.sendMessage(from, { 
            video: { url: videoURL },
            caption: cap,
            thumbnail: { url: thumbnailURL }
        }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case "xnxxvideo":
case "xnxxvid":
{
    if (!q) {
        return reply("Voc√™ precisa fornecer o URL de um v√≠deo do XNXX.");
    }
    
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/xnxxdow?url=${q}`);
        
        // Verifica se a resposta cont√©m dados e URL do v√≠deo
        if (!res || !res.title || !res.files || !res.files.high) {
            return reply("Nenhum v√≠deo encontrado ou resposta inv√°lida da API.");
        }
        
        const videoURL = res.files.high; // Pegando a melhor qualidade (high)
        const caption = res.title || "Aqui est√° seu v√≠deo do XNXX.";
        
        // Envia o v√≠deo com a URL de melhor qualidade
        blackmd.sendMessage(from, { video: { url: videoURL }, caption: caption }, { quoted: info });
        
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicita√ß√£o.");
    }
}
break;
case 'mediafire':
try {
if(!q.includes("mediafire.com")) return reply("Faltando o link do mediafire para download do arquivo, cade?");
let nex = await fetchJson(`https://api.nexfuture.com.br/api/downloads/mediafire/dl?url=${q}`)
reply(`Enviando: ${nex.resultado.nome}\n\nPeso: ${nex.resultado.size}`)

await blackmd.sendMessage(from, {document: 
{url: nex.resultado.url}, mimetype: "application/"+nex.resultado.mime, fileName: nex.resultado.nome});
} catch (error) {
console.log(error)
return reply("Deu um pequeno error, tente novamente mais tarde...")
}
break;
case "threads": case "thr":
if(!q.includes("threads.net")) return reply(`Cade o link do threads? Exemplo: ${prefix+command} https://www.threads.net/@tali_mito22/post/C_3_FbKyHtm/?xmt=AQGzOjjOpgW7PRhCZRcda0GvAqfvYqPWDwHgzn_v6_FVLQ`)
reply("Aguarde, estou enviando..")
try {
blackmd.sendMessage(from, {video: {url: `https://api.bronxyshost.com.br/api-bronxys/threads?url=${q}&apikey=Yuta-Chanel`}})
} catch (e) {
return reply("Erro, tente falar com o suporte...")
}
break;

case 'gitclone':
if(!q) return reply(`Exemplo: ${prefix}gitclone https://github.com/m4thxyz/blackofc`)
reply(`*[‚ùï] _Enviando... Aguarde_* ‚úî`)
let regex1 = /(?:https|git)(?::\/\/|@)github\.com[\/:]([^\/:]+)\/(.+)/i
if(!regex1.test(args[0])) return reply('Aguarde...')
let [, user, repo] = args[0].match(regex1) || []
repo = repo.replace(/.git$/, '')
let url = `https://api.github.com/repos/${user}/${repo}/zipball`
let filename = (await fetch(url, {method: 'HEAD'})).headers.get('content-disposition').match(/attachment; filename=(.*)/)[1]
let finishname = filename.split(`-`).splice(0, filename.split(`-`).length - 1).join(`-`)
blackmd.sendMessage(from, {document: {url: url}, fileName: finishname+'.zip', mimetype: 'application/zip' }, {quoted: info}).catch(e => {
console.log(e)
return reply(`Erro`)
})
break

case 'docfake':
if(!isVip && !isChatOfc) return reply("[ ‚ùó ] o uso desde recurso fora do chat oficial est√° restrito apenas aos usu√°rios VIP ‚ùå")
setTimeout(() => {reagir(from, "üìù")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
sp = `/`
docfake = [
  {formato: `pdf`, link: `application/pdf`},
  {formato: `xml`, link: `application/xml`},
  {formato: `zip`, link: `application/zip`},
  {formato: `js`, link: `application/javascript`},
  {formato: `json`, link: `application/json`},
  {formato: `jpg`, link: `image/jpeg`},
  {formato: `ppt`, link: `application/vnd.ms-powerpoint`},
  {formato: `pptx`, link: `application/vnd.openxmlformats-officedocument.presentationml.presentation`},
  {formato: `apk`, link: `application/vnd.android.package-archive`},
  {formato: `txt`, link: `text/plain`},
  {formato: `aac`, link: `audio/aac`},
  {formato: `m4a`, link: `audio/mp4`},
  {formato: `mp4`, link: `video/mp4`},
  {formato: `mp3`, link: `audio/mpeg`},
  {formato: `gif`, link: `image/gif`},
  {formato: `svg`, link: `image/svg+xml`},
  {formato: `png`, link: `image/png`}
]
if(contar(q, sp) != 2) return reply(`*Ops, vejo que voc√™ est√° usando o comando de forma errada... Voc√™ deve usar neste formato e exemplo ‚Ü¥*
*Formato:* ${prefix+command} nome${sp}tamanho${sp}formato

*Exemplo:* ${prefix+command} pack do p√©${sp}250${sp}zip

${`-`.repeat(40)}

${docfake.map(d => `‚Ä¢ ${d.formato}`).join(`\n`)}`)
barra = q.replace(sp+` `, sp).replace(` `+sp, sp).replace(` ${sp} `, sp)
var [nome, tamanho, tipo] = barra.split(sp)
AB = docfake.map(i => i.formato).indexOf(tipo.toLowerCase())
if(AB < 0) return reply(`O formato "${tipo}" n√£o existe no banco de dados...`)
if(Number(tamanho) < 0) return reply(`O tamanho precisa ser um n√∫mero maior que zero..`)
//======================\\
blackmd.sendMessage(from, {document: fs.readFileSync('./database/docf.txt'), mimetype: docfake[AB].link, fileName: nome+`.`+docfake[AB].formato, fileLength: Number(tamanho) * 1000000, headerType: 4, contextInfo: {forwardingScore: 999, isForwarded:true}}, {quoted: seloblk})
break;

case 'bc': case 'bcgroup': case 'transmitir': case 'transmiss√£o': {
if(!isOwner && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.dono)
if(!q) return reply( `Texto onde?\n\nExemplo : ${prefix + command} BOA VISTA `)
let getGroups = await blackmd.groupFetchAllParticipating()
let groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
let anu = groups.map(v => v.id)
for (i = 0; i < anu.length; i++) {
await sleep(1500)
let txt = `„Äå TRANSMISS√ÉO DO BOT „Äç\n\n ${q}`
blackmd.sendMessage(anu[i], {text: txt})
}
reply(`Enviando com sucesso `)
}
break



case 'join': case 'entrar': {
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply('Insira um link de convite ao lado do comando.')
if(!q.includes('chat.whatsapp.com/')) return reply('Ops, verifique o link que voc√™ inseriu.')
let { key } = await blackmd.sendMessage(from, {text: `*Pode deixar meu senhor, estou entrando no grupo...* ü´°`}, {quoted: info})
link = q.split('app.com/')[1]
await sleep(500)
try {
blackmd.groupAcceptInvite(`${link}`)
await sleep(500)
blackmd.sendMessage(from, {text: `*Entrei* ü•∞`, edit: key}, {quoted: info})
} catch(erro) {
console.log(erro)
if(JSON.stringify(erro).includes('resource-limit')) return blackmd.sendMessage(from, {text: `O grupo j√° est√° com o n√∫mero m√°ximo de membros... N√£o consigo entrar ü´†`, edit: key}, {quoted: info})
if(JSON.stringify(erro).includes('not-authorized')) return blackmd.sendMessage(from, {text: `N√£o foi poss√≠vel entrar no grupo pq algum admin me baniu... Pfvr, pe√ßa para o meu dono me adicionar (chame ${prefix}dono)`, edit: key}, {quoted: info})
blackmd.sendMessage(from, {text: `Erro, n√£o foi poss√≠vel entrar no grupo... Melhor adicionar manualmente.`, edit: key}, {quoted: info})
}}
break

case 'request':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
not = `*Use o comando com as 3 escolhas poss√≠veis abaixo:*
‚Ä¢ ${prefix+command} -lista
‚Ä¢ ${prefix+command} -aceitar
‚Ä¢ ${prefix+command} -recusar`
if(!q) return reply(not)
req = await blackmd.groupRequestParticipantsList(from)
if(req.length <= 0) return reply(`[‚ùó] n√£o h√° solicita√ß√µes no momento ‚ùå`)
if(args[0].toLowerCase() === "-lista") {
  caixa = []
  for(r = 0; r < req.length; r++) {
    i = req[r]
    lista = `¬ª${r + 1}¬´\nüë§ *Participante:* @${i.jid.split("@")[0]}\nüìº *N√∫mero:* ${addNumberMais(i.jid)}\nüé≤ *M√©todo:* `
    if(i.request_method == "linked_group_join") {
      comunidade = await blackmd.groupMetadata(i.parent_group_jid)
      lista += `\"solicita√ß√£o por comunidade\"\nüóÇ *Comunidade:* ${comunidade.subject}`
    } else if(i.request_method == "non_admin_add") { lista += `\"adicionado por membro\"\nü•ã *Membro Respons√°vel:* @${i.requestor.split("@")[0]}`
    } else lista += `\"link de convite\"`
    caixa.push(lista)
  }
  return mention(`üßÆ *Lista total ${req.length != 1 ? `dos ${req.length} participantes` : `do √∫nico participante`} na lista de espera deste grupo ‚Ü¥*\n${caixa.map(c => c).join(`\n-\n`)}`)
} else if(args[0].toLowerCase() === "-aceitar") {
  if(!args[1]) return reply(`KD o n√∫mero do usu√°rio na lista? Ex:\n${prefix+command} -aceitar 1`)
  if(args[1].toLowerCase() === "all") {
    total = req.length
    nmr = 0
    for(a of req) {
      await sleep(700)
      aceitar(from, a.jid)
      nmr += 1
    }
    if(nmr >= total) {
      await sleep(500)
      return mention(`${nmr != 1 ? `Todos os ${nmr} participantes da lista foram aceitos` : `O √∫nico participante da lista foi aceito`} pelo admin @${sender.split("@")[0]} com sucesso ‚úÖ`)
    }
  } else {
    if(Number(args[1]) < 1 || Number(args[1]) > req.length) return reply(enviar.msg.notusu)
    usu = req[Number(args[1]) - 1].jid
    aceitar(from, usu)
    return mention(`O participante @${usu.split("@")[0]} foi aceito pelo admin @${sender.split("@")[0]} com sucesso ‚úÖ`)
  }
} else if(args[0].toLowerCase() === "-recusar") {
  if(!args[1]) return reply(`KD o n√∫mero do usu√°rio na lista? Ex:\n${prefix+command} -recusar 1`)
  if(args[1].toLowerCase() === "all") {
    total = req.length
    nmr = 0
    for(r of req) {
      await sleep(700)
      recusar(from, r.jid)
      nmr += 1
    }
    if(nmr >= total) {
      await sleep(500)
      return mention(`${nmr != 1 ? `Todos os ${nmr} participantes da lista foram recusados` : `O √∫nico participante da lista foi recusado`} com sucesso pelo admin @${sender.split("@")[0]} ‚ô®`)
    }
  } else {
    if(Number(args[1]) < 1 || Number(args[1]) > req.length) return reply(enviar.msg.notusu)
    usu = req[Number(args[1]) - 1].jid
    recusar(from, usu)
    return mention(`O participante @${usu.split("@")[0]} foi recusado pelo admin @${sender.split("@")[0]} com sucesso ‚ô®`)
  }
} else return reply(not)
break

case 'attacc':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isAcceptGroup) {
dataGp[0].acceptGroup.active = true
setGp(dataGp)
reply(`üåÄ Ativou com sucesso o recurso de aceitar automaticamente o membro no grupo üìù`)
} else {
dataGp[0].acceptGroup.active = false
setGp(dataGp)
reply(`‚ÄºÔ∏è Desativou com sucesso o recurso de aceitar automaticamente o membro no grupo ‚úîÔ∏è`)
}
break

case 'setattacc':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isAcceptGroup) return reply(`√â necess√°rio ativar o recurso de auto aceita√ß√£o primeiro... Use ${prefix}attacc`)
nmr = Number(q.slice(0, q.length - 1))
letra = q.slice(q.length - 1, q.length).toLowerCase()
if(nmr <= 0) return reply(`O tempo precisa ser maior que 0... Ex: ${prefix+command} 10m`)
if(letra != "s" && letra != "m" && letra != "h") return reply(`Use apenas "s", "m" ou "h" para identificar o tempo, ex: ${prefix+command} 10m`)
if(letra == "s") multiplicador = 1
if(letra == "m") multiplicador = 60
if(letra == "h") multiplicador = 3600
nmr *= multiplicador
dataGp[0].acceptGroup.time = nmr
setGp(dataGp)
reply(`O cooldow de tempo para a aceita√ß√£o autom√°tica no grupo ${groupName} foi atualizado para ${q} com sucesso ‚úÖ`)
break

case 'antiimg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('Hmmmm')
if(Number(args[0]) === 1) {
if(isAntiImg) return reply('J√° Esta ativo')
dataGp[0].antiimg = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti imagem neste grupo‚úîÔ∏è')
} else if(Number(args[0]) === 0) {
if(!isAntiImg) return reply('Ja esta Desativado.')
dataGp[0].antiimg = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti imagem neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antivideo':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('Hmmmm')
if(Number(args[0]) === 1) {
if(isAntiVid) return reply('Ja esta ativo')
dataGp[0].antivideo = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti video neste grupo‚úîÔ∏è')
} else if(Number(args[0]) === 0) {
if(!isAntiVid) return reply('Ja esta Desativado')
dataGp[0].antivideo = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti video neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antiaudio':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('Hmmmm')
if(Number(args[0]) === 1) {
if(isAntiAudio) return reply('Ja esta ativo')
dataGp[0].antiaudio = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti audio neste grupo‚úîÔ∏è')
} else if(Number(args[0]) === 0) {
if(!isAntiAudio) return reply('Ja esta Desativado')  
dataGp[0].antiaudio = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti audio neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antisticker':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('Hmmmm')
if(Number(args[0]) === 1) {
if(isAntiSticker) return reply('J√° Esta ativo')
dataGp[0].antisticker = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti sticker neste grupo‚úîÔ∏è')
} else if(Number(args[0]) === 0) {
if(!isAntiSticker) return reply('Ja esta Desativado.')
dataGp[0].antisticker = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti sticker neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antidocumento':
case 'antidoc':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(Antidoc) return reply('Ja esta ativo')
dataGp[0].antidoc = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti documento neste grupo‚úîÔ∏è')
} else if(Number(args[0]) === 0) {
if(!Antidoc) return reply('Ja esta Desativado')
dataGp[0].antidoc = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de anti documento neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antictt':
case 'anticontato':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntiCtt) return reply('Ja esta ativo')
dataGp[0].antictt = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de anticontato neste grupo üìù')
} else if(Number(args[0]) === 0) {
if(!isAntiCtt) return reply('Ja esta Desativado')
dataGp[0].antictt = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de anticontato neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antiloc':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
try {														 
if(args.length < 1) return reply('1 pra ativar, 0 pra desligar')
if(Number(args[0]) === 1) {
if(Antiloc) return reply('J√° est√° Ativo.')
dataGp[0].antiloc = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti loc neste grupo‚úîÔ∏è')
} else if(Number(args[0]) === 0) {
if(!Antiloc) return reply('J√° est√° Desativado.')
dataGp[0].antiloc = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti loc neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
} catch {
reply('Deu erro, tente novamente :/')
}
break

case 'antiporno':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
try {														 
if(args.length < 1) return reply('1 pra ativar, 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntiPorno) return reply('J√° est√° Ativo.')
dataGp[0].antiporno = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti porno neste grupo‚úîÔ∏è')
} else if(Number(args[0]) === 0) {
if(!isAntiPorno) return reply('J√° est√° Desativado.')
dataGp[0].antiporno = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti porno neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
} catch {
reply('Deu erro, tente novamente :/')
}
break

case 'addshieldgp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(contar(q, '/') != 1) return reply(`> ${prefix+command} @pessoa/quantidade
_(essa "quantidade" remete a quantos links o usu√°rio pode mandar antes de ser banido)_`)
barra = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/")
var [marc, mxm] = barra.split('/')
usu = identArroba(marc)
if(isShieldGPuser(from, usu)) return reply(enviar.shield.gp.true)
addShieldGP(from, usu, mxm)
mention(`Usu√°rio @${usu.split('@')[0]} est√° imune do ban ao enviar links de grupo...`)
break

case 'addshieldhard':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(contar(q, '/') != 1) return reply(`> ${prefix+command} @pessoa/quantidade
_(essa "quantidade" remete a quantos links o usu√°rio pode mandar antes de ser banido)_`)
barra = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/")
var [marc, mxm] = barra.split('/')
usu = identArroba(marc)
if(isShieldGPuser(from, usu)) return reply(enviar.shield.hard.true)
addShieldHARD(from, usu, mxm)
mention(`Usu√°rio @${usu.split('@')[0]} est√° imune do ban ao enviar links em geral...`)
break

case 'rmshieldgp': case 'rmshieldhard':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!marc_tds) return reply(`Marque o usu√°rio, a mensagem ou o @, de quem voc√™ quer retirar a prote√ß√£o do anti link ${command == "rmshieldgp" ? `GP` : `HARD`}...`)
if(command == "rmshieldgp" && !isShieldGPuser(from, marc_tds)) return reply(enviar.shield.gp.false)
if(command == "rmshieldhard" && !isShieldHARDuser(from, marc_tds)) return reply(enviar.shield.hard.false)
rm = command == "rmshieldgp" ? rmShieldGP : rmShieldHARD
rm(from, marc_tds)
reply("Escudo do usu√°rio removido com sucesso...")
break

case 'shieldgplist':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!JSON.stringify(shieldantilinkgp).includes(from)) {
shieldantilinkgp.push({groupId: from, usus: []})
fs.writeFileSync("./basededados/shieldantilinkgp.json", JSON.stringify(shieldantilinkgp))
}
AB = shieldantilinkgp.map(i => i.groupId).indexOf(from)
txt = `[ ‚ùó ] *Lista de usu√°rios imunes ao ban por link de grupo:*\n`
for(i of shieldantilinkgp[AB].usus) {
  txt += `\n@${i.id.split('@')[0]}`
}
txt += `\n-> *Total:* ${shieldantilinkgp[AB].usus.length}`
mention(txt)
break

case 'shieldhardlist':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!JSON.stringify(shieldantilinkhard).includes(from)) {
shieldantilinkhard.push({groupId: from, usus: []})
fs.writeFileSync("./basededados/shieldantilinkhard.json", JSON.stringify(shieldantilinkhard))
}
AB = shieldantilinkhard.map(i => i.groupId).indexOf(from)
txt = `[ ‚ùó ] *lista de usu√°rios imunes ao ban por link em geral:*\n`
for(i of shieldantilinkhard[AB].usus) {
  txt += `\n@${i.id.split('@')[0]}`
}
txt += `\n-> *Total:* ${shieldantilinkhard[AB].usus.length}`
mention(txt)
break

case 'antilinkgp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntilinkgp) return reply('Ja esta ativo')
dataGp[0].antilinkgp = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de antilinkgp üìù')
} else if(Number(args[0]) === 0) {
if(!isAntilinkgp) return reply('Ja esta Desativado')
dataGp[0].antilinkgp = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de antilink de grupo ‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'banlinkgp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isBanlinkgp) return reply('Ja esta ativo')
dataGp[0].banlinkgp = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de banir & apagar os links de grupo üìù')
} else if(Number(args[0]) === 0) {
if(!isBanlinkgp) return reply('Ja esta Desativado')
dataGp[0].banlinkgp = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de banir o usu√°rio... Irei s√≥ apagar o link ‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antilinkhard':
case 'antilink':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntiLinkHard) return reply('Ja esta ativo')
dataGp[0].antilinkhard = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de antilink hardcore neste grupo üìù')
} else if(Number(args[0]) === 0) {
if(!isAntiLinkHard) return reply('Ja esta Desativado')
dataGp[0].antilinkhard = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de antilink harcore neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'banlinkhard':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isBanLinkHard) return reply('Ja esta ativo')
dataGp[0].banlinkhard = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de banir & apagar os links üìù')
} else if(Number(args[0]) === 0) {
if(!isBanLinkHard) return reply('Ja esta Desativado')
dataGp[0].banlinkhard = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de banir o usu√°rio... Irei s√≥ apagar o link ‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'x9':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isx9) return reply('Ja esta ativo')
dataGp[0].x9 = true
setGp(dataGp)
reply('üåÄ Ativou o recurso de x9 com sucesso... Irei notificar qualquer altera√ß√£o dispon√≠vel feita neste grupo üòè..')
} else if(Number(args[0]) === 0) {
if(!isx9) return reply('Ja esta Desativado')
dataGp[0].x9 = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de x9 neste grupo, n√£o irei notificar mais nenhuma altera√ß√£o..‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'visualizarmsg':
if(!isOwner) return reply(enviar.msg.dono)
if(!isVisualizar) {
obrigadoEXT.visualizarmsg = true
setObg(obrigadoEXT)
reply('üåÄ Ativou com sucesso o recurso de visualizar todas as mensagens enviada em grupos e privado üìù')
} else if(isVisualizar) {
obrigadoEXT.visualizarmsg = false
setObg(obrigadoEXT)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de visualizar todas as mensagens enviada em grupos e privado‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

/*case 'antispam':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntiSpam) return reply('Ja esta ativo')
dataGp[0].antispam = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de ANTI SPAM neste grupo üìù')
} else if(Number(args[0]) === 0) {
if(!isAntiSpam) return reply('Ja esta Desativado')
dataGp[0].antispam = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de ANTI SPAM neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break*/

case 'antivisu': case 'antivisuunica':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntiVisuUnica) return reply('Ja esta ativo')
dataGp[0].visuUnica = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de revelar visu √∫nica neste grupo üìù')
} else if(Number(args[0]) === 0) {
if(!isAntiVisuUnica) return reply('Ja esta Desativado')
dataGp[0].visuUnica = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de revelar visu √∫nica neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'admcmd':
case 'antimembros':
case 'blockgp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntiMembros) return reply('Ja esta ativo')
dataGp[0].soadm = true
setGp(dataGp)
reply('‚úÖ Ativou com sucesso o recurso de s√≥ adm utilizar comandos neste grupo üìù')
} else if(Number(args[0]) === 0) {
if(!isAntiMembros) return reply('Ja esta Desativado')
dataGp[0].soadm = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou o recurso de S√≥ ADM utilizar comandos neste grupo ‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antifake':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntifake) return reply('Ja esta ativo')
dataGp[0].antifake = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de antifake neste grupo üìù')
} else if(Number(args[0]) === 0) {
if(!isAntifake) return reply('Ja esta Desativado')
dataGp[0].antifake = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de antifake neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'prefixos':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if(!isMultiP) return reply(`Para usar este comando, voc√™ deve ativar o comando, multiprefix\nExemplo: ${prefix}multiprefixo 1`)
if(dataGp[0].prefixos.length < 1) return reply("N√£o contem nenhum prefixo a + adicionado neste grupo.")
bla = `üíå *Ol√° @${sender.split("@")[0]}, os prefixos dispon√≠veis s√£o:*${dataGp[0].prefixos.map(i => `„Äé ${i} „Äè`).join("<->")}`
mention(bla)
break

case 'addprefixo':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if(!isMultiP) return reply(`Para usar este comando, voc√™ deve ativar o comando, multiprefix\nExemplo: ${prefix}multiprefixo 1`)
if(antiModLetra(q)) return reply("N√£o pode letra modificada, nem emoji..")
if(!q.trim()) return reply("Determine o novo prefixo, n√£o pode espa√ßo vazio...")
if(q.trim() > 1) return reply("N√£o pode adc mais de um prefixo de uma s√≥ vez...")
if(dataGp[0].prefixos.indexOf(q.trim()) >= 0) return reply(`Esse prefixo j√° se encontra incluso, procure ver na lista dos prefixos\nExemplo: ${prefix}prefixos`)
dataGp[0].prefixos.push(q.trim())
setGp(dataGp)
reply(`Prefixo [ ${q.trim()} ] adicionado com sucesso...`)
break

case 'tirarprefixo':
case 'delprefix':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if(!isMultiP) return reply(`Para usar este comando, voc√™ deve ativar o comando, multiprefix\nExemplo: ${prefix}multiprefixo 1`)  
if(antiModLetra(q)) return reply("N√£o pode letra modificada, nem emoji..")
if(!q.trim()) return reply("Determine o prefixo que deseja tirar, n√£o pode espa√ßo vazio...")
if(q.trim() > 1) return reply("N√£o pode remover mais de um prefixo de uma s√≥ vez...")
if(dataGp[0].prefixos.indexOf(q.trim()) < 0) return reply(`Esse prefixo n√£o est√° incluso, procure ver na lista dos prefixos\nExemplo: ${prefix}prefixos`)
if(dataGp[0].prefixos.length == 1) return reply("Adicione um prefixo para pode tirar este, tem que ter pelo menos 1 prefixo j√° incluso dentro do sistema para tirar outro.")
dataGp[0].prefixos.splice(dataGp[0].prefixos.indexOf(q.trim()), 1)
setGp(dataGp)
reply(`Prefixo [ ${q.trim()} ] removido com sucesso...`)
break

case 'infomultiprefixo': case 'infomultiprefix':
if(!isOwner) return reply(enviar.msg.dono)
mention(`${tempo} @${sender.split("@")[0]}, irei te dar uma aula b√°sica de como usar o multiprefixo:

${prefix}addprefixo
(Use este comando para adicionar mais prefixos neste grupo)

${prefix}tirarprefixo
(Use este comando para remover um dos prefixos neste grupo)

${prefix}prefixos
(Este comando ir√° mostrar todos os prefixos dispon√≠veis neste grupo)

${prefix}multiprefixo
(E o b√°sico de todos, este ir√° ativar/desativar o sistema de multiprefixo)`)
break

case 'multiprefixo': case 'multiprefix':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if(!isMultiP) {
dataGp[0].multiprefix = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de multi prefixos neste grupo üìù')
}
if(isMultiP) {
dataGp[0].multiprefix = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de multi prefixos neste grupo‚úîÔ∏è')
}
break

case 'antinotas':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('Hmmmm')
if(Number(args[0]) === 1) {
if(isAntiNotas) return reply('J√° Esta ativo')
dataGp[0].antinotas = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti notas neste grupo‚úîÔ∏è')
} else if(Number(args[0]) === 0) {
if(!isAntiNotas) return reply('Ja esta Desativado.')
dataGp[0].antinotas = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti notas neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'anticatalogo':
case 'anticatalg':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAnticatalogo) return reply('Ja esta ativo')
dataGp[0].anticatalogo = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de anticatalogo neste grupo üìù')
} else if(Number(args[0]) === 0) {
if(!isAnticatalogo) return reply('Ja esta Desativado')
dataGp[0].anticatalogo = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de anticatalogo neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'bemvindo':
case 'welcome':
setTimeout(() => {reagir(from, "ü´°")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply(`${prefix+command} 1 | ${prefix+command} 0`)
if(Number(args[0]) === 1) {
if(isWelkom) return reply('Ja esta ativo')
dataGp[0].wellcome[0].bemvindo1 = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de bem vindo neste grupo üìù')
} else if(Number(args[0]) === 0) {
if(!isWelkom) return reply('Ja esta Desativado')
dataGp[0].wellcome[0].bemvindo1 = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de bemvindo neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'bemvindo2':
case 'welcome2':
setTimeout(() => {reagir(from, "ü´°")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply(`${prefix+command} 1 | ${prefix+command} 0`)
if(Number(args[0]) === 1) {
if(isWelkom2) return reply('‚úÖ O recurso j√° est√° ativado no grupo ‚úÖ')
dataGp[0].wellcome[1].bemvindo2 = true
setGp(dataGp)
reply('‚úÖO recurso foi ativado‚úÖ')
} else if(Number(args[0]) === 0) {
if(!isWelkom2) return reply('‚ùå O recurso n√£o est√° ativado no grupo ‚ùå')
dataGp[0].wellcome[1].bemvindo2 = false
setGp(dataGp)
reply('‚ùåO recurso foi desativado‚ùå')
} else {
reply(`Digite da forma correta:\nComando: ${prefix + command} 1, para ativar e 0 para desativar`)
}
break

case 'bemvindo3':
case 'welcome3':
setTimeout(() => {reagir(from, "ü´°")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply(`${prefix+command} 1 | ${prefix+command} 0`)
if(Number(args[0]) === 1) {
if(isWelkom3) return reply('‚úÖ O recurso j√° est√° ativado no grupo ‚úÖ')
dataGp[0].wellcome[2].bemvindo3 = true
setGp(dataGp)
reply('‚úÖO recurso foi ativado‚úÖ')
} else if(Number(args[0]) === 0) {
if(!isWelkom3) return reply('‚ùå O recurso n√£o est√° ativado no grupo ‚ùå')
dataGp[0].wellcome[2].bemvindo3 = false
setGp(dataGp)
reply('‚ùåO recurso foi desativado‚ùå')
} else {
reply(`Digite da forma correta:\nComando: ${prefix + command} 1, para ativar e 0 para desativar`)
}
break

case 'bemvindo4':
case 'welcome4':
setTimeout(() => {reagir(from, "ü´°")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply(`${prefix+command} 1 | ${prefix+command} 0`)
if(Number(args[0]) === 1) {
if(isWelkom4) return reply('‚úÖ O recurso j√° est√° ativado no grupo ‚úÖ')
dataGp[0].wellcome[3].bemvindo4 = true
setGp(dataGp)
reply('‚úÖO recurso foi ativado‚úÖ')
} else if(Number(args[0]) === 0) {
if(!isWelkom4) return reply('‚ùå O recurso n√£o est√° ativado no grupo ‚ùå')
dataGp[0].wellcome[3].bemvindo4 = false
setGp(dataGp)
reply('‚ùåO recurso foi desativado‚ùå')
} else {
reply(`Digite da forma correta:\nComando: ${prefix + command} 1, para ativar e 0 para desativar`)
}
break

case 'bemvindo5':
case 'welcome5':
setTimeout(() => {reagir(from, "ü´°")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply(`${prefix+command} 1 | ${prefix+command} 0`)
if(Number(args[0]) === 1) {
if(isWelkom5) return reply('‚úÖ O recurso j√° est√° ativado no grupo ‚úÖ')
dataGp[0].wellcome[4].bemvindo5 = true
setGp(dataGp)
reply('‚úÖO recurso foi ativado‚úÖ')
} else if(Number(args[0]) === 0) {
if(!isWelkom5) return reply('‚ùå O recurso n√£o est√° ativado no grupo ‚ùå')
dataGp[0].wellcome[4].bemvindo5 = false
setGp(dataGp)
reply('‚ùåO recurso foi desativado‚ùå')
} else {
reply(`Digite da forma correta:\nComando: ${prefix + command} 1, para ativar e 0 para desativar`)
}
break

case 'legendabv':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de boas-vindas*')
teks = body.slice(11)
if(isWelkom) {
dataGp[0].wellcome[0].legendabv = Number(teks) === 0 ? 0 : teks
setGp(dataGp)
reply(`*Mensagem de boas vindas ${Number(teks) !== 0 ? `definida` : `desativada`} com sucesso!*`)
} else {
reply(`Ative o ${prefix}bemvindo 1`)
}
break

case 'legendasaiu':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de sa√≠da*')
teks = body.slice(13)
if(isWelkom) {
dataGp[0].wellcome[0].legendasaiu = Number(teks) === 0 ? 0 : teks
setGp(dataGp)
reply(`*Mensagem de sa√≠da ${Number(teks) !== 0 ? `definida` : `desativada`} com sucesso!*`)
} else {
reply(`Ative o ${prefix}bemvindo 1`)
}
break

case 'legendabv2':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de boas-vindas*')
teks = body.slice(12)
if(isWelkom2) {
dataGp[0].wellcome[1].legendabv = Number(teks) === 0 ? 0 : teks
setGp(dataGp)
reply(`*Mensagem de boas vindas2 ${Number(teks) !== 0 ? `definida` : `desativada`} com sucesso!*`)
} else {
reply(`Ative o ${prefix}bemvindo2 1`)
}
break

case 'legendasaiu2':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de sa√≠da*')
teks = body.slice(14)
if(isWelkom2) {
dataGp[0].wellcome[1].legendasaiu = Number(teks) === 0 ? 0 : teks
setGp(dataGp)
reply(`*Mensagem de sa√≠da2 ${Number(teks) !== 0 ? `definida` : `desativada`} com sucesso!*`)
} else {
reply(`Ative o ${prefix}bemvindo2 1`)
}
break

case 'stickerbv':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isWelkom3) return reply(`Ative o ${prefix}bemvindo3 1`)
fig = `./basededados/grupos/figurinhas/sticker-bv-${from}.webp`
if(Number(args[0]) === 0 && fs.existsSync(fig)) {DLT_FL(fig)
dataGp[0].wellcome[2].selobv = false
setGp(dataGp)
return reply(`A figurinha do bem vindo foi deletada com sucesso ‚úî`)}
if(!isQuotedSticker) return reply(`Marque uma figurinha...`)
sticker = info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage
media = await getFileBuffer(sticker, `sticker`)
fs.writeFileSync(fig, media)
if(q) {dataGp[0].wellcome[2].selobv = true
dataGp[0].wellcome[2].legendabv = q
setGp(dataGp)}
reply(`A figurinha do bem vindo foi definida com sucesso ‚úÖ`)
break

case 'stickersaiu':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isWelkom3) return reply(`Ative o ${prefix}bemvindo3 1`)
fig = `./basededados/grupos/figurinhas/sticker-saiu-${from}.webp`
if(Number(args[0]) === 0 && fs.existsSync(fig)) {DLT_FL(fig)
dataGp[0].wellcome[2].selosaiu = false
setGp(dataGp)
return reply(`A figurinha de sa√≠da foi deletada com sucesso ‚úî`)}
if(!isQuotedSticker) return reply(`Marque uma figurinha...`)
sticker = info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage
media = await getFileBuffer(sticker, `sticker`)
fs.writeFileSync(fig, media)
if(q) {dataGp[0].wellcome[2].selosaiu = true
dataGp[0].wellcome[2].legendasaiu = q
setGp(dataGp)}
reply(`A figurinha de sa√≠da foi definida com sucesso ‚úÖ`)
break

case 'audiobv':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isWelkom4) return reply(`Ative o ${prefix}bemvindo4 1`)
mp3 = `./basededados/grupos/audios/audio-bv-${from}.mp3`
if(Number(args[0]) === 0 && fs.existsSync(mp3)) {DLT_FL(mp3)
dataGp[0].wellcome[3].selobv = false
setGp(dataGp)
return reply(`O √°udio do bem vindo foi deletado com sucesso ‚úî`)}
if(!isQuotedAudio) return reply(`Marque um √°udio...`)
audio = info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage
media = await getFileBuffer(audio, 'audio')
fs.writeFileSync(mp3, media)
if(q) {dataGp[0].wellcome[3].selobv = true
dataGp[0].wellcome[3].legendabv = q
setGp(dataGp)}
reply(`O √°udio do bem vindo foi definido com sucesso ‚úÖ`)
break

case 'audiosaiu':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isWelkom4) return reply(`Ative o ${prefix}bemvindo4 1`)
mp3 = `./basededados/grupos/audios/audio-saiu-${from}.mp3`
if(Number(args[0]) === 0 && fs.existsSync(mp3)) {DLT_FL(mp3)
dataGp[0].wellcome[3].selosaiu = false
setGp(dataGp)
return reply(`O √°udio de sa√≠da foi deletado com sucesso ‚úî`)}
if(!isQuotedAudio) return reply(`Marque um √°udio...`)
audio = info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage
media = await getFileBuffer(audio, 'audio')
fs.writeFileSync(mp3, media)
if(q) {dataGp[0].wellcome[3].selosaiu = true
dataGp[0].wellcome[3].legendabv = q
setGp(dataGp)}
reply(`O √°udio de sa√≠da foi definido com sucesso ‚úÖ`)
break

case 'legendabv5':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de boas-vindas*')
teks = q
if(isWelkom) {
dataGp[0].wellcome[4].legendabv = Number(teks) === 0 ? 0 : teks
setGp(dataGp)
reply(`*Mensagem de boas vindas ${Number(teks) !== 0 ? `definida` : `desativada`} com sucesso!*`)
} else {
reply(`Ative o ${prefix}bemvindo5 1`)
}
break

case 'legendasaiu5':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de sa√≠da*')
teks = q
if(isWelkom) {
dataGp[0].wellcome[4].legendasaiu = Number(teks) === 0 ? 0 : teks
setGp(dataGp)
reply(`*Mensagem de sa√≠da ${Number(teks) !== 0 ? `definida` : `desativada`} com sucesso!*`)
} else {
reply(`Ative o ${prefix}bemvindo5 1`)
}
break

case 'legenda-estrangeiro':
case 'legenda-estrangeiros': 
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de remo√ß√£o de estrangeiros*')
if(isAntifake) {
dataGp[0].legenda_estrangeiro = q
setGp(dataGp)
reply('*Mensagem de remo√ß√£o de estrangeiros definida com sucesso!*')
} else {
reply(`Ative o antifake primeiro com ${prefix}antifake 1`)
}
break

case 'legenda-video': 
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de remo√ß√£o de estrangeiros*')
dataGp[0].legenda_video = q
setGp(dataGp)
reply('*Mensagem de remo√ß√£o de video definida com sucesso!*')
break

case 'legenda-imagem': 
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de remo√ß√£o de estrangeiros*')
dataGp[0].legenda_imagem = q
setGp(dataGp)
reply('*Mensagem de remo√ß√£o de imagem definida com sucesso!*')
break

case 'legenda-documento': 
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de remo√ß√£o de estrangeiros*')
dataGp[0].legenda_documento = q
setGp(dataGp)
reply('*Mensagem de remo√ß√£o de Documento definida com sucesso!*')
break

case 'addautorm':
case 'addautoban':
case 'listanegra':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!mrc_ou_numero) return reply("Marque a mensagem do usu√°rio com o comando ou utilize o comando com o n√∫mero do usu√°rio que deseja adicionar na lista negra..")
if(dataGp[0].listanegra.includes(mrc_ou_numero)) return reply('*Esse N√∫mero ja esta incluso*')
dataGp[0].listanegra.push(mrc_ou_numero)
setGp(dataGp)
reply(`*N√∫mero adicionado a lista de autoban* üôÖüèª‚Äç‚ôÇÔ∏è`)
break

case 'autobang':
case 'listanegrag':
if(!isOwner) return reply(enviar.msg.dono)
if(!mrc_ou_numero) return reply("Marque a mensagem do usu√°rio com o comando ou utilize o comando com o n√∫mero do usu√°rio que deseja adicionar na lista negra Global..")
if(listanegraG.includes(mrc_ou_numero)) return reply('*Esse N√∫mero ja esta incluso*')
listanegraG.push(mrc_ou_numero)
fs.writeFileSync('./dono/config-all.json', JSON.stringify(obrigadoEXT, null, '\t'))
reply(`*N√∫mero adicionado a lista de autoban*`)
break

case 'delautobang':
case 'tirardalistag':
if(!isOwner) return reply(enviar.msg.dono)
if(!mrc_ou_numero) return reply("Marque a mensagem do usu√°rio com o comando ou utilize o comando com o n√∫mero do usu√°rio que deseja tirar da lista negra..")
if(!listanegraG.includes(mrc_ou_numero)) return reply('*Esse N√∫mero n√£o esta incluso*')
var i = listanegraG.indexOf(mrc_ou_numero)
listanegraG.splice(i, 1)
fs.writeFileSync('./dono/config-all.json', JSON.stringify(obrigadoEXT, null, '\t'))
reply(`*N√∫mero foi removido da lista negra*`)
break

case 'admautoban':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply('Precisa ser Dono')
if(!q.includes(`chat.whatsapp.com`)) return reply(`Insira o link do grupo...`)
var linkRegex = /chat.whatsapp.com\/([0-9A-Za-z]{20,24})/i
    var [_, code] = q.match(linkRegex) || []
    if (!code)return reply('Link Invalido')
    var res = await blackmd.groupAcceptInvite(code)
reply("espere um momento")
resp = await blackmd.groupMetadata(res)
ggg = resp.participants.filter((i) => i.admin)
nunber = ``
for(number of ggg){
await delay(1000)
dataGp[0].listanegra.push(number.id)
setGp(dataGp)
nunber += `# ${number.id.match(/([0-9A-Za-z]{10,14})/i)[0]}\n`
}
reply(`*N√∫meros Adicionados A Lista De Autoban*
*${ggg.length} Pessoas Adicionadas A Lista De Autoban*
${nunber}`)
await delay(1000)
blackmd.groupLeave(resp.id)
break

case 'delremover':
case 'delautorm':  
case 'delautoban': 
case 'tirardalista':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!mrc_ou_numero) return reply("Marque a mensagem do usu√°rio com o comando ou utilize o comando com o n√∫mero do usu√°rio que deseja tirar da lista negra..")
if(!dataGp[0].listanegra.includes(mrc_ou_numero)) return reply('*Esse N√∫mero n√£o esta incluso*')
var i = dataGp[0].listanegra.indexOf(mrc_ou_numero)
dataGp[0].listanegra.splice(i, 1)
setGp(dataGp)
reply(`*N√∫mero foi removido da lista de autoban*`)
break

case 'listban':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(dataGp[0].listanegra.length < 1) return reply('*Nenhum N√∫mero n√£o foi adicionado*')
teks = '*N√∫meros que vou moer na porrada se voltar üò°:*\n'
for(i=0;i<dataGp[0].listanegra.length;++i) {
teks += `‚áí *${dataGp[0].listanegra[i].split('@')[0]}*\n`
}
teks += '*Esses ai vou descer meu martelo do ban ü•µ*'
reply(teks)
break

case 'savemp3': case 'savem4a':
if(!isOwner) return reply(enviar.msg.dono)
var [tx, rct] = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/").split("/")
if(!tx) return reply("KD o t√≠tulo do √°udio?")
if(antiModLetra(tx)) return reply("N√£o pode letras modificadas nem emoji..")
if(!isQuotedAudio) return reply("Marque um √°udio por favor...")
mod = rmLetras(tx)
ini = mod.split(" ").join("_")
media = info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage
fim = media.mimetype.split("/")[1] == "mpeg" ? "mp3" : media.mimetype.split("/")[1] == "mp4" ? "m4a" : "ogg"
nome = ini+"."+fim
doc = await getFileBuffer(media, 'audio')
fs.writeFileSync(`./database/audios/save/${nome}`, doc)
AB = audios.map(i => i.rm).indexOf(nome)
if(AB >= 0) {
  audios.splice(AB, 1)
  saveJSON(audios, "./database/data/audios.json")
}
audios.push({txt: mod, rm: nome, emoji: rct || ""})
saveJSON(audios, "./database/data/audios.json")
reply(`*O √°udio ${nome} foi salvo na pasta com sucesso...* ‚úÖ`)
break

case 'delmp3': case 'delm4a':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply("KD o t√≠tulo do √°udio?")
if(antiModLetra(q)) return reply("N√£o pode letras modificadas nem emoji..")
mod = rmLetras(q)
ini = mod.split(" ").join("_")
exec(`ls ./database/audios/save`, (err, stdout) => {
  if(err) {
    console.log(err)
  }
  if(stdout) {
    nmr = -1
    caixa = []
    for(i of audios) {
      nmr += 1
      if(ini == i.rm.split(`.`)[0]) caixa.push(nmr)
    }
    if(caixa.length <= 0) return reply(`[‚ùó] √°udio n√£o encontrado ou inexistente ‚ùå`)
    AB = caixa[0]
    nome = audios[AB].rm
    DLT_FL(`./database/audios/save/${nome}`)
    audios.splice(AB, 1)
    saveJSON(audios, "./database/data/audios.json")
    reply(`*O √°udio ${nome} foi deletado da pasta com sucesso...* ‚úÖ`)
  }
})
break

case 'listmp3': case 'listm4a':
if(!isOwner) return reply(enviar.msg.dono)
if(audios.length <= 0) return reply("N√£o h√° √°udios salvos na pasta")
txt = `üéß *Total:* ${audios.length}`
for(i = 0; i < audios.length; i++) {
txt += `\n${audios[i].emoji.length > 0 ? audios[i].emoji : react1[Math.floor(Math.random()*react1.length)]}‚É§ ¬ª${i+1}¬´ ${audios[i].rm}`
}
reply(txt)
break

case 'botversion':
botv = JSON.parse(fs.readFileSync(`./package.json`)).version
sendRouletteButton(from, {image: {url: logoslink.logo}, caption: `üé≤ Vers√£o atual do bot - ${botv}`, footer: `New Black V4 Oficial Update`}, blackmd, sender, [{type: `copy_url`, text: NomeDoBot, url: `https://github.com/m4thxyz/blackofc`}], seloctt)
break


// INTELIG√äNCIA ARTIFICIAL // IAS

case 'deepimage':
  if (!q) return reply(`Envie o texto para gerar a imagem.\nExemplo: *${prefix}deepimage gato fofo*`);

  if (!global.deepPrompt) global.deepPrompt = {};

  // Se o usu√°rio ainda n√£o escolheu o modelo, salva o prompt
  if (!global.deepPrompt[sender]) {
    global.deepPrompt[sender] = q.trim();
    
    // Lista de modelos dispon√≠veis
    const modelosDeep = [
  { name: `‚ú® Cute Creature`, title: `Criatura Fofa`, body: 'Gera criaturas fofas', command: `${prefix}deepimage cute-creature-generator` },
  { name: `‚ú® Fantasy World`, title: `Mundo Fant√°stico`, body: 'Gera mundos de fantasia', command: `${prefix}deepimage fantasy-world-generator` },
  { name: `‚ú® Cyberpunk`, title: `Cen√°rio Cyberpunk`, body: 'Gera cen√°rios futuristas cyberpunk', command: `${prefix}deepimage cyberpunk-generator` },
  { name: `‚ú® Anime Portrait`, title: `Retrato Anime`, body: 'Gera retratos estilo anime', command: `${prefix}deepimage anime-portrait-generator` },
  { name: `‚ú® Old Style`, title: `Estilo Antigo`, body: 'Gera arte em estilo antigo', command: `${prefix}deepimage old-style-generator` },
  { name: `‚ú® Renaissance Painting`, title: `Pintura Renascentista`, body: 'Gera imagens no estilo renascentista', command: `${prefix}deepimage renaissance-painting-generator` },
  { name: `‚ú® Abstract Painting`, title: `Pintura Abstrata`, body: 'Gera arte abstrata', command: `${prefix}deepimage abstract-painting-generator` },
  { name: `‚ú® Impressionism Painting`, title: `Pintura Impressionista`, body: 'Gera imagens impressionistas', command: `${prefix}deepimage impressionism-painting-generator` },
  { name: `‚ú® Surreal Graphics`, title: `Gr√°ficos Surreais`, body: 'Gera imagens surreais', command: `${prefix}deepimage surreal-graphics-generator` },
  { name: `‚ú® 3D Objects`, title: `Objetos 3D`, body: 'Gera objetos em 3D', command: `${prefix}deepimage 3d-objects-generator` },
  { name: `‚ú® Origami 3D`, title: `Origami 3D`, body: 'Gera imagens de origamis em 3D', command: `${prefix}deepimage origami-3d-generator` },
  { name: `‚ú® Hologram 3D`, title: `Holograma 3D`, body: 'Gera hologramas 3D', command: `${prefix}deepimage hologram-3d-generator` },
  { name: `‚ú® 3D Character`, title: `Personagem 3D`, body: 'Gera personagens 3D', command: `${prefix}deepimage 3d-character-generator` },
  { name: `‚ú® Watercolor Painting`, title: `Pintura em Aquarela`, body: 'Gera aquarelas', command: `${prefix}deepimage watercolor-painting-generator` },
  { name: `‚ú® Pop Art`, title: `Pop Art`, body: 'Gera arte pop', command: `${prefix}deepimage pop-art-generator` },
  { name: `‚ú® Contemporary Architecture`, title: `Arquitetura Contempor√¢nea`, body: 'Gera arquitetura moderna', command: `${prefix}deepimage contemporary-architecture-generator` },
  { name: `‚ú® Future Architecture`, title: `Arquitetura Futurista`, body: 'Gera arquitetura do futuro', command: `${prefix}deepimage future-architecture-generator` },
  { name: `‚ú® Watercolor Architecture`, title: `Arquitetura em Aquarela`, body: 'Gera pr√©dios em aquarela', command: `${prefix}deepimage watercolor-architecture-generator` },
  { name: `‚ú® Fantasy Character`, title: `Personagem Fant√°stico`, body: 'Gera personagens de fantasia', command: `${prefix}deepimage fantasy-character-generator` },
  { name: `‚ú® Steampunk`, title: `Estilo Steampunk`, body: 'Gera imagens steampunk', command: `${prefix}deepimage steampunk-generator` },
  { name: `‚ú® Logo`, title: `Logo Criativo`, body: 'Gera logos autom√°ticos', command: `${prefix}deepimage logo-generator` },
  { name: `‚ú® Pixel Art`, title: `Arte em Pixel`, body: 'Gera pixel arts', command: `${prefix}deepimage pixel-art-generator` },
  { name: `‚ú® Street Art`, title: `Arte de Rua`, body: 'Gera grafites de rua', command: `${prefix}deepimage street-art-generator` },
  { name: `‚ú® Surreal Portrait`, title: `Retrato Surreal`, body: 'Gera retratos surreais', command: `${prefix}deepimage surreal-portrait-generator` },
  { name: `‚ú® Anime World`, title: `Mundo Anime`, body: 'Gera cen√°rios estilo anime', command: `${prefix}deepimage anime-world-generator` },
  { name: `‚ú® Fantasy Portrait`, title: `Retrato Fant√°stico`, body: 'Gera retratos de fantasia', command: `${prefix}deepimage fantasy-portrait-generator` },
  { name: `‚ú® Comics Portrait`, title: `Retrato em HQ`, body: 'Gera retratos estilo quadrinhos', command: `${prefix}deepimage comics-portrait-generator` },
  { name: `‚ú® Cyberpunk Portrait`, title: `Retrato Cyberpunk`, body: 'Gera retratos futuristas', command: `${prefix}deepimage cyberpunk-portrait-generator` },
  { name: `‚ú® Neo-Noir`, title: `Neo Noir`, body: 'Gera arte no estilo Neo Noir', command: `${prefix}deepimage neo-noir-generator` },
  { name: `‚ú® Pixel World`, title: `Mundo Pixelado`, body: 'Gera mundos em pixel', command: `${prefix}deepimage pixel-world-generator` },
  { name: `‚ú® Manga Panel`, title: `Painel de Mang√°`, body: 'Gera pain√©is de mang√°s', command: `${prefix}deepimage manga-panel-genarator` },
  { name: `‚ú® 3D Cartoon`, title: `Cartoon 3D`, body: 'Gera cartoons em 3D', command: `${prefix}deepimage 3d-cartoon-generator` },
  { name: `‚ú® Fantasy Map`, title: `Mapa Fant√°stico`, body: 'Gera mapas de fantasia', command: `${prefix}deepimage fantasy-map-generator` },
  { name: `‚ú® Cyber Beast`, title: `Bestas Cibern√©ticas`, body: 'Gera feras futuristas', command: `${prefix}deepimage cyber-beast-generator` },
  { name: `‚ú® Dystopian Landscape`, title: `Paisagem Dist√≥pica`, body: 'Gera mundos dist√≥picos', command: `${prefix}deepimage dystopian-landscape-generator` },
  { name: `‚ú® Ocean Life`, title: `Vida Marinha`, body: 'Gera cenas submarinas', command: `${prefix}deepimage ocean-life-generator` },
  { name: `‚ú® Space World`, title: `Mundo Espacial`, body: 'Gera cen√°rios espaciais', command: `${prefix}deepimage space-world-generator` },
  { name: `‚ú® Comics Superhero`, title: `Her√≥i de HQ`, body: 'Gera super-her√≥is', command: `${prefix}deepimage comics-superhero-generator` },
  { name: `‚ú® Anime Superhero`, title: `Super-her√≥i Anime`, body: 'Gera her√≥is estilo anime', command: `${prefix}deepimage anime-superhero-generator` },
  { name: `‚ú® Prophetic Vision`, title: `Vis√£o Prof√©tica`, body: 'Gera imagens de vis√µes', command: `${prefix}deepimage prophetic-vision-generator` },
  { name: `‚ú® Grotesque Art`, title: `Arte Grotesca`, body: 'Gera imagens bizarras', command: `${prefix}deepimage grotesque-art-generator` },
  { name: `‚ú® Tribal Art`, title: `Arte Tribal`, body: 'Gera arte tribal', command: `${prefix}deepimage tribal-art-generator` },
  { name: `‚ú® Mysticism Art`, title: `Arte M√≠stica`, body: 'Gera imagens m√≠sticas', command: `${prefix}deepimage mysticism-art-generator` },
  { name: `‚ú® Urban Fashion`, title: `Moda Urbana`, body: 'Gera looks de rua', command: `${prefix}deepimage urban-fashion-generator` },
  { name: `‚ú® Children Book`, title: `Livro Infantil`, body: 'Gera ilustra√ß√µes infantis', command: `${prefix}deepimage children-book-generator` },
  { name: `‚ú® Minimalistic Art`, title: `Arte Minimalista`, body: 'Gera arte simples e limpa', command: `${prefix}deepimage minimalistic-art-generator` },
  { name: `‚ú® Art Deco`, title: `Arte D√©co`, body: 'Gera arte estilo d√©co', command: `${prefix}deepimage art-deco-generator` },
  { name: `‚ú® Haunted Portrait`, title: `Retrato Assombrado`, body: 'Gera retratos assustadores', command: `${prefix}deepimage haunted-portrait-generator` },
  { name: `‚ú® Steampunk Landscape`, title: `Paisagem Steampunk`, body: 'Gera paisagens steampunk', command: `${prefix}deepimage steampunk-landscape-generator` },
  { name: `‚ú® Art Nouveau`, title: `Arte Nouveau`, body: 'Gera imagens nouveau', command: `${prefix}deepimage art-nouveau-generator` },
  { name: `‚ú® Baroque Art`, title: `Arte Barroca`, body: 'Gera imagens barrocas', command: `${prefix}deepimage baroque-art-generator` },
  { name: `‚ú® Gothic Art`, title: `Arte G√≥tica`, body: 'Gera arte no estilo g√≥tico', command: `${prefix}deepimage gothic-art-generator` },
  { name: `‚ú® Cubist Art`, title: `Arte Cubista`, body: 'Gera imagens cubistas', command: `${prefix}deepimage cubist-art-generator` },
  { name: `‚ú® Romantic Art`, title: `Arte Rom√¢ntica`, body: 'Gera imagens rom√¢nticas', command: `${prefix}deepimage romantic-art-generator` },
  { name: `‚ú® Photorealistic Portrait`, title: `Retrato Realista`, body: 'Gera retratos realistas', command: `${prefix}deepimage photorealistic-portrait-generator` },
  { name: `‚ú® Chibi Character`, title: `Personagem Chibi`, body: 'Gera personagens chibi', command: `${prefix}deepimage chibi-character-generator` },
  { name: `‚ú® Dreamscape`, title: `Paisagem dos Sonhos`, body: 'Gera cenas surreais', command: `${prefix}deepimage dreamscape-generator` },
  { name: `‚ú® Mecha Suit`, title: `Armadura Mecha`, body: 'Gera rob√¥s mecha', command: `${prefix}deepimage mecha-suit-generator` },
  { name: `‚ú® Abstract Expressionism`, title: `Expressionismo Abstrato`, body: 'Gera arte abstrata', command: `${prefix}deepimage abstract-expressionism-generator` },
];

    const botaodeep = [
      { title: `SELECIONE UM MODELO`, options: modelosDeep.map(m => ({
        name: m.name,
        title: m.title,
        body: m.body,
        command: m.command
      }))}
    ];

    try {
      img = await blackmd.profilePictureUrl(sender, 'image');
    } catch {
      img = semfoto;
    }

    if (isGroup) reply(`Enviando PV üî∞`);

    // Armazena a mensagem que disparou o comando
    const m = msg;

    sendRouletteButton(sender, { image: { url: img }, caption: `‚úèÔ∏è Texto: *${q}*\n\nEscolha o estilo abaixo para gerar a imagem:`, footer: NomeDoBot }, blackmd, sender, [{ type: `list`, title: `üé® Modelos DeepImage`, rowId: botaodeep }], seloctt);
  } else {
    // Se o usu√°rio j√° escolheu um modelo, gera a imagem
    const modelo = q.trim(); // O modelo escolhido
    const prompt = global.deepPrompt[sender];

    try {
      let { data } = await axios.get(`https://api.vreden.my.id/api/artificial/deepimage/${modelo}?prompt=${encodeURIComponent(prompt)}&shape=portrait`);
      
      if (data?.result?.output_url) {
        blackmd.sendMessage(sender, { image: { url: data.result.output_url }, caption: `üñºÔ∏è Imagem gerada para:\n\n*${prompt}*\n\nModelo: *${modelo.replace('-generator', '').replace(/-/g, ' ')}*` }, { quoted: info });
      } else {
        reply(`‚ùå Erro ao gerar a imagem.`);
      }
    } catch (e) {
      console.error(e);
      reply(`‚ùå Ocorreu um erro ao gerar a imagem.`);
    }

    // Apaga o prompt ap√≥s a gera√ß√£o da imagem
    delete global.deepPrompt[sender];
  }
  break;

case 'animarfoto':
case 'fotoemdesenho':
    try {
        let imageUrl;
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            // Se for m√≠dia (foto enviada ou marcada)
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            let uploadResult = await upload(owgi);
            imageUrl = uploadResult;
        } else if (q && q.includes('http')) {
            // Se for um link enviado no texto
            imageUrl = q.trim();
        } else {
            return reply('‚öôÔ∏è Marque uma foto ou envie o link direto da imagem.');
        }

        reply(`Aguarde ${pushname}, estou processando sua imagem...`);

        // Faz a chamada na API
        const vredenApi = `https://api.vreden.my.id/api/artificial/aiease/img2img/filter?url=${encodeURIComponent(imageUrl)}&style=4`;
        const vredenResponse = await axios.get(vredenApi);

        if (vredenResponse.data.status === 200 && vredenResponse.data.result && vredenResponse.data.result.length > 0) {
            const resultImage = vredenResponse.data.result[0].origin;

            // Baixa a imagem resultante
            const resultBuffer = await axios.get(resultImage, { responseType: 'arraybuffer' });

            await blackmd.sendMessage(from, {
                image: Buffer.from(resultBuffer.data, 'binary'),
                caption: `Aqui est√° sua imagem animada!`,
            });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel processar a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao animar/desenhar foto:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao tentar processar a imagem.' }, { quoted: info });
    }
    break;
    case 'expandirfoto':
case 'expandir':
    try {
        let imageUrl;
        
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            // Se for m√≠dia (foto enviada ou marcada)
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            let uploadResult = await upload(owgi);
            imageUrl = uploadResult;
        } else if (q && q.includes('http')) {
            // Se for um link enviado no texto
            imageUrl = q.trim();
        } else {
            return reply('‚öôÔ∏è Marque uma foto ou envie o link direto da imagem.');
        }

        reply(`Aguarde ${pushname}, estou expandindo sua imagem...`);

        // Faz a chamada na API de Expandir
        const expandApi = `https://api.vreden.my.id/api/artificial/imgedit/expand?url=${encodeURIComponent(imageUrl)}&top=100&bottom=100&left=100&right=100`;
        const expandResponse = await axios.get(expandApi, { responseType: 'arraybuffer' });

        await blackmd.sendMessage(from, {
            image: Buffer.from(expandResponse.data, 'binary'),
            caption: `Aqui est√° sua imagem expandida!`,
        }, { quoted: info });

    } catch (error) {
        console.error('Erro ao expandir a imagem:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao tentar expandir a imagem.' }, { quoted: info });
    }
    break;

    case 'hdr':
    case 'melhorarfoto':
    try {
        let imageUrl;
        
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            // Se for m√≠dia (foto enviada ou marcada)
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            let uploadResult = await upload(owgi);
            imageUrl = uploadResult;
        } else if (q && q.includes('http')) {
            // Se for um link enviado no texto
            imageUrl = q.trim();
        } else {
            return reply('‚öôÔ∏è Marque uma foto ou envie o link direto da imagem.');
        }

        reply(`Aguarde ${pushname}, estou processando sua imagem HDR...`);

        // Faz a chamada na API de HDR
        const hdrApi = `https://api.vreden.my.id/api/artificial/hdr?url=${encodeURIComponent(imageUrl)}&pixel=4`;
        const hdrResponse = await axios.get(hdrApi);

        if (hdrResponse.data.status === 200 && hdrResponse.data.result && hdrResponse.data.result.data.downloadUrls.length > 0) {
            const resultImage = hdrResponse.data.result.data.downloadUrls[0];

            // Baixa a imagem resultante
            const resultBuffer = await axios.get(resultImage, { responseType: 'arraybuffer' });

            await blackmd.sendMessage(from, {
                image: Buffer.from(resultBuffer.data, 'binary'),
                caption: `Aqui est√° sua imagem HDR!`,
            });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel processar a imagem HDR.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao melhorar foto HDR:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao tentar processar a imagem HDR.' }, { quoted: info });
    }
    break;
case 'animagine':
case 'gerar-animagine':
    if (!q) return blackmd.sendMessage(from, { text: '[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o texto para gerar a imagem. Exemplo: !animagine Sua descri√ß√£o aqui' }, { quoted: info });

    const promptAnimagine = encodeURIComponent(q);
    const apiUrlAnimagine = `https://api.vreden.my.id/api/artificial/animagine?prompt=${promptAnimagine}`;

    try {
        reply(`Aguarde ${pushname}, estou gerando sua imagem com estilo Animagine...`);

        const responseAnimagine = await axios.get(apiUrlAnimagine);

        if (responseAnimagine.data.status === 200 && responseAnimagine.data.result && responseAnimagine.data.result.output && responseAnimagine.data.result.output.data.length > 0) {
            const animagineImage = responseAnimagine.data.result.output.data[0].image.url;

            const animagineBuffer = await axios.get(animagineImage, { responseType: 'arraybuffer' });

            await blackmd.sendMessage(from, {
                image: Buffer.from(animagineBuffer.data, 'binary'),
                caption: `Aqui est√° sua imagem gerada: ${q}`,
            });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel gerar a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao gerar imagem Animagine:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao gerar a imagem.' }, { quoted: info });
    }
    break;
    case 'colorir':
case 'colorir-foto':
    try {
        let imageUrl;
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            // Se for imagem enviada ou marcada
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            let uploadResult = await upload(owgi);
            imageUrl = uploadResult;
        } else if (q && q.includes('http')) {
            // Se for link enviado
            imageUrl = q.trim();
        } else {
            return reply('‚öôÔ∏è Voc√™ precisa marcar uma imagem ou enviar o link direto.');
        }

        reply(`Aguarde ${pushname}, estou colorindo sua foto...`);

        const colorizerApi = `https://api.vreden.my.id/api/artificial/colorizer?url=${encodeURIComponent(imageUrl)}`;
        const responseColorizer = await axios.get(colorizerApi);

        if (responseColorizer.data.status === 200 && responseColorizer.data.result) {
            const colorizedImage = responseColorizer.data.result;

            const colorizedBuffer = await axios.get(colorizedImage, { responseType: 'arraybuffer' });

            await blackmd.sendMessage(from, {
                image: Buffer.from(colorizedBuffer.data, 'binary'),
                caption: `Aqui est√° sua foto colorida!`,
            });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel colorir a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao colorir foto:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao tentar colorir a imagem.' }, { quoted: info });
    }
    break;
case 'flux':
case 'gerar-flux':
    if (!q) return blackmd.sendMessage(from, { text: '[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o texto para gerar a imagem. Exemplo: !gerar-flux Sua descri√ß√£o aqui' }, { quoted: info });

    const promptFlux = encodeURIComponent(q);
    const apiUrlFlux = `https://api.vreden.my.id/api/artificial/flux?prompt=${promptFlux}&model=flux_1_schnell&size=1_1_HD&style=anime&color=vibrant&lighting=golden_hour`;

    try {
        reply(`Aguarde um momento ${pushname}, estou gerando sua imagem...`);

        const responseFlux = await axios.get(apiUrlFlux, { responseType: 'arraybuffer' });

        await blackmd.sendMessage(from, {
            image: Buffer.from(responseFlux.data, 'binary'),
            caption: `Imagem gerada para: ${q}`,
        }, { quoted: info });

    } catch (error) {
        console.error('Erro ao gerar imagem usando Flux:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao gerar a imagem.' }, { quoted: info });
    }
    break;
    // Fun√ß√£o para gerar imagem Flux
async function gerarImagemFlux(from, info, pushname, q, estilo) {
    if (!q) {
        return blackmd.sendMessage(from, { text: `[‚öôÔ∏èÔ∏è] Por favor, forne√ßa a descri√ß√£o.\nExemplo: .flux-${estilo} sua descri√ß√£o aqui` }, { quoted: info });
    }

    const promptEncoded = encodeURIComponent(q);
    const apiUrlFlux = `https://api.vreden.my.id/api/artificial/flux?prompt=${promptEncoded}&model=flux_1_schnell&size=1_1_HD&style=${estilo}&color=vibrant&lighting=golden_hour`;

    try {
        reply(`Aguarde um momento ${pushname}, estou gerando sua imagem com estilo *${estilo.replace('_', ' ')}*...`);

        const responseFlux = await axios.get(apiUrlFlux, { responseType: 'arraybuffer' });

        await blackmd.sendMessage(from, {
            image: Buffer.from(responseFlux.data, 'binary'),
            caption: `Imagem gerada para: ${q}`,
        }, { quoted: info });
    } catch (error) {
        console.error(`Erro ao gerar imagem estilo ${estilo}:`, error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao gerar a imagem.' }, { quoted: info });
    }
}

// Cases de cada estilo
case 'flux-anime':
    await gerarImagemFlux(from, info, pushname, q, 'anime');
    break;

case 'flux-digital':
    await gerarImagemFlux(from, info, pushname, q, 'digital');
    break;

case 'flux-fantasy':
    await gerarImagemFlux(from, info, pushname, q, 'fantasy');
    break;

case 'flux-neon_punk':
    await gerarImagemFlux(from, info, pushname, q, 'neon_punk');
    break;

case 'flux-dark':
    await gerarImagemFlux(from, info, pushname, q, 'dark');
    break;

case 'flux-low_poly':
    await gerarImagemFlux(from, info, pushname, q, 'low_poly');
    break;

case 'flux-line_art':
    await gerarImagemFlux(from, info, pushname, q, 'line_art');
    break;

case 'flux-pixel_art':
    await gerarImagemFlux(from, info, pushname, q, 'pixel_art');
    break;

case 'flux-comic':
    await gerarImagemFlux(from, info, pushname, q, 'comic');
    break;

case 'flux-analog_film':
    await gerarImagemFlux(from, info, pushname, q, 'analog_film');
    break;

case 'flux-surreal':
    await gerarImagemFlux(from, info, pushname, q, 'surreal');
    break;

case 'fluximg':
    await gerarImagemFlux(from, info, pushname, q, 'no_style');
    break;
case 'escreverlivro':
case 'escrever-livro':
    if (!q) return blackmd.sendMessage(from, { text: '[‚öôÔ∏è] Por favor, forne√ßa o texto que deseja que seja escrito no livro. Exemplo: !escreverlivro Seu texto aqui.' }, { quoted: info });

    try {
        reply(`‚úçÔ∏è Aguarde ${pushname}, estou escrevendo seu livro...`);

        const encodedText = encodeURIComponent(q);
        const apiUrl = `https://api.ownblox.biz.id/api/nulis?text=${encodedText}`;
        
        const response = await axios.get(apiUrl, { responseType: 'arraybuffer' });

        await blackmd.sendMessage(from, {
            image: Buffer.from(response.data, 'binary'),
            caption: `Aqui est√° seu texto escrito no livro!`,
        }, { quoted: info });

    } catch (error) {
        console.error('Erro ao gerar imagem de escrita:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao tentar escrever no livro.' }, { quoted: info });
    }
    break;
case 'gerarqrcode':
case 'gerar-qrcode':
    try {
        if (!q) return blackmd.sendMessage(from, { text: '‚öôÔ∏è Por favor, envie o texto ou link que deseja transformar em QR Code.\n\nExemplo: !gerarqrcode https://meusite.com' }, { quoted: info });

        reply(`Aguarde ${pushname}, estou gerando seu QR Code...`);

        const qrApiUrl = `https://api.ownblox.biz.id/api/qrcodegenerator?text=${encodeURIComponent(q)}`;
        const qrResponse = await axios.get(qrApiUrl, { responseType: 'arraybuffer' });

        await blackmd.sendMessage(from, {
            image: Buffer.from(qrResponse.data, 'binary'),
            caption: `QR Code gerado para: ${q}`,
        }, { quoted: info });

    } catch (error) {
        console.error('Erro ao gerar QR Code:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao gerar o QR Code.' }, { quoted: info });
    }
    break;
case 'amazonai':
case 'gerar-amazonai':
    if (!q) return blackmd.sendMessage(from, { text: '[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o texto para gerar a imagem. Exemplo: !gerar-amazonai Sua descri√ß√£o aqui' }, { quoted: info });

    const promptAmazon = encodeURIComponent(q); // Codifica o prompt para a URL
    const apiUrlAmazon = `https://api.vreden.my.id/api/artificial/amazonai?prompt=${promptAmazon}&frame=6`;

    try {
        reply(`aguarde um momento ${pushname}, estou gerando sua imagem...`);

        const responseAmazon = await axios.get(apiUrlAmazon);
        
        if (responseAmazon.data.status === 200 && responseAmazon.data.result && responseAmazon.data.result.image_link) {
            const imageUrl = responseAmazon.data.result.image_link;

            // Baixa a imagem para enviar
            const imageBuffer = await axios.get(imageUrl, { responseType: 'arraybuffer' });
            
            await blackmd.sendMessage(from, {
                image: Buffer.from(imageBuffer.data, 'binary'),
                caption: `Imagem gerada para: ${q}`,
            });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel gerar a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao gerar imagem usando AmazonAI:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao gerar a imagem.' }, { quoted: info });
    }
    break;
    case 'Mora': 
    case 'mora':
    if (!q) return blackmd.sendMessage(from, { text: '[‚öôÔ∏èÔ∏è] Por favor, envie a sua pergunta. Exemplo: .mora Que dia √© hoje?' }, { quoted: info });

    const queryMora = encodeURIComponent(q);
    const usernameMora = encodeURIComponent(pushname || 'usu√°rio');
    const apiUrlMora = `https://api.vreden.my.id/api/mora?query=responda empoetugues:${queryMora}&username=${usernameMora}`;

    try {

        const responseMora = await axios.get(apiUrlMora);
        
        if (responseMora.data.status === 200 && responseMora.data.result) {
            blackmd.sendMessage(from, { text: responseMora.data.result }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o consegui obter resposta da Mora.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao consultar Mora:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao tentar falar com a Mora.' }, { quoted: info });
    }
    break;
    case 'qio':
    case 'qioo2':
    if (!q) return blackmd.sendMessage(from, { text: '[‚öôÔ∏èÔ∏è] Por favor, envie a sua mensagem. Exemplo: .qioo2 Oi, tudo bem?' }, { quoted: info });

    const queryQioo2 = encodeURIComponent(q);
    const usernameQioo2 = encodeURIComponent(pushname || 'usu√°rio');
    const apiUrlQioo2 = `https://api.vreden.my.id/api/qioo2?query=reesponda em portugu√™s:${queryQioo2}&username=${usernameQioo2}`;

    try {

        const responseQioo2 = await axios.get(apiUrlQioo2);
        
        if (responseQioo2.data.status === 200 && responseQioo2.data.result) {
            blackmd.sendMessage(from, { text: responseQioo2.data.result }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o consegui obter resposta do Qioo2.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao consultar Qioo2:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao tentar falar com o Qioo2.' }, { quoted: info });
    }
    break;
case 'removebg':
case 'tirarfundo':
    try {
        let imageUrl;
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            // Se for m√≠dia (foto enviada ou marcada)
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            let uploadResult = await upload(owgi);
            imageUrl = uploadResult;
        } else if (q && q.includes('http')) {
            // Se for link enviado no texto
            imageUrl = q.trim();
        } else {
            return reply('‚öôÔ∏è Marque uma foto ou envie o link direto da imagem.');
        }

        reply(`Aguarde ${pushname}, estou removendo o fundo da sua imagem...`);

        const apiUrlRemoveBG = `https://api.vreden.my.id/api/artificial/aiease/img2img/removebg?url=${encodeURIComponent(imageUrl)}`;
        const responseRemoveBG = await axios.get(apiUrlRemoveBG);

        if (responseRemoveBG.data.status === 200 && responseRemoveBG.data.result && responseRemoveBG.data.result.length > 0) {
            const resultImage = responseRemoveBG.data.result[0].origin;

            // Envia o link da imagem sem fundo
            blackmd.sendMessage(from, { text: `‚úÖ Fundo removido com sucesso!\n\nüîó Link da imagem sem fundo:\n${resultImage}` }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel remover o fundo da imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao remover fundo da imagem:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao tentar remover o fundo da imagem.' }, { quoted: info });
    }
    break;
    case 'gerararte':
case 'text2img':
    if (!q) return blackmd.sendMessage(from, { text: '[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o texto para gerar a arte. Exemplo: !gerararte Uma cidade futurista entre as nuvens' }, { quoted: info });

    try {
        const promptText2Img = encodeURIComponent(q);
        const apiUrlText2Img = `https://api.vreden.my.id/api/artificial/aiease/text2img?prompt=${promptText2Img}&style=19`;

        reply(`Aguarde um momento ${pushname}, estou criando sua arte...`);

        const responseText2Img = await axios.get(apiUrlText2Img);

        if (responseText2Img.data.status === 200 && responseText2Img.data.result && responseText2Img.data.result.length > 0) {
            for (const imageData of responseText2Img.data.result) {
                const imageUrl = imageData.origin;
                const imageBuffer = await axios.get(imageUrl, { responseType: 'arraybuffer' });

                await blackmd.sendMessage(from, {
                    image: Buffer.from(imageBuffer.data, 'binary'),
                    caption: `Arte gerada para: ${q}`,
                }, { quoted: info });
            }
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel gerar a arte.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao gerar arte:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao gerar a arte.' }, { quoted: info });
    }
    break;
 case 'removermarca':
case 'tirarmarca':
    try {
        let imageUrl;
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            // Se for m√≠dia (foto enviada ou marcada)
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            let uploadResult = await upload(owgi);
            imageUrl = uploadResult;
        } else if (q && q.includes('http')) {
            // Se for link enviado no texto
            imageUrl = q.trim();
        } else {
            return reply('‚öôÔ∏è Marque uma foto ou envie o link direto da imagem.');
        }

        reply(`Aguarde ${pushname}, estou removendo a marca d'√°gua...`);

        // Chama a API para remover a marca
        const apiWatermark = `https://api.vreden.my.id/api/artificial/aiease/img2img/watermark?url=${encodeURIComponent(imageUrl)}`;
        const responseWatermark = await axios.get(apiWatermark);

        if (responseWatermark.data.status === 200 && responseWatermark.data.result && responseWatermark.data.result.length > 0) {
            const resultImage = responseWatermark.data.result[0].origin;

            const resultBuffer = await axios.get(resultImage, { responseType: 'arraybuffer' });

            await blackmd.sendMessage(from, {
                image: Buffer.from(resultBuffer.data, 'binary'),
                caption: `Marca d'√°gua removida com sucesso!`,
            }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel remover a marca d√°gua.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao remover marca d\'√°gua:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao tentar remover a marca d\'√°gua.' }, { quoted: info });
    }
    break;
case 'ximage':
case 'gerarximage':
    if (!q) return reply('‚öôÔ∏è Por favor, forne√ßa a descri√ß√£o para gerar a imagem. Exemplo: !ximage Sua descri√ß√£o aqui.');

    try {
        reply(`Aguarde ${pushname}, estou gerando sua imagem XImage...`);

        const promptXimage = encodeURIComponent(q);
        const apiXimage = `https://api.vreden.my.id/api/artificial/ximage?prompt=${promptXimage}`;

        const responseXimage = await axios.get(apiXimage);

        if (responseXimage.data.status === 200 && responseXimage.data.result && responseXimage.data.result.output) {
            const imageUrl = responseXimage.data.result.output;

            const resultBuffer = await axios.get(imageUrl, { responseType: 'arraybuffer' });

            await blackmd.sendMessage(from, {
                image: Buffer.from(resultBuffer.data, 'binary'),
                caption: `Imagem gerada para: ${q}`,
            }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel gerar a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao gerar imagem XImage:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao tentar gerar a imagem.' }, { quoted: info });
    }
    break;
// as novas est√£o acima
case 'imagem':
    case 'gerar-imagem':
    if (!q) return blackmd.sendMessage(from, { text: '[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o texto para gerar a imagem. Exemplo: !gerar-imagem Sua frase aqui' }, { quoted: info });

    const textoParaImagem = encodeURIComponent(q); // Codifica o texto para a URL
    const apiUrlImagem = `https://world-ecletix.onrender.com/api/gerar-imagem?texto=${textoParaImagem}`;

    try {
        // Envia a mensagem informando que est√° gerando a imagem
        reply(`aguarde um momento ${pushname}, pode demorar.`);

        // Envia a imagem diretamente usando a nova API
        const imageResponse = await axios.get(apiUrlImagem, { responseType: 'arraybuffer' });
        
        if (imageResponse.status === 200) {
            const imageBuffer = Buffer.from(imageResponse.data, 'binary');

            // Envia a imagem gerada no chat de onde veio a solicita√ß√£o
            await blackmd.sendMessage(from, {
                image: imageBuffer,
                caption: `Aqui est√° a imagem gerada para: ${q}`, // Mensagem opcional
            });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel gerar a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao fazer a requisi√ß√£o √† API de gera√ß√£o de imagem:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao gerar a imagem.' }, { quoted: info });
    }
    break;
    case 'gen':
case 'Gen':
    if (!q) return blackmd.sendMessage(from, { text: '[‚öôÔ∏è] Por favor, forne√ßa um prompt para gerar a imagem. Exemplo: !gerar-imagem Sua descri√ß√£o aqui' }, { quoted: info });

    const prompt = encodeURIComponent(q); // Codifica o texto para URL
    const gen = `http://premium.primaryhost.shop:2050/generate?prompt=${prompt}`;

    try {
        reply(`Aguarde um momento ${pushname}, estou gerando a imagem...`);

        // Faz a requisi√ß√£o para a API de gera√ß√£o de imagem
        const response = await axios.get(gen);
        
        if (response.status === 200 && response.data.image_url) {
            const imageUrl = response.data.image_url;

            // Envia a imagem gerada no chat
            await blackmd.sendMessage(from, {
                image: { url: imageUrl },
                caption: `Aqui est√° a imagem gerada para: ${q}`,
            });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel gerar a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao gerar a imagem:', error);
        blackmd.sendMessage(from, { text: 'üö® Erro ao gerar a imagem.' }, { quoted: info });
    }
    break;
    case 'orbital-img':
case 'gerar-orbital-img':
  if (!q) return blackmd.sendMessage(from, { text: '[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o texto para gerar a imagem. Exemplo: !orbital-img Sua descri√ß√£o aqui' }, { quoted: info });

  const textoOrbitalImg = encodeURIComponent(q);
  const apiUrlOrbitalImg = `https://world-ecletix.onrender.com/api/orbital-img?texto=${textoOrbitalImg}`;

  try {
    reply(`Aguarde um momento ${pushname}, estou gerando sua imagem...`);

    const imageResponse = await axios.get(apiUrlOrbitalImg, { responseType: 'arraybuffer' });
    if (imageResponse.status === 200) {
      const imageBuffer = Buffer.from(imageResponse.data, 'binary');
      await blackmd.sendMessage(from, {
        image: imageBuffer,
        caption: `Aqui est√° a imagem gerada para: ${q}`,
      });
    } else {
      blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel gerar a imagem.' }, { quoted: info });
    }
  } catch (error) {
    console.error('Erro ao fazer a requisi√ß√£o √† API Orbital Image:', error);
    blackmd.sendMessage(from, { text: 'üö® Erro ao gerar a imagem.' }, { quoted: info });
  }
  break;
case 'imgsys':
case 'gerar-imgsys':
  if (!q) return blackmd.sendMessage(from, { text: '[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o texto para gerar a imagem. Exemplo: !imgsys Sua descri√ß√£o aqui' }, { quoted: info });

  const textoImgSys = encodeURIComponent(q);
  const apiUrlImgSys = `https://world-ecletix.onrender.com/api/imgsys?texto=${textoImgSys}`;

  try {
    reply(`Aguarde um momento ${pushname}, estou gerando sua imagem...`);

    const imageResponse = await axios.get(apiUrlImgSys, { responseType: 'arraybuffer' });
    if (imageResponse.status === 200) {
      const imageBuffer = Buffer.from(imageResponse.data, 'binary');
      await blackmd.sendMessage(from, {
        image: imageBuffer,
        caption: `Aqui est√° a imagem gerada para: ${q}`,
      });
    } else {
      blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel gerar a imagem.' }, { quoted: info });
    }
  } catch (error) {
    console.error('Erro ao fazer a requisi√ß√£o √† API ImgSys:', error);
    blackmd.sendMessage(from, { text: 'üö® Erro ao gerar a imagem.' }, { quoted: info });
  }
  break;
  case 'fluximg':
case 'gerar-fluximg':
  if (!q) return blackmd.sendMessage(from, { text: '[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o texto para gerar a imagem. Exemplo: !fluximg Sua descri√ß√£o aqui' }, { quoted: info });

  const textoFluxImg = encodeURIComponent(q);
  const apiUrlFluxImg = `https://world-ecletix.onrender.com/api/fluximg?texto=${textoFluxImg}`;

  try {
    reply(`Aguarde um momento ${pushname}, estou gerando sua imagem...`);

    const imageResponse = await axios.get(apiUrlFluxImg, { responseType: 'arraybuffer' });
    if (imageResponse.status === 200) {
      const imageBuffer = Buffer.from(imageResponse.data, 'binary');
      await blackmd.sendMessage(from, {
        image: imageBuffer,
        caption: `Aqui est√° a imagem gerada para: ${q}`,
      });
    } else {
      blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel gerar a imagem.' }, { quoted: info });
    }
  } catch (error) {
    console.error('Erro ao fazer a requisi√ß√£o √† API FluxImg:', error);
    blackmd.sendMessage(from, { text: 'üö® Erro ao gerar a imagem.' }, { quoted: info });
  }
  break;
  case 'sd':
case 'gerar-sd':
  if (!q) return blackmd.sendMessage(from, { text: '[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o texto para gerar a imagem. Exemplo: !sd Sua descri√ß√£o aqui' }, { quoted: info });

  const promptSD = encodeURIComponent(q);
  const apiUrlSD = `https://world-ecletix.onrender.com/api/sd?prompt=${promptSD}`;

  try {
    reply(`Aguarde um momento ${pushname}, estou gerando sua imagem...`);

    const imageResponse = await axios.get(apiUrlSD, { responseType: 'arraybuffer' });
    if (imageResponse.status === 200) {
      const imageBuffer = Buffer.from(imageResponse.data, 'binary');
      await blackmd.sendMessage(from, {
        image: imageBuffer,
        caption: `Aqui est√° a imagem gerada para: ${q}`,
      });
    } else {
      blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel gerar a imagem.' }, { quoted: info });
    }
  } catch (error) {
    console.error('Erro ao fazer a requisi√ß√£o √† API SD:', error);
    blackmd.sendMessage(from, { text: 'üö® Erro ao gerar a imagem.' }, { quoted: info });
  }
  break;
case 'imagine':
case 'Imagine':
  if (!q) return blackmd.sendMessage(from, { text: '[‚öôÔ∏èÔ∏è] Por favor, forne√ßa o texto para gerar a imagem. Exemplo: !imagine Sua descri√ß√£o aqui' }, { quoted: info });

  const textoImagine = encodeURIComponent(q);
  const apiUrlImagine = `https://world-ecletix.onrender.com/api/imagine?texto=${textoImagine}`;

  try {
    reply(`Aguarde um momento ${pushname}, estou gerando sua imagem...`);

    const imageResponse = await axios.get(apiUrlImagine, { responseType: 'arraybuffer' });
    if (imageResponse.status === 200) {
      const imageBuffer = Buffer.from(imageResponse.data, 'binary');
      await blackmd.sendMessage(from, {
        image: imageBuffer,
        caption: `Aqui est√° a imagem gerada para: ${q}`,
      });
    } else {
      blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel gerar a imagem.' }, { quoted: info });
    }
  } catch (error) {
    console.error('Erro ao fazer a requisi√ß√£o √† API Imagine:', error);
    blackmd.sendMessage(from, { text: 'üö® Erro ao gerar a imagem.' }, { quoted: info });
  }
  break;

   case 'Gemini2':
case 'gemini2':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o gemini IA.');
  }

  const promptOrbital = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://api-ia.orbital.host/gemini?prompt=${promptOrbital}`);
    const data = await response.json();
    
    if (data.result) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do Gemini IA: ${data.result}` }, { quoted: info });
    } else {
      reply("üö® N√£o consegui obter a resposta do Orbital IA. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Orbital IA:", error);
    reply("üö® N√£o foi poss√≠vel. Tente novamente mais tarde.");
  }
  break;
//novas ias
case 'grok':
case 'Grok':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o Grok.');
  }

  const grokTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/grok-2?texto=${grokTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do Grok: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`üö® Erro: ${response.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do Grok. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Grok:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;

case 'gpt4o':
case 'Gpt4o':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o GPT-4o.');
  }

  const gpt4oTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/gpt-4o?texto=${gpt4oTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do GPT-4o: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`üö® Erro: ${response.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do GPT-4o. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GPT-4o:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;

case 'gpt4turbo':
case 'Gpt4turbo':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o GPT-4 Turbo.');
  }

  const gpt4turboTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/gpt-4-turbo?texto=${gpt4turboTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do GPT-4 Turbo: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`üö® Erro: ${response.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do GPT-4 Turbo. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GPT-4 Turbo:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;
case 'claude3opus':
case 'Claude3Opus':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o Claude 3 Opus.');
  }

  const claude3OpusTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/claude-3-opus?texto=${claude3OpusTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do Claude 3 Opus: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`üö® Erro: ${response.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do Claude 3 Opus. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Claude 3 Opus:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;

case 'grokbeta':
case 'GrokBeta':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o Grok Beta.');
  }

  const grokBetaTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/grok-beta?texto=${grokBetaTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do Grok Beta: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`üö® Erro: ${response.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do Grok Beta. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Grok Beta:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;

case 'grok2mini':
case 'Grok2Mini':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o Grok 2 Mini.');
  }

  const grok2MiniTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/grok-2-mini?texto=${grok2MiniTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do Grok 2 Mini: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`üö® Erro: ${response.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do Grok 2 Mini. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Grok 2 Mini:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;
case 'claude3sonnet':
case 'Claude3Sonnet':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o Claude 3 Sonnet.');
  }

  const claude3SonnetTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/claude-3-sonnet?texto=${claude3SonnetTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do Claude 3 Sonnet: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`üö® Erro: ${response.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do Claude 3 Sonnet. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Claude 3 Sonnet:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;

case 'claude35sonnet':
case 'Claude35Sonnet':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o Claude 3.5 Sonnet.');
  }

  const claude35SonnetTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/claude-3-5-sonnet?texto=${claude35SonnetTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do Claude 3.5 Sonnet: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`üö® Erro: ${response.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do Claude 3.5 Sonnet. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Claude 3.5 Sonnet:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;

case 'claude35sonnet2':
case 'Claude35Sonnet2':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o Claude 3.5 Sonnet 2.');
  }

  const claude35Sonnet2Texto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/claude-3-5-sonnet-2?texto=${claude35Sonnet2Texto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do Claude 3.5 Sonnet 2: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`üö® Erro: ${response.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do Claude 3.5 Sonnet 2. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Claude 3.5 Sonnet 2:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;
case 'dalle':
case 'Dalle':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma descri√ß√£o para a gera√ß√£o de imagem com DALL¬∑E.');
  }

  const dalleTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/dalle?texto=${dalleTexto}`);

    if (response.url) {
      blackmd.sendMessage(from, { image: { url: response.url }, caption: "üñºÔ∏è Imagem gerada pelo DALL¬∑E" }, { quoted: info });
    } else if (response.mensagem) {
      reply(`üö® Erro: ${response.mensagem}`);
    } else {
      reply("üö® N√£o consegui gerar a imagem. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter imagem do DALL¬∑E:", error);
    reply("üö® N√£o foi poss√≠vel gerar a imagem, tente novamente mais tarde.");
  }
  break;
case 'lexica':
case 'Lexica':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma descri√ß√£o para a gera√ß√£o de imagem com Lexica.');
  }

  const lexicaTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/lexica?texto=${lexicaTexto}`);

    if (response.url) {
      blackmd.sendMessage(from, { image: { url: response.url }, caption: "üñºÔ∏è Imagem gerada pelo Lexica" }, { quoted: info });
    } else if (response.mensagem) {
      reply(`üö® Erro: ${response.mensagem}`);
    } else {
      reply("üö® N√£o consegui gerar a imagem. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter imagem do Lexica:", error);
    reply("üö® N√£o foi poss√≠vel gerar a imagem, tente novamente mais tarde.");
  }
  break;
//fim das novas ias
case 'lady':
case 'Lady':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para a lady.');
  }

  const ladyTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a nova API da lady
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/lady?texto=${ladyTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta da lady: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`üö® Erro: ${response.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta da lady. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta da lady:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;
  case 'analisaimg': //by luanzin dev
  if (!args[1] || !args[2]) {
    return reply('üö® Por favor, forne√ßa um prompt e uma URL de imagem. Exemplo: !analiseimg "analisar esta imagem" [URL da imagem]');
  }

  const promptVerImg = encodeURIComponent(args[1]);
  const imageUrl = args[2];

  try {
    const response = await fetchJson(`https://api-ia.orbital.host/gemini/img?prompt=${promptVerImg}&imageUrl=${imageUrl}`);
    const data = await response.json();
    
    if (data.result) {
      blackmd.sendMessage(from, { text: `üñºÔ∏è Resultado da an√°lise: ${data.result}` }, { quoted: info });
    } else {
      reply("üö® N√£o consegui obter a an√°lise da imagem.");
    }
  } catch (error) {
    console.error("Erro ao analisar a imagem:", error);
    reply("üö® N√£o foi poss√≠vel se conectar ao Orbital IA. Tente novamente mais tarde.");
  }
  break;
case 'ia':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para a IA.');
  }

  const textoIa = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API da IA
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ia?texto=${textoIa}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta da IA: ${data.resposta}` }, { quoted: info });
    } else {
      reply(data.mensagem ? `üö® Erro: ${data.mensagem}` : "üö® N√£o consegui obter a resposta da IA. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta da IA:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;
case 'gemini3':
case 'gptgemini':
    try {
        if (!q) return blackmd.sendMessage(from, { text: '‚öôÔ∏è Por favor, envie o conte√∫do para conversar com o Gemini.\n\nExemplo: !gemini oi amigo' }, { quoted: info });

        reply(`Aguarde ${pushname}, estou consultando o modelo Gemini...`);

        const geminiApiUrl = `https://api.ownblox.biz.id/api/gemini?text=responda em portugu√™s:${encodeURIComponent(q)}`;
        const geminiResponse = await axios.get(geminiApiUrl);

        if (geminiResponse.data && geminiResponse.data.sukses) {
            await blackmd.sendMessage(from, { text: geminiResponse.data.jawaban }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel obter resposta do Gemini.' }, { quoted: info });
        }

    } catch (error) {
        console.error('Erro ao consultar Gemini:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao consultar o modelo Gemini.' }, { quoted: info });
    }
    break;

case 'gemini':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o Gemini.');
  }

  const textoGemini = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API do Gemini
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/gemini?texto=${textoGemini}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do Gemini: ${data.resposta}` }, { quoted: info });
    } else {
      reply(data.mensagem ? `üö® Erro: ${data.mensagem}` : "üö® N√£o consegui obter a resposta do Gemini. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Gemini:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;

case 'geminipro':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o GeminiPro.');
  }

  const textoGeminipro = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API do GeminiPro
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-geminipro?texto=${textoGeminipro}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do GeminiPro: ${data.resposta}` }, { quoted: info });
    } else {
      reply(data.mensagem ? `üö® Erro: ${data.mensagem}` : "üö® N√£o consegui obter a resposta do GeminiPro. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GeminiPro:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;
  case 'chatgpt':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o ChatGPT.');
  }

  const textoChatGPT = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API do ChatGPT
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/chatgpt?texto=${textoChatGPT}`);

    if (data.response) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do ChatGPT: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`üö® Erro: ${data.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do ChatGPT. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do ChatGPT:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;

case 'gpt3.5-turbo':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o GPT-3.5-Turbo.');
  }

  const textoGpt35Turbo = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API do GPT-3.5-Turbo
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-gpt3.5-turbo?texto=${textoGpt35Turbo}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do GPT-3.5-Turbo: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`üö® Erro: ${data.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do GPT-3.5-Turbo. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GPT-3.5-Turbo:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;

case 'gpt4':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o GPT-4.');
  }

  const textoGpt4 = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API do GPT-4
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-gpt4?texto=${textoGpt4}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do GPT-4: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`üö® Erro: ${data.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do GPT-4. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GPT-4:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;
  case 'gpt4':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o GPT-4.');
  }

  const textoGpt44 = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API do GPT-4
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-gpt4?texto=${textoGpt44}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do GPT-4: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`üö® Erro: ${data.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do GPT-4. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GPT-4:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;

case 'gpt4v2':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o GPT-4V2.');
  }

  const textoGpt4v2 = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API do GPT-4V2
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-gpt4v2?texto=${textoGpt4v2}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do GPT-4V2: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`üö® Erro: ${data.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do GPT-4V2. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GPT-4V2:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;
  
case 'Meta':
case 'meta':
case 'gptllama':
    try {
        if (!q) return blackmd.sendMessage(from, { text: '‚öôÔ∏è Por favor, envie o conte√∫do para conversar com o LLaMA.\n\nExemplo: !llama oi' }, { quoted: info });

        reply(`Aguarde ${pushname}, estou consultando o modelo LLaMA...`);

        const llamaApiUrl = `https://api.ownblox.biz.id/api/llama-3.3-70b-versatile?content=${encodeURIComponent(q)}`;
        const llamaResponse = await axios.get(llamaApiUrl);

        if (llamaResponse.data && llamaResponse.data.status === 200) {
            await blackmd.sendMessage(from, { text: llamaResponse.data.response }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel obter resposta do modelo LLaMA.' }, { quoted: info });
        }

    } catch (error) {
        console.error('Erro ao consultar LLaMA:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao consultar o modelo LLaMA.' }, { quoted: info });
    }
    break;
case 'image2text':
    try {
        if (!q && !isMedia) return reply('‚öôÔ∏è Marque uma imagem ou envie um link de imagem.');

        let imageUrl = '';
        if (isMedia || isQuotedImage) {
            let imgMessage = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            imageUrl = imgMessage.url;
        } else if (q && q.includes('http')) {
            imageUrl = q.trim();
        }

        const imageToTextApi = `https://api.siputzx.my.id/api/ai/image2text?url=${encodeURIComponent(imageUrl)}`;
        const response = await axios.get(imageToTextApi);

        if (response.data.status) {
            blackmd.sendMessage(from, { text: response.data.dados }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel processar a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro no Image2Text:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao tentar processar a imagem.' }, { quoted: info });
    }
    break;    
case 'explicarfoto':
case 'explicar-foto':
    try {
        let imageUrl;
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            // Se for m√≠dia (foto enviada ou marcada)
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            let uploadResult = await upload(owgi);
            imageUrl = uploadResult;
        } else if (q && q.includes('http')) {
            // Se for um link enviado no texto
            imageUrl = q.trim();
        } else {
            return reply('‚öôÔ∏è Marque uma foto ou envie o link direto da imagem para explicar.');
        }

        if (!q.replace(imageUrl, '').trim()) {
            return reply('‚öôÔ∏è Ap√≥s a imagem, envie tamb√©m a pergunta/descri√ß√£o.\n\nExemplo: !explicarfoto [imagem marcada] explique essa foto');
        }

        const userQuestion = q.replace(imageUrl, '').trim();
        reply(`Aguarde ${pushname}, estou analisando a imagem...`);

        const bardApiUrl = `https://api.siputzx.my.id/api/ai/bard-img?imageUrl=${encodeURIComponent(imageUrl)}&query=${encodeURIComponent(userQuestion)}`;
        const bardResponse = await axios.get(bardApiUrl);

        if (bardResponse.data && bardResponse.data.status) {
            await blackmd.sendMessage(from, { text: bardResponse.data.dados }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel analisar a imagem.' }, { quoted: info });
        }

    } catch (error) {
        console.error('Erro ao analisar imagem:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao tentar analisar a imagem.' }, { quoted: info });
    }
    break;
    case 'magicstudio':
    try {
        if (!q) return reply('‚öôÔ∏è Escreva um prompt para gerar a imagem.');

        const magicStudioApi = `https://api.siputzx.my.id/api/ai/magicstudio?prompt=${encodeURIComponent(q)}`;
        const response = await axios.get(magicStudioApi, { responseType: 'arraybuffer' });

        const buffer = Buffer.from(response.data, 'binary');
        await blackmd.sendMessage(from, { image: buffer, caption: 'Aqui est√° a imagem gerada!' }, { quoted: info });
    } catch (error) {
        console.error('Erro no MagicStudio:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao gerar a imagem.' }, { quoted: info });
    }
    break;
    case 'trocar-rosto':
    case 'faceswap':
    try {
        if (!q || !q.includes('http') || q.split(' ').length !== 2) {
            return reply('‚öôÔ∏è Forne√ßa dois links de imagem separados por espa√ßo para trocar os rostos.');
        }

        const [sourceUrl, targetUrl] = q.split(' ');

        const faceswapApi = `https://api.siputzx.my.id/api/ai/faceswap?source=${encodeURIComponent(sourceUrl)}&target=${encodeURIComponent(targetUrl)}`;
        const response = await axios.get(faceswapApi, { responseType: 'arraybuffer' });

        const buffer = Buffer.from(response.data, 'binary');
        await blackmd.sendMessage(from, { image: buffer, caption: 'Aqui est√° a troca de rostos!' }, { quoted: info });
    } catch (error) {
        console.error('Erro no Faceswap:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao tentar realizar a troca de rostos.' }, { quoted: info });
    }
    break;
case 'Gerar-foto':
case 'gerar-foto':
    try {
        if (!q) return reply('‚öôÔ∏è Escreva um prompt para gerar a imagem.');

        const fluxApi = `https://api.siputzx.my.id/api/ai/flux?prompt=${encodeURIComponent(q)}`;
        const response = await axios.get(fluxApi, { responseType: 'arraybuffer' });

        const buffer = Buffer.from(response.data, 'binary');
        await blackmd.sendMessage(from, { image: buffer, caption: 'Aqui est√° a imagem gerada!' }, { quoted: info });
    } catch (error) {
        console.error('Erro no Flux:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao gerar a imagem.' }, { quoted: info });
    }
    break;
case 'bard':
    try {
        if (!q) return reply(`‚öôÔ∏è Escreva algo para o Bard responder.`);
        const bardApi = `https://api.siputzx.my.id/api/ai/bard?query=${encodeURIComponent(q)}`;
        const bardResponse = await axios.get(bardApi);

        if (bardResponse.data.status && bardResponse.data.data) {
            blackmd.sendMessage(from, { text: bardResponse.data.data }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o consegui gerar a resposta.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro no Bard:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao tentar gerar a resposta.' }, { quoted: info });
    }
    break;
    case 'bard2':
    try {
        if (!q) return reply(`‚öôÔ∏è Escreva algo para o Bard responder.`);
        const bardApi = `https://api.siputzx.my.id/api/ai/bard?query=${encodeURIComponent(q)}`;
        const bardResponse = await axios.get(bardApi);

        if (bardResponse.data.status && bardResponse.data.data) {
            blackmd.sendMessage(from, { text: bardResponse.data.data }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o consegui gerar a resposta.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro no Bard:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao tentar gerar a resposta.' }, { quoted: info });
    }
    break;

case 'meta-turbo':
case 'meta-llama':
    try {
        if (!q) return blackmd.sendMessage(from, { text: '‚öôÔ∏è Envie o conte√∫do para conversar com o Meta-Llama.\n\nExemplo: .metallama oi' }, { quoted: info });

        const llamaApiUrl = `https://api.siputzx.my.id/api/ai/meta-llama-33-70B-instruct-turbo?content=responda em portugues:${encodeURIComponent(q)}`;
        const llamaResponse = await axios.get(llamaApiUrl);

        if (llamaResponse.data && llamaResponse.data.status) {
            await blackmd.sendMessage(from, { text: llamaResponse.data.data }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o foi poss√≠vel obter resposta do Meta-Llama.' }, { quoted: info });
        }

    } catch (error) {
        console.error('Erro ao consultar Meta-Llama:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao consultar o modelo Meta-Llama.' }, { quoted: info });
    }
    break;    
case 'llama':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma consulta para o Llama.');
  }

  const textoLlama = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API do Llama
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-llama?texto=${textoLlama}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do Llama: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`üö® Erro: ${data.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do Llama. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Llama:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;
  case 'blackboxai-pro':
    try {
        if (!q) return reply(`‚öôÔ∏è Escreva algo para o Blackbox AI Pro responder.`);
        const blackboxProApi = `https://api.siputzx.my.id/api/ai/blackboxai-pro?content=${encodeURIComponent(q)}`;
        const response = await axios.get(blackboxProApi);

        if (response.data.status && response.data.data) {
            blackmd.sendMessage(from, { text: response.data.data }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o consegui gerar a resposta.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro no Blackbox AI Pro:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao tentar gerar a resposta.' }, { quoted: info });
    }
    break;
case 'blackboxai':
    try {
        if (!q) return reply(`‚öôÔ∏è Escreva algo para o Blackbox AI responder.`);
        const blackboxApi = `https://api.siputzx.my.id/api/ai/blackboxai?content=${encodeURIComponent(q)}`;
        const response = await axios.get(blackboxApi);

        if (response.data.status && response.data.data) {
            blackmd.sendMessage(from, { text: response.data.data }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: 'üö® N√£o consegui gerar a resposta.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro no Blackbox AI:', error);
        blackmd.sendMessage(from, { text: 'üö® Ocorreu um erro ao tentar gerar a resposta.' }, { quoted: info });
    }
    break;
case 'blackbox':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma consulta para o BlackBox.');
  }

  const textoBlackbox = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API do BlackBox
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-blackbox?texto=${textoBlackbox}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do BlackBox: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`üö® Erro: ${data.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do BlackBox. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do BlackBox:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;

case 'lumin':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma consulta para o Lumin.');
  }

  const queryLumin = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API do Lumin
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-lumin?query=${queryLumin}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do Lumin: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`üö® Erro: ${data.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do Lumin. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Lumin:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;
  case 'wwdgpt':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma consulta para o WWDGPT.');
  }

  const promptWWDGPT = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API do WWDGPT
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-wwdgpt?prompt=${promptWWDGPT}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do WWDGPT: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`üö® Erro: ${data.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do WWDGPT. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do WWDGPT:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;

case 'letmegpt':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma consulta para o LetMeGPT.');
  }

  const queryLetMeGPT = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API do LetMeGPT
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-letmegpt?query=${queryLetMeGPT}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do LetMeGPT: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`üö® Erro: ${data.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do LetMeGPT. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do LetMeGPT:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;

case 'iasimi':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma consulta para o SimSimi.');
  }

  const querySimsimi = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API do SimSimi
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-simsimi?query=${querySimsimi}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do SimSimi: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`üö® Erro: ${data.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do SimSimi. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do SimSimi:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;


  case 'gpt4-o':
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma pergunta para o GPT-4-O.');
  }

  const textoGpt4O = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisi√ß√£o para a API do GPT-4-O
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-gpt4-o?texto=${textoGpt4O}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `üó£Ô∏è Resposta do GPT-4-O: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`üö® Erro: ${data.mensagem}`);
    } else {
      reply("üö® N√£o consegui obter a resposta do GPT-4-O. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GPT-4-O:", error);
    reply("üö® N√£o foi poss√≠vel, tente novamente mais tarde.");
  }
  break;
case 'gerarimg': // by luanzin dev
  if (!args[1]) {
    return reply('üö® Por favor, forne√ßa uma descri√ß√£o para gerar uma imagem.');
  }

  const promptGerarImg = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetch(`https://api-ia.orbital.host/orbital/img-ai?prompt=${promptGerarImg}&model=v3`);
    const data = await response.json();
    
    if (data.url) {
      const imageBuffer = await getBuffer(data.url);
      blackmd.sendMessage(from, { image: imageBuffer, caption: `*Resultado para: _${args.slice(1).join(' ')}_*` }, { quoted: info });
    } else {
      reply("üö® N√£o consegui gerar a imagem.");
    }
  } catch (error) {
    console.error("Erro ao gerar a imagem:", error);
    reply("üö® N√£o foi poss√≠vel se conectar ao Orbital IA. Tente novamente mais tarde.");
  }
  break;
case 'crimg': case 'imagegpt': case 'mdj': case 'imageai':
setTimeout(() => {reagir(from, "üî∞")}, 300)
if(!isVip && !isChatOfc) return reply(enviar.msg.vip)
if(!q) return reply(`KD o t√≠tulo da pesquisa?`)
try {
const imageBuffer = await superimg(q)
blackmd.sendMessage(from, {image: imageBuffer}, {quoted: info})
} catch(e) {
console.log(e)
reply(`Erro`)
}
break

case 'photoleap': case 'midjourney':
if(!isVip && !isChatOfc) return reply(enviar.msg.vip)
try {
if(!q) return reply("O que voc√™ deseja criar atrav√©s de seu questionamento?");
reply(enviar.espere);
sendImage(from, `https://aemt.me/ai/text2img?text=${q}`, ``, seloctt)
} catch(e) {
console.log(e)
reply("Erro")
}
break

case 'jeff': case 'simi':
setTimeout(() => {reagir(from, "ü§ì")}, 300)
if(!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
if(!q) return reply(`Pergunte algo junto ao comando...`)
try {
datasimi = await fetchJson(`https://api.simsimi.vn/v1/simtalk`, {method: 'POST',
headers: {'content-type': "application/x-www-form-urlencoded"},
body: "text="+q+"&lc=pt"})
return reply(datasimi.message)
} catch (e){
return reply("Resposta n√£o encontrada..")
}
break

case 'katy':
setTimeout(() => {reagir(from, "üòç")}, 300)
if(!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
if(!q) return reply(`Pergunte algo junto ao comando...`)
try {
datasimi = await fetchJson(`https://api.simsimi.vn/v1/simtalk`, {method: 'POST',
headers: {'content-type': "application/x-www-form-urlencoded"},
body: "text="+q+"&lc=pt"})
const gtts = require('./armor/funcoes/gtts')(`pt`)
dtt = datasimi.message
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
gtts.save(ranm, dtt, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
blackmd.sendMessage(from, {audio: fs.readFileSync(ranm), ptt:true, mimetype: "audio/mp4"}, {quoted: seloctt}).catch(e => {
return reply("Erro..")
})
DLT_FL(ranm)
DLT_FL(rano)
})
})
} catch (e){
return reply("Resposta n√£o encontrada..")
}
break

case 'simih':
if(!isOwner) return reply("Indispon√≠vel")
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isSimi) return reply('O modo Simi est√° ativo')
dataGp[0].simi1 = true
setGp(dataGp)
reply('Ativado com sucesso o modo simi neste grupo üòó..')
} else if(Number(args[0]) === 0) {
if(!isSimi) return reply('J√° est√° Desativado.')
dataGp[0].simi1 = false
setGp(dataGp)
reply('Desativado modo simi com sucesso neste grupo üò°Ô∏è')
} else {
reply('1 para ativar, 0 para desativar, lerdao vc em KKKKK')
}
break

case 'simih2':
if(!isOwner) return reply("Indispon√≠vel")
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isSimi2) return reply('O modo Simi est√° ativo')
dataGp[0].simi2 = true
setGp(dataGp)
reply('Ativado com sucesso o modo simi neste grupo üòó..')
} else if(Number(args[0]) === 0) {
if(!isSimi2) return reply('J√° est√° Desativado.')
dataGp[0].simi2 = false
setGp(dataGp)
reply('Desativado modo simi com sucesso neste grupo üò°Ô∏è')
} else {
reply('1 para ativar, 0 para desativar, lerdao vc em KKKKK')
}
break

case 'autofigu': case 'autosticker':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAutofigu) return reply('Ja esta ativo')
dataGp[0].autosticker = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de auto figurinhas neste grupo üìù')
} else if(Number(args[0]) === 0) {
if(!isAutofigu) return reply('Ja esta Desativado')
dataGp[0].autosticker = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de auto figurinhas neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'autoaudio': case 'autotranscricao':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAutoTranscricao) return reply('Ja esta ativo')
dataGp[0].autotranscricao = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de auto transcri√ß√£o neste grupo üìù')
} else if(Number(args[0]) === 0) {
if(!isAutoTranscricao) return reply('Ja esta Desativado')
dataGp[0].autotranscricao = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de auto transcri√ß√£o neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break


case 'autoresposta':
setTimeout(() => {reagir(from, "üîä")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply(`${prefix+command} 1 / ${prefix+command} 0`)
if(Number(args[0]) === 1) {
if(isAutorepo) return reply('Ja esta ativo')
dataGp[0].autoresposta = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de auto resposta neste grupo üìù')
} else if(Number(args[0]) === 0) {
if(!isAutorepo) return reply('Ja esta Desativado')
dataGp[0].autoresposta = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de auto resposta neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'modozoeira':
case 'modozueira':
setTimeout(() => {reagir(from, "ü§™")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins && !isOwner) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply(`${prefix+command} 1 / ${prefix+command} 0`)
if(Number(args[0]) === 1) {
if(isModobn) return reply('o modozoeira j√° est√° ativo')
dataGp[0].jogos = true
setGp(dataGp)
reply('üéØ Ativou com sucesso o recurso de Modo zoeira neste grupo ü™Ä')
} else if(Number(args[0]) === 0) {
if(!isModobn) return reply('o modozoeira j√° est√° Desativado')
dataGp[0].jogos = false
setGp(dataGp)
reply('üéØ Desativou com sucesso o recurso de Modo zoeira neste grupo ü™Ä')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'rank':
case 'ranklevel':
case 'rankpatente':
if(!isGroup) return reply(enviar.msg.grupo)
setTimeout(() => {reagir(from, "üëë")}, 300)
if(!isLevelingOn) return reply(`*√â necess√°rio ativar o sistema de level primeiro* üôÜüèª‚Äç‚ôÇÔ∏è
*Use* ${prefix}leveling 1`)
if(level.length > 4) {
matheuzinho = level.map(i => i)
rank = matheuzinho.sort((a, b) => (a.contador < b.contador) ? 0 : -1)
if(level.length > 10) {
var totalR = 10
} else {
var totalR = level.length
}
txt = `‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà üî≠ ùöÅùô∞ùôΩùô∫ ùôªùô¥ùöÖùô¥ùôª üî≠ ‚ñà‚ñá‚ñÜ‚ñÖ‚ñÑ‚ñÉ‚ñÇ‚ñÅ`
for ( i = 0; i < totalR; i++) {
  if(i != null) {
    data = levelDBuser(rank[i].id)
txt += `

‚ïì‚îÄ‚îÅ‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚îÅ‚îÄ‚îí
‚î¢‚ïï\t\t\tüéÆ ${NomeDoBot} üéÆ
‚ïΩ‚ïü ~>„Äé ¬ª${i+1}¬´ „Äè
‚ïΩ‚ïü ‚Ä¢ …¥…™·¥Ñ·¥ã: ${getname(data.id)}
‚ïΩ‚ïü ‚Ä¢ …™·¥Ö: wa.me/${data.id.split('@')[0]}
‚ïΩ‚ïü ‚Ä¢  ü·¥á·¥†·¥á ü: ${data.level}
‚ïΩ‚ïü ‚Ä¢ ·¥ò·¥Ä·¥õ·¥á…¥·¥õ·¥á: ${patente(data.contador)}
‚ïΩ‚ïü ‚Ä¢ x·¥ò: ${data.contador}
‚îï‚ï®‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚îö`
}
}
caixa = []
for ( i = 0; i < level.length; i++) {
  caixa.push({id: rank[i].id})
}
AB = caixa.map(i => i.id).indexOf(sender)
txt += `\n\n${AB > 9 ? `‚Ä¢ Íú±·¥ú·¥Ä ·¥©·¥èÍú±…™√ß√£·¥è …¥·¥è  Ä·¥Ä…¥·¥ã ~> ${AB + 1}\n` : ``}üÑ±üÖà: ${NickDono}`
reply(txt)
} else { reply(`Sem dados ü§∑üèª‚Äç‚ôÇÔ∏è`) }
break

case 'top10': case 'rank10':
mapa = level.map(i => i)
rank = mapa.sort((a, b) => (a.contador < b.contador) ? 0 : -1)
img = site+`/api/canvas/top?message=${encodeURI("XP:")}&fundo=https://telegra.ph/file/67d9c49eecc1cd1fcd637.jpg`
try { usu1 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[0].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu1 = semfoto }
try { usu2 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[1].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu2 = semfoto }
try { usu3 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[2].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu3 = semfoto }
try { usu4 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[3].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu4 = semfoto }
try { usu5 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[4].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu5 = semfoto }
try { usu6 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[5].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu6 = semfoto }
try { usu7 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[6].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu7 = semfoto }
try { usu8 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[7].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu8 = semfoto }
try { usu9 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[8].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu9 = semfoto }
try { usu10 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[9].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu10 = semfoto }
foto = [usu1, usu2, usu3, usu4, usu5, usu6, usu7, usu8, usu9, usu10]
for(i = 0; i < 10; i++) {
  if(i != null) {
    usu = rank[i]
    nmr = String(i + 1)
    img += `&foto${nmr}=${foto[i]}&nome${nmr}=${encodeURI(getname(usu.id))}&xp${nmr}=${usu.contador}`
  }
}
sendImage(from, img)
break

case 'top1': case 'rank1':
mapa = level.map(i => i)
rank = mapa.sort((a, b) => (a.contador < b.contador) ? 0 : -1)
img = site+`/api/canvas/top?message=${encodeURI("XP:")}&fundo=https://telegra.ph/file/67d9c49eecc1cd1fcd637.jpg`
try { usu1 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[0].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu1 = semfoto }
try { usu2 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[1].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu2 = semfoto }
try { usu3 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[2].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu3 = semfoto }
try { usu4 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[3].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu4 = semfoto }
try { usu5 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[4].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu5 = semfoto }
try { usu6 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[5].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu6 = semfoto }
try { usu7 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[6].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu7 = semfoto }
try { usu8 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[7].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu8 = semfoto }
try { usu9 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[8].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu9 = semfoto }
try { usu10 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[9].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu10 = semfoto }
foto = [usu1, usu2, usu3, usu4, usu5, usu6, usu7, usu8, usu9, usu10]
for(i = 0; i < 10; i++) {
  if(i != null) {
    usu = rank[i]
    nmr = String(i + 1)
    img += `&foto${nmr}=${foto[i]}&nome${nmr}=${encodeURI(getname(usu.id))}&xp${nmr}=${usu.contador}`
  }
}
sendStickerFromUrl(from, img)
break

case 'patente':
case 'level':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isLevelingOn) return reply(`*√â necess√°rio ativar o sistema de level primeiro* üôÜüèª‚Äç‚ôÇÔ∏è
*Use* ${prefix}leveling 1`)
if(isYouInLevel(sender)) {
levelstts = levelDBuser(sender)
myexp = levelstts.contador
newpatente = patente(myexp)

AB = dbpt.map(d => d.pat).indexOf(newpatente)
newtt = myexp < 10000000 ? myexp < 5000000 ? dbpt[AB].nmr : 5000000 : myexp
newcont = myexp < 10000000 ? myexp < 5000000 ? dbpt[AB + 1].nmr : 10000000 : myexp

matheuzinho = level.map(i => i)
rank = matheuzinho.sort((a, b) => (a.contador < b.contador) ? 0 : -1)

bar = myexp < 10000000 ? barrinha((myexp - newtt), (newcont - newtt)) : ""
sub = newcont - myexp
//==========reply===========\\
leveltxt = `‚îè‚îÄ‚îÄ‚îÅ‚îÅ‚ó§ ùôªùô¥ùöÖùô¥ùôªùô∏ùôΩùô∂ ‚ó¢‚îÅ‚îÅ‚îÄ‚îÄ‚îì
‚ïΩ
‚ïü‚îì
‚ïë‚î¢ ùôΩùô∏ùô≤ùô∫: ${pushname}
‚ïë‚ïΩ
‚ïë‚î¢ ùôªùô¥ùöÖùô¥ùôª: ${levelstts.level}
‚ïë‚ïΩ
‚ïë‚î¢ ùôøùô∞ùöÉùô¥ùôΩùöÉùô¥: ${newpatente}
‚ïë‚ïΩ
‚ïë‚î¢ ùöáùôø: ${myexp} ${myexp < 10000000 ? `-> ${newcont}` : ``}
‚ïë‚ïΩ${myexp < 10000000 ? `${bar}\n‚ïë‚ïΩ` : ``}
‚ïô‚î∑‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÄ‚îÄ‚îÄ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ${myexp < 10000000 ? `\n_Falta${Number(sub) > 1 ? `m` : ``} ${sub} XP para upar o pr√≥ximo level_` : `_Voc√™ alcan√ßou a patente m√°xima_`}`
a1 = levelstts.level
a2 = (rank.map(i => i.id).indexOf(sender)) + 1
a3 = myexp
a4 = myexp < 10000000 ? newcont : myexp
a5 = Number(myexp < 10000000 ? (((myexp - newtt) / (newcont - newtt)) * 100) : 100).toFixed(0)
} else {
leveltxt = `‚îè‚îÄ‚îÄ‚îÅ‚îÅ‚ó§ ùôªùô¥ùöÖùô¥ùôªùô∏ùôΩùô∂ ‚ó¢‚îÅ‚îÅ‚îÄ‚îÄ‚îì
‚ïΩ
‚ïü‚îì
‚ïë‚î¢ ùôΩùô∏ùô≤ùô∫: ${pushname}
‚ïë‚ïΩ
‚ïë‚î¢ ùôªùô¥ùöÖùô¥ùôª: 1
‚ïë‚ïΩ
‚ïë‚î¢ ùôøùô∞ùöÉùô¥ùôΩùöÉùô¥: Bronze I ü•â
‚ïë‚ïΩ
‚ïë‚î¢ ùöáùôø: 0
‚ïë‚ïΩ
‚ïô‚î∑‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÄ‚îÄ‚îÄ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ`
a1 = 0
a2 = level.length + 1
a3 = 0
a4 = 100
a5 = 0
}
try { ppimg = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image'))}`)).data
} catch(e) { ppimg = semfoto }
img = `https://blacksystemofc.com.br/api/canvas/musicardbun/level?nome=${encodeURI(pushname)}&level=${a1}&brightness=100&perfil=${ppimg}&rank=${a2}&xpb=${a3}&xpa=${a4}&progresso=${a5}`
sendImage(from, img, leveltxt, seloctt)
break

case 'patentes':
if(!isLevelingOn) return reply(`*√â necess√°rio ativar o sistema de level primeiro* üôÜüèª‚Äç‚ôÇÔ∏è
*Use* ${prefix}leveling 1`)
setTimeout(() => {reagir(from, react2)}, 300)
reply(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚îÅ‚îÅ‚îÄ‚îÄ${dbpt.map(i => `
‚ïü ‚Ä¢ ${i.pat}
‚ïö‚ïê‚ï¶‚îÄ ‚Ä¢ ${i.xp} XP ‚ú®`).join(`
‚îÄ‚îÅ‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚îÅ‚îÅ‚îÄ‚îÄ`)}
‚îÄ‚îÅ‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚îÅ‚îÅ‚îÄ‚îÄ`)
break

case 'addlevel':
if(!isOwner) return reply(enviar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Digite o n√∫mero do usu√°rio e a quantidade de level que deseja adicionar
Ex: ${prefix+command} ${addNumberMais(sender)}/2`)
var [a, b] = q.split(`/`)
usu = rmLetras(a) === "me" ? sender : identArroba(a)
if(!isYouInLevel(usu)) return reply(enviar.msg.notusu)
if(Number(b) <= 0) return reply(`O n√∫mero precisa ser maior que 0...`)
if(b.includes(".")) return reply("N√£o pode n√∫mero decimal")
addlevel(usu, b)
reply(`${b} leve${Number(b) > 1 ? `is` : `l`} adicionado${Number(b) > 1 ? `s` : ``} a este usu√°rio...`)
break

case 'tirarlevel':
if(!isOwner) return reply(enviar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Digite o n√∫mero do usu√°rio e a quantidade de level que deseja remover
Ex: ${prefix+command} ${addNumberMais(sender)}/2`)
var [a, b] = q.split(`/`)
usu = rmLetras(a) === "me" ? sender : identArroba(a)
if(!isYouInLevel(usu)) return reply(enviar.msg.notusu)
if(Number(b) <= 0) return reply(`O n√∫mero precisa ser maior que 0...`)
if(b.includes(".")) return reply("N√£o pode n√∫mero decimal")
rmlevel(usu, b)
reply(`${b} leve${Number(b) > 1 ? `is` : `l`} retirado${Number(b) > 1 ? `s` : ``} deste usu√°rio...`)
break

case 'addxp':
if(!isOwner) return reply(enviar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Digite o n√∫mero do usu√°rio e a quantidade de XP que deseja adicionar
Ex: ${prefix+command} ${addNumberMais(sender)}/2`)
var [a, b] = q.split(`/`)
usu = rmLetras(a) === "me" ? sender : identArroba(a)
if(!isYouInLevel(usu)) return reply(enviar.msg.notusu)
if(Number(b) <= 0) return reply(`O n√∫mero precisa ser maior que 0...`)
if(b.includes(".")) return reply("N√£o pode n√∫mero decimal")
addXP(usu, b)
reply(`${b} experi√™ncia${Number(b) > 1 ? `s` : ``} fo${Number(b) > 1 ? `ram` : `i`} adicionada${Number(b) > 1 ? `s` : ``} a este usu√°rio...`)
break

case 'tirarxp':
if(!isOwner) return reply(enviar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Digite o n√∫mero do usu√°rio e a quantidade de XP que deseja adicionar
Ex: ${prefix+command} ${addNumberMais(sender)}/2`)
var [a, b] = q.split(`/`)
usu = rmLetras(a) === "me" ? sender : identArroba(a)
if(!isYouInLevel(usu)) return reply(enviar.msg.notusu)
if(Number(b) <= 0) return reply(`O n√∫mero precisa ser maior que 0...`)
if(b.includes(".")) return reply("N√£o pode n√∫mero decimal")
rmXP(usu, b)
reply(`${b} experi√™ncia${Number(b) > 1 ? `s` : ``} fo${Number(b) > 1 ? `ram` : `i`} retirada${Number(b) > 1 ? `s` : ``} deste usu√°rio...`)
break

case 'blocklevel':
if(!isOwner) return reply(enviar.msg.dono)
if(!marc_tds) return reply("Marque a pessoa que deseja bloquear do contador")
if(isBlockGetLevelUser(marc_tds)) return reply("Este usu√°rio j√° est√° bloqueado...")
blockLevelUser(marc_tds);
reply("‚úÖ Usu√°rio bloqueado do contador com sucesso... As intera√ß√µes do mesmo n√£o ser√£o mais contabilizadas üî∞")
break

case 'unblocklevel':
if(!isOwner) return reply(enviar.msg.dono)
if(!marc_tds) return reply("Marque a pessoa que deseja bloquear do contador")
if(!isBlockGetLevelUser(marc_tds)) return reply("Este usu√°rio n√£o est√° bloqueado...")
unBlockLevelUser(marc_tds);
reply("‚úÖ Usu√°rio desbloqueado do contador com sucesso... As intera√ß√µes do mesmo voltar√£o a serem contabilizadas üî∞")
break

case 'blocklevel-list': case 'blocklevellist':
if(!isOwner) return reply(enviar.msg.dono)
txt = `[ ‚ùó ]  *Lista de usu√°rios bloqueados do contador de XP:*\n`
let blocklevellist = 0
for(i = 0; i < level.length; i++) {
  if(level[i].block) {
    txt += `‚áí @${level[i].id.split('@')[0]}\n`
    blocklevellist += 1
  }
}
txt += `\n‚ô®Ô∏è Total: ${blocklevellist}`
if(blocklevellist > 0) return mention(txt)
reply("N√£o h√° usu√°rios bloqueados")
break

case 'execdblevel':
if(!isOwner && !isnit && !info.key.fromMe) return reply('```SOMENTE MEU DONO LIND√ÉO```')
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
alllevel = []
for(a of allGroups) {for(b of a.participants) {alllevel.push(b.id)}}
endlevel = []
ttl = level.length
adc = 0
for(c of level) {if(isJsonIncludes(alllevel, c.id)) {adc += 1
endlevel.push(c)}}
sub = ttl - adc
if(sub <= 0) return reply(`Todos os users do level est√£o nos grupos com o bot...`)
saveLeVeLdb(endlevel);
reply(sub > 1 ? `Foram encontrados/removidos do sistema de leveling ${sub} usu√°rios que n√£o estavam presentes em nenhum grupo com o bot...` : `1 √∫nico usu foi deletado... Nem sei quem era kkkk`)
break

case 'rmlevel':
if(!isOwner) return reply(enviar.msg.dono)
if(!marc_tds) return reply("Marque a pessoa que deseja apagar do contador")
if(!JSON.stringify(level).includes(marc_tds)) return reply("Este usu√°rio n√£o est√° no contador...")
AB = level.map(i => i.id).indexOf(marc_tds)
level.splice(AB, 1)
saveLeVeLdb(level);
reply("‚úÖ Usu√°rio apagado do contador com sucesso...")
break

case 'transferirlevel': case 'trfrlv':
if(!isOwner) return reply(enviar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Este comando √© para transferir o level e XP do n√∫mero antigo de um usu√°rio para o seu novo n√∫mero... Retorne ap√≥s o comando o n√∫mero antigo do usu√°rio, e o seu novo n√∫mero, separando ambos com uma barra ( / ), ex:
${prefix+command} ${addNumberMais(botNumber)}/${addNumberMais(randomUser)}`)
usu1 = identArroba(q.split(`/`)[0])
usu2 = identArroba(q.split(`/`)[1])
if(!isYouInLevel(usu1)) return mention(`O usu√°rio @${usu1.split("@")[0]} n√£o est√° na database do level...`)
if(!isYouInLevel(usu2)) return mention(`O usu√°rio @${usu2.split("@")[0]} n√£o est√° na database do level...`)
lv = levelDBuser(usu1).level
cntd = levelDBuser(usu1).contador
addlevel(usu2, lv)
addXP(usu2, cntd)
AB = level.map(i => i.id).indexOf(usu1)
level.splice(AB, 1)
saveLeVeLdb(level)
mention(`Todos os ${lv} leveis e ${cntd} XP foram transferidos para o usu√°rio @${usu2.split("@")[0]} com sucesso ‚úî`)
break

case 'leveling':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('Ative pressione 1, Desativar pressione 0')
if(Number(args[0]) === 1) {
if(isLevelingOn) return reply('*O recurso de n√≠vel j√° estava ativo antes*')
dataGp[0].level = true
setGp(dataGp)
reply(enviar.levelon) 
} else if(Number(args[0]) === 0) {
if(!isLevelingOn) return reply(`O recurso de level j√° est√° Desativado neste grupo.`)
dataGp[0].level = false
setGp(dataGp)
reply(enviar.leveloff)
} else {
reply('*[ Adicionar par√¢metro 1 ou 0 ]*')
}
break

case 'gerarcard':
if(!isOwner) return reply(enviar.msg.dono)
var [i, v, d] = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/").split("/")
if(!i) return reply(`Marque com @ o usu√°rio que vc quer adc o card`)
usu = i.toLowerCase() == "me" ? sender : identArroba(i)
if(!v || !isJsonIncludes(valoresXP, v.toLowerCase())) return reply(`Voc√™ deve retornar ap√≥s o comando, o multiplicador de XP, entre os abaixo:
${valoresXP.map(a => `‚Ä¢ ${a.velocidade}`).join(`\n`)}

Exemplo: ${prefix+command} @/${valoresXP[alerandom(valoresXP.length)].velocidade}`)
AB = valoresXP.map(p => p.velocidade).indexOf(v.toLowerCase())
if(!d) return reply(`Ainda falta escolher o tempo... Ex: @/2x/24h`)
nmr = Number(d.slice(0, d.length - 1))
letra = d.slice(d.length - 1, d.length).toLowerCase()
if(letra == `d`) vzs = 24
else vzs = 1
nmr *= vzs
if(!d || !isJsonIncludes(valoresXP[AB].dados, Number(nmr))) return reply(`Voc√™ deve retornar ap√≥s o multiplicador de XP, a quantidade de dias do card, entre os abaixo:
${valoresXP[AB].dados.map(a => `‚Ä¢ ${sendLetterTime(a.tempo)}`).join}

Exemplo: ${prefix+command} @/2x/48h`)
addUsuCardXP(mention, prefix, usu, v, d)
break

case 'gerarkeycard': {
if(!isOwner) return reply(enviar.msg.dono)
var [v, d] = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/").split("/")
if(!v || !isJsonIncludes(valoresXP, v.toLowerCase())) return reply(`Voc√™ deve retornar ap√≥s o comando, o multiplicador de XP, entre os abaixo:
${valoresXP.map(a => `‚Ä¢ ${a.velocidade}`).join(`\n`)}

Exemplo: ${prefix+command} ${valoresXP[alerandom(valoresXP.length)].velocidade}`)
AB = valoresXP.map(p => p.velocidade).indexOf(v.toLowerCase())
if(!d) return reply(`Ainda falta escolher o tempo... Ex: 2x/24h`)
nmr = Number(d.slice(0, d.length - 1))
letra = d.slice(d.length - 1, d.length).toLowerCase()
if(letra == `d`) vzs = 24
else vzs = 1
nmr *= vzs
if(!isJsonIncludes(valoresXP[AB].dados, Number(nmr))) return reply(`Voc√™ deve retornar ap√≥s o multiplicador de XP, a quantidade de dias do card, entre os abaixo:
${valoresXP[AB].dados.map(a => `‚Ä¢ ${sendLetterTime(a.tempo)}`).join}

Exemplo: ${prefix+command} 2x/48h`)
let { key } = await blackmd.sendMessage(from, {text: `üé≤ *_KEY GERADA COM SUCESSO_* üé≤`}, {quoted: info})
await sleep(1500)
gerarTypeKey(sender, {type: 5, grupo: from, tempo: d, velocidade: v.toLowerCase()})
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
await sleep(500)
blackmd.sendMessage(from, {text: `${chave}`, edit: key}, {quoted: info})
await sleep(500)
sendMess(from, `üé≥ *_Descri√ß√£o ‚§µ_*
„ÄîüéØ„Äï‚•≤ *Tipo:* "CARD XP"
„Äî‚è±„Äï‚•≤ *Tempo:* ${Number(d.slice(0, d.length - 1)) > 0 ? d : `‚àû INFINITO`}`)
await sleep(500)
blackmd.sendMessage(from, {text: `Copie essa chave ou encaminhe ao privado do cliente ‚úî`}, {quoted: {
  key: {
    fromMe: false,
    participant: botNumber
  },
  message: {
    conversation: chave
  }
}})
}
break

case 'buycard':
addCardExperience(sender)
var [v, d] = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/").split("/")
if(!isJsonIncludes(valoresXP, v.toLowerCase())) return reply(`Voc√™ deve retornar ap√≥s o comando, o multiplicador de XP, entre os abaixo:
${valoresXP.map(a => `‚Ä¢ ${a.velocidade}`).join(`\n`)}

Exemplo: ${prefix+command} ${valoresXP[alerandom(valoresXP.length)].velocidade}`)
AB = valoresXP.map(p => p.velocidade).indexOf(v.toLowerCase())
if(!d) return reply(`Ainda falta escolher o tempo... Ex: 2x/24h`)
nmr = Number(d.slice(0, d.length - 1))
letra = d.slice(d.length - 1, d.length).toLowerCase()
if(letra == `d`) vzs = 24
else vzs = 1
nmr *= vzs
if(!isJsonIncludes(valoresXP[AB].dados, Number(nmr))) return reply(`Voc√™ deve retornar ap√≥s o multiplicador de XP, a quantidade de dias do card, entre os abaixo:
${valoresXP[AB].dados.map(a => `‚Ä¢ ${sendLetterTime(a.tempo)}`).join}

Exemplo: ${prefix+command} 2x/48h`)
AC = valoresXP[AB].dados.map(c => c.tempo).indexOf(nmr)
valor = valoresXP[AB].dados[AC].valor
if(getCoinsUsu(sender).saldo < valor) return reply(`üí≥ Um CARD XP *${v}* v√°lido por *${sendTimeHours(nmr)}* custar√° *R$ ${(valor).toFixed(2)}*, mas voc√™ n√£o possui saldo suficiente para completar a compra... Use o comando *${prefix}recarga* para adicionar saldo a saldo a sua conta e usufruir dos privil√©gios da loja üòÉüéØ`)
if(isGroup) reply(`Irei te enviar no PV üßµ`)
rmCoinsInVirtualBalance(sender, valor)
await sleep(1000)
gerarTypeKey(sender, {type: 5, grupo: from, tempo: sendLetterTime(nmr), velocidade: v.toLowerCase(), valor: valor})
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
sendButton(sender, {text: `üí° A chave "${chave}" foi gerada com sucesso... Copie e cole a mesma no seu grupo ou no PV do bot para validar o card e adicionar o seu combo multiplicador de XP üòä`, footer: chave}, blackmd, sender, [{type: `copy_text`, text: `CLIQUE AQUI`, url: chave}], seloctt)
break

case 'mycard':
addCardExperience(sender)
card = getCardXPusu(sender).cards
if(card.length <= 0) return reply(`Vc n√£o possui cards multiplicadores de XP... Caso queira adquirir algum, olhe no comando ${prefix}loja o que melhor de satisfazer üéØ`)
txt =
`üîñ *Seus cart√µes dispon√≠veis:*`
for(i = 0; i < card.length; i++) {
  txt += `\n\n¬ª${i + 1}¬´
‚Ä¢ *Multiplicador:* ${card[i].multi}x
‚Ä¢ *Tempo:* ${sendLetterTime(card[i].horas)}
‚Ä¢ *Ativo„Äé ${i == getCardXPusu(sender).mapa && getCardXPusu(sender).active ? "‚úÖ" : "‚ùå"} „Äè*`
}
txt += `\n\n*Total:* ${card.length > 0 ? card.length + `\n_(Use ${prefix}setcard para ativar seu cart√£o de XP)_` : card.length}`
reply(txt)
break

case 'setcard':
addCardExperience(sender)
usu = getCardXPusu(sender)
card = usu.cards
if(!Number(q) || Number(q) < 1 || Number(q) > card.length || q.includes(".")) return reply(`*Olhe no comando ${prefix}mycard o n√∫mero referente ao card que vc quer ativar, ex:*
${prefix+command} 1

Saiba tbm que, depois de ativado o card, n√£o h√° como ativar outro at√© que este acabe ‚ö†Ô∏è`)
if(usu.active) return reply("üíå *H√° um card ativo no momento... Espere o mesmo acabar primeiro para ativar outro* üîñ")
i = Number(q) - 1
usu.mapa = i
usu.active = true
usu.tempo = card[i].horas
saveCardXP()
reply(`üîñ *Seu Card ${card[i].multi}x v√°lido por ${sendLetterTime(card[i].horas)} foi ativado com sucesso* ‚úîÔ∏è`)
break

case 'bangp':
case 'unbangp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if(command == 'bangp'){
if(isBanchat) return reply(`Este grupo ja est√° banido`)
dataGp[0].bangp = true
setGp(dataGp)
reply(`üö´ *GRUPO BANIDO COM SUCESSO* üö´`)
} else {
if(!isBanchat) return reply(`Este grupo n√£o est√° banido`)
dataGp[0].bangp = false
setGp(dataGp)
reply(`‚úÖ *GRUPO DESBANIDO COM SUCESSO* ‚úÖ`)
}
break

case 'b':
case 'u':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if(command == 'b'){
if(isBanchat) return blackmd.sendMessage(sender, {text: `Este grupo ja est√° banido`}, {quoted: info})
dataGp[0].bangp = true
setGp(dataGp)
} else {
if(!isBanchat) return blackmd.sendMessage(sender, {text: `Este grupo n√£o est√° mais banido`}, {quoted: info})
dataGp[0].bangp = false
setGp(dataGp)
}
break

case 'boton':
case 'botoff':
if(!isOwner) return reply(enviar.msg.dono)
if(command == `botoff`) {
if(isBotoff) return reply(`O bot j√° est√° desligado...`)
setTimeout(() => {reagir(from, "‚ùå")}, 300)
obrigadoEXT.botoff = true
setObg(obrigadoEXT)
reply('‚ùå *Desligando todas as fun√ß√µes do BLACK*')
} else {
if(!isBotoff) return reply(`O bot j√° est√° ligado...`)
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
obrigadoEXT.botoff = false
setObg(obrigadoEXT)
reply(`‚úÖ *Religando todas as fun√ß√µes do BLACK*`)
}
break

case 'modo+18':
case 'modonsfw':
case 'nsfw':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('Hmmmm')
if(Number(args[0]) === 1) {
if(isNsfw) return reply('O modo nsfw j√° est√° ativo')
dataGp[0].nsfw = true
setGp(dataGp)
reply(`\`\`\`‚úìAtivado com sucesso o modo nsfw +18 no grupo\`\`\` *${groupMetadata.subject}*`)
} else if(Number(args[0]) === 0) {
if(!isNsfw) return reply('O modo nsfw j√° est√° Desativado')  
dataGp[0].nsfw = false
setGp(dataGp)
reply(`\`\`\`‚úìModo Nsfw +18 desativado com sucesso no grupo\`\`\` *${groupMetadata.subject}*`)
} else {
reply('1 para ativar, 0 para desligar')
}
break

case 'antipalavr√£o':
case 'antipalavrao':  
case 'antipalavra':    
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply(`[‚ùó] 1 / 0, Exemplo ${prefix + command} 1`)
if(Number(args[0]) === 1) {
if(isPalavrao) return reply('Ja esta ativo.')
dataGp[0].antipalavrao.active = true
setGp(dataGp)
reply('üåÄ Ativou com sucesso o recurso de Anti Palavras hardcore neste grupo üìù')
} else if(Number(args[0]) === 0) {
if(!isPalavrao) return reply('Ja esta Desativado')
dataGp[0].antipalavrao.active = false
setGp(dataGp)
reply('‚ÄºÔ∏è Desativou com sucesso o recurso de Anti Palavra harcore neste grupo‚úîÔ∏è')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'addpalavra':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isPalavrao) return reply('Anti palavr√£o desativado!')
if(args.length < 1) return reply( `Use assim : ${prefix + command} [palavr√£o]. exemplo ${prefix + command} puta`)
texto = args.join(' ').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "")
if(isPalavras.includes(texto)) return reply('J√° foi adicionada')
dataGp[0].antipalavrao.palavras.push(texto)
setGp(dataGp)
reply('Palavr√£o adicionado com sucesso!')
break

case 'delpalavra':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isPalavrao) return reply('Anti palavr√£o desativado!')
if(args.length < 1) return reply( `Use assim : ${prefix + command} [palavr√£o]. exemplo ${prefix + command} puta`)
texto = args.join(' ').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "")
if(!isPalavras.includes(texto)) return reply('J√° foi removida')
var i = dataGp[0].antipalavrao.palavras.indexOf(texto)
dataGp[0].antipalavrao.palavras.splice(i, 1)
setGp(dataGp)
reply('Palavr√£o removido da lista com sucesso!')
break

case 'listapalavr√£o': case 'listapalavra':
case 'listpalavra':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isPalavrao) return reply('Anti palavr√£o desativado!')
let lbw = `Esta √© a lista de palavr√£o\nTotal : ${isPalavras.length}\n`
for (let i of isPalavras) {
lbw += `‚û∏ ${i}\n`
}
await reply(lbw)
break

case 'limitecaracteres':
case 'limiteflood':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply(`Digite ${prefix + command} 1 para ativar`)
if(Number(args[0]) === 1) {
if(isAntiFlood) return reply(`üåÄ O recurso limite de caracteres j√° est√° ativo no grupo üåÄ`)
dataGp[0].limitec.active = true
setGp(dataGp)
reply(`‚úîÔ∏è O recurso limite de caracteres foi ativado nesse grupoüìù`)
} else if(Number(args[0]) === 0) {
 if(!isAntiFlood) return reply('‚úîÔ∏è O recurso limite de caracteres n√£o est√° ativado no grupo üìù')
dataGp[0].limitec.active = false
setGp(dataGp)
reply('O recurso limite de caracteres foi desativado nesse grupo ‚úîÔ∏è')
} else {
reply(`Digite ${prefix + command} 1 para ativar, 0 para desativar o recurso`)
}
break

case 'limitecglobal':
case 'limitec':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isAntiFlood) return reply(`Ative este recurso primeiro ${prefix}limiteflood 1`)
if(!q) return reply(`Cade a quantidade? Ex: ${prefix + command} 5000`)
if(isNaN(q) == true) return reply('Digite apenas n√∫meros')
if(command == 'limitec'){
dataGp[0].limitec.quantidade = q
setGp(dataGp)
reply(`Foi alterado o limite de caracteres para: ${q}`)
} else {
if(!isOwner) return reply(enviar.msg.dono)
var data = { limitefl: q }
fs.writeFileSync('./database/usuarios/flood.json', JSON.stringify(data, null, '\t'))
reply(`Foi adicionado um limite global de caracteres de: ${q}`)
}
break

case 'status': case 'stts':
  setTimeout(() => {reagir(from, "‚ùî")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
txt =
`„Ö§„Ö§„Äò Ôº≥Ôº¥Ôº°Ôº¥ÔºµÔº≥ „Äô
‚ï≠‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïØ
‚îÇ
‚îÇ‚áí Anti Imagem: ${isAntiImg ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti V√≠deo: ${isAntiVid ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti √Åudio: ${isAntiAudio? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti Sticker: ${isAntiSticker ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti Documento: ${Antidoc ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti Contato ${isAntiCtt ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti Localiza√ß√£o: ${Antiloc ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti Link Grupo: ${isAntilinkgp ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti BAN Link Grupo: ${!isBanlinkgp ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti Link Hard: ${isAntiLinkHard ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti BAN Link Hard: ${!isBanLinkHard ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti Fake: ${isAntifake ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti Notas: ${isAntiNotas ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti Catalogo: ${isAnticatalogo ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti Palavr√£o: ${isPalavrao ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Limite Caracteres: ${isAntiFlood ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Bem Vindo 1: ${isWelkom ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Bem Vindo 2: ${isWelkom2 ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Bem Vindo 3: ${isWelkom3 ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Bem Vindo 4: ${isWelkom4 ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Bem Vindo 5: ${isWelkom5 ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Auto Aceita√ß√£o: ${isAcceptGroup ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Simi 1: ${isSimi ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Simi 2: ${isSimi2 ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Auto Sticker: ${isAutofigu ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Auto Resposta: ${isAutorepo ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Modo Zoeira: ${isModobn ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Modo RPG: ${isBlackCity ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Level: ${isLevelingOn ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Modo +18: ${isNsfw ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti Liga√ß√£o: ${isAnticall ? '‚úÖ' : '‚ùå'}
‚îÇ‚áí Anti PV Block: ${isAntiPv ? '‚úÖ' : '‚ùå'}
‚îÇ
‚ï∞‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïÆ`
blackmd.sendMessage(from, {image: {url: logoslink.logo}, caption: txt}, {quoted: seloctt})
break

case 'reiniciar': case 'rr': {//adapted by math
if(!isOwner) return
var carregar = [
`[ ‚ùó ] Reiniciando meus sistemas em 5Ô∏è‚É£`,
`[ ‚ùó ] Reiniciando meus sistemas em 4Ô∏è‚É£`,
`[ ‚ùó ] Reiniciando meus sistemas em 3Ô∏è‚É£`,
`[ ‚ùó ] Reiniciando meus sistemas em 2Ô∏è‚É£`,
`[ ‚ùó ] Reiniciando meus sistemas em 1Ô∏è‚É£`,
`[ ‚ùó ] Reiniciando meus sistemas em 0Ô∏è‚É£`,
`~_*¬© black system*_~`
]
let { key } = await blackmd.sendMessage(from, {text: tempo+" "+pushname}, {quoted: info})//primeira mensagem
await sleep (1000)
for(let i = 0; i < carregar.length; i++) {
await sleep (1000)
await blackmd.sendMessage(from, {text: carregar[i], edit: key }, {quoted: info})
}
await sleep(1000)
process.exit()
}
break

//==========(Sticker-Stickers)===========\\

case 'emoji':
case 'semoji':
reagir(from, react2)
try {
if(!q.trim()) return reply(`Exemplo: ${prefix}emoji ü§î/whatsapp`)
var [emoji, nm] = q.split("/")
if(nm) {
var txtemoji = nm
} else {
var txtemoji = `whatsapp`
}
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/emoji?q=${emoji}/${txtemoji.toLowerCase()}&apikey=Yuta-Channel`)
sendStickerFromUrl(from, ABC.rst)
} catch {
return reply("Erro..")
}
break

case 'linktxt':
if(!q) return
reply(`${encodeURI(q)}`)
break

case 'wf': case 'fw': case 'qc': case 'wpp':
if(!q) return reply(`Oh, coloca um texto na frente do comando`)
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
tttt = q.includes('/') ? q.split('/')[1] : q
if(tttt.length > 50) return reply("Texto muito grande")
const text = q.includes('/') ? q.split('/')[1] : `${q}`

const username = menc_prt ? getname(menc_prt) : q.includes('/') ? getname(identArroba(q.split('/')[0])).replace("usu√°rio", q.split('/')[0]) : pushname

fotousu = menc_prt ? menc_prt : q.includes('/') ? Number(q.split('/')[0].replace("@", "").replace(new RegExp("[()+-/ +/]", "gi"), "")) ? q.split('/')[0].replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` : sender : sender

//IMAGEM DO PERFIL
try {
ppimg = await blackmd.profilePictureUrl(fotousu)
} catch {
ppimg = `https://telegra.ph/file/2a7516ef21d72cf8d9452.jpg`
}
//FIM IMAGEM DO PERFIL

//REQUIRES PRA FIGURINHA
const { writeExifImg } = require('./lib/exif')
//FIM DA REQUIERES

//DEFINI√á√ÉO FIGU
blackmd.sendImageAsSticker = async (jid, path, quoted, options = {}) => {
        let buff = Buffer.isBuffer(path) ? path : /^data:.*?\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\/\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0)
        let buffer
        if (options && (options.packname || options.author)) {
            buffer = await writeExifImg(buff, options)
        } else {
            buffer = await imageToWebp(buff)
        }

        await blackmd.sendMessage(jid, { sticker: { url: buffer }, ...options }, { quoted })
        return buffer
    }
//FIM DEFINI√á√ïES FIGU    
    
    
const avatar = `${ppimg}`

const json = {
  "type": "quote",
  "format": "png",
  "backgroundColor": "#000000",
  "width": 512,
  "height": 768,
  "scale": 2,
  "messages": [
    {
      "entities": [],
      "avatar": true,
      "from": {
        "id": 1,
        "name": username,
        "photo": {
          "url": avatar
        }
      },
      "text": text,
      "replyMessage": {}
    }
  ]
};
        const response = axios.post('https://bot.lyo.su/quote/generate', json, {
        headers: {'Content-Type': 'application/json'}
}).then(res => {
    const buffer = Buffer.from(res.data.result.image, 'base64')
        blackmd.sendImageAsSticker(from, buffer, info, { packname: permuteFigPackName(`‚Üë ùôéùôèùôÑùòæùôÜùôÄùôç ùòΩùôî`), author: permuteFigAuthorName(`${NomeDoBot} üìç`) })
});
break

case 'figfundo':
case 'figvideo':
case 'figusemfundo': 
case 'sfundo':
case 'sf':
setTimeout(() => {reagir(from, react2)}, 300)
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) {
rafa = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
aletxt = [`‚ñß‚ÉØ‚ÉüùöÅùöéùöñùöòùöüùöéùöóùöçùöò ùôµùöûùöóùöçùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`, `‚ñß‚ÉØ‚ÉüùöÅùöéùöùùöíùöõùöäùöóùöçùöò ùôµùöûùöóùöçùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`]
reply(aletxt[Math.floor(Math.random()*aletxt.length)])
buff = await getFileBuffer(rafa, 'image')
bas64 = `data:image/jpeg;base64,${buff.toString('base64')}`
anu = args.join(' ').split('|')
satu = anu[0] !== '' ? anu[0] : `üìçCriado por‚Üì`
sd = `${NomeDoBot}`
dua = typeof anu[1] !== 'undefined' ? anu[1] : `${sd}`
var mantap = await convertSticker(bas64, `${dua}`, `${satu}`)
var sti = new Buffer.from(mantap, 'base64');
blackmd.sendMessage(from, {sticker: sti}, {quoted: seloctt})
} else {
return reply(`So imagem mn -_-`)
}
break

case 'miih':
case 'mih':
case 'miihzinha':
reagir(from, "üíú")
if(!isQuotedSticker) return reply(`Marque uma figurinha com o comando...

> ${prefix+command}`)
encmediats = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
reply(`_De miihzinha_
_Para miihzinha_
_Pela miihzinha_ üëë

*Gerando figu...* üíú`)
bas01 = `data:image/jpeg;base64,${encmediats.toString('base64')}`
var mantap = await convertSticker(bas01, ` ‡∫ä`, `Ôº≠Ôº©Ôº©Ôº® `)
var sti = new Buffer.from(mantap, 'base64');
blackmd.sendMessage(from, {sticker: sti, contextInfo: { externalAdReply:{title: `·Éù√≠√≠’∞ s’¥’©…æ“Ω·ÉùŒ±c’æ üíúüß∏`,body:"", previewType:"PHOTO",thumbnail: sti}}}, {quoted: seloctt})
.catch((err) => {
reply(`‚ùå Erro, tenta mais tarde`); 
})
break

case 'flady':
case 'slady':
case 'fl':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
if(!isQuotedSticker) return reply(`Marque uma figurinha com o comando...

- ${prefix+command}`)
reply(`‚ñß‚ÉØ‚ÉüùöÅùöéùöóùöòùöñùöéùöäùöóùöçùöò ùöÇùöûùöä ùôµùöíùöêùöûùöõùöíùöóùöëùöäÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
renameContextSticker(permuteFigPackName(pushname), permuteFigAuthorName(NomeDoBot), `ROUBADA COM SUCESSO üòéüëçüèΩ`, info)
.catch((err) => {
reply(`‚ùå Erro, tenta mais tarde`); 
})
break

case 'rename':
case 'roubar':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
if(!isQuotedSticker) return reply('Marque uma figurinha...')
var kls = q
var pack = kls.split("/")[0];
var author2 = kls.split("/")[1];
if(!q) return reply('*Falta um nome para renomear a figurinha... ;-;*')
if(!pack) return reply(`*Necessita de um nome antes da barra ( / ), ex:*
${prefix+command} ${pushname+q}`)
if(!author2) return reply(`*Falta um complemento, ex:*
${prefix+command} ${q}/complemento`)
reply(`ùôøùöäùöåùöî ùôΩùöäùöñùöé: _"${pack.split(`\n`).join(`_\n_`)}"_
ùô∞ùöûùöùùöëùöòùöõ ùôΩùöäùöñùöé: _"${author2.split(`\n`).join(`_\n_`)}"_
-------------------------------------------------------------
‚ñß‚ÉØ‚ÉüùöÅùöéùöóùöòùöñùöéùöäùöóùöçùöò ùöÇùöûùöä ùôµùöíùöêùöûùöõùöíùöóùöëùöäÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
renameContextSticker(pack, author2, `${pack}|${author2}`, info)
.catch((err) => {
reply(`‚ùå Erro, tenta mais tarde`); 
})
break

/*case 'fblack':
case 'sblack':
case 'fb':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
if(!isQuotedSticker) return reply(`Marque uma figurinha com o comando...

- ${prefix+command}`)
encmediats = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
reply(`‚ñß‚ÉØ‚ÉüùöÅùöéùöóùöòùöñùöéùöäùöóùöçùöò ùöÇùöûùöä ùôµùöíùöêùöûùöõùöíùöóùöëùöäÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
bas01 = `data:image/jpeg;base64,${encmediats.toString('base64')}`
var mantap = await convertSticker(bas01, permuteFigAuthorName(pushname), permuteFigPackName(NomeDoBot))
var sti = new Buffer.from(mantap, 'base64');
blackmd.sendMessage(from, {sticker: sti, contextInfo: {externalAdReply: {title: `ROUBADA COM SUCESSO üòéüëçüèΩ`, body:"", previewType:"PHOTO", thumbnail: sti}}}, {quoted: seloctt})
.catch((err) => {
reply(`‚ùå Erro, tenta mais tarde`); 
})
break

case 'rename':
case 'roubar':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
if(!isQuotedSticker) return reply('Marque uma figurinha...')
encmediats = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
var kls = q
var pack = kls.split("/")[0];
var author2 = kls.split("/")[1];
if(!q) return reply('*Falta um nome para renomear a figurinha... ;-;*')
if(!pack) return reply(`*Necessita de um nome antes da barra ( / ), ex:*
${prefix+command} ${pushname+q}`)
if(!author2) return reply(`*Falta um complemento, ex:*
${prefix+command} ${q}/complemento`)
reply(`ùôøùöäùöåùöî ùôΩùöäùöñùöé: _"${pack}"_
ùô∞ùöûùöùùöëùöòùöõ ùôΩùöäùöñùöé: _"${author2}"_
-------------------------------------------------------------
‚ñß‚ÉØ‚ÉüùöÅùöéùöóùöòùöñùöéùöäùöóùöçùöò ùöÇùöûùöä ùôµùöíùöêùöûùöõùöíùöóùöëùöäÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
bas64 = `data:image/jpeg;base64,${encmediats.toString('base64')}`
var mantap = await convertSticker(bas64, `${author2}`, `${pack}`)
var sti = new Buffer.from(mantap, 'base64');
blackmd.sendMessage(from, {sticker: sti, contextInfo: { externalAdReply:{title: `${pack}|${author2}`,body:"", previewType:"PHOTO",thumbnail: sti}}}, {quoted: seloctt})
.catch((err) => {
reply(`‚ùå Erro, tenta mais tarde`); 
})
break*/

case 'ususticker': case 'us':
if(!isGroup) return mention(privateCmd(sender, prefix+command, `"n√£o encontrado"`, 0))
if(!menc_os2) return reply(`Marque a pessoa de quem voc√™ quer transformar a foto de perfil em figurinha...`)
///////////PEGAR A FOTO DO USU√ÅRIO/////////////
try {
fotoDePerfilDoMath = await blackmd.profilePictureUrl(`${menc_os2.split('@')[0]}@c.us`, 'image')
} catch {
return reply("Usu√°rio est√° sem foto de perfil ‚ùå")
}
//////////////GERAR LINK DA FOTO////////////////
try {
shortpc = await axios.get(`https://tinyurl.com/api-create.php?url=${fotoDePerfilDoMath}`);
matheuzinho = shortpc.data
} catch {
return reply("Falha ao tentar converter ‚ùå")
}
//////////////FAZER A FIGURINHA/////////////////
reply(`‚ù™‚àòÃ•‚Éü‚∏Ω‚Éüùô≤ùöòùöóùöüùöéùöõùöùùöéùöóùöçùöò ùô¥ùöñ ùôµùöíùöêùöûùöõùöíùöóùöëùöä‚àòÃ•‚Éü‡ß¥‚ñ∏`)
sendStickerFromUrl(from, matheuzinho)
break

case 'fstiker':
case 'fsticker':
case 'f':
reagir(from, "‚úÖ")
var RSM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var boij = RSM?.imageMessage || info.message?.imageMessage || RSM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSM?.viewOnceMessage?.message?.imageMessage
var boij2 = RSM?.videoMessage || info.message?.videoMessage || RSM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSM?.viewOnceMessage?.message?.videoMessage  
if(boij) {
var pack = permuteFigPackName(`‚ù™üë§ùöÑùöúùöû√°ùöõùöíùöò (ùöä)‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏
‚ù™ü§ñùô±ùöòùöù‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏
‚ù™üëëùô≥ùöòùöóùöò‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏
‚ù™üåêùöÇùöíùöùùöé‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏`)
var author2 = permuteFigAuthorName(`${pushname}
${NomeDoBot}
${NickDono}
${site}`)
reply(`‚ù™‚àòÃ•‚Éü‚∏Ω‚Éüùô≤ùöòùöóùöüùöéùöõùöùùöéùöóùöçùöò ùô¥ùöñ ùôµùöíùöêùöûùöõùöíùöóùöëùöä‚àòÃ•‚Éü‡ß¥‚ñ∏`)
owgi = await getFileBuffer(boij, 'image')
let encmediaa = await sendImageAsSticker(blackmd, from, owgi, info, { packname:pack, author:author2})
await DLT_FL(encmediaa)
} else if(boij2 && boij2?.seconds < 11) {
var pack = permuteFigPackName(`‚ù™üë§ùöÑùöúùöû√°ùöõùöíùöò (ùöä)‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏
‚ù™ü§ñùô±ùöòùöù‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏
‚ù™üëëùô≥ùöòùöóùöò‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏
‚ù™üåêùöÇùöíùöùùöé‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏`)
var author2 = permuteFigAuthorName(`${pushname}
${NomeDoBot}
${NickDono}
${site}`)
reply(`‚ù™‚àòÃ•‚Éü‚∏Ω‚Éüùô≤ùöòùöóùöüùöéùöõùöùùöéùöóùöçùöò ùô¥ùöñ ùôµùöíùöêùöûùöõùöíùöóùöëùöä‚àòÃ•‚Éü‡ß¥‚ñ∏`)
owgi = await getFileBuffer(boij2, 'video')
let encmedia = await sendVideoAsSticker(blackmd, from, owgi, info, { packname:pack, author:author2})
await DLT_FL(encmedia)
} else {
reply(`Marque uma imagem ou v√≠deo de at√© 10 segundos com o comando ${prefix+command}`)
}
break
case 'figurinha':
{
(async function () {
var legenda = q ? q?.split("/")[0] : `‚ïº‚ä≥‚ä∞ Solicitado Por:`
var autor = q ? q?.split("/")[1] : q?.split("/")[0] ? '' : `${pushname}`
if (isMedia && !info.message.videoMessage || isQuotedImage) {
var encmedia = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'image')
fs.writeFileSync(rane, buffimg)
rano = getRandom('.webp')
exec(`ffmpeg -i ${rane} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${rano}`, (err) => {
fs.unlinkSync(rane)
// "android-app-store-link": "https://play.google.com/store/search?q=%2B55%2094%209147-2796%20%F0%9F%94%A5%F0%9F%94%A5%F0%9F%94%A5%F0%9F%94%A5%F0%9F%94%A5&c=apps",
var json = {
"sticker-pack-name": legenda,
"sticker-pack-publisher": autor
}
var exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])
var jsonBuff = Buffer.from(JSON.stringify(json), "utf-8")
var exif = Buffer.concat([exifAttr, jsonBuff])
exif.writeUIntLE(jsonBuff.length, 14, 4)
let nomemeta = Math.floor(Math.random() * (99999 - 11111 + 1) + 11111)+".temp.exif"
fs.writeFileSync(`./${nomemeta}`, exif) 
exec(`webpmux -set exif ${nomemeta} ${rano} -o ${rano}`, () => {
blackmd.sendMessage(from, {sticker: fs.readFileSync(rano)}, {quoted: info})
fs.unlinkSync(nomemeta)
fs.unlinkSync(rano)
})
})
} else if (isMedia && info.message.videoMessage.seconds < 11 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 35) {
var encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
rano = getRandom('.webp')
await ffmpeg(`./${rane}`)
.inputFormat(rane.split('.')[1])
exec(`ffmpeg -i ${rane} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 200:200 ${rano}`, (err) => {
fs.unlinkSync(rane)
let json = {
"sticker-pack-name": legenda,
"sticker-pack-publisher": autor
}
let exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])
let jsonBuff = Buffer.from(JSON.stringify(json), "utf-8")
let exif = Buffer.concat([exifAttr, jsonBuff])
exif.writeUIntLE(jsonBuff.length, 14, 4)
let nomemeta = "temp.exif"
fs.writeFileSync(`./${nomemeta}`, exif) 
exec(`webpmux -set exif ${nomemeta} ${rano} -o ${rano}`, () => {
blackmd.sendMessage(from, {sticker: fs.readFileSync(rano)}, {quoted: info})
fs.unlinkSync(nomemeta)
fs.unlinkSync(rano)
})
})
} else {
reply(`Voc√™ precisa enviar ou marcar uma imagem ou v√≠deo com no m√°ximo 10 segundos`)
}
})().catch(e => {
console.log(e)
reply("Hmm deu erro")
try {
if (fs.existsSync("temp.exif")) fs.unlinkSync("temp.exif");
if (fs.existsSync(rano)) fs.unlinkSync(rano);
if (fs.existsSync(media)) fs.unlinkSync(media);
} catch {}
})
}
break
case 'st':
case 'stk':
case 'sticker':
case 's':
setTimeout(() => { reagir(from, "‚úÖ") }, 300)
var RSM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var boij2 = RSM?.imageMessage || info.message?.imageMessage || RSM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSM?.viewOnceMessage?.message?.imageMessage
var boij = RSM?.videoMessage || info.message?.videoMessage || RSM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSM?.viewOnceMessage?.message?.videoMessage

if (boij2) {
  var pack = permuteFigPackName(`‚ù™üë§ùöÑùöúùöû√°ùöõùöíùöò (ùöä)‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏`)
  var author2 = permuteFigAuthorName(`${pushname}`)
  owgi = await getFileBuffer(boij2, 'image')
  let encmediaa = await sendImageAsSticker2(blackmd, from, owgi, info, { packname: pack, author: author2 })
  await DLT_FL(encmediaa)
} else if (boij && boij.seconds < 11) {
  var pack = permuteFigPackName(`‚ù™üë§ùöÑùöúùöû√°ùöõùöíùöò (ùöä)‡∏∫‡£™`)
  var author2 = permuteFigAuthorName(`${pushname}`)
  owgi = await getFileBuffer(boij, 'video')
  let encmedia = await sendVideoAsSticker2(blackmd, from, owgi, info, { packname: pack, author: author2 })
  await DLT_FL(encmedia)
} else {
  return reply(`Marque uma imagem ou v√≠deo de at√© 10 segundos com o comando ${prefix + command}`)
}
break

case 'rgpackfig': case 'rgpf':
if(!isVip) return reply(enviar.msg.vip)
if(!q) return reply("KD o MOD \"pack\" da figurinha?")
if(isJsonIncludes(figname, sender)) {
  AB = figname.map(i => i.id).indexOf(sender)
  if(!isJsonIncludes(figname[AB].fig, "pack")) {
    figname[AB].fig.push({mod: "pack", pack: q})
    saveJSON(figname, "./basededados/figname.json")
    return reply(`*MOD "pack" da figurinha adicionado com sucesso* ‚úîÔ∏è`)
  } else {
    BC = figname[AB].fig.map(i => i.mod).indexOf("pack")
    figname[AB].fig[BC].pack = q
    saveJSON(figname, "./basededados/figname.json")
    return reply(`*MOD "pack" da figurinha alterado com sucesso* ‚úîÔ∏è`)
  }
} else {
  figname.push(
    {id: sender, fig: [
      {mod: "pack", pack: q}
      ]
    }  
  )
  saveJSON(figname, "./basededados/figname.json")
  return reply(`*MOD "pack" da figurinha adicionado com sucesso* ‚úîÔ∏è`)
}
break

case 'rgauthorfig': case 'rgaf':
if(!isVip) return reply(enviar.msg.vip)
if(!q) return reply("KD o MOD \"author\" da figurinha?")
if(isJsonIncludes(figname, sender)) {
  AB = figname.map(i => i.id).indexOf(sender)
  if(!isJsonIncludes(figname[AB].fig, "author")) {
    figname[AB].fig.push({mod: "author", author: q})
    saveJSON(figname, "./basededados/figname.json")
    return reply(`*MOD "author" da figurinha adicionado com sucesso* ‚úîÔ∏è`)
  } else {
    BC = figname[AB].fig.map(i => i.mod).indexOf("author")
    figname[AB].fig[BC].author = q
    saveJSON(figname, "./basededados/figname.json")
    return reply(`*MOD "author" da figurinha alterado com sucesso* ‚úîÔ∏è`)
  }
} else {
  figname.push(
    {id: sender, fig: [
      {mod: "author", author: q}
      ]
    }  
  )
  saveJSON(figname, "./basededados/figname.json")
  return reply(`*MOD "author" da figurinha adicionado com sucesso* ‚úîÔ∏è`)
}
break

case 'rmpackfig': case 'rmpf':
case 'rmauthorfig': case 'rmaf':
case 'rmfigall': case 'rmfa':
if(!isVip) return reply(enviar.msg.vip)
if(isJsonIncludes(figname, sender)) {
  AB = figname.map(i => i.id).indexOf(sender)
  if(command == "rmfigall" || command == "rmfa") {
    figname.splice(AB, 1)
    saveJSON(figname, "./basededados/figname.json")
    return reply(`*MOD's "pack" & "author" da figurinha deletados com sucesso* ‚úîÔ∏è`)
  } else if(command == "rmpackfig" || command == "rmpf") {
    txt = "pack"
  } else {
    txt = "author"
  }
  BC = figname[AB].fig.map(i => i.mod).indexOf(txt)
  if(BC < 0) return reply(`üé≤ *Voc√™ n√£o registrou o MOD "${txt}" da figurinha para deletar o mesmo* üìõ`)
  figname[AB].fig.splice(BC, 1)
  saveJSON(figname, "./basededados/figname.json")
  return reply(`*MOD "${txt}" da figurinha deletado com sucesso* ‚úîÔ∏è`)
} else reply("üé≤ *imposs√≠vel apagar um dado inexistente* üìõ")
break

case 's2':
setTimeout(() => {reagir(from, react2)}, 300)
if(!isVip) { reply(enviar.msg.vip)
return blackmd.sendMessage(from, {audio: {url:'./database/audios/sovip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
try {
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) { 
reply(`‚ù™‚àòÃ•‚Éü‚∏Ω‚Éüùô≤ùöòùöóùöüùöéùöõùöùùöéùöóùöçùöò ùô¥ùöñ ùôµùöíùöêùöûùöõùöíùöóùöëùöä‚àòÃ•‚Éü‡ß¥‚ñ∏`)
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
sendStickerFromUrl(from, {url: res})
} else if((isMedia && info.message.videoMessage.seconds < 10 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 10) && !q.length <= 1) { 
reply(`‚ù™‚àòÃ•‚Éü‚∏Ω‚Éüùô≤ùöòùöóùöüùöéùöõùöùùöéùöóùöçùöò ùô¥ùöñ ùôµùöíùöêùöûùöõùöíùöóùöëùöä‚àòÃ•‚Éü‡ß¥‚ñ∏`)
boij = isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.videoMessage : info.message.videoMessage
owgi = await getFileBuffer(boij, 'video')
res = await upload(owgi)
sendStickerFromUrl(from, {url: res})
} else {
reply("Voc√™ deve marcar uma imagem, ou um v√≠deo de at√© 10 segundos..")
}
} catch {
reply(`Deu erro... Talvez o arquivo seja muito grande üòï`)
}
break

case 'name1':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
if(!isOwner) return reply(`;-;`)
var RSM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var boij2 = RSM?.imageMessage || info.message?.imageMessage || RSM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSM?.viewOnceMessage?.message?.imageMessage
var boij = RSM?.videoMessage || info.message?.videoMessage || RSM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSM?.viewOnceMessage?.message?.videoMessage
if(boij2){
var n3 = `name3`
var n4 = `name4`
reply(`name2`)
owgi = await getFileBuffer(boij2, 'image')
let encmediaa = await sendImageAsSticker2(blackmd, from, owgi, info, { packname:n3, author:n4})
await DLT_FL(encmediaa)
} else if(boij && boij.seconds < 11){
var n3 = `name3`
var n4 = `name4`
reply(`name2`)
owgi = await getFileBuffer(boij, 'video')
let encmedia = await sendVideoAsSticker2(blackmd, from, owgi, info, { packname:n3, author:n4})
await DLT_FL(encmedia)
} else {
return reply(`name5 (opcional)`)
}
break

case 'toimg':
if(!isQuotedSticker) return reply(`Marque uma figurinha, e eu vou transformar em imagem...\n\nSe for figurinha animada, use ${prefix}togif`)
try {
reply(`‚ù™‚àòÃ•‚Éü‚∏Ω‚Éüùô≤ùöòùöóùöüùöéùöõùöùùöéùöóùöçùöò ùô¥ùöñ ùô∏ùöñùöäùöêùöéùöñ‚àòÃ•‚Éü‡ß¥‚ñ∏`)
buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
blackmd.sendMessage(from, {image: buff}, {quoted: seloctt}).catch(e => {
console.log(e);
reply('ERRO!!')
})
} catch {
reply("Erro..")
}
break

//==========(PLAQUINHAS-LOGOS)===========\

case 'placaloli':
if(!q) return reply(enviar.wrongFormat)
reply('Aguarde..')
lod = await fetchJson(`https://nekobot.xyz/api/imagegen?type=kannagen&text=${q}`)
sendStickerFromUrl(from, lod.message, enviar.success)
break
// ENTRETENIMENTO 
  // MENU JOGOS // 

case 'site1':
reagir(from, "üåê")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üåê *modyolo* https://modyolo.com`)
break
case 'site2':
reagir(from, "üåê")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üåê *liteapks* https://liteapks.com`)
break
case 'site3':
reagir(from, "üåê")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üåê *getmods* https://getmodsapk.com/`)
break
case 'site4':
reagir(from, "üåê")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üåê *apkmody* https://apkmody.com`)
break
case 'site5':
reagir(from, "üåê")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üåê *apkdone* https://apkdone.com/`)
break

case 'site6':
reagir(from, "üé¶")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé¶ *pobreflix* https://pobreflix.life`)
break 
case 'site7':
reagir(from, "üé¶")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé¶ *megaflix* https://megaflix6.com`)
break
case 'site8':
reagir(from, "üé¶")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé¶ *boralfix* https://www.boraflix.com`)
break
case 'site9':
reagir(from, "üé¶")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé¶ *superflix* https://superflix.cloud/`)
break
case 'site10':
reagir(from, "üé¶")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé¶ *filmesxp* https://filmesxp.com/`)
break
case 'site11':
reagir(from, "üì∫")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üì∫ *multicanais* https://multicanais.com`)
break
case 'site12':
reagir(from, "üì∫")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üì∫ *futemax* https://futemax.uk/`)
break
case 'site13':
reagir(from, "üì∫")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üì∫ *redecanais* https://redecanais.gs/`)
break
case 'site14':
reagir(from, "üì∫")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üì∫ *player tv* https://playertv.net/`)
break
case 'site15':
reagir(from, "üì∫")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üì∫ *pirate tv* https://piratetv.pro/`)
break

case 'jogo1':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Minecraft:* https://www.mediafire.com/file/4k6ajlxiht8kp4n/Minecraft_1.21.0_OFFICIAL.apk/file`)
break
case 'jogo2':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *DragonBall Z - Dokkan:* https://www.mediafire.com/file/015ibjiljfkv7uo/Dokkan_v4_12_1_MOD.apk/file`)
break
case 'jogo3':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *GTA SanAndreas:* https://www.mediafire.com/file/ln6r3kx0ie77r9t/GTA_San_Andreas_2021.zip/file`)
break
case 'jogo4':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *GTA SA - Legendado em Portugu√™s:* http://www.mediafire.com/file/7op13aup1ll7m9y/GTA_SA_COM_TRADU%25C3%2587%25C3%2583O_PT-BR.zip/file`)
break
case 'jogo5':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *GTA SA com Mod Cleo:* http://www.mediafire.com/file/d8cfwzctx95x0dx/GTA_SA_v2.00_Mod_Cleo.zip/file`)
break
case 'jogo6':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *GTA SA Online:* https://www.mediafire.com/file/0xccd5m0zwqstag/GTA_SA_ONLINE_SAMP_ByHT.zip/file`)
break
case 'gpsamp':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu o grupo, espero que voc√™ goste!
-
üî• *Grupo Ofc:* https://chat.whatsapp.com/JDEH0eU70z2LLU4FywshzY`)
break
case 'jogo7':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *GTA SuperLite + Mod Cleo:* http://www.mediafire.com/file/wdkg8pmndtihil3/GTA_SA_super_lite_mod_cleo_ByHT.zip/file`)
break
case 'jogo8':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *LastDay on Eart Survival:* https://www.mediafire.com/file/k4pr6awvr5eb1ak/Last%20Day%20on%20Earth%201.17.7-mod.apk/file `)
break
case 'jogo9':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Bomber Friends MOD:* https://www.mediafire.com/file/dir8pwrb1mpm57w/Bomber_Friends_v4.10_MOD.apk/file`)
break
case 'jogo10':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Arcade Hunter:* https://www.mediafire.com/file/ugcdaclnpodtxxs/Arcade_Hunter-Sword%252CGun%252C_and_Magic_1.11.0-mod.apk/file`)
break
case 'jogo11':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Defesa de Zombie Ocioso:* https://www.mediafire.com/file/8422sjofw1cdnka/Zombie+Idle+Defense+1.5.79.229MOD-t.apk/file`)
break
case 'jogo12':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Pac-Man:* https://www.mediafire.com/file/gxwy01ni99pcur2/PAC-MAN+9.2.7.10150MOD-t.apk/file`)
break
case 'jogo13':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Car Driving School Simulator - APK:* https://www.mediafire.com/file/r6aps8mn6wqoabj/Car+Driving+School+Simulator+3.1.0.283MOD-t.apk/file
üé≥ _Obrigat√≥rio instalar o OBB:_
¬†https://www.mediafire.com/file/hcsb5tpr7byh8fg/com.boombitgames.DrivingSchoolParking.zip/file`)
break
case 'jogo14':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Cyber Fighters Premium:* https://www.mediafire.com/file/4tmv2cdahvqamlx/Cyber+Fighters+Premium+1.11.35.68MOD-t.apk/file`)
break
case 'jogo15':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Rag Racing:* https://www.mediafire.com/file/g88v399ks1fpnfq/drag-racing-mod_2.0.37.rar/file`)
break
case 'jogo16':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Mr. Brow:* https://www.mediafire.com/file/i0ii099sejk9fnk/Mr+Bow+4.15.75MOD-t.apk/file`)
break
case 'jogo17':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Airport City:* https://www.mediafire.com/file/vuupmpp3r03lso0/Airport+City+8.7.18.101418MOD-t.apk/file`)
break
case 'jogo18':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Crash Bandicoot:* https://www.mediafire.com/file/nyx8rjqn5m51o3r/Crash+Bandicoot+Mobile+v0.7.6242+Mod.apk/file `)
break
case 'jogo19':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Real Steel World Robot Boxing (APK+OBB):* https://www.mediafire.com/file/zcnsxb55mldn51e/Real+Steel+World+Robot+Boxing+v54.54.126+Mod.apk/file`)
break
case 'jogo20':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Anger of Sticker:* https://www.mediafire.com/file/zfmqmszkhbgoem2/anger-of-stick-5-mod_1.1.39.apk/file`)
break
case 'jogo21':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Angry Birds 2 (APK+OBB)*
https://www.mediafire.com/file/uwnurszwrdbv5ge/angrybirds2-2481.apk/file`)
break
case 'jogo22':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Especial Force Group 2 (CS):* https://www.mediafire.com/file/uwf5cq9u8tjg44x/specialforcesgroup2-421.apk/file`)
break
case 'jogo23':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Roblox:* https://apkadmin.com/k05ck2q6ioo1/ROBLOX_v2.459.415955_MOD_MENU.apk.html`)
break
case 'jogo24':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Critical Striker:* https://www.mediafire.com/file/7yqmk1gn4wrieri/CRITICAL_STRIKE.zip/file`)
break
case 'jogo25':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Dream League Soccer:* http://www.mediafire.com/file/yuw9n5d4phzz5wg/Dream_League_Soccer_2019_v6.13-mod.apk/file`)
break
case 'jogo26':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Clash of Clans:* http://www.mediafire.com/file/aoaem76tyg0hvfv/Clash_Of_Clans_v13.675.6_MOD.apk/file`)
break
case 'jogo27':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Criminal Case Paris:* http://www.mediafire.com/fil...e/i5pbv8d7yjbbtly/Criminal%20Case%20Paris%20v2.36.1-mod.apk/file`)
break 

case 'jogo28':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Drift Max World:* https://www.mediafire.com/file/hqui6asekutsocq/DRIFT+MAX+WORLD+DINHEIRO+INFINITO.zip/file`)
break

case 'jogo29':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Downhill Masters:* https://www.mediafire.com/file/9cdgreyc8amkto9/Downhill_Masters_v1.0.59_MOD.apk/file`)
break
case 'jogosamp':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
‚òï IP DO SERVIDOR DO MEU CRIADOR: 23.88.73.88:11627
-
üé≥ *SA-MP:* https://play.google.com/store/apps/details?id=ru.unisamp_mobile.launcher`)
break

case 'jogo30':
reagir(from, "üéÆ")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé≥ *Monopoly:* https://www.mediafire.com/file/q5jfi61xwbqiu2x/Monopoly-v1-7-11-mod.zip/file`)
break 

// S√âRIES //

case 'serie1':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Arcane:* https://overflix.online/series/arcane/`)
break

case 'serie2':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Stranger Things:* https://overflix.online/series/stranger-things-gratis-hd/`)
break

case 'serie3':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Soldados ou Zumbis:* https://overflix.online/series/s-o-z-soldados-ou-zumbis/`)
break

case 'serie4':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Senhor dos Aneis:* https://overflix.online/series/o-senhor-dos-aneis-os-aneis-de-poder-online-hd-gratis/`)
break

case 'serie5':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Riverdale:* https://overflix.online/series/riverdale-online-gratis-hd-full/`)
break

case 'serie6':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *A casa do drag√£o:* https://overflix.online/series/a-casa-do-dragao-online-gratis-hd/`)
break

case 'serie7':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Sintonia:* https://overflix.online/series/sintonia-online-gratis/`)
break

case 'serie8':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Chucky:* https://overflix.online/series/chucky-a-serie/`)
break

case 'serie9':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Flash:* https://overflix.online/series/flash-hd-online-gratis/`)
break

case 'serie10':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Game of Thrones:* https://overflix.online/series/game-of-thrones-hd-online-gratis/`)
break

case 'serie11':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Legados:* https://overflix.online/series/legados-gratis-hd-online/`)
break

case 'serie12':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *The Good Doctor:* https://overflix.online/series/the-good-doctor-o-bom-doutor-hd-online/`)
break

case 'serie13':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *The Walking Dead:* https://overflix.online/series/the-walking-dead/`)
break

case 'serie14':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Peaky Blinders:* https://overflix.online/series/peaky-blinders-sangue-apostas-e-navalhas/`)
break

case 'serie15':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Diarios de um vampiro:* https://overflix.online/series/diarios-de-um-vampiro/`)
break

case 'serie16':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Gavi√£o Arqueiro:* https://overflix.online/series/gaviao-arqueiro-full-online-gratis/`)
break 

case 'serie17':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Westworld:* https://overflix.online/series/westworld-hd-gratis-online/`)
break

case 'serie18':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *L√∫cifer:* https://overflix.online/series/lucifer-online-hd/`)
break

case 'serie19':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Lobo Adolecentes:* https://overflix.online/series/lobo-adolescente/`)
break

case 'serie20':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *La Casa de Papel:* https://overflix.online/series/la-casa-de-papel/`)
break

case 'serie21':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Cobra Kai:* https://overflix.online/series/cobra-kai-online-gratis-hd/`)
break

case 'serie22':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Love Victor:* https://overflix.online/series/love-victor-gratis-online-hd/`)
break

case 'serie23':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Vikings:* https://overflix.online/series/vikings-hd/`)
break

case 'serie24':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Cavaleiro da Lua:* https://overflix.online/series/cavaleiro-da-lua-online-gratis-hd-full/`)
break

case 'serie25':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Fear The Walking Dead:* https://overflix.online/series/fear-the-walking-dead/`)
break

case 'serie26':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Rick Morty:* https://overflix.online/series/rick-morty/`)
break

case 'serie27':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Round 6:* https://overflix.online/series/round-6-online-gratis-hd-full/`)
break

case 'serie28':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Carnival Row:* https://overflix.online/series/carnival-row-online-hd/`)
break

case 'serie29':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Dark:* https://overflix.online/series/dark/`)
break

case 'serie30':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Arqueiro:* https://overflix.online/series/arqueiro/`)
break 

case 'serie31':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Eu Nunca:* https://overflix.online/series/eu-nunca/`)
break

case 'serie32':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *The Last Kingdom:* https://overflix.online/series/the-last-kingdom/`)
break

case 'serie33':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *O livro de Boba Fett:* https://overflix.online/series/o-livro-de-boba-fett-hd-online-gratis-full/`)
break

case 'serie34':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Ragnarok:* https://overflix.online/series/ragnarok/`)
break 

case 'serie35':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *OS 100:* https://overflix.online/series/os-100/`)
break

case 'serie36':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *FBI:* https://overflix.online/series/fbi/`)
break

case 'serie37':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Extracurricular:* https://overflix.online/series/extracurricular/`)
break

case 'serie38':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Halo:* https://overflix.online/series/halo-online-gratis/`)
break

case 'serie39':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Warrior Nun:* https://overflix.online/series/warrior-nun-online-completo/`)
break

case 'serie40':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Anne With:* https://overflix.online/series/anne-with-an-e/`)
break

case 'serie41':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Patrulha do destino:* https://overflix.online/series/patrulha-do-destino-online/`)
break

case 'serie42':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Dinastia:* https://overflix.online/series/dinastia/`)
break

case 'serie43':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Watchmen:* https://overflix.online/series/watchmen/`)
break

case 'serie44':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_ü•∂ Ol√° , aqui est√° o seu pedido, espero que voc√™ goste!_*
-
üé• *Lovecraft Country:* https://overflix.online/series/lovecraft-country-dublado-legendado-online-hd-gratis/`)
break

// CONTAS FREE //
case 'contas_netflix':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui ssta as contas da Netflix vazadas_*
-
üåê https://pt.anotepad.com/note/read/ytgrkdgt`)
break
case 'contas_hbo':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui est√° algumas contas da hbo max_*
-
üåê https://pt.anotepad.com/note/read/8yxaityw`)
break
case 'contas_star+':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta sua conta da star+_*
-
üåê https://pt.anotepad.com/note/read/nssgyhhn`)
break
case 'contas_disney+':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta sua conta da disney+_*
-
üåê https://pt.anotepad.com/note/read/xpgsi45r`)
break
case 'contas_paramount+':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta sua conta da Paramount+_*
-
üåê https://pt.anotepad.com/note/read/fnt5ks2y`)
break
case 'contas_spotify':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta sua conta do spotify_*
-
üåê https://pt.anotepad.com/note/read/qfddqeid`)
break
case 'crunchyroll':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta sua conta da crunchyroll_*
-
üåê https://pt.anotepad.com/note/read/8dqxjewt`)
break
case 'contas_iptv':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta sua conta de iptv_*
-
üåê https://pt.anotepad.com/note/read/q8r3hh85`)
break
case 'contas_myfamily':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta sua conta my family_*
-
üåê https://pt.anotepad.com/note/read/n2d4k9q8`)
break
case 'contas_clarotv':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta sua conta da clarotv+_*
-
üåê https://pt.anotepad.com/note/read/5cfjbs68`)
break
case 'contas_expressvpn':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta sua conta da express_*
-
üåê https://pt.anotepad.com/note/read/7tge88jb`)
break
case 'contas_dazn':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta sua conta da dazn_*
-
üåê https://pt.anotepad.com/note/read/hq5fn9ai`)
break
case 'contas_bins':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta algumas bins para criar contas_*
-
üåê https://pt.anotepad.com/note/read/ergtdncf`)
break
case 'contas_onlyfans':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta algumas contas do onlyfans_*
-
üåê https://pt.anotepad.com/note/read/7hqa96gi`)
break
case 'contas_facebook':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta algumas contas do Facebook_*
-
üåê https://pt.anotepad.com/note/read/gj3k5hen`)
break
case 'contas_nordvpn':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta algumas contas do nordvpn_*
-
üåê https://pt.anotepad.com/note/read/rs2h7mdh`)
break
case 'contas_hotmail':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta alguns Hotmail vazados*
-
üåê https://pt.anotepad.com/note/read/stder3wm`)
break
case 'contas_outlook':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta emails vazados do Outlook _*
-
üåê https://pt.anotepad.com/note/read/5knqawjf`)
break
case 'contas_xbox':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta algumas contas do xbox_*
-
üåê https://pt.anotepad.com/note/read/7mhaapfrf`)
break
case 'contas_nba':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta algumas contas da NBA_*
-
üåê https://pt.anotepad.com/note/read/i3q54wyw`)
break
case 'contas_primevideo':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta algumas contas da primevideo_*
-
üåê https://pt.anotepad.com/note/read/j4rgegxm`)
break
case 'contas_minecraft':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta algumas comtas do Minecraft_*
-
üåê https://pt.anotepad.com/note/read/swmbmbte`)
break
case 'contas_steam':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta algumas contas da steam_*
-
üåê https://pt.anotepad.com/note/read/bdnpenfp`)
break
case 'contas_terra':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta algumas contas do blog terra_*
-
üåê https://pt.anotepad.com/note/read/y298dt52`)
break
case 'contas_instagram':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta algumas contas do Instagram_*
-
üåê https://pt.anotepad.com/note/read/q8gcxsrf`)
break
case 'contas_hulu':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta algumas contas do hulu_*
-
üåê https://pt.anotepad.com/note/read/q8gcxsrf`)
break
case 'contas_duolingo':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta algumas contas do duolingo_*
-
üåê https://pt.anotepad.com/note/read/697r98pg`)
break
case 'contas_viki':
reagir(from, "üëÄ")
await sleep(1000)
reply(`*_aqui esta algumas contas viki rukuten_*
-
üåê https://pt.anotepad.com/note/read/swd4tx9j`)
break
case 'contas_cod':
reagir(from, "üéûÔ∏è")
await sleep(1000)
reply(`*_aqui esta sua conta do cod_*
-
üåê https://pt.anotepad.com/note/read/5jxtiamj`)
break
//=============(LOGOS)=============\\

case 'edit1': 

					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_api.jpg?text.0.text=${teks}&text.0.color=000000&text.0.font.family=Pacifico&text.0.font.weight=600&text.0.background.color=ffffff&text.0.outline.color=ffffff&text.0.outline.width=10&text.0.outline.blur=17`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break

case 'edit2':
                           
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis2.jpg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=1%25&text.0.position.y=16%25&text.0.size=80&text.0.color=ff2772&text.0.opacity=67&text.0.font.family=Bangers&text.0.font.style=italic&text.0.background.opacity=50&text.0.outline.width=6`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break

case 'edit3':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis3.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=59%25&text.0.size=89&text.0.color=000000&text.0.opacity=71&text.0.font.family=Changa%20One&text.0.font.style=italic&text.0.background.opacity=10&text.0.outline.color=ffffff&text.0.outline.width=3`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break	
					
					case 'edit4':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis.jpg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=11%25&text.0.position.y=22%25&text.0.size=20&text.0.color=241b1b&text.0.opacity=33&text.0.font.family=Rock%20Salt&text.0.font.style=italic&text.0.background.opacity=49`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break	
					
					case 'edit5':
                   
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis5.jpg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=1%25&text.0.position.y=22%25&text.0.align=left&text.0.size=59&text.0.font.family=Permanent%20Marker&text.0.outline.color=df00ff&text.0.outline.width=2&text.0.outline.blur=18`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break

case 'edit6':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis6.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.x=1%25&text.0.position.y=50%25&text.0.size=68&text.0.color=464646&text.0.opacity=51&text.0.font.family=Sigmar%20One&text.0.background.opacity=2&text.0.outline.color=ffffff&text.0.outline.width=2&text.0.outline.opacity=61`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break	
					
					case 'edit7':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis7.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.x=1%25&text.0.position.y=58%25&text.0.size=69&text.0.color=00ffea&text.0.opacity=37&text.0.font.family=Bangers&text.0.background.opacity=77&text.0.outline.color=ffffff&text.0.outline.width=2&text.0.outline.blur=20`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break

case 'edit8':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					//venomk = await getvenomk(`https://lollityp.sirv.com/venom_apis.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=47%25&text.0.size=99&text.0.color=ff0000&text.0.opacity=50&text.0.font.family=Cookie&text.0.font.style=italic&text.0.background.opacity=92&text.0.outline.width=23&text.0.outline.blur=24&text.0.outline.opacity=87`)
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis.jpg?w=640&h=640&text.0.text=Venom&text.0.position.gravity=north&text.0.position.y=53%25&text.0.size=96&text.0.color=ff0000&text.0.opacity=46&text.0.font.family=Shadows%20Into%20Light&text.0.font.style=italic&text.0.background.opacity=70&text.0.outline.width=9&text.0.outline.blur=52`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break					
					
					case 'edit9':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis9.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=50%25&text.0.size=68&text.0.color=ffffff&text.0.opacity=61&text.0.font.family=Tangerine&text.0.font.style=italic&text.0.background.opacity=61&text.0.outline.color=ff6f00&text.0.outline.width=9`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break

case 'edit10':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis10.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=62%25&text.0.size=63&text.0.color=004124&text.0.opacity=99&text.0.font.family=Permanent%20Marker&text.0.font.style=italic&text.0.background.color=feff00&text.0.outline.color=ffe8a3&text.0.outline.width=9&text.0.outline.blur=21`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break

case 'edit11':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis11.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=60%25&text.0.size=64&text.0.color=0071ff&text.0.font.family=Old%20Standard%20TT&text.0.font.style=italic&text.0.background.opacity=55&text.0.outline.color=00d0ff&text.0.outline.width=19&text.0.outline.blur=30`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break	
					
					case 'edit12':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis12.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=65%25&text.0.size=61&text.0.color=ff00e6&text.0.opacity=32&text.0.font.family=Chewy&text.0.font.style=italic&text.0.outline.width=6`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break	
					
					case 'edit13':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis13.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=63%25&text.0.size=68&text.0.color=ffffff&text.0.opacity=92&text.0.font.family=Permanent%20Marker&text.0.font.weight=800&text.0.outline.color=5dff00&text.0.outline.width=13&text.0.outline.blur=21`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break		
					
					case 'edit14':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis14.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=68%25&text.0.size=60&text.0.color=ffffff&text.0.font.family=Sigmar%20One&text.0.font.style=italic&text.0.background.opacity=17&text.0.outline.color=a99cff&text.0.outline.width=9&text.0.outline.blur=16`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break	
					
					case 'edit15':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis15.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=62%25&text.0.size=63&text.0.color=000000&text.0.font.family=Audiowide&text.0.font.style=italic&text.0.background.opacity=15&text.0.outline.color=ffffff&text.0.outline.width=9&text.0.outline.blur=33`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break	
					
					case 'edit16':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto √© longo, at√© 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis16.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=58%25&text.0.size=99&text.0.color=fffefe&text.0.font.family=Permanent%20Marker&text.0.background.color=000000&text.0.outline.color=000000&text.0.outline.width=19&text.0.outline.blur=66`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
break	
case 'illuminated-metallic':
case 'carved-wood':
case 'night-sky':
case 'butterfly':
case 'coffee-cup':
case 'picture-of-love':
case 'flower-typography':
case 'harry-potter':
case 'under-grass':
case 'pubg':
case 'naruto':
case 'metallic':
case 'shadow-sky':
case 'flaming':
case 'metalgold':
case 'cemiterio':
case 'efeitoneon':
case 'shadow':
case 'txtborboleta':
case 'cup':
case 'harryp':
case 'lobometal':
case 'neon2':
case 'madeira':
case 'florwooden':
case 'coffecup2':
case 'coffecup':
case 'lovemsg3':
case 'lovemsg2':
case 'lovemsg':
case 'narutologo':
case 'romantico':
case 'darkdragon':
case 'papel':
case 'fire':
case 'sweet-candy':  
  const inputTextForApi = args.join(' '); // Nome alterado para evitar conflitos

  // Usar o texto como est√°, j√° que a API aceita apenas um texto
  const singleText = inputTextForApi || 'Indefinido'; 

  reply(`AGUARDE...`);
  console.log('Aguardando resposta da API...');
  
  try {
    // Construir a URL da API
    const apiUrl = `https://world-ecletix.onrender.com/api/${command}?texto=${singleText}`;
    console.log('URL da API:', apiUrl);

    const res = await fetchJson(apiUrl);
    
    // Log da resposta completa da API
    console.log('Resposta da API:', res);

    // Verificar se a resposta cont√©m a URL da imagem
    if (res.imageUrl) {
      const generatedImageUrl = res.imageUrl;

      // Log da URL da imagem recebida
      console.log('URL da imagem recebida:', generatedImageUrl);

      // Enviar a imagem com a URL da resposta
      await blackmd.sendMessage(from, { image: { url: generatedImageUrl }, caption: `${command} gerado com sucesso!` }, { quoted: info });

      console.log(`${command} gerado com sucesso!`);
      
    } else {
      console.log('Erro: A URL da imagem est√° ausente na resposta.');
      reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
    }
    
  } catch (e) {
    console.error('Erro ao gerar imagem:', e.message, e.stack);
    reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
  }
  break;
case 'vingadores':
case 'ffbanner':
case 'marvel': 
case 'steel':
case 'america':   
case 'deadpool':   
case 'space':
case 'pornhub':
case 'typography':   
case 'pohub':  
case 'graffiti':  
case 'thor':  
  const userInputText = args.join(' '); // Nome mais espec√≠fico para a entrada do usu√°rio

  // Separar os textos por "/"
  const primaryText = userInputText.split('/')[0] || 'Indefinido';
  const secondaryText = userInputText.split('/')[1] || 'Indefinido';
  
  // Verificar se o separador '/' foi inclu√≠do
  if (!userInputText.includes("/")) {
    return reply(`Cad√™ a "/"?\nExemplo: ${prefix + command} texto1/texto2`);
  }
  
  reply(`AGUARDE...`);
  console.log('Aguardando resposta da API...');
  
  try {
    // Fazer solicita√ß√£o √† API passando os dois textos
    const apiUrl = `https://world-ecletix.onrender.com/api/${command}?texto=${primaryText}&texto2=${secondaryText}`;
    console.log('URL da API:', apiUrl);

    const res = await fetchJson(apiUrl);
    
    // Log da resposta completa da API
    console.log('Resposta da API:', res);

    // Verificar se a resposta cont√©m sucesso
    if (res.status && res.resultado && res.resultado.success) {
      const generatedImageUrl = res.resultado.imageUrl;

      // Log da URL da imagem recebida
      console.log('URL da imagem recebida:', generatedImageUrl);

      // Enviar a imagem com a URL da resposta
      await blackmd.sendMessage(from, { image: { url: generatedImageUrl }, caption: `${command} gerado com sucesso!` }, { quoted: info });

      console.log(`${command} gerado com sucesso!`);
      
    } else {
      console.log('Erro: A API n√£o retornou sucesso ou a URL da imagem est√° ausente.');
      reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
    }
    
  } catch (e) {
    console.error('Erro ao gerar imagem:', e.message, e.stack);
    reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
  }
  break;
  case 'gameplay':  
  console.log('Comando recebido:', args.join(' '));

  // Separar os dois textos por "/"
  const [gameplayText1 = 'Indefinido', gameplayText2 = 'Indefinido'] = args.join(' ').split('/');

  console.log('Gameplay Text 1:', gameplayText1);
  console.log('Gameplay Text 2:', gameplayText2);

  if (!args.join(' ').includes("/") || args.join(' ').split('/').length < 2) {
    console.log('Erro: Formato incorreto. Textos n√£o est√£o separados corretamente.');
    return reply(`Cad√™ os dois textos separados por "/"?\nExemplo: ${prefix + command} texto1/texto2`);
  }

  reply(`AGUARDE...`);
  console.log('Aguardando resposta da API...');

  try {
    // Construir a URL corretamente conforme especificado
    const apiUrl = `https://world-ecletix.onrender.com/api/gameplay?texto=${gameplayText1}&texto=${gameplayText2}`;
    console.log('URL da API:', apiUrl);

    // Fazer solicita√ß√£o √† API passando os 2 textos
    const response = await fetchJson(apiUrl);
    console.log('Resposta da API:', response);

    // Verificar se a URL da imagem foi retornada corretamente
    if (response.imageUrl) {
      let imageUrl = response.imageUrl;

      console.log('URL da imagem recebida:', imageUrl);

      // Corrigir a URL se tiver barra dupla "//"
      if (imageUrl.includes('//')) {
        imageUrl = imageUrl.replace('https://', '').replace('//', '/');
        imageUrl = 'https://' + imageUrl;
      }

      console.log('URL da imagem corrigida:', imageUrl);

      // Enviar a imagem com a URL da resposta
      await blackmd.sendMessage(from, { image: { url: imageUrl }, caption: `${command} gerado com sucesso!` }, { quoted: info });
      console.log('Imagem enviada com sucesso!');
      
    } else {
      console.log('Erro: A URL da imagem est√° ausente na resposta.');
      reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
    }

  } catch (e) {
    console.error('Erro ao gerar imagem:', e.message, e.stack);
    reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
  }
  break;
case 'googlesg':  
  console.log('Comando recebido:', args.join(' '));

  const textooo = args.join(' ');

  // Separar os tr√™s textos por "/"
  const texto1 = textooo.split('/')[0] || 'Indefinido';
  const texto2 = textooo.split('/')[1] || 'Indefinido';
  const texto3 = textooo.split('/')[2] || 'Indefinido';

  console.log('Texto 1:', texto1);
  console.log('Texto 2:', texto2);
  console.log('Texto 3:', texto3);

  if (!textooo.includes("/") || textooo.split('/').length < 3) {
    console.log('Erro: Formato incorreto. Textos n√£o est√£o separados corretamente.');
    return reply(`Cad√™ os tr√™s textos separados por "/"?\nExemplo: ${prefix + command} texto1/texto2/texto3`);
  }

  reply(`AGUARDE...`);
  console.log('Aguardando resposta da API...');

  try {
    // Construir a URL corretamente conforme especificado
    const apiUrl = `https://world-ecletix.onrender.com/api/googlesg?texto=${texto1}&texto2=${texto2}&texto3=${texto3}`;
    console.log('URL da API:', apiUrl);

    // Fazer solicita√ß√£o √† API passando os 3 textos
    const response = await fetchJson(apiUrl);
    console.log('Resposta da API:', response);

    // Verificar se a URL da imagem foi retornada corretamente
    if (response.imageUrl) {
      let imageUrl = response.imageUrl;

      console.log('URL da imagem recebida:', imageUrl);

      // Corrigir a URL se tiver barra dupla "//"
      if (imageUrl.includes('//')) {
        imageUrl = imageUrl.replace('https://', '').replace('//', '/');
        imageUrl = 'https://' + imageUrl;
      }

      console.log('URL da imagem corrigida:', imageUrl);

      // Enviar a imagem com a URL da resposta
      await blackmd.sendMessage(from, { image: { url: imageUrl }, caption: `${command} gerado com sucesso!` }, { quoted: info });
      console.log('Imagem enviada com sucesso!');
      
    } else {
      console.log('Erro: A URL da imagem est√° ausente na resposta.');
      reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
    }

  } catch (e) {
    console.error('Erro ao gerar imagem:', e.message, e.stack);
    reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
  }
  break;
case 'steel':
case 'dragon-ball':
case 'praia':
case 'graffiti':
case 'star-wars':
case 'glitch':
case 'royal':
case 'cloud':
case 'birthday':
case 'natal':
case 'matirix':
case 'galaxy':
case 'snow':  
case 'devil':
case 'anonymous':
case 'boom':
case 'mascotegame':
case 'mascoteavatar':
case 'wingeffect':
case 'angelglx':
case 'gizquadro':
case 'blackpink': 
case 'girlmascote':
case 'logogame':
case 'logogame':
case 'smoke':
case 'papel':
case 'angelwing':
case 'hackneon':
case 'fpsmascote':
case 'equipemascote':
case 'txtquadrinhos':
case '3dsilver':
case 'goldtext':
case 'starballons':
case 'frozen':
case 'halloween':
case 'ffavatar':
  textin = args.join(" ")
  if (!q) return reply(`Qual o nome?`)
  reply('enviando...')
  
  try {
    // Fazer solicita√ß√£o √† API usando o comando din√¢mico na URL
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/${command}?texto=${textin}`);
    
    // Verificar se o resultado foi bem-sucedido
    if (response.status && response.resultado && response.resultado.success) {
      const imageUrl = response.resultado.imageUrl;
      
      // Baixar a imagem e enviar a resposta
      const blabla = await getBuffer(imageUrl);
      await blackmd.sendMessage(from, { image: blabla }, { quoted: info });
      
    } else {
      reply("Erro ao criar sua logo! Tente novamente mais tarde.");
    }
    
  } catch (e) {
    console.error('Erro ao gerar logo:', e)
    reply("Erro ao criar sua logo! Tente novamente mais tarde.")
  }
  break			               

case 'cria': 
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto √© longo, at√© 15 caracteres')
reply(`‚ñß‚ÉØ‚Éüùô∂ùöéùöõùöäùöóùöçùöò ùöÇùöûùöä ùôªùöòùöêùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_api.jpg?text.0.text=${teks}&text.0.color=000000&text.0.font.family=Pacifico&text.0.font.weight=600&text.0.background.color=ffffff&text.0.outline.color=ffffff&text.0.outline.width=10&text.0.outline.blur=17`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break

case 'anime1':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto √© longo, at√© 15 caracteres')
reply(`‚ñß‚ÉØ‚Éüùô∂ùöéùöõùöäùöóùöçùöò ùöÇùöûùöä ùôªùöòùöêùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis2.jpg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=1%25&text.0.position.y=16%25&text.0.size=80&text.0.color=ff2772&text.0.opacity=67&text.0.font.family=Bangers&text.0.font.style=italic&text.0.background.opacity=50&text.0.outline.width=6`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break

case 'ff1':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto √© longo, at√© 15 caracteres')
reply(`‚ñß‚ÉØ‚Éüùô∂ùöéùöõùöäùöóùöçùöò ùöÇùöûùöä ùôªùöòùöêùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis3.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=59%25&text.0.size=89&text.0.color=000000&text.0.opacity=71&text.0.font.family=Changa%20One&text.0.font.style=italic&text.0.background.opacity=10&text.0.outline.color=ffffff&text.0.outline.width=3`)
blackmd.sendMessage(from, { image: venomk }, {quoted: seloctt })
break	

case 'game':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto √© longo, at√© 15 caracteres')
reply(`‚ñß‚ÉØ‚Éüùô∂ùöéùöõùöäùöóùöçùöò ùöÇùöûùöä ùôªùöòùöêùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis5.jpg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=1%25&text.0.position.y=22%25&text.0.align=left&text.0.size=59&text.0.font.family=Permanent%20Marker&text.0.outline.color=df00ff&text.0.outline.width=2&text.0.outline.blur=18`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break

case 'ff2':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto √© longo, at√© 15 caracteres')
reply(`‚ñß‚ÉØ‚Éüùô∂ùöéùöõùöäùöóùöçùöò ùöÇùöûùöä ùôªùöòùöêùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis6.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.x=1%25&text.0.position.y=50%25&text.0.size=68&text.0.color=464646&text.0.opacity=51&text.0.font.family=Sigmar%20One&text.0.background.opacity=2&text.0.outline.color=ffffff&text.0.outline.width=2&text.0.outline.opacity=61`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break	

case 'anime2':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto √© longo, at√© 15 caracteres')
reply(`‚ñß‚ÉØ‚Éüùô∂ùöéùöõùöäùöóùöçùöò ùöÇùöûùöä ùôªùöòùöêùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis7.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.x=1%25&text.0.position.y=58%25&text.0.size=69&text.0.color=00ffea&text.0.opacity=37&text.0.font.family=Bangers&text.0.background.opacity=77&text.0.outline.color=ffffff&text.0.outline.width=2&text.0.outline.blur=20`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break

case 'entardecer':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto √© longo, at√© 15 caracteres')
reply(`‚ñß‚ÉØ‚Éüùô∂ùöéùöõùöäùöóùöçùöò ùöÇùöûùöä ùôªùöòùöêùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis9.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=50%25&text.0.size=68&text.0.color=ffffff&text.0.opacity=61&text.0.font.family=Tangerine&text.0.font.style=italic&text.0.background.opacity=61&text.0.outline.color=ff6f00&text.0.outline.width=9`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break

case 'indian':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto √© longo, at√© 15 caracteres')
reply(`‚ñß‚ÉØ‚Éüùô∂ùöéùöõùöäùöóùöçùöò ùöÇùöûùöä ùôªùöòùöêùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis10.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=62%25&text.0.size=63&text.0.color=004124&text.0.opacity=99&text.0.font.family=Permanent%20Marker&text.0.font.style=italic&text.0.background.color=feff00&text.0.outline.color=ffe8a3&text.0.outline.width=9&text.0.outline.blur=21`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break 

case 'ffrose':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto √© longo, at√© 15 caracteres')
reply(`‚ñß‚ÉØ‚Éüùô∂ùöéùöõùöäùöóùöçùöò ùöÇùöûùöä ùôªùöòùöêùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis12.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=65%25&text.0.size=61&text.0.color=ff00e6&text.0.opacity=32&text.0.font.family=Chewy&text.0.font.style=italic&text.0.outline.width=6`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break	

case 'ffgren':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto √© longo, at√© 15 caracteres')
reply(`‚ñß‚ÉØ‚Éüùô∂ùöéùöõùöäùöóùöçùöò ùöÇùöûùöä ùôªùöòùöêùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis13.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=63%25&text.0.size=68&text.0.color=ffffff&text.0.opacity=92&text.0.font.family=Permanent%20Marker&text.0.font.weight=800&text.0.outline.color=5dff00&text.0.outline.width=13&text.0.outline.blur=21`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break		

case 'chufuyu':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto √© longo, at√© 15 caracteres')
reply(`‚ñß‚ÉØ‚Éüùô∂ùöéùöõùöäùöóùöçùöò ùöÇùöûùöä ùôªùöòùöêùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis14.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=68%25&text.0.size=60&text.0.color=ffffff&text.0.font.family=Sigmar%20One&text.0.font.style=italic&text.0.background.opacity=17&text.0.outline.color=a99cff&text.0.outline.width=9&text.0.outline.blur=16`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break	

case 'wolf':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto √© longo, at√© 15 caracteres')
reply(`‚ñß‚ÉØ‚Éüùô∂ùöéùöõùöäùöóùöçùöò ùöÇùöûùöä ùôªùöòùöêùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis15.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=62%25&text.0.size=63&text.0.color=000000&text.0.font.family=Audiowide&text.0.font.style=italic&text.0.background.opacity=15&text.0.outline.color=ffffff&text.0.outline.width=9&text.0.outline.blur=33`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break	

case 'dragonred':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto √© longo, at√© 15 caracteres')
reply(`‚ñß‚ÉØ‚Éüùô∂ùöéùöõùöäùöóùöçùöò ùöÇùöûùöä ùôªùöòùöêùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis16.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=58%25&text.0.size=99&text.0.color=fffefe&text.0.font.family=Permanent%20Marker&text.0.background.color=000000&text.0.outline.color=000000&text.0.outline.width=19&text.0.outline.blur=66`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break	

case 'purple':              
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto √© longo, at√© 15 caracteres')
reply(`‚ñß‚ÉØ‚Éüùô∂ùöéùöõùöäùöóùöçùöò ùöÇùöûùöä ùôªùöòùöêùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
venomk = await getBuffer(`https://docs-jojo.herokuapp.com/api/text3d?text=${teks}`, {method: 'get'})
blackmd.sendMessage(from, { image: venomk }, {quoted: seloctt, caption: `${teks}`})			     	
break

case 'metadinha':
reagir(from, "üòç")
try {
ABC = await fetchJson(apikeymeta);
matheuzinho = ABC[Math.floor(Math.random()*ABC.length)]
blackmd.sendMessage(from, {image: {url: matheuzinho.male}, caption: `üôáüèª‚Äç‚ôÇÔ∏è *HOMEM* üôÖüèª‚Äç‚ôÇÔ∏è`})
blackmd.sendMessage(from, {image: {url: matheuzinho.female}, caption: `üôÜüèª‚Äç‚ôÄÔ∏è *MULHER* üíÅüèª‚Äç‚ôÄÔ∏è`})
} catch (e) {
return reply("Erro..")
}
break;


//========(SORTEIO-VOTAR-CASES)=========\\

case 'infosorteio':
case 'helpsorteio':  
blackmd.sendMessage(from, {text: infosorteio(sender, prefix), mentions: [sender]}, {quoted: selo})
break

case 'substituir':
if(!isOwner && !isnit) return reply("S√≥ dono..")
 if(isMedia && !info.message.videoMessage || isQuotedDocument) {
media = isQuotedDocument ? info.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : info.message.documentMessage
rane = getRandom('.'+await getExtension(media.mimetype))
doc = await getFileBuffer(media, 'document')
fs.writeFileSync(q, doc)
reply(`Arquivo substitu√≠do com sucesso ü§≠`)
} else {
reply('Marque o documento ou arquivo..')
}
break

case 'index-bot':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
if(!isOwner)return reply(enviar.msg.dono)
if(isMedia && !info.message.videoMessage || isQuotedDocument) {
media = isQuotedDocument ? info.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : info.message.documentMessage
rane = getRandom('.'+await getExtension(media.mimetype))
doc = await getFileBuffer(media, 'document')
fs.writeFileSync('./index.js', doc)
blackmd.sendMessage(from, {text:'*Index atualizada* ‚úÖ'},{quoted: seloctt})
setTimeout(async () => {
blackmd.sendMessage(from, {text: "*Irei reiniciar o bot em 3... 2... 1...*"})
setTimeout(async () => {
process.exit()
}, 2200)
}, 2000)
} else {
reply('Marque o documento ou o arquivo que deseja enviar pra determinar pasta ou substituir..')
}
break

case 'banfake': case 'banfakes':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
caixa = []
for(i of somembros) {
  if(!numerodono.includes(i) && !botNumber.includes(i)) {
    if(Number(i.slice(0, 2)) !== 55) caixa.push(i)
  }
}
if(caixa.length > 0) {
  for(a = 0; a < caixa.length; a++) {
    await sleep(1000)
    remover(from, caixa[a])
  }
} else reply("N√£o h√° n√∫meros fake presentes neste grupo...")
break

case 'fakeban':
case 'b4n':
case 'bam':
setTimeout(() => {reagir(from, "ü´°")}, 300)
if(!isGroupAdmins) return reply(enviar.msg.adm)
blackmd.sendMessage(from, {text: `*O alvo ‚Ü¥*
@${menc_os2.split('@')[0]} *foi removido com sucesso...* ü´°`, mentions: [menc_os2]}, {quoted: seloctt})
setTimeout(() => {
blackmd.sendMessage(from, {text: `@${menc_os2.split('@')[0]} caiu na pegadinha do malandro üòÇ`, mentions: [menc_os2]})
}, 120000)
break

case 'suic': case 'suicui': case 'suicidiuio': case 'suic√≠uidio': case 'suic√≠dio': case 'suicidio': case 'suic√≠dioÔ∏éÔ∏éÔ∏éÔ∏éÔ∏éÔ∏éÔ∏é':
if(!isModobn) return reply(enviar.msg.modobz)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isGroup) return reply(enviar.msg.grupo)
if(isOwner || JSON.stringify(vip).includes(sender)) return reply("Voc√™ n√£o tem permiss√£o de se matar üòÅ")
reply(`N√£o ${pushname}, n√£o se mate üò≠üíî`)
await sleep(3000)
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
await sleep(1000)
reply(`Ah, menos um p√° eu me preocupar üò™`)
break

case 'ban': case 'banir': case 'kick': case 'avadakedavra':
reagir(from, "‚úÖ")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!menc_os2) return reply(`Marque o usu√°rio que voc√™ deseja banir do grupo, a mensagem ou o @`)

//a pessoa n√£o est√° no grupo
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Esse usu√°rio n√£o se encontra mais no grupo...")

//marcaram @ do bot
if(botNumber.includes(menc_os2)) {
if(!isOwner) {
reply("Aplicando puni√ß√£o pq tentaram me banir... C√™ tem sorte de s√≥ perder o ADM")
return blackmd.groupParticipantsUpdate(from, [sender], "demote")
} else return reply("Qual foi patr√£o ?")
}

//marcaram @ do dono
if(isAllOwner(menc_os2)) {
if(!isOwner) {
reply("T√° achando que vai banir meu dono assim na minha frente ?? Sente o poder do ban ent√£o pra ver se √© bom üòç")
await sleep(1000)
return blackmd.groupParticipantsUpdate(from, [sender], "remove")
} else return reply("N√£o vou te banir patr√£o ;-;")
}

//marcaram @ de um vip
if(JSON.stringify(vip).includes(menc_os2) && !isOwner) {
reply("O cara quer banir um ser superior kkkkk")
return blackmd.groupParticipantsUpdate(from, [sender], "demote")
}

//n√£o √© vip nem dono
blackmd.sendMessage(from, {audio: {url:'./database/audios/ban.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.groupParticipantsUpdate(from, [menc_os2], "remove")
return blackmd.sendMessage(from, {text: `*USU√ÅRIO* @${menc_os2.split("@")[0]} *FOI REMOVIDO COM SUCESSO* üòéüëçüèΩ`, mentions: [menc_os2]})
break

case 'band':
reagir(from, "üóëÔ∏è")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)

//a pessoa n√£o est√° no grupo
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Esse usu√°rio n√£o se encontra mais no grupo...")

//marcaram @ do bot
if(botNumber.includes(menc_os2)) {
if(!isOwner) {
reply("Aplicando puni√ß√£o pq tentaram me banir... C√™ tem sorte de s√≥ perder o ADM")
return blackmd.groupParticipantsUpdate(from, [sender], "demote")
} else return reply("Qual foi patr√£o ?")
}

//marcaram @ do dono
if(numerodono.includes(menc_os2)) {
if(!isOwner) {
reply("T√° achando que vai banir meu dono assim na minha frente ?? Sente o poder do ban ent√£o pra ver se √© bom üòç")
await sleep(1000)
return blackmd.groupParticipantsUpdate(from, [sender], "remove")
} else return reply("N√£o vou te banir patr√£o ;-;")
}

//marcaram @ de um vip
if(JSON.stringify(vip).includes(menc_os2) && !isOwner) {
reply("O cara quer banir um ser superior kkkkk")
return blackmd.groupParticipantsUpdate(from, [sender], "demote")
}

//n√£o √© vip nem dono
blackmd.sendMessage(from, {audio: {url:'./database/audios/ban.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.groupParticipantsUpdate(from, [menc_os2], "remove")
blackmd.sendMessage(from, {text: `*USU√ÅRIO* @${menc_os2.split("@")[0]} *FOI REMOVIDO COM SUCESSO* üòéüëçüèΩ`, mentions: [menc_os2]})
await sleep(2000)
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.message.extendedTextMessage.contextInfo.stanzaId, participant: menc_os2}})
break

case 'vasco':
reagir(from, "üè¥‚Äç‚ò†Ô∏è")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)

//a pessoa n√£o est√° no grupo
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Esse usu√°rio n√£o se encontra mais no grupo...")

//marcaram @ do bot
if(botNumber.includes(menc_os2)) {
if(!isOwner) {
reply("Que vasco o que men√≥ ? Eu sou Palmeirense üíö")
return blackmd.groupParticipantsUpdate(from, [sender], "demote")
} else return reply("Qual foi patr√£o ?")
}

//marcaram @ do dono
if(numerodono.includes(menc_os2)) {
if(!isOwner) {
reply("No No No... Meu Dono √© layon üòç")
await sleep(1000)
return blackmd.groupParticipantsUpdate(from, [sender], "remove")
} else return reply("N√£o vou te banir patr√£o ;-;")
}

//marcaram @ de um vip
if(JSON.stringify(vip).includes(menc_os2) && !isOwner) {
reply("Esse a√≠ n√£o √© vasca√≠no n√£o kkkkk")
return blackmd.groupParticipantsUpdate(from, [sender], "demote")
}

//n√£o √© vip nem dono
vascoban = ["zagueiro", "atacante", "goleiro", "volante", "ponta esquerda", "ponta direita", "meio campo"]
blackmd.sendMessage(from, {text: `@${menc_os2.split("@")[0]} foi jogar no Vasco como ${vascoban[Math.floor(Math.random()*vascoban.length)]} ‚ò†Ô∏è`, mentions: [menc_os2]})
blackmd.sendMessage(from, {audio: {url:'./database/audios/vasco.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
await sleep(2000)
blackmd.groupParticipantsUpdate(from, [menc_os2], "remove")
break

case 'setmsg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
AB = avisos.map(i => i.groupId).indexOf(from)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(avisos[AB].module == true) {
  avisos[AB].module = false
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
  reply(`Sistema de hor√°rios programados desativado com sucesso neste grupo... Caso queira ligar, basta usar o comando novamente üòÄ`)
} else {
  avisos[AB].module = true
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
  reply(`Sistema de hor√°rios programados ativado com sucesso neste grupo... Caso queira desligar, basta usar o comando novamente üòÄ`)
}
break

case 'rankcmd':
if(!isGroup) return reply(enviar.msg.grupo)
if(rankcmd.length < 5) return reply("O bot ainda n√£o possui comandos salvos o suficiente para calcular o ranking")
matheuzinho = rankcmd.map(i => i)
rank = matheuzinho.sort((a, b) => (a.usado < b.usado) ? 0 : -1)
txt = `‚ù™üíé‡∏∫‡£™‡£≠ÕòÍï∏‚ñ∏ ·¥õ·¥è·¥© 5 ·¥Ñ·¥è·¥ç·¥Ä…¥·¥Ö·¥èÍú± ·¥ç·¥Ä…™Íú± ·¥úÍú±·¥Ä·¥Ö·¥èÍú± ·¥©·¥è Ä ·¥úÍú±·¥ú√° Ä…™·¥èÍú± ·¥á·¥ç …¢ Ä·¥ú·¥©·¥è:`
for(i = 0; i < 5; i++) {
  quant = rank[i].usado
  txt += `\n¬ª${i + 1}¬´
‚ñß‚ÉØ‚Éü·¥Ñ·¥è·¥ç·¥Ä…¥·¥Ö·¥è: ${prefix+rank[i].cmd}
„Ö§„Ö§‚ñß‚ÉØ‚Éü·¥úÍú±·¥Ä·¥Ö·¥è: ${quant} vez${Number(quant) > 1 ? `es` : ``}`
}
try {
  matheuzinho = await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image');
  shortpc = await axios.get(`https://tinyurl.com/api-create.php?url=${matheuzinho}`);
  ppimg = shortpc.data
} catch(e) { ppimg = semfoto }
sendUrlText(from, txt, pushname, ``, ppimg, `https://wame/`+sender.split("@")[0], seloctt)
break

case 'checkcmd':
if(!q) return reply(`Informe o nome do comando que voc√™ quer puxar, ex:
${prefix+command} play`)
if(q.includes(prefix)) return reply(`N√£o inclua o prefixo na busca...`)
caixa = []
for(i of rankcmd) {
  if(rmLetras(q) == i.cmd) caixa.push(i)
}
if(caixa.length <= 0) return reply(`N√£o h√° registros de uso desde comando em minha database...`)
reply(`üé≤ O Comando *${prefix+caixa[0].cmd}* foi usado ${caixa[0].usado} vez${Number(caixa[0].usado) !== 1 ? `es` : ``}, segundo o que consta em minha database...`)
break

case 'revealmsg':
if(!isOwner) return reply(enviar.msg.dono)
var getGroups = await blackmd.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
var ingfoo = groups.map(v => v)
ingfoo.sort((a, b) => (a[0] < b.length))
if(q.toLowerCase() == "grupo") {
if(!isGroup) return reply(enviar.msg.grupo)
idgp = from
nome = groupName
} else if(Number(args[0]) > 0 && Number(args[0]) <= ingfoo.length) {
idgp = ingfoo[Number(args[0])].id
nome = ingfoo[Number(args[0])].subject
} else {
return reply("Olhe no comando "+prefix+command+"listarevgp o n√∫mero correspondente ao grupo que voc√™ quer ativar/desativar o repasse de mensagens... Ex: "+prefix+command+"2\n\nCaso vc opte por \""+prefix+command+" grupo\", ele ir√° ativar/desativar este grupo aqui...")
}
if(JSON.stringify(revealmsg).includes(idgp)) {
AB = revealmsg.map(i => i.groupId).indexOf(idgp)
revealmsg.splice(AB, 1)
fs.writeFileSync("./basedefuncionamento/revealmsg.json", JSON.stringify(revealmsg, null, 2))
reply("Repasse de mensagens do grupo "+nome+" desativado com sucesso üí¢")
} else {
revealmsg.push({groupId: idgp})
fs.writeFileSync("./basedefuncionamento/revealmsg.json", JSON.stringify(revealmsg, null, 2))
reply("Repasse de mensagens do grupo "+nome+" ativado com sucesso ‚úÖ")
}
break

case 'listarevgp':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
if(!isOwner) return reply('```SOMENTE MEU DONO LIND√ÉO```')
var getGroups = await blackmd.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
var ingfoo = groups.map(v => v)
ingfoo.sort((a, b) => (a[0] < b.length))
teks1 = "·èû·èÜ’èÕ≤·é™ ·é†·é¨ ·èÄ·é°·ÇÆ·è¢œ¥’è ·é†œ¥ ·è¥œ¥Õ≤\nÕ≤œ¥Õ≤·é™·èû ( "+ingfoo.length+" )\n________________________________________"
for (let i = 0; i < ingfoo.length; i++){
matheuzinho = JSON.stringify(revealmsg).includes(ingfoo[i].id) ? "‚úÖ" : "‚ùå"
teks1 += "\n\n¬ª"+i+"¬´\n‚è§ÕüÕûÕüÕû Í¶øùôΩùöòùöñùöé ùô≥ùöò ùô∂ùöõùöûùöôùöò ‚Ü¥\n„Äò "+ingfoo[i].subject+" „Äô\n‚è§ÕüÕûÕüÕû Í¶øùô∏ùô≥ ùô≥ùöò ùô∂ùöõùöûùöôùöò ‚Ü¥\n√ó "+ingfoo[i].id+"\n‚∏∫ÕüÕûÍ™∂ùô∞ùöùùöíùöüùöäùöçùöò‚áí„Äé "+matheuzinho+" „Äè\n________________________________________"
}
reply(teks1)
break

case 'resetadsgp':
if(!isOwner) return reply(enviar.msg.dono)
if(!JSON.stringify(adsgp).includes("grupos")) {
  adsgp.push({tipo: "grupos", gps: []})
  fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
if(!JSON.stringify(adsgp).includes("mensagens")) {
  adsgp.push({tipo: "mensagens", msgs: []})
  fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
AB = adsgp.map(i => i.tipo).indexOf("grupos")
AC = adsgp.map(i => i.tipo).indexOf("mensagens")
adsgp[AB].gps = []
fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
adsgp[AC].msgs = []
fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
reply("Sistema resetado")
break

case 'setadsgp':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(adsgp).includes("quantidade")) {
  adsgp.push({tipo: "quantidade", quant: 5})
  fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
if(!JSON.stringify(adsgp).includes("grupos")) {
  adsgp.push({tipo: "grupos", gps: []})
  fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
if(!JSON.stringify(adsgp).includes("mensagens")) {
  adsgp.push({tipo: "mensagens", msgs: []})
  fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
var [linkM4, msgM4] = q.split('|')
AB = adsgp.map(i => i.tipo).indexOf("grupos")
AC = adsgp.map(i => i.tipo).indexOf("mensagens")
if(!linkM4) return reply('Insira um link de convite ao lado do comando.')
if(!msgM4) return reply(`Vejo que voc√™ n√£o inseriu a mensagem que ser√° enviada... Fa√ßa assim:\n${prefix+command} link do grupo|mensagem para enviar`)
if(linkM4.includes('chat.whatsapp.com/')) {
  link = linkM4.split('app.com/')[1]
  try {
    var getGroups = await blackmd.groupFetchAllParticipating()
    var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
    var ingfoo = groups.map(v => v)
    ingfoo.sort((a, b) => (a[0] < b.length))
    grupos77 = []
    for(i = 0; i < ingfoo.length; i++) {
      grupos77.push({groupId: ingfoo[i].id})
    }
    adsgp[AB].gps = grupos77
    fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
    adsgp[AC].msgs.push({txt: msgM4, cobrado: false})
    fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
    blackmd.groupAcceptInvite(`${link}`)
    return reply(`Todos os grupos da lista foram salvos na pasta... Qualquer grupo que esteja fora da lista ser√° tratado como indigno e r√©u de receber an√∫ncios em seu chat`)
  } catch(erro) {
    if(String(erro).includes('resource-limit') ) {
      reply('O grupo j√° est√° com o alcance m√°ximo de membros.')
    }
    if(String(erro).includes('not-authorized') ) {
      reply('N√£o foi poss√≠vel entrar no grupo.\nMotivo: Banimento.')
    }
  }
} else return reply('Ops, verifique o link que voc√™ inseriu.')
break

case 'setadstime': case 'sat':
if(!isOwner) return reply(enviar.msg.dono)
if(!JSON.stringify(adsgp).includes("quantidade")) {
  adsgp.push({tipo: "quantidade", quant: 5})
  fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
if(!Number(args[0]) || Number(args[0]) < 1) return reply(`Defina a quantidade de mensagens a serem enviadas no grupo ao usar o comando ${prefix}setadsgp

Ex: ${prefix+command} 5`)
if(q.includes(".")) return reply("N√£o pode n√∫meros decimais")
AB = adsgp.map(i => i.tipo).indexOf("quantidade")
adsgp[AB].quant = Number(args[0])
fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
reply(`Quant. de mensagens definida com sucesso ‚úÖ`)
break

case 'startads': case 'endads':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
adsStart = getGroupAds(from)
if(adsStart.acctive) {
adsStart.acctive = false
saveADS()
return reply(`‚ùï *adssystem desativado com sucesso* üóØ`)
} else {
adsStart.acctive = true
saveADS()
return reply(`üî∞ *adssystem ativado com sucesso* „ÄΩ`)
}
break

case 'addads': case 'setads':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!q) return reply(`Retorne ap√≥s o comando a sua mensagem/an√∫ncio... Ex:
${prefix+command} sua mensagem aqui`)
if(!getGroupAds(from).acctive) return reply(enviar.adsatc)
imgads = []
if(isImage || isQuotedImage) {
  try {
    media = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
    gfb = await getFileBuffer(media, 'image')
    img = await upload(gfb)
    imgads.push(img)
  } catch { return reply(`N√£o foi poss√≠vel salvar essa imagem... ‚ùå`) }
}
addAdminAds(from, sender, q, imgads)
mention(`An√∫ncio salvo com sucesso @${sender.split("@")[0]}. Escreva abaixo o tempo desse an√∫ncio, usando *h* para *horas* e *m* para *minutos*, ex: "1h" (escreva sem as aspas) üôÇ`)
break

case 'listads':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!getGroupAds(from).acctive) return reply(enviar.adsatc)
groupAds = getGroupAds(from).horarios
if(groupAds.length <= 0) return reply(`N√£o h√° an√∫ncios definidos neste grupo...`)
txt = `üìõ *Lista de an√∫ncios programados neste grupo:*
üî∞ *Total:* ${groupAds.length}

${groupAds.map(i =>
`üé≠ *ID:* ${i.id}
üìñ *ADS:* ${i.text.length > 100 ? i.text.slice(0, 100) + `...` : i.text}
‚è± *Tempo:* ${String(i.tempo.valor) + i.tempo.type}
üß© *Pr√≥ximo ADS:* ${i.tempo.horario}
üñº *M√≠dia ( ${i.imagem.length > 0 ? `‚úî` : `‚úñ`} )*`).join(`\n\n`)}`
reply(txt)
break

case 'diminuirtempoads': case 'dta':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!getGroupAds(from).acctive) return reply(enviar.adsatc)
groupAds = getGroupAds(from).horarios
if(groupAds.length <= 0) return reply(`N√£o h√° an√∫ncios definidos neste grupo...`)
if(!q) return reply(`üé≠ *Retorne ap√≥s o comando o id do an√∫ncio que voc√™ quer deletar, ex:*
${prefix+command} 010124013045

_(Olhe no comando ${prefix}listads os ID dispon√≠veis)_`)
if(!isIDads(from, q)) return reply(`ID inexistente ‚ùå`)
AB = groupAds.map(a => a.id).indexOf(q)
gth = groupAds[AB].tempo.horario
if(Number(gth.split(":")[1]) !== 0) {
soma = Number(sendHours("HH")) < Number(gth.split(":")[0]) ? gth.split(":")[0] + ":00" : Number(sendHours("HH")) !== 23 ? String(Number(sendHours("HH")) + 1) + ":00" : "00:00"
groupAds[AB].tempo.horario = soma
saveADS()
return reply(`O an√∫ncio de ID ${q} teve seu hor√°rio alterado de *${gth}h* para *${soma}h* ‚è≤`)
} else return reply(`Este an√∫ncio j√° tem seus minutos em 00`)
break

case 'rmads':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!getGroupAds(from).acctive) return reply(enviar.adsatc)
groupAds = getGroupAds(from).horarios
if(groupAds.length <= 0) return reply(`N√£o h√° an√∫ncios definidos neste grupo...`)
if(!q) return reply(`üé≠ *Retorne ap√≥s o comando o id do an√∫ncio que voc√™ quer deletar, ex:*
${prefix+command} 010124013045

_(Olhe no comando ${prefix}listads os ID dispon√≠veis)_`)
if(!isIDads(from, q) && q.toLowerCase() !== `all`) return reply(`ID inexistente ‚ùå`)
if(q.toLowerCase() == `all`) {
AB = ads.map(a => a.groupId).indexOf(from)
ads.splice(AB, 1)
saveADS()
return reply(`*Todos os an√∫ncios foram deletados com sucesso* ‚úî`)
} else {
rmAds(from, q)
return reply(`*O an√∫ncio de ID ${q} foi deletado com sucesso* ‚úî`)
}
break

case 'addmsg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
AB = avisos.map(i => i.groupId).indexOf(from)
if(!isGroupAdmins) return reply(enviar.msg.adm)
var [write, timezin] = q.split("/")
if(!write) return reply(`KD a mensagem ? Ex:
-> ${prefix+command} Bom dia/06:00 (ser√° enviada uma mensagem neste grupo todo dia √†s 6 da manh√£)`)
if(!timezin) return reply(`KD o hor√°rio ? Ex:
-> ${prefix+command} Boa tarde/12:00 (ser√° enviada uma mensagem neste grupo toda tarde ao meio dia)`)
if(!timezin.includes(":")) return reply(`Separe as horas e minutos com "dois pontos" ( : ), ex:
-> ${prefix+command} Boa tarde/15:30 (ser√° enviada uma mensagem neste grupo toda tarde √†s 15 horas e 30 minutos)`)
if(!Number(timezin.replace(":", ""))) return reply(`N√£o inclua outro caractere no hor√°rio al√©m dos "dois pontos" ( : ), ex:
-> ${prefix+command} Boa noite/18:02 (ser√° enviada uma mensagem neste grupo toda noite √†s 18 horas e 2 minutos)`)
day = moment.tz('America/Sao_Paulo').format('DD')
avisos[AB].mensagens.push({msg: write, tempo: timezin, dia: "00"})
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Registro criado com sucesso... A mensagem "${write.slice(0, 50)+"..."}" ser√° repassada neste grupo todo dia √†s ${timezin}

Caso queira apagar o registro, use ${prefix}rmmsg`)
break

case 'addrandom':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
AB = avisos.map(i => i.groupId).indexOf(from)
AC = avisos.map(i => i.groupId).indexOf("matheuzinho")
if(!isGroupAdmins) return reply(enviar.msg.adm)
var [time, typeRandom] = q.split("/")
if(!time) return reply(`Coloque o hor√°rio em que as mensagens aleat√≥rias da caixa ser√£o enviadas neste grupo...`)
if(!time.includes(":")) return reply(`Separe as horas e minutos com "dois pontos" ( : ), ex:
-> ${prefix+command} 15:30/0`)
if(!Number(time.replace(":", ""))) return reply(`N√£o inclua outro caractere no hor√°rio al√©m dos "dois pontos" ( : ), ex:
-> ${prefix+command} 18:02/0`)
if(Number(typeRandom) !== 1 && Number(typeRandom) !== 2) return reply(`Coloque uma barra ( / ) ap√≥s o hor√°rio e defina com 1 se as mensagens forem puxadas da caixa do grupo e 2 se as mensagens forem puxadas da caixa global... Ex:
-> ${prefix+command} 14:00/1`)
if(Number(typeRandom) === 1 && avisos[AB].globalAleatory.length <= 1) return reply(`N√£o h√° mensagens suficientes na caixa do grupo para sortear aleatoriamente... Use o comando ${prefix}envrandom primeiro`)
if(Number(typeRandom) === 2 && avisos[AC].mensagens.length <= 1) return reply(`N√£o h√° mensagens suficientes na caixa global para sortear aleatoriamente... Use o comando ${prefix}envrandom primeiro`)
day = moment.tz('America/Sao_Paulo').format('DD')
avisos[AB].aleatory.push({tempo: time, dia: "00", ativation: Number(typeRandom) > 1 ? true : false})
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Mensagem aleat√≥ria da caixa definida todo dia neste grupo √†s ${time}... Caso queira deletar o hor√°rio, use ${prefix}delrandom`)
break

case 'envrandom':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
AB = avisos.map(i => i.groupId).indexOf(from)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!q) return reply(`Coloque ap√≥s o comando uma mensagem para ser enviada para a caixa do grupo... Ao usar o comando ${prefix}addrandom, o bot enviar√° aleatoriamente uma das mensagens dessa caixa no hor√°rio definido`)
avisos[AB].globalAleatory.push(q)
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Mensagem deste grupo definida com sucesso... Caso queira enivar, use ${prefix}addrandom`)
break

case 'envglobal':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
AB = avisos.map(i => i.groupId).indexOf("matheuzinho")
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`Coloque ap√≥s o comando uma mensagem para ser enviada para a caixa do grupo... Ao usar o comando ${prefix}addrandom, o bot enviar√° aleatoriamente uma das mensagens dessa caixa no hor√°rio definido`)
avisos[AB].mensagens.push(q)
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Mensagem globlal definida com sucesso... Caso queira enivar, use ${prefix}addrandom`)
break

case 'rmmsg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = avisos.map(i => i.groupId).indexOf(from)
if(avisos[AB].mensagens.length <= 0) return reply(`N√£o h√° avisos neste grupo`)
if(!Number(args[0]) || Number(args[0]) < 1 || Number(args[0]) > avisos[AB].mensagens.length) return reply(`Olhe no comando ${prefix}listmsg o n√∫mero correspondente a mensagem que voc√™ quer apagar... Ex:
-> ${prefix+command} 2`)
BC = Number(args[0]) - 1
avisos[AB].mensagens.splice(BC, 1)
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Mensagem deletada com sucesso...`)
break

case 'delrandom':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = avisos.map(i => i.groupId).indexOf(from)
if(avisos[AB].aleatory.length <= 0) return reply(`N√£o h√° hor√°rio definidos neste grupo`)
if(!Number(args[0]) || Number(args[0]) < 0 || Number(args[0]) > avisos[AB].aleatory.length) return reply(`Olhe no comando ${prefix}listmsg o n√∫mero correspondente ao hor√°rio que voc√™ quer apagar... Ex:
-> ${prefix+command} 2`)
BC = Number(args[0]) - 1
avisos[AB].mensagens.splice(BC, 1)
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Hor√°rio deletado com sucesso...`)
break

case 'rmrandom':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = avisos.map(i => i.groupId).indexOf(from)
if(avisos[AB].globalAleatory.length <= 0) return reply(`N√£o h√° nenhuma mensagem na caixa deste grupo`)
if(!Number(args[0]) || Number(args[0]) < 0 || Number(args[0]) > avisos[AB].globalAleatory.length) return reply(`Olhe no comando ${prefix}listmsg o n√∫mero correspondente a mensagem que voc√™ quer apagar... Ex:
-> ${prefix+command} 2`)
BC = Number(args[0]) - 1
avisos[AB].globalAleatory.splice(BC, 1)
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Mensagem deletada com sucesso...`)
break

case 'rmglobal':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!isOwner) return reply(enviar.msg.dono)
AB = avisos.map(i => i.groupId).indexOf("matheuzinho")
if(avisos[AB].mensagens.length <= 0) return reply(`N√£o h√° nenhuma mensagem na caixa global`)
if(!Number(args[0]) || Number(args[0]) < 0 || Number(args[0]) > avisos[AB].mensagens.length) return reply(`Olhe no comando ${prefix}listmsg o n√∫mero correspondente a mensagem que voc√™ quer apagar... Ex:
-> ${prefix+command} 2`)
BC = Number(args[0]) - 1
avisos[AB].mensagens.splice(BC, 1)
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Mensagem deletada com sucesso...`)
break

case 'listmsg':
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = avisos.map(i => i.groupId).indexOf(from)
if(avisos[AB].mensagens.length <= 0) return reply(`N√£o h√° avisos neste grupo`)
txt = `üé¥ *Exbindo ${avisos[AB].mensagens.length > 1 ? `os ${avisos[AB].mensagens.length} avisos progamados neste grupo` : `o √∫nico aviso progamado deste grupo`} ‚Ü¥*`
for(i = 0; i < avisos[AB].mensagens.length; i++) {
  txt += `\n\n¬ª${i + 1}¬´ *Mensagem:* ${avisos[AB].mensagens[i].msg}
*Hor√°rio:* ${avisos[AB].mensagens[i].tempo}`
}
txt += `\n\n_Caso queira apagar uma mensagem, use ${prefix}rmmsg e ap√≥s o comando, o n√∫mero correspondente... Ex: ${prefix}rmmsg 1_`
if(avisos[AB].aleatory.length > 0) {
  txt += `\n\nüîÅ *Exibindo caixa de mensagens aleat√≥rias porgramadas neste grupo ‚Ü¥*`
  for(i = 0; i < avisos[AB].aleatory.length; i++) {
    txt += `\n¬ª${i + 1}¬´ -> ${avisos[AB].aleatory[i].tempo}`
  }
  txt += `\n\n_Caso queira apagar uma mensagem, use ${prefix}rmrandom e ap√≥s o comando, o n√∫mero correspondente... Ex: ${prefix}rmrandom 1_`
}
reply(txt)
break

case 'infomsg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!isGroupAdmins) return reply(enviar.msg.adm)
reply(`*Comandos do sistema de mensagem programada:*
-> ${prefix}listmsg
_Lista todos os hor√°rios programados neste grupo_

-> ${prefix}addmsg
_Adiciona uma mensagem programada neste grupo_

-> ${prefix}rmmsg
_Deleta a mensagem programada selecionada deste grupo_

-> ${prefix}envrandom
_Cria uma caixa de mensagens dentro do grupo para usar o comando ${prefix}addrandom_

-> ${prefix}addrandom
_Ao definir um hor√°rio, ser√° enviado uma mensagem aleat√≥ria de dentro da "caixa" do comando acima todo dia no hor√°rio definido_

-> ${prefix}delrandom
_Deleta a frase aleat√≥ria criada no comando acima_

-> ${prefix}envglobal
_Cria uma caixa global enviando a frase para l√°. √â √∫til para quando quiseres usar o comando acima de mensagens aleat√≥rias em v√°rios grupos e n√£o quer fazer o mesmo processo em cada grupo... Basta usar esse comando e ap√≥s ele o ${prefix}envrandom_

-> ${prefix}rmgloblal
_Deleta a mensagem da caixa global criada acima_`)
break

case 'rggp':
if(!isOwner) return reply(enviar.msg.dono)
if(JSON.stringify(globegroup).includes(from)) return reply(`Grupo j√° registrado...`)
try {
var fotogp = await blackmd.profilePictureUrl(from, 'image')
} catch {
var fotogp = `https://telegra.ph/file/6ca032835ed7a16748b6f.jpg`
}
linkgp = await blackmd.groupInviteCode(from)
globegroup.push({id: from, thumb: fotogp, nome: groupName, link: `https://chat.whatsapp.com/${linkgp}`})
fs.writeFileSync("./basededados/globegroup.json", JSON.stringify(globegroup, null, 2))
reply(`Grupo adicionado ao comando global ${prefix}grupos`)
break

case 'rmgp':
if(!isOwner) return reply(enviar.msg.dono)
rmgp = q.length > 8 ? q : from
if(!JSON.stringify(globegroup).includes(rmgp)) return reply(`Grupo n√£o registrado...`)
AB = globegroup.map(i => i.id).indexOf(rmgp)
globegroup.splice(AB, 1)
fs.writeFileSync("./basededados/globegroup.json", JSON.stringify(globegroup, null, 2))
reply(`Grupo retirado do comando global ${prefix}grupos`)
break

case 'grupos':
if(isGroupAdmins || isVip) {
  if(globegroup.length > 0) {
    gpale = globegroup[Math.floor(Math.random()*globegroup.length)]
    blackmd.sendMessage(from, {image: {url: gpale.thumb}, caption: `_‚è§ÕüÕûÕüÕû Í¶øLink do grupo ‚Ü¥_
‚áí ${gpale.nome}

${gpale.link}`}, {quoted: seloctt})
  } else {
    reply("N√£o h√° grupos registrados...")
  }
} else {
  reply("[ ‚ùó ] s√≥ ADM ou VIP ‚ùå")
}
break

case 'gerargrupos'://By: Aqua Bot
case 'gerargrupo'://By: Aqua Bot
case 'gerargp'://By: Aqua Bot
if(!q) return reply("Ei, qual tipo de grupo?")
reply(`üîé _procurando grupos_ üîç`)
 if(!isVip) return reply(enviar.msg.vip)  
    swp = await fetchJson(`https://tohka.tech/api/pesquisa/gpwhatsapp?nome=${q}&apikey=Misaki`)
    teks = `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ‚ùØ‚ùØ   *BLACK BOT - GRUPOS* ‚ùÆ‚ùÆ\n\n`;
    for(let i of swp) {
        teks += "‚ñß‚ÉØ‚ÉüNOME„Äé" + i.nome + "„Äè\n"
        teks += "‚ñß‚ÉØ‚ÉüDESCRI√á√ÉO‚Üí " + i.descri√ß√£o + "\n"
        teks += "‚ñß‚ÉØ‚ÉüLINK‚Üí " + i.link + "\n\n"
    }
    teks += `‚òÜ„ÉÖ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅBLACK BOT‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ„ÉÖ‚òÜ`
  reply(teks)
break

case 'mute':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!menc_os2) return reply(prefix + command + " @ da pessoa")
if(sender.includes(menc_os2)) return reply(`N√£o √© poss√≠vel mutar a si mesmo...`)
if(numerodono.includes(menc_os2)) return reply(`N√£o √© poss√≠vel mutar meu dono...`)
if(botNumber.includes(menc_os2)) return reply(`N√£o √© poss√≠vel mutar o bot...`)
if(groupAdmins.includes(menc_os2)) return reply(`N√£o √© poss√≠vel mutar um ADM...`)
if(JSON.stringify(vip).includes(menc_os2)) return reply(`N√£o √© poss√≠vel mutar um usu√°rio VIP...`)
if(JSON.stringify(mute).includes(from)) {
AB = mute.map(i => i.gpid).indexOf(from)
if(JSON.stringify(mute[AB].mutados).includes(menc_os2)) return reply(`Este usu√°rio j√° est√° mutado...`)
mute[AB].mutados.push({id: menc_os2, sn: false})
fs.writeFileSync("./basededados/mute.json", JSON.stringify(mute, null, 2))
} else {
mute.push({gpid: from,
mutados: [{id: menc_os2, sn: false}]
})
fs.writeFileSync("./basededados/mute.json", JSON.stringify(mute, null, 2))
}
reply(`Usu√°rio mutado com sucesso... Caso ele fale algo, ser√° banido.`)
break

case 'desmute':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!JSON.stringify(mute).includes(from)) return reply(enviar.msg.notusu)
if(menc_os2) {
var qp = menc_os2
} else {
var qp = args[0] + `@s.whatsapp.net`
}
AB = mute.map(i => i.gpid).indexOf(from)
BC = mute[AB].mutados.map(a => a.id).indexOf(qp)
if(BC < 0) return reply(enviar.msg.notusu)
mute[AB].mutados.splice(BC, 1)
fs.writeFileSync("./basededados/mute.json", JSON.stringify(mute, null, 2))
reply(`Usu√°rio desmutado com sucesso...`)
break

case 'mutelist':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!JSON.stringify(mute).includes(from)) return reply(`N√£o h√° usu√°rios mutados neste grupo...`)
AB = mute.map(i => i.gpid).indexOf(from)
if(Number(mute[AB].mutados.length) > 0) {
txt = `ü§´ *Usu√°rios mutados do grupo ‚Ü¥*
${groupName}
üìü *Total:* ${mute[AB].mutados.length}\n`
for(a = 0; a < mute[AB].mutados.length; a++) {
txt += `‚Ä¢ @${mute[AB].mutados[a].id.split('@')[0]}\n`
}
mention(txt)
} else {
reply(`N√£o h√° usu√°rios mutados neste grupo...`)
}
break

case 'infomute':
reply(`${tempo} ${pushname}, os comandos dispon√≠veis s√£o:
‚Ä¢ ${prefix}mute
‚Ä¢ ${prefix}desmute
‚Ä¢ ${prefix}mutelist

-> ${prefix}mute
Marque o usu√°rio com @ ou a mensagem dele, para mutar o mesmo...

-> ${prefix}desmute
Marque o usu√°rio com @ ou a mensagem dele, para desmutar o mesmo... O ban n√£o anula o mute.

-> ${prefix}mutelist
Ir√° mostrar a lista de todos os usu√°rios mutados... Bem, se houver algum.`)
break

case 'inforoleta':
setTimeout(() => {reagir(from, "üíÄ")}, 300)
reply(`H√° duas roletas russas funcionando...

[ ${prefix}roleta ]
O bot ir√° escolher aleatoriamente uma pessoa do grupo, e banir imediatamente...

[ ${prefix}roleta2 ]
A roleta 2 ir√° fazer a mesma coisa que a de cima... Por√©m nesta, os ADMs estar√£o salvos do banimento.`)
break

case 'roleta':
reagir(from, "üíÄ")
if(!isModobn) return reply(enviar.msg.modobz)
if(!isGroupAdmins) return reply(`Voc√™ n√£o tem essa permiss√£o... üñêüèΩüòî`)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
membros = []
for(i = 0; i < groupMembers.length; i++) {
if(groupMembers[i].id != nmrdn && groupMembers[i].id != botNumber && groupMembers[i].id != groupMetadata.owner) membros.push({id: groupMembers[i].id})
}
if(membros.length > 0) {
alerl = membros[Math.floor(Math.random() * membros.length)].id
mention(`Entre os sorteados do grupo ${groupName}, @${alerl.split('@')[0]} hoje n√£o √© seu dia de sorte...`)
balas = ["vazio", "vazio", "vazio", "vazio", "vazio", "cheio", "cheio", "cheio"]
balinha = balas[alerandom(balas.length)]
await sleep(1000)
if(balinha == "vazio") return sendMess(from, "Hahaha, t√¥ zoando... sorte sua que o cartucho tava vazio ü§°")
blackmd.sendMessage(from, {text: `Suas √∫ltimas palavras...`})
blackmd.groupParticipantsUpdate(from, [alerl], "remove")
} else {
reply(`N√£o h√° membros suficientes no grupo para efetuar a roleta russa...`)
}
break

case 'roleta2':
reagir(from, "üíÄ")
if(!isModobn) return reply(enviar.msg.modobz)
if(!isGroupAdmins) return reply(`Voc√™ n√£o tem essa permiss√£o... üñêüèΩüòî`)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(somembros.length <= 0) return reply(`S√≥ foram encontrados admins no grupo ${groupName}`)
membros = []
for(i = 0; i < somembros.length; i++) {
if(!numerodono.includes(somembros[i]) && !botNumber.includes(somembros[i]) && !groupMetadata.owner.includes(somembros[i])) membros.push({id: somembros[i]})
}
if(membros.length > 1) {
alerl = membros[Math.floor(Math.random() * membros.length)].id
mention(`Entre os sorteados do grupo ${groupName}, @${alerl.split('@')[0]} hoje n√£o √© seu dia de sorte...`)
balas = ["vazio", "vazio", "vazio", "vazio", "vazio", "cheio", "cheio", "cheio"]
balinha = balas[alerandom(balas.length)]
await sleep(1000)
if(balinha == "vazio") return sendMess(from, "Hahaha, t√¥ zoando... sorte sua que o cartucho tava vazio ü§°")
blackmd.sendMessage(from, {text: `Suas √∫ltimas palavras...`})
blackmd.groupParticipantsUpdate(from, [alerl], "remove")
} else {
reply(`N√£o h√° usu√°rios suficientes para efetuar o sistema de roleta russa...`)
}
break

case 'promover': case 'promo':
setTimeout(() => {reagir(from, "üëë")}, 300)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!menc_os2 || menc_jid2[1]) return reply("Marque a mensagem do usu√°rio ou marque o @ dele.., lembre de s√≥ marcar um usu√°rio...")
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Este usu√°rio foi removido do grupo ou saiu, n√£o ser√° poss√≠vel promover..")
blackmd.sendMessage(from, {text: `@${menc_os2.split("@")[0]} *ACABA DE RECEBER A COROA DE ADMINISTRADOR DO GRUPO... ESPERO QUE HONRE A SUA FUN√á√ÉO* üëë`, mentions: [menc_os2]})
blackmd.sendMessage(from, {audio: {url:'./database/audios/promovido.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.groupParticipantsUpdate(from, [menc_os2], "promote")  
break

case 'rebaixar': case 'reb':
setTimeout(() => {reagir(from, "ü•≤")}, 300)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!menc_os2 || menc_jid2[1]) return reply("Marque a mensagem do usu√°rio ou marque o @ dele.., lembre de s√≥ marcar um usu√°rio...")
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Este usu√°rio foi removido do grupo ou saiu, n√£o ser√° poss√≠vel rebaixar..")
blackmd.sendMessage(from, {text: `@${menc_os2.split("@")[0]} *ACABA DE PERDER A COROA DE ADM DO GRUPO...* ü•≤`, mentions: [menc_os2]})
blackmd.groupParticipantsUpdate(from, [menc_os2], "demote")  
break

case 'alfabeto':
case 'a':
setTimeout(() => {reagir(from, react2)}, 300)
if(!q) return reply(`*Ex:* A letra que cair √© a inicial da pessoa que vai te fazer feliz esse ano...`)
alfa = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S","T","U","V","W","X","Y","Z"]
reply(`‚ù§Ô∏è‚Äçüî• Vamos sortear uma letra para a frase‚ü©
${q}`)
setTimeout(async() => {
blackmd.sendMessage(from, {text: `${alfa[Math.floor(Math.random()*alfa.length)]} ${react2}`})
}, 2000)
break

case 'sorteio2':
if(!isGroupAdmins) return reply(enviar.msg.adm)
try{
if(!isGroup) return reply(enviar.msg.grupo)
if(!q) return reply(`Coloque algo, ap√≥s o comando sorteio, por exemplo, ${prefix+command} de 100 R$`)
d = []
teks = `üéâParab√©ns, por ganhar o sorteio ${q}:\n\n`
for(i = 0; i < 1; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `üî•·çù‚Éü¬†¬†‚û£ @${groupMembers[r].id.split('@')[0]}\n`
d.push(groupMembers[r].id)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
reply('Deu erro, tente novamente :/')
}
break

case 'sorteio':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(isJsonIncludes(sorteio, from)) return reply(`H√° um sorteio em andamento neste grupo...`)
if(!q) return reply(`Voc√™ precisa configurar o sorteio primeiro, definindo hor√°rio, participante e emoji... Se tiver mais d√∫vidas, olhe no ${prefix}infosorteio`)
cont = contar(q, " ")
if(cont != 2 && !isJsonIncludes(sorteio, from)) return reply(`Vejo que voc√™ est√° usando de forma errada... Precisa ser desse jeito:
${prefix+command} 12:45 1/all ‚ù§`)
var [time, part, emj] = q.split(` `)
var [p_win, p_all] = part.split(`/`)
if(!Number(time.replace(":", ""))) return reply(`Pfvr ${pushname}, revise o hor√°rio que vc colocou...`)
horacerta = converterMin(contarMin(time))
if(contarMin(horacerta) <= contarMin(sendHours("HH:mm"))) return reply(`O sistema de sortieo est√° em desenvolvimento... Portanto, selecione um hor√°rio acima do atual üé≠`)
total_p = p_all.toLowerCase() == "all" ? groupMembers.length - 1 : p_all
lm = converterMin((contarMin(horacerta) - 5) < 0 ? contarMin("24:00") + (contarMin(horacerta) - 5) : contarMin(horacerta) - 5)
if(Number(p_win) > Number(total_p)) return reply(`A quantidade de ganhadores n√£o pode ser maior que a quantidade de participantes`)
if(!antiModLetra(emj)) return reply(`Voc√™ n√£o indicou com emoji, a rea√ß√£o devida...`)
msg = info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.conversation || info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.extendedTextMessage?.text
if(!msg) return reply(`Vc n√£o marcou a mensagem ksksks Marque uma mensagem, que no caso √© o t√≠tulo do sorteio, e este texto ser√° salvo no banco de dados do bot para ser sorteado no hor√°rio determinado ü•∞`)
sorteio.push({groupId: from, texto: msg, data: horacerta, dia: sendHours("DD"), emoji: emj, limite: lm, ganhadores: Number(p_win), total: Number(total_p), start: false, participants: []})
saveJSON(sorteio, "./basedefuncionamento/sorteio.json")
txt = `üë§ *Admin:* @${sender.split("@")[0]}
‚è≥ *Hor√°rio:* ${horacerta}

\t\t\t‚ö† *ATEN√á√ÉO MEMBROS* ‚ö†

${msg}

_Se voc√™ tiver interesse em participar do sorteio acima, reaja esta mensagem com o emoji "${emj}"_
_H√° ${total_p} vagas... Entrada ser√° encerrada ${lm} (admins podem mudar esse limite no comando ${prefix}stms)_`
reagir(from, emj)
blackmd.sendMessage(from, {text: txt, mentions: groupMembers.map(i => i.id)}, {quoted: seloctt})
break

case 'sortelist':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = sorteio.map(i => i.groupId).indexOf(from)
if(AB < 0) return reply(enviar.msg.notusu)
txt = `‚è≥ *Hor√°rio do sorteio:* ${sorteio[AB].data}
üòé *Entrada limite:* ${sorteio[AB].limite}
üëª *Total:* ${sorteio[AB].participants.length}/${sorteio[AB].total}
üë§ *Participantes:*${sorteio[AB].participants.map(p => `\n‚Ä¢ @${p.split("@")[0]}`).join(``)}

\t${sorteio[AB].texto}

_Se voc√™ tiver interesse em participar do sorteio acima, basta reagir esta mensagem com o emoji "${sorteio[AB].emoji}"_`
mention(txt)
break

case 'stms':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = sorteio.map(i => i.groupId).indexOf(from)
if(AB < 0) return reply(enviar.msg.notusu)
if(!Number(args[0])) return reply(`Retorne ap√≥s o comando quantos minutos antes do sorteio, os usu√°rios poder√£o entrar..., Ex: ${prefix+command} 5`)
nmr = converterMin(contarMin(sorteio[AB].data) - Number(args[0]))
sorteio[AB].limite = nmr
saveJSON(sorteio, "./basedefuncionamento/sorteio.json")
reply(`O hor√°rio limite para participar do sorteio neste grupo foi atualizado com sucesso para ${nmr} ‚úÖ`)
break

case 'stopsorte':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = sorteio.map(i => i.groupId).indexOf(from)
if(AB < 0) return reply(enviar.msg.notusu)
sorteio.splice(AB, 1)
saveJSON(sorteio, "./basedefuncionamento/sorteio.json")
reply(`O sorteio deste grupo foi cancelado com sucesso...`)
break

case 'nuke': case 'arquivargp':
if(!isOwner) return reply(enviar.msg.dono)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(info.key.fromMe) return 
grupo = groupMembers.map(i => i.id)
grupo.splice(grupo.indexOf(nmrdn), 1)
grupo.splice(grupo.indexOf(botNumber), 1)
if(grupo.length <= 0) return reply("N√£o h√° membros para banir aqui...")
for(i = 0; i < grupo.length; i++) {
await sleep(1300)
blackmd.groupParticipantsUpdate(from, [grupo[i]], 'remove')
}
break

case 'sorteionumero':
case 'snmr':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
if(!q) return reply(`Escolha um n√∫mero m√°ximo...
Ex: ${prefix+command} 300`)
reply(`_Sorteando n√∫mero aleat√≥rio entre 0-${q}_`)
setTimeout(async() => {
try {
blackmd.sendMessage(from, {text: `*N√∫mero sorteado ( ${Math.floor(Math.random()*q)} )*`})
} catch {
blackmd.sendMessage(from, {text: `${q} n√£o √© n√∫mero... üòï`})
}
}, 1100)
break

//==========(TTPS/ATTP)============\\

case 'ttp':
    if (!q) return reply(`*_‚ùïColoque o texto que voc√™ quiser!_*\n- *üßë‚Äçüè´ Por exemplo:* ${prefix + command} sandro`);

    reagir(from, "üëª");
    await sleep(1000);
    reply('fazendo');

    // Montar a URL da API com o texto fornecido
    const string = args.join(' ') || 'Texto indefinido';
    const post = `https://api.maher-zubair.tech/maker/text2img?q=${encodeURIComponent(string)}`;

    // Fun√ß√£o para enviar sticker a partir da URL
    const sendStickerFromUrl = async (to, url, options) => {
        try {
            const buffer = await getBuffer(url);
            const filePath = 'temp.png'; // Caminho tempor√°rio para o arquivo
            fs.writeFileSync(filePath, buffer);

            // Converter a imagem para WebP
            const webpPath = 'temp.webp';
            exec(`ffmpeg -i ${filePath} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${webpPath}`, (err) => {
                if (err) {
                    console.error('Erro ao converter imagem para WebP:', err);
                    reply("Erro ao converter imagem para figurinha");
                    return;
                }

                // Enviar a figurinha
                blackmd.sendMessage(to, { sticker: fs.readFileSync(webpPath) }, options);

                // Limpar arquivos tempor√°rios
                fs.unlinkSync(filePath);
                fs.unlinkSync(webpPath);
            });
        } catch (error) {
            console.error('Erro ao obter o buffer:', error);
            reply("Erro ao criar a figurinha");
        }
    };

    // Enviar a figurinha
    sendStickerFromUrl(from, post, { quoted: info }).catch(e => {
        reply(mess.error());
    });
    break;

case 'attp1':
case 'attp2':
case 'attp3':
case 'attp4':
case 'attp5':
case 'attp6':
case 'attp7':
case 'attp8':
case 'attp9':
case 'attp10':
    if (!q) return reply("Ei, Cad√™ o Texto?");
    try {
        reply(`*Gerando figu com a frase* _"${q.split("\n").join("_\n_")}"_`);
        let link = `https://world-ecletix.onrender.com/api/attp?texto=${encodeURIComponent(q)}&tipo=${command}`;
        blackmd.sendMessage(from, { sticker: { url: link } }, { quoted: info });
    } catch (err) {
        reply("Erro ao gerar a figurinha");
    }
    break;

//======================================\\

//===(ZOUEIRAS/BRINCADEIRAS/HUMOR)===\\

case 'modonsfw':
case 'nsfw':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('Hmmmm')
if(Number(args[0]) === 1) {
if(isNsfw) return reply('O modo nsfw j√° est√° ativo')
nsfw.push(from)
fs.writeFileSync('./database/grupos/nsfw.json', JSON.stringify(nsfw))
reply(`\`\`\`‚úìAtivado com sucesso o modo nsfw +18 no grupo\`\`\` *${groupMetadata.subject}*`)
} else if(Number(args[0]) === 0) {
if(!isNsfw) return reply('O modo nsfw j√° est√° Desativado')  
nsfw.splice(from, 1)
fs.writeFileSync('./database/grupos/nsfw.json', JSON.stringify(nsfw))
reply(`\`\`\`‚úìModo Nsfw +18 desativado com sucesso no grupo\`\`\` *${groupMetadata.subject}*`)
} else {
reply('1 para ativar, 0 para desligar')
}
break 

case 'sn':
  setTimeout(() => {reagir(from, "ü§î")}, 300)
  if(!q) return reply(`*Fa√ßa uma pergunta para o bot responder com sim/n√£o...*\n*Exemplo:* ${prefix+command} hj tem gol do Ribamar ?`)
  const sn = ['sim', 'n√£o']
  const sn2 = ["creio que", "acredito que", "acho que", "receio que"]
const sn_ = sn[Math.floor(Math.random() * (sn.length))]
const sn2_ = sn2[Math.floor(Math.random() * (sn2.length))]
  sim_nao = `Pergunta‚ßΩ ${q}\n\n*Pensando bem... ${sn2_} ${sn_}* ü§∑üèª‚Äç‚ôÇÔ∏è`
reply(sim_nao)
break

case 'campominado': case 'campo-minado':
if(!isGroup) return reply(enviar.msg.grupo)
game = `./armor/jogo/mina-game/campo-minado-${from}.json`
if(!fs.existsSync(game)) {
barra = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/")
var [mark, difi] = barra.split("/")
if(!mark.includes("@")) return reply("Marque algu√©m do grupo para jogar com voc√™, o @ ou a mensagem...")
usu = mark.split("@")[1] + "@s.whatsapp.net"
if(!isJsonIncludes(groupMembers, usu)) return reply("Usu√°rio marcado n√£o est√° mais entre n√≥s...")
if(usu == botNumber) return reply("Eu sou o bot n√© meu pr√ß, eu n√£o jogo ü§¶üèª‚Äç‚ôÇÔ∏è")
pc = prefix+command
if(q.includes("@") && !q.includes("/")) return mention(`üí£ Vc deve escolher entre uma das tr√™s dificuldades:
üåü‚É§ ${pc+" "+q}/easy
‚ö°‚É§ ${pc+" "+q}/medium
üí•‚É§ ${pc+" "+q}/hard`)
qp = difi.toLowerCase()
if(qp != "easy" && qp != "medium" && qp != "hard") return mention(`Vc deve escolher entre uma das tr√™s dificuldades:
${pc+" "+q}/easy
${pc+" "+q}/medium
${pc+" "+q}/hard`)
if(qp == "easy") { mm = 7; mxm = 9 }
if(qp == "medium") { mm = 14; mxm = 7 }
if(qp == "hard") { mm = 21; mxm = 5 }
delt = []
for(a = 1; a < (mxm + 1); a++) {
  for(b = 1; b < (mxm + 1); b++) {
    if(b == 1) c = "a"
    if(b == 2) c = "b"
    if(b == 3) c = "c"
    if(b == 4) c = "d"
    if(b == 5) c = "e"
    if(b == 6) c = "f"
    if(b == 7) c = "g"
    if(b == 8) c = "h"
    if(b == 9) c = "i"
    delt.push(a+c)
  }
}
caixa = []
for(i = 0; i < mm; i++) {
  valor = alerandom(delt.length)
  caixa.push(delt[valor])
  delt.splice(valor, 1)
}
start = {
  ID: sendHours("DDMMYYYYHHmmss"),
  jogadores: [{id: sender, erros: 3}],
  criador: sender,
  chamado: usu,
  play: 0,
  come√ßou: false,
  dificuldade: qp,
  totalminas: mm,
  totalquad: mxm,
  minas: caixa,
  plantado: []
}
fs.writeFileSync(game, JSON.stringify(start, null, 2))
mention(`‚ö° ${tempo} @${usu.split('@')[0]},
@${sender.split('@')[0]} est√° te desafiando para jogar uma partida eletrizante n√≠vel ${qp} de "campo minado" üí£üòú

Digite ¬ª S ¬´ para aceitar e ¬ª N ¬´ para recusar ü´µüèΩüòÑ`)
await sleep(900000)
finish = `./armor/jogo/mina-game/campo-minado-${from}.json`
if(fs.existsSync(finish) && JSON.parse(fs.readFileSync(finish)).ID == sendHours("DDMMYYYYHHmmss")) {
  fs.unlinkSync(finish)
  reply("Sess√£o expirada üí£")
}
} else {
  campominado = JSON.parse(fs.readFileSync(game))
  if(campominado.come√ßou == true) {
    if(isJsonIncludes(campominado.jogadores, sender)) return reply("Voc√™ j√° est√° jogando "+pushname)
    return mention(`‚ö° Os presentes membros ${campominado.jogadores.map(i => `@`+i.id.split("@")[0]).join(` e `)} est√£o jogando no momento... Pfvr, aguarde a partida terminar üí£`)
  } else {
    if(campominado.chamado == sender) return mention(`*‚ö° Voc√™ foi convidado pelo @${campominado.criador.split("@")[0]} para jogar "campo minado" n√≠vel ${campominado.dificuldade}... Pfvr, digite sim/n√£o üí£*`)
    if(campominado.criador == sender) return mention(`*üòì T√¥ aguardando confirma√ß√£o do @${campominado.chamado.split("@")[0]}...* (Caso queira desistir, use ${prefix}resetmina)`)
    return reply("‚ö° H√° uma partida em andamento neste grupo üí£")
  }
}
break

case 'resetmina': case 'rmn':
if(!isGroup) return reply(enviar.msg.grupo)
game = `./armor/jogo/mina-game/campo-minado-${from}.json`
if(!fs.existsSync(game)) return reply("Nenhuma sess√£o em andamento neste grupo üí£üòú")
campominado = JSON.parse(fs.readFileSync(game))
if(!isGroupAdmins && campominado.criador != sender) return reply("[ ‚ùó ] apenas admins do grupo ou quem come√ßou o jogo podem cancelar a partida ‚ùå")
fs.unlinkSync(game)
reply("Partida cancelada üí£üòú")
break

case 'infominagame':
reply(`üí£ O primeiro passo √© chamar algu√©m pra jogar e escolher a dificuldade, que pode ser easy, medium ou hard... Use o comando ${prefix}campo-minado

üòú Ap√≥s configurada a dificuldade e chamado o jogador, o mesmo ter√° que responder com sim/n√£o para iniciar ou terminar o jogo.

üéÆ Uma vez aceito, j√° em jogo, ambos os jogadores ter√£o 3 chances de errar... Basta responder a coordenada como 2b ou 5a, sempre colocando a letra ap√≥s o n√∫mero.

üèÜ Vence o jogador que mais sobreviver`)
break

case 'addforca':
if(!isOwner) return reply(enviar.msg.dono)
if(contar(q, `/`) != 2) return reply(`Retorne ap√≥s o comando o tema, a palavra e a dica que voc√™ deseja adicionar...
Ex: ve√≠culo/carro/tem 4 rodas`)
var [tema, palavra, dica] = q.split(`/`)
rgWordForcaGame(tema, palavra, dica);
txt = `üéó *_Forca registrada com sucesso_* üéó
üé≠ *Tema:* ${iniMai(tema)}
üé® *Palavra:* ${iniMai(palavra)}
üß∂ *Dica:* ${iniMai(dica)}`
reply(txt)
break

case 'rmforca':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`KD a palavra que voc√™ quer deletar?`)
rmWordForcaGame(reply, q);
break

case 'rmtema':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`KD o tema que voc√™ quer deletar?`)
rmThemeForcaGame(reply, q);
break

case 'listword': case 'listaforca':
if(!isOwner) return reply(enviar.msg.dono)
if(forcaWord.length <= 0) return reply(`[‚ùó] n√£o h√° palavras salvas ‚ùå`)
txt = forcaWord.map(a => `üéà _*Tema:* ${iniMai(a.title)}_
üìö _*Palavras ‚Ü¥*_
${a.words.map(b => `\tüé≤ *Nome:* ${iniMai(b.nome)}
\tüß∏ *Dica:* ${iniMai(b.desc)}`).join(`\n\n`)}`).join(`\n\n-\n\n`)
reply(txt)
break

case 'forca': case 'startforca':
if(!isGroup) return reply(enviar.msg.grupo)
reagir(from, "üéó")
if(!existSomeWordForcaGame) return reply(`N√£o h√° palavras na database do bot para seres distribuidas... Chame o dono do bot para ele adicionar mais palavras ü•∞`)
if(isForcaGame(from)) {
  reply(`üéó H√° uma sess√£o em andamento... Use ${prefix}fc para responder ou ${prefix}rrfc para reiniciar`)
  await sleep(5000)
  return sendTextForcaGame(reply, prefix, from)
}
startForcaGame(reply, prefix, from)
break

case 'myforca': case 'minhaforca': case 'myf':
addUsuarioForca(sender);
try { ppimg = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image'))}`)).data
} catch(e) { ppimg = semfoto }
sendUrlText(from, getUsuDatabaseForca(sender, barrinha), pushname, ``, ppimg, `https://wa.me/`+sender.split("@")[0], seloblk)
break

case 'fc':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isForcaGame(from)) return reply(`N√£o h√° nenhum jogo em andamento... Para come√ßar, use ${prefix}forca`)
if(!q) return reply(`Retore ap√≥s o comando a letra ou a palavra toda da forca, ex:
${prefix+command} ${randomLetra.toLowerCase()}`)
jogarLetraForcaGame(mention, from, sender, prefix, q);
break

case 'rfc': case 'rrfc':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isForcaGame(from)) return reply(`N√£o h√° nenhum jogo em andamento... Para come√ßar, use ${prefix}forca`)
if(command == "rrfc") return restartForcaGame(reply, prefix, from);
resetForcaGame(from);
reply(`üß∏ Partida de forca encerrada com sucesso..`)
break

//=======================RPG=====================\\

case 'modorpg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(Number(args[0]) === 1) {
if(isBlackCity) return reply("O RPG j√° est√° ativado...")
dataGp[0].modorpg = true
setGp(dataGp)
return reply("LADY CITY RPG ativado com sucesso ‚úÖ")
} else if(Number(args[0]) === 0) {
if(!isBlackCity) return reply("O RPG n√£o est√° ativado...")
dataGp[0].modorpg = false
setGp(dataGp)
return reply("LADY CITY RPG desativado com sucesso ‚ô®Ô∏è")
} else return reply(`Use ${prefix+command} 1/0`)
break

case 'criarcidade':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(!isOwner) return reply(enivar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Retorne ap√≥s o comando o nome da cidade e o n√∫mero do dono dela, ex:
${prefix+command} xarquel√¢ndia/${addNumberMais(randomUser)}`)
var [cdd_bc, dono_bc] = q.split(`/`)
usu = identArroba(dono_bc)
createCityBlackRPG(usu, cdd_bc);
mention(`Cidade criada no n√∫mero de @${usu.split("@")[0]} com sucesso ‚úÖ`)
break

case 'cidadesrpg': case 'cidades':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(cidadesRPG.length <= 0) return reply(enviar.rpg.notcdd)
txt = `üè¶ *Total:* ${cidadesRPG.length}`
for(i = 0; i < cidadesRPG.length; i++) {
  cdd = cidadesRPG[i]
  AB = cdd.moradores.map(c => c.id).indexOf(cdd.prefeito)
  txt += `\n\nüèò *Nome:* ${iniMai(cdd.nome)}
ü§µüèΩ *Prefeito:* ${cdd.moradores[AB].nome}
üë§ *Moradores:* ${cdd.moradores.length}/${cdd.level * 30}
üì¶ *Vagas:* ${!limitCity(cdd.nome) ? `‚úÖ` : `‚ùå`}`
}
reply(txt)
break

case 'minhacidade': case 'mycity':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)
AB = cidadesRPG.map(c => c.nome).indexOf(findCity(sender))
cdd = cidadesRPG[AB]
AC = cdd.moradores.map(m => m.id).indexOf(cdd.prefeito)
txt = `üèò *Nome:* ${iniMai(cdd.nome)}
ü§µüèΩ *Prefeito:* ${cdd.moradores[AC].nome} ‚Ü¥
üßÆ *Total:* ${cdd.moradores.length}/${cdd.level * 30}
üë§ *Moradores:*
${cdd.moradores.map(m => `‚Ä¢ ${m.nome}`).join(`\n`)}`
thumb = `https://telegra.ph/file/3b3f6ced554bc4c73b40e.png`
sendUrlText(from, txt, `ùòΩùôÄùôà ùôëùôÑùôâùòøùôä (ùòº) üèô`, ``, thumb, thumb, seloctt)
break

case 'deletarcidade': case 'delcdd':
if(!isOwner) return reply(enivar.msg.dono)
if(!q) return reply(`Retorne ap√≥s o comando, o nome da cidade que voc√™ deseja deletar... Se n√£o souber, olhe no comando ${prefix}cidadesrpg as cidades existentes.`)
AB = cidadesRPG.map(i => i.nome).indexOf(q)
if(AB < 0) return reply(`[‚ùó] Cidade n√£o encontrada ou inexistente ‚ùå`)
cidadesRPG.splice(AB, 1)
saveCityBlackRPG();
reply(`Cidade deletada com sucesso ‚úÖ`)
break

case 'rgbc': case 'rgblackcity':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(isYouInBlackCity(sender)) return reply(enviar.rpg.existrg)
if(contar(q, `/`) != 1) return reply(`Retorne ap√≥s o comando o nome e a cidade que voc√™ se registrar, ex:
${prefix+command} John/Rio dos ladr√¥es`)
var [a, b] = q.replace(`/ `, `/`).replace(` /`, `/`).replace(` / `, `/`).split(`/`)
if(!existCity(b)) return reply(enviar.rpg.notexistcity.replace(`#city#`, b))
if(limitCity(b)) return reply(enviar.rpg.citylimit)
registrarUsuInBlackCity(sender, a, b);
try { ppimg = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image'))}`)).data
} catch(e) { ppimg = semfoto }
img = `https://blacksystemofc.com.br/api/canvas/jxr/welcome?nome=${encodeURI(a)}&guilda=${encodeURI("LADY CITY")}&perfil=https://telegra.ph/file/8599989096be411a4a72b.jpg&membro=${totalUserBlackCity.length}&avatar=${ppimg}&fundo=${Number(sendHours("HH")) >= 6 && Number(sendHours("HH")) < 18 ? `https://telegra.ph/file/82bdf76492757e8dac17a.jpg` : `https://telegra.ph/file/14397844299a8fa11d4a9.jpg`}`
txt = enviar.rpg.welcome.replace(`#usu#`, sender.split("@")[0])
mencionarIMG(txt, img, seloctt)
break

case 'saldo': case 'carteira': case 'banco': case 'meubc':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)
data = filesDBuserBC(sender)
txt = `
\t\t\tüé≤ *_GERAL_* üé≤
üìñ *Nome:* ${data.nome}
üí∞ *Saldo:* R$ ${Number(data.saldo).toFixed(2)}
üè¶ *Banco:* R$ ${data.banco}

\t\t\tüìÉ *_REGISTRO_* üìÉ
üìÜ *Data:* ${data.registro.data}
‚åö *Hora:* ${data.registro.hora}
${`- `.repeat(30)}
_Livro de registro, p√°g. ${(totalUserBlackCity.map(t => t.UID).indexOf(sender)) + 1}_`
sendImage(from, `https://blackstorage.store/midia/1744987995710.jpg`, txt, info)
break

case 'addpix':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(!isOwner) return reply(enivar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Separe o n√∫mero do usu√°rio e o valor com uma barra ( / ), ex:
${prefix+command} ${addNumberMais(botNumber)}/100`)
usu = identArroba(q.split(`/`)[0])
if(!isYouInBlackCity(usu)) return reply(enviar.msg.notusu)
filesDBuserBC(usu).saldo += Number(q.split(`/`)[1])
saveCityBlackRPG();
mention(`R$ ${Number(q.split(`/`)[1]).toFixed(2)} fo${Number(q.split(`/`)[1]) !== 1 ? `ram` : `i`} adc ao saldo do usu√°rio @${usu.split(`@`)[0]} com sucesso ‚úÖ`)
break

case 'rmpix':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(!isOwner) return reply(enivar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Separe o n√∫mero do usu√°rio e o valor com uma barra ( / ), ex:
${prefix+command} ${addNumberMais(botNumber)}/100`)
usu = identArroba(q.split(`/`)[0])
if(!isYouInBlackCity(usu)) return reply(enviar.msg.notusu)
nmr = (filesDBuserBC(usu).saldo - Number(q.split(`/`)[1])) < 0 ? 0 : filesDBuserBC(usu).saldo - Number(q.split(`/`)[1])
filesDBuserBC(usu).saldo = nmr
saveCityBlackRPG();
mention(`R$ ${Number(q.split(`/`)[1]).toFixed(2)} fo${Number(q.split(`/`)[1]) !== 1 ? `ram` : `i`} rmvd do saldo do usu√°rio @${usu.split(`@`)[0]} com sucesso ‚úÖ`)
break

case 'setpix':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(!isOwner) return reply(enivar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Separe o n√∫mero do usu√°rio e o valor com uma barra ( / ), ex:
${prefix+command} ${addNumberMais(botNumber)}/100`)
usu = identArroba(q.split(`/`)[0])
if(!isYouInBlackCity(usu)) return reply(enviar.msg.notusu)
filesDBuserBC(usu).saldo = Number(q.split(`/`)[1])
saveCityBlackRPG();
mention(`O saldo do usu√°rio @${usu.split(`@`)[0]} foi setado em R$ ${Number(q.split(`/`)[1]).toFixed(2)} com sucesso ‚úÖ`)
break

case 'rmusubc':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(!isOwner) return reply(enivar.msg.dono)
if(!marc_tds) return reply(`Marque o usu√°rio, a mensagem ou o @, de quem voc√™ quer deletar da Black City...`)
if(!isYouInBlackCity(marc_tds)) return reply(enviar.msg.notusu)
rmUsuBlackCity(marc_tds);
reply(`Usu√°rio deletado com sucesso... üò™`)
break

case 'getfile':
if(!isOwner) return mention(privateCmd(sender, prefix+command, `"n√£o encontrado"`, 0))
if(!q && !q.startsWith(`./`)) return reply("T√° faltando o caminho at√© o arquivo... Ex: "+prefix+command+" ./index.js")
try {
nome = q.split(`/`)[contar(q, `/`)]
reply("*Enviando no nosso grupo privado o arquivo "+nome+"*")
await sleep(1000)
blackmd.sendMessage(obrigadoEXT.idprivategp, {document: {url: q}, fileName: nome, mimetype: `application/${nome.endsWith(`js`) ? `javascript` : `json`}`})
} catch(e) { console.log(e)
reply(`Erro`) }
break

case 'modulos': case 'modulo':

case 'criarjson':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply("KD o nome do json?")
qp = q.toLowerCase()
if(fs.existsSync(`./basededados/${qp}.json`)) return reply("JSON j√° existente")
try {
fs.writeFileSync(`./basededados/${qp}.json`, JSON.stringify([]))
reply("JSON criado com sucesso ‚úÖ")
} catch { reply("Erro") }
break

case 'rmjson':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply("KD o nome do json?")
qp = q.toLowerCase()
if(!fs.existsSync(`./basededados/${qp}.json`)) return reply("JSON n√£o existente")
try {
fs.unlinkSync(`./basededados/${qp}.json`)
reply("JSON deletado com sucesso ‚úîÔ∏è")
} catch { reply("Erro") }
break

case 'anagrama':
if(!isGroup) return reply('Comando apenas para grupos')
if(!isModobn) return reply(enviar.msg.modobz)
ana = alerandom(palavrasANA.length)
anagrama = `./armor/jogo/anagrama/anagrama-${from}.json`
if(!isGroupAdmins && !fs.existsSync(anagrama)) return reply("Somente admins podem iniciar o jogo do anagrama")
if(args.join(' ') === '1') {
if(fs.existsSync(anagrama)) {
dataAnagrama = JSON.parse(fs.readFileSync(anagrama))
reply(`*O jogo j√° foi iniciado neste grupo:*
√ó *Palavra:* ${shuffle(dataAnagrama.embaralhada)}
√ó *Dica:* ${dataAnagrama.dica}
`)
} else {
saveJSON(palavrasANA[ana], anagrama)
blackmd.sendMessage(from, {text: `
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚âΩ„Äå üëæ ANAGRAMA üëæ „Äç
‚îÇ‚ûΩ *DESCUBRA A PALAVRA*
‚îÇ‚ûΩ *ANAGRAMA:* ${shuffle(palavrasANA[ana].embaralhada)}
‚îÇ‚ûΩ *DICA:* ${palavrasANA[ana].dica}
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
`}, {quoted: info})
}
} else if(args.join(' ') ==='0') {
if(!fs.existsSync(anagrama)) return reply('N√£o tem como desativar o jogo do anagrama, p√¥s ele n√£o foi ativado')
fs.unlinkSync(anagrama)
reply("Jogo anagrama desativado com sucesso neste grupo...")
} else return reply('Use 1 para ativar o jogo do anagrama\nPara desativar use anagrama 0')
break

case 'revelaranagrama': case 'ran': {
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
ana = alerandom(palavrasANA.length)
anagrama = `./armor/jogo/anagrama/anagrama-${from}.json`
if(!fs.existsSync(anagrama)) return reply("Jogo anagrama n√£o iniciado...")
dataAnagrama = JSON.parse(fs.readFileSync(anagrama))
resp = dataAnagrama.original
fs.unlinkSync(anagrama)
var bglh = [
`[ ‚ùó ] Reiniciando o jogo em 5Ô∏è‚É£`,
`[ ‚ùó ] Reiniciando o jogo em 4Ô∏è‚É£`,
`[ ‚ùó ] Reiniciando o jogo em 3Ô∏è‚É£`,
`[ ‚ùó ] Reiniciando o jogo em 2Ô∏è‚É£`,
`[ ‚ùó ] Reiniciando o jogo em 1Ô∏è‚É£`,
`[ ‚ùó ] Reiniciando o jogo em 0Ô∏è‚É£`
]
let { key } = await blackmd.sendMessage(from, {text: `üí¢ FINALIZANDO GAME üí¢`}, {quoted: info})//primeira mensagem
await sleep(1000)
await blackmd.sendMessage(from, {text: `*Fim de jogo, a palavra era ‚Ü¥*
‚áí 
*Irei resetar o jogo* üòï`, edit: key }, {quoted: info})
await sleep(1000)
for(let b = 0; b < resp.length; b++) {
await blackmd.sendMessage(from, {text: `*Fim de jogo, a palavra era ‚Ü¥*
‚áí ${resp.slice(0, b+1)}
*Irei resetar o jogo* üòï`, edit: key }, {quoted: info})
}
await sleep(1000)
for(let i = 0; i < bglh.length; i++) {
await sleep(1000)
await blackmd.sendMessage(from, {text: bglh[i], edit: key }, {quoted: info})
}
saveJSON(palavrasANA[ana], anagrama)
await blackmd.sendMessage(from, {text: `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚âΩ„Äå üëæ ANAGRAMA üëæ „Äç
‚îÇ‚ûΩ *DESCUBRA A PALAVRA*
‚îÇ‚ûΩ *ANAGRAMA:* ${shuffle(palavrasANA[ana].embaralhada)}
‚îÇ‚ûΩ *DICA:* ${palavrasANA[ana].dica}
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`, edit: key }, {quoted: info})
}
break

case 'quizanimais':
if(!isGroup) return reply(enviar.msg.grupo)
if(!q) return reply(`Use ${prefix+command} 1/0 _(1 para come√ßar o jogo, e 0 para desligar)_`)
if(Number(args[0]) === 1) {
if(!isGroupAdmins && !fs.existsSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)) return reply("Somente admins podem iniciar o jogo... Ap√≥s iniciado, qualquer membro poder√° usar üê†")
if(fs.existsSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)) {
QuizbyMath = JSON.parse(fs.readFileSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`))
reply(`_O quiz animais j√° foi iniciado neste grupo... Tente acertar o animal na foto abaixo_ üåö`)
setTimeout(() => {
blackmd.sendMessage(from, {image: {url: QuizbyMath.foto}, caption: `\n‚úîÔ∏è ùôåùôêùôÑùôï ùòºùôâùôÑùôàùòºùôÑùôé ‚úîÔ∏è\n\nüåö‚É§ ùòøùôöùô®ùôòùô™ùôóùôßùôñ ùôä ùòºùô£ùôûùô¢ùôñùô° ‚Üë‚Üë‚Üë\n`})
}, 500)
} else {
matheuzinho = Math.floor(Math.random() * quizanimais.length)
fs.writeFileSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`, `${JSON.stringify(quizanimais[matheuzinho])}`)
blackmd.sendMessage(from, {image: {url: quizanimais[matheuzinho].foto}, caption: `\n‚úîÔ∏è ùôåùôêùôÑùôï ùòºùôâùôÑùôàùòºùôÑùôé ‚úîÔ∏è\n\nüåö‚É§ ùòøùôöùô®ùôòùô™ùôóùôßùôñ ùôä ùòºùô£ùôûùô¢ùôñùô° ‚Üë‚Üë‚Üë\n`}, {quoted: seloctt})
}
} else if(Number(args[0]) === 0) {
if(!fs.existsSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)) return reply("N√£o tem como finalizar um jogo n√£o iniciado...")
fs.unlinkSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)
reply("Quiz animais finalizado com sucesso ‚úÖ")
}
break

case 'revelarquiz': case 'rq':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!fs.existsSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)) return reply("N√£o tem como finalizar um jogo n√£o iniciado...")
QuizbyMath = JSON.parse(fs.readFileSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`))
reply(`‚úÖ *Jogo finalizado... O animal era:* ${QuizbyMath.original}

*Irei reiniciar o jogo...*`)
fs.unlinkSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)
setTimeout(() => {
matheuzinho = Math.floor(Math.random() * quizanimais.length)
fs.writeFileSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`, `${JSON.stringify(quizanimais[matheuzinho])}`)
blackmd.sendMessage(from, {image: {url: quizanimais[matheuzinho].foto}, caption: `\n‚úîÔ∏è ùôåùôêùôÑùôï ùòºùôâùôÑùôàùòºùôÑùôé ‚úîÔ∏è\n\nüåö‚É§ ùòøùôöùô®ùôòùô™ùôóùôßùôñ ùôä ùòºùô£ùôûùô¢ùôñùô° ‚Üë‚Üë‚Üë\n`}, {quoted: seloctt})
}, 4000)
break

case 'blk5':
if(!isOwner) return
blackmd.relayMessage(
      from,
      {
        interactiveMessage: {
          headerType: `IMAGE`,
          body: {text: `Opa mn @${sender.split("@")[0]}`},
          footer: {text: "@m4thxyz_"},
    contextInfo: {participant: sender, mentionedJid: [sender], quotedMessage: info.message},
          nativeFlowMessage: {
            buttons: [{
              name: "cta_url",
              buttonParamsJson: JSON.stringify({
                display_text: "Site do Black",
                url: "https://blackmd.online",
                merchant_url: "https://blackmd.online"
              }),
            },
            {
              name: "cta_copy",
              buttonParamsJson: JSON.stringify({
                display_text: "Copie Minha Bucetinha",
                copy_code: "https://xvideos.com.br"
              }),
            },
            {
              name: "quick_reply",
              buttonParamsJson: JSON.stringify({
                display_text: "PLAY",
                id: "/play",
                disabled: false
              }),
            },
            {
              name: "quick_reply",
              buttonParamsJson: JSON.stringify({
                display_text: "PING",
                id: "/ping",
                disabled: false
              }),
            }],
            messageParamsJson: "",
          },
        },
      },
      {}
    )
break
// NSFW +18
case 'alice': {
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for tente mais tarde.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://kamuiapi.shop/api/packs/v1/alice?apikey=YT8q4bUNXV"}});
}
case 'hime':
case 'hime-tsu': {
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for tente mais tarde.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://kamuiapi.shop/api/packs/hime-tsu?apikey=YT8q4bUNXV"}});
}

case 'waifumia':
case 'waifumiia': {
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://kamuiapi.shop/api/packs/waifumiia?apikey=YT8q4bUNXV"}});
}

case 'onlyfans2': {
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://kamuiapi.shop/api/packs/onlyfans?apikey=YT8q4bUNXV"}});
}
case 'belle': {
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://kamuiapi.shop/api/packs/v1/belle?apikey=YT8q4bUNXV"}});
}
case 'hannah': {
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://kamuiapi.shop/api/packs/v1/hannah?apikey=YT8q4bUNXV"}});
}


case 'fotinhas': {
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/fotinhas"}});
}
case 'onlyfansfoto': {
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/onlyfans"}});
}
break
case 'vazados':
  if (!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`);
  if (!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå");

  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);

  try {
    const json = JSON.parse(fs.readFileSync('./basededados/sex/sex.json').toString());
    const random = json[Math.floor(Math.random() * json.length)];

    const templateMassage = {
      video: {
        url: random,
        quoted: info
      },
      caption: `${command}`,
      footer: `${NomeDoBot}`,
    };

    blackmd.sendMessage(sender, templateMassage);
  } catch (e) {
    reply("Erro ao carregar o conte√∫do. A base de dados pode estar corrompida ou indispon√≠vel.");
  }
  break;
  
case 'explanada':
case 'explanadas': {
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/explanadas"}});
}
break;

case 'foto18':
case 'foto+18': {
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reply(`Estou enviando no seu PV ${pushname}, se n√£o for porque a API caiu.`);
  
  // Fazendo a requisi√ß√£o diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/atriz"}});
}
break;
case 'xvideos':
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")

  // Verifica se o usu√°rio forneceu um termo de pesquisa
  if (!q) {
    return blackmd.sendMessage(
      from,
      { text: `Por favor, forne√ßa um termo de pesquisa. Exemplo: ${prefix}xvideos loira rabuda` },
      { quoted: info }
    );
  }

  const termoPesquisaXvideos = q; // Captura o termo de pesquisa do usu√°rio
  const urlXvideos = `https://world-ecletix.onrender.com/api/xvideos?termo=${encodeURIComponent(termoPesquisaXvideos)}`;

  reply("üîÑ Realizando a pesquisa no Xvideos...");

  try {
    const { data } = await axios.get(urlXvideos);

    if (!Array.isArray(data) || data.length === 0) {
      return reply("‚ùå Nenhum resultado encontrado.");
    }

    let messageXvideos = 'üîç *Resultados da pesquisa no Xvideos:*\n\n';

    data.slice(0, 5).forEach((item, index) => { // Exibir apenas os 5 primeiros resultados
      messageXvideos += `üìå *${index + 1}. ${item.title || 'Sem t√≠tulo'}*\n`;
      messageXvideos += `‚è≥ Dura√ß√£o: ${item.duration || 'Desconhecida'}\n`;
      messageXvideos += `üîó [Acesse aqui](${item.link})\n\n`;
    });

    // Envia a mensagem com os resultados da pesquisa
    await blackmd.sendMessage(from, { text: messageXvideos }, { quoted: info });

  } catch (error) {
    console.error("Erro ao buscar v√≠deos no Xvideos:", error);
    reply("üö® N√£o foi poss√≠vel realizar a pesquisa. Tente novamente mais tarde.");
  }
  break;
  
case 'xnxx':
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
 

  // Capturar o termo de pesquisa do usu√°rio
  const termoPesquisaXnxx = text.trim(); // Captura o texto enviado ap√≥s o comando

  if (!termoPesquisaXnxx) {
    return reply("‚ùå Voc√™ n√£o forneceu um termo de pesquisa. Por favor, tente novamente com um termo.");
  }

  const urlXnxx = `https://world-ecletix.onrender.com/api/xnxx?query=${encodeURIComponent(termoPesquisaXnxx)}`;

  reply("üîÑ Realizando a pesquisa no XNXX...");

  try {
    const { data } = await axios.get(urlXnxx);

    if (!Array.isArray(data) || data.length === 0) {
      return reply("‚ùå Nenhum resultado encontrado.");
    }

    let messageXnxx = 'üîç *Resultados da pesquisa no XNXX:*\n\n';

    data.slice(0, 5).forEach((item, index) => { // Exibir apenas os 5 primeiros resultados
      // Extraindo informa√ß√µes do campo "info"
      const matchDuration = item.info.match(/\d+min(?:\s\d+sec)?/);
      const matchResolution = item.info.match(/(\d{3,4}p)/);
      const matchLikes = item.info.match(/(\d{1,3})%/);

      const duration = matchDuration ? matchDuration[0] : 'Desconhecida';
      const resolution = matchResolution ? matchResolution[0] : 'Desconhecida';
      const likes = matchLikes ? `${matchLikes[0]} de aprova√ß√£o` : 'Sem informa√ß√£o';

      messageXnxx += `üìå *${index + 1}. ${item.title || 'Sem t√≠tulo'}*\n`;
      messageXnxx += `‚è≥ Dura√ß√£o: ${duration}\n`;
      messageXnxx += `üì∫ Resolu√ß√£o: ${resolution}\n`;
      messageXnxx += `üëç Aprova√ß√£o: ${likes}\n`;
      messageXnxx += `üîó [Acesse aqui](${item.link})\n\n`;
    });

    // Envia a mensagem com os resultados
    await blackmd.sendMessage(sender, { text: messageXnxx }, { quoted: info });

  } catch (error) {
    console.error("Erro ao buscar v√≠deos no XNXX:", error);
    reply("üö® N√£o foi poss√≠vel realizar a pesquisa. Tente novamente mais tarde.");
  }
  break;

case 'pornhub':
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")

  // Capturar o termo de pesquisa do usu√°rio
  const termoPesquisaPornhub = q.trim(); // Captura o texto enviado ap√≥s o comando

  if (!termoPesquisaPornhub) {
    return reply("‚ùå Voc√™ n√£o forneceu um termo de pesquisa. Por favor, tente novamente com um termo.");
  }

  const urlPornhub = `https://world-ecletix.onrender.com/api/pornohub?termo=${encodeURIComponent(termoPesquisaPornhub)}`;

  reply("üîÑ Realizando a pesquisa no Pornhub...");

  try {
    const { data } = await axios.get(urlPornhub);

    if (!Array.isArray(data) || data.length === 0) {
      return reply("‚ùå Nenhum resultado encontrado.");
    }

    let messagePornhub = 'üîç *Resultados da pesquisa no Pornhub:*\n\n';

    data.slice(0, 5).forEach((item, index) => { // Exibir apenas os 5 primeiros resultados
      messagePornhub += `üìå *${index + 1}. ${item.titulo || 'Sem t√≠tulo'}*\n`;
      messagePornhub += `‚è≥ Dura√ß√£o: ${item.dura√ß√£o || 'Desconhecida'}\n`;
      messagePornhub += `üë§ Autor: ${item.autor || 'Desconhecido'}\n`;
      messagePornhub += `üëÄ Visualiza√ß√µes: ${item.visualiza√ß√µes || 'Sem info'}\n`;
      messagePornhub += `üî• Aprova√ß√£o: ${item.hype || 'Sem info'}\n`;
      messagePornhub += `üîó [Acesse aqui](${item.link})\n\n`;
    });

    await blackmd.sendMessage(sender, { text: messagePornhub }, { quoted: info });

  } catch (error) {
    console.error("Erro ao buscar v√≠deos no Pornhub:", error);
    reply("üö® N√£o foi poss√≠vel realizar a pesquisa. Tente novamente mais tarde.");
  }
  break;
case 'pornogratis':
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")

  // Capturar o termo de pesquisa do usu√°rio
  const termoPornogratis = q.trim(); // Captura o texto enviado ap√≥s o comando

  if (!termoPornogratis) {
    return reply("‚ùå Voc√™ n√£o forneceu um termo de pesquisa. Por favor, tente novamente com um termo.");
  }

  const urlPornogratis = `https://world-ecletix.onrender.com/api/pornogratis?termo=${encodeURIComponent(termoPornogratis)}`;

  reply("üîÑ Buscando no Porn√¥ Gr√°tis...");

  try {
    const { data } = await axios.get(urlPornogratis);

    if (!Array.isArray(data) || data.length === 0) {
      return reply("‚ùå Nenhum resultado encontrado.");
    }

    let messagePornogratis = 'üîû *Resultados do Porn√¥ Gr√°tis:*\n\n';

    data.slice(0, 5).forEach((item, index) => { // Exibe os 5 primeiros
      messagePornogratis += `üìå *${index + 1}. ${item.nome || 'Sem t√≠tulo'}*\n`;
      messagePornogratis += `üñºÔ∏è Imagem: ${item.img ? `[Clique aqui](${item.img})` : 'N√£o dispon√≠vel'}\n`;
      messagePornogratis += `üîó [Acesse aqui](${item.link})\n\n`;
    });

    await blackmd.sendMessage(sender, { text: messagePornogratis }, { quoted: info });

  } catch (error) {
    console.error("Erro ao buscar v√≠deos no Porn√¥ Gr√°tis:", error);
    reply("üö® N√£o foi poss√≠vel realizar a pesquisa. Tente novamente mais tarde.");
  }
  break;
  
case 'menu_hentai':
case 'hentaipack':
if(!isVip) { 
  setTimeout(() => {reagir(from, "üö´")}, 300)
  reply(enviar.msg.vip)
  blackmd.sendMessage(from, {
    audio: {url: './database/audios/vip.mp3'},
    mimetype: 'audio/mp4',
    ptt: true
  })
} else {
  setTimeout(() => {reagir(from, "üò≥")}, 300)
  if(isGroup && !isNsfw) return reply(`Ative o modo +18 primeiro`)
  
  const menuHentai = `
\`\`\`‚ñß‚ÉØ‚Éüs√≥ as mais brabas‚É§\`\`\`
üîû *PACK-LOGOS* üîû

‚∏∫ÕüÕûÍ™∂ *${prefix}ass* üçë
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}ahegao* ü§§
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}bdsm* üîó
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}blowjob* üòÆ
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}cuckold* üí•
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}cum* ü•µ
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}ero* üï≥Ô∏è
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}femdom* üçÜ
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}foot* ü¶∂üèº
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}gangbang* ü™ë
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}glasses* ü™ü
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}hentai* üéûÔ∏è
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}jahy* üêà‚Äç‚¨õ
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}masturbation* üí¶
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}orgy* üë•
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}panties* üëô
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}pussy* üå∏
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}boobs* ü§≤üèΩ
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}tentacles* üåø
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}thighs* üó∫Ô∏è
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}yuri* üåö
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}zettai* üòè
‚è§ÕüÕûÕüÕû Í¶ø*${prefix}kasedaiki* üçº
`

  reply(menuHentai)
  reply(`Te enviei PV üòè`)
}
break

//in√≠cio do nsfw

case 'loli':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { loli } = require('./database/nsfw/animes.js')
var totalnsfw = loli[Math.floor(Math.random() * loli.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'trap':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { trap } = require('./database/nsfw/animes.js')
var totalnsfw = trap[Math.floor(Math.random() * trap.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'ass':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { ass } = require("./database/nsfw/nsfw.js")
var totalnsfw = ass[Math.floor(Math.random()*ass.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'ahegao':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { ahegao } = require("./database/nsfw/nsfw.js")
var totalnsfw = ahegao[Math.floor(Math.random()*ahegao.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'bdsm':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { bdsm } = require("./database/nsfw/nsfw.js")
var totalnsfw = bdsm[Math.floor(Math.random()*bdsm.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'blowjob':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { blowjob } = require("./database/nsfw/nsfw.js")
var totalnsfw = blowjob[Math.floor(Math.random()*blowjob.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'cuckold':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { cuckold } = require("./database/nsfw/nsfw.js")
var totalnsfw = cuckold[Math.floor(Math.random()*cuckold.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'cum':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { cum } = require("./database/nsfw/nsfw.js")
var totalnsfw = cum[Math.floor(Math.random()*cum.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'ero':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { ero } = require("./database/nsfw/nsfw.js")
var totalnsfw = ero[Math.floor(Math.random()*ero.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'femdom':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { femdom } = require("./database/nsfw/nsfw.js")
var totalnsfw = femdom[Math.floor(Math.random()*femdom.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'foot':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { foot } = require("./database/nsfw/nsfw.js")
var totalnsfw = foot[Math.floor(Math.random()*foot.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'gangbang':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { gangbang } = require("./database/nsfw/nsfw.js")
var totalnsfw = gangbang[Math.floor(Math.random()*gangbang.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'ganbganb':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { ganbganb } = require('./database/nsfw/animes.js')
var totalnsfw = ganbganb[Math.floor(Math.random() * ganbganb.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'glasses':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { glasses } = require("./database/nsfw/nsfw.js")
var totalnsfw = glasses[Math.floor(Math.random()*glasses.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'hentai':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { hentai } = require("./database/nsfw/nsfw.js")
var totalnsfw = hentai[Math.floor(Math.random()*hentai.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'hentai2':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { hentai2 } = require('./database/nsfw/animes.js')
var totalnsfw = hentai2[Math.floor(Math.random() * hentai2.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'nekos': {
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { neko2 } = require('./database/nsfw/animes.js')
var totalnsfw = neko2[Math.floor(Math.random() * neko2.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
}
break

case 'neko2': {
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { neko2 } = require('./database/nsfw/hentai.js')
var totalnsfw = neko2[Math.floor(Math.random() * neko2.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
}
break

case 'jahy':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { jahy } = require("./database/nsfw/nsfw.js")
var totalnsfw = jahy[Math.floor(Math.random()*jahy.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'masturbation':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { masturbation } = require("./database/nsfw/nsfw.js")
var totalnsfw = masturbation[Math.floor(Math.random()*masturbation.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'orgy':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { orgy } = require("./database/nsfw/nsfw.js")
var totalnsfw = orgy[Math.floor(Math.random()*orgy.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'panties':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { panties } = require("./database/nsfw/nsfw.js")
var totalnsfw = panties[Math.floor(Math.random()*panties.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'pussy':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { pussy } = require("./database/nsfw/nsfw.js")
var totalnsfw = pussy[Math.floor(Math.random()*pussy.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'boobs':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { boobs } = require("./database/nsfw/nsfw.js")
var totalnsfw = boobs[Math.floor(Math.random()*boobs.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'tentacles':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { tentacles } = require("./database/nsfw/nsfw.js")
var totalnsfw = tentacles[Math.floor(Math.random()*tentacles.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'thighs':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { thighs } = require("./database/nsfw/nsfw.js")
var totalnsfw = thighs[Math.floor(Math.random()*thighs.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'yuri':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { yuri } = require("./database/nsfw/nsfw.js")
var totalnsfw = yuri[Math.floor(Math.random()*yuri.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'zettai':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { zettai } = require("./database/nsfw/nsfw.js")
var totalnsfw = zettai[Math.floor(Math.random()*zettai.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'kasedaiki':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "üö´")}, 300)
reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "üòà")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
const { kasedaiki } = require("./database/nsfw/nsfw.js")
var totalnsfw = kasedaiki[Math.floor(Math.random()*kasedaiki.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui est√°* ${pushname} üò≥üî•`}, {quoted: info})
break

case 'amador':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 41) + 1
   wew = {url: `https://github.com/Herojoii/midiiporno/raw/main/packs/AmadorVideo/${numb}.mp4`}
   mag = 'üîûAmadorVideoüîû'
let buttonMessage = {
video: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break


case 'onlyfans':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 47) + 1
   wew = {url: `https://github.com/Herojoii/midiiporno/raw/main/packs/OnlyfansVideo/%20${numb}.mp4`}
   mag = 'üîûOnlyfansVideoüîû'
let buttonMessage = {
video: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'porno':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 15) + 1
   wew = {url: `https://github.com/Herojoii/midiiporno/raw/main/packs/PornoVideo/${numb}.mp4`}
   mag = 'üîûPornoVideoüîû'
let buttonMessage = {
video: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'egrilvideo':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")  
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 14) + 1
   wew = {url: `https://github.com/Herojoii/midiiporno/raw/main/packs/EgrilVideo/%20${numb}.mp4`}
   mag = 'üîûEgrilVideoüîû'
let buttonMessage = {
video: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'aline':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 65) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/AlineFaria/%20${numb}.jpg`}
    mag = 'üîûAlineFariaüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'alifox':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 59) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/AlineFox/%20${numb}.jpg`}
   mag = 'üîûAlineFoxüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'alycai':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 28) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/AlyciaRibeiro/%20${numb}.jpg`}
   mag = 'üîûAlyciaRibeiroüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'amichan':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 29) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/Amiichan/%20${numb}.jpg`}
   mag = 'üîûAmiichanüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'aninha':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 30) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/AninhaLopes/%20${numb}.jpg`}
   mag = 'üîûAninhaLopesüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'baby':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 36) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/BabyMatoso/%20${numb}.jpg`}
   mag = 'üîûBabyMatosoüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'belle':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 31) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/BelleDelphine/%20${numb}.jpg`}
   mag = 'üîûBelleDelphineüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'brenda':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 25) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/BrendaTrindade/%20${numb}.jpg`}
   mag = 'üîûBrendaTrindadeüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'cami':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 30) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/CamiBrito/%20${numb}.jpg`}
   mag = 'üîûCamiBritoüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'clowniac':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 29) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/Cclowniac/%20${numb}.jpg`}
   mag = 'üîûCclowniacüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'galvao':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 32) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/FehGalvao/%20${numb}.jpg`}
   mag = 'üîûFehGalvaoüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'giovanna':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 34) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/GiovannaCampomar/%20${numb}.jpg`}
   mag = 'üîûGiovannaCampomarüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'isadora':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 30) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/ISADORA%20MARTINEZ/%20${numb}.jpg`}
   mag = 'üîûISADORA MARTINEZüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'isa':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 21) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/IsaWaifu/%20${numb}.jpg`}
   mag = 'üîûIsaWaifuüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'lay':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 25) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/LayNuniz/%20${numb}.jpg`}
   mag = 'üîûLayNunizüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'leticia':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 28) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/LeticiaShirayuki/%20${numb}.jpeg`}
   mag = 'üîûLeticiaShirayukiüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'marina':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 27) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/MarinaMui/%20${numb}.jpg`}
   mag = 'üîûMarinaMuiüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'maru':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 40) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/MaruKarv/%20${numb}.jpg`}
   mag = 'üîûMaruKarvüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'princesa':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 32) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/McPrincesa/%20${numb}.jpg`}
   mag = 'üîûMcPrincesaüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'meadinha':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 33) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/Me1adinha/%20${numb}.jpg`}
   mag = 'üîûMe1adinhaüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'nath':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 23) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/NathBister%C3%A7o/%20${numb}.jpg`}
   mag = 'üîûNathBisterüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'nega':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 21) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/NegaBarbie/%20${numb}.jpg`}
   mag = 'üîûNegaBarbieüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'polonesa':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 28) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/PolonesaDoHype/%20${numb}.jpg`}
   mag = 'üîûPolonesaDoHypeüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'pornofot':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 44) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/PornoFoto/%20${numb}.jpg`}
   mag = 'üîûPornoFotoüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'rute':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 30) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/RuteRocha/%20${numb}.jpg`}
   mag = 'üîûRuteRochaüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'vita':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 30) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/VitaCelestine/%20${numb}.jpg`}
   mag = 'üîûVitaCelestineüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'carnie':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 29) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/carniello/%20${numb}.jpg`}
   mag = 'üîûcarnielloüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'egril':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
   numb = Math.floor(Math.random() * 36) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/egril/%20${numb}.jpg`}
   mag = 'üîûegrilüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'neter':{
  if(!isNsfw && isGroup) return reply(`√â necess√°rio que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ‚ùó ] O uso desse recurso fora do Chat Ofc est√° restrito apenas a usu√°rios VIP ‚ùå")
  reagir(from, "üòà")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} üòà`)
   numb = Math.floor(Math.random() * 30) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/netersg/%20${numb}.jpg`}
   mag = 'üîûnetersgüîû'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break


case 'plaq': case 'plaq1':
setTimeout(() => {reagir(from, "üò≥")}, 300)
if(!isGroup && !isVip) return reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!q) return reply(`Escreva algo...`)
reply(`${isGroup ? "Chega PV lek" : "Enviando"} üòà`)
blackmd.sendMessage(sender, {image: {url: `https://ubbornag.sirv.com/Screenshot_20210513-151821.png?text.0.text=${q}&text.0.position.x=-40%25&text.0.position.y=-65%25&text.0.size=30&text.0.color=000000&text.0.opacity=53&text.0.font.family=Shadows%20Into%20Light%20Two&text.0.outline.blur=15`}, caption: `*Plaquinha feita ‚úì*`, mentions: [sender]}, {quoted: info})
break

case 'plaq2':
setTimeout(() => {reagir(from, "üò≥")}, 300)
if(!isGroup && !isVip) return reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!q) return reply(`Escreva algo...`)
reply(`${isGroup ? "Chega PV lek" : "Enviando"} üòà`)
blackmd.sendMessage(sender, {image: {url: `https://raptibef.sirv.com/images%20(3).jpeg?text.0.text=${q}&text.0.position.gravity=center&text.0.position.x=19%25&text.0.size=45&text.0.color=000000&text.0.opacity=55&text.0.font.family=Crimson%20Text&text.0.font.weight=300&text.0.font.style=italic&text.0.outline.opacity=21`}, caption: `*Plaquinha feita ‚úì*`, mentions: [sender]}, {quoted: info})
break

case 'plaq3':
setTimeout(() => {reagir(from, "üò≥")}, 300)
if(!isGroup && !isVip) return reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!q) return reply(`Escreva algo...`)
buffer = await getBuffer(`https://raptibef.sirv.com/images%20(1).jpeg?profile=Zanga%202.0&text.0.text=${q}`)
reply(`${isGroup ? "Chega PV lek" : "Enviando"} üòà`)
blackmd.sendMessage(sender, {image: buffer, caption: `*Plaquinha feita ‚úì*`, mentions: [sender]}, {quoted: info})
break

case 'plaq4':
setTimeout(() => {reagir(from, "üò≥")}, 300)
if(!isGroup && !isVip) return reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!q) return reply(`Escreva algo...`)
buffer = await getBuffer(`https://raptibef.sirv.com/images.jpeg?profile=Zanga%203.0&text.0.text=${q}&text.0.outline.blur=63`)
reply(`${isGroup ? "Chega PV lek" : "Enviando"} üòà`)
blackmd.sendMessage(sender, {image: buffer, caption: `*Plaquinha feita ‚úì*`, mentions: [sender]}, {quoted: info})
break

case 'plaq5':
setTimeout(() => {reagir(from, "üò≥")}, 300)
if(!isGroup && !isVip) return reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!q) return reply(`Escreva algo...`)
buffer = await getBuffer(`https://umethroo.sirv.com/Torcedora-da-sele%C3%A7%C3%A3o-brasileira-nua-mostrando-a-bunda-236x300.jpg?text.0.text=${q}&text.0.position.x=-64%25&text.0.position.y=-39%25&text.0.size=25&text.0.color=1b1a1a&text.0.font.family=Architects%20Daughter`)
reply(`${isGroup ? "Chega PV lek" : "Enviando"} üòà`)
blackmd.sendMessage(sender, {image: buffer, caption: `*Plaquinha feita ‚úì*`, mentions: [sender]}, {quoted: info})
break

case 'plaq6':
setTimeout(() => {reagir(from, "üò≥")}, 300)
if(!isGroup && !isVip) return reply("[ ‚ùó ] *Este recurso no PV s√≥ est√° liberado para os usu√°rios VIP* ‚ùå")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!q) return reply(`Escreva algo...`)
buffer = await getBuffer(`https://umethroo.sirv.com/peito1.jpg?text.0.text=${q}&text.0.position.x=-4%25&text.0.position.y=-6%25&text.0.size=14&text.0.color=000000&text.0.font.family=Shadows%20Into%20Light&text.0.font.weight=700`)
reply(`${isGroup ? "Chega PV lek" : "Enviando"} üòà`)
blackmd.sendMessage(sender, {image: buffer, caption: `*Plaquinha feita ‚úì*`, mentions: [sender]}, {quoted: info})
break

//fim do nsfw
// BRINCADEIRAS ZOEIRA ZOEIRAS 
// MENU ZOEIRA 
case 'punheta':
    setTimeout(() => {reagir(from, "ü§î")}, 300)
    if (!isGroup) return reply('Este comando s√≥ pode ser usado em grupos.');
    if (!isModobn) return reply(`Ative o modo brincadeira usando ${prefix}modobrincadeira 1`);

    // Verifica se algu√©m foi mencionado
    if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');

    if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

    // Envia o √°udio
    blackmd.sendMessage(from, {audio: {url: './database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info});

    // Envia o GIF e menciona a pessoa
    blackmd.sendMessage(from, {
        video: {url: 'https://blackstorage.store/midia/1745777201746.mp4'},
        gifPlayback: true, 
        caption: `Voc√™ ${pushname} acabou de bater uma pro(a) *@${menc_os2.split('@')[0]}*`, // A men√ß√£o correta aqui
        mentions: [menc_os2] // Passando o id correto para a men√ß√£o
    }, { quoted: info });
    break;

case 'siririca':
    setTimeout(() => {reagir(from, "ü§î")}, 300)
    if (!isGroup) return reply('Este comando s√≥ pode ser usado em grupos.');
    if (!isModobn) return reply(`Ative o modo brincadeira usando ${prefix}modobrincadeira 1`);

    // Verifica se algu√©m foi mencionado
    if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');

    if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

    // Envia o √°udio
    blackmd.sendMessage(from, {audio: {url: './database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info});

    // Envia o GIF e menciona a pessoa
    blackmd.sendMessage(from, {
        video: {url: 'https://blackstorage.store/midia/1745777337685.mp4'},
        gifPlayback: true, 
        caption: `Voc√™ ${pushname} acabou de tocar uma pro(a)*@${menc_os2.split('@')[0]}*`, // A men√ß√£o correta aqui
        mentions: [menc_os2] // Passando o id correto para a men√ß√£o
    }, { quoted: info });
    break;
case 'fiel':
    setTimeout(() => {reagir(from, "üò≥")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo);
    if (!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`);

    if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
    if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

    blackmd.sendMessage(from, {audio: {url: './database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info});

    blackmd.sendMessage(from, {
        text: `*Verificando se voc√™ √© fiel...* üò≥\n\n‚áí *@${menc_os2.split('@')[0]}*\n\n*Calma ae kkk...*`,
        mentions: [menc_os2]
    }, {quoted: info});

    setTimeout(async() => {
        const random = `${Math.floor(Math.random() * 20)}`;
        blackmd.sendMessage(from, {
            image: {url: 'https://files.catbox.moe/o8lt9f.jpg'},
            caption: `*Fiel, n√©? kkk*\n\n‚áí *@${menc_os2.split('@')[0]}*\n\nVoc√™ tem ‚úÆ${random}%‚úÆ de chance de ser fiel üò≥\n\n${NomeDoBot}üéñÔ∏è`,
            mentions: [menc_os2]
        }, {quoted: seloctt});
    }, 7000);
    break;

case 'machista':
    setTimeout(() => {reagir(from, "üò≥")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo);
    if (!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`);

    if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
    if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

    blackmd.sendMessage(from, {audio: {url: './database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info});

    blackmd.sendMessage(from, {
        text: `*Detectando se voc√™ √© machista...* üò≥\n\n‚áí *@${menc_os2.split('@')[0]}*\n\n*Calma ae kkk...*`,
        mentions: [menc_os2]
    }, {quoted: info});

    setTimeout(async() => {
        const random = `${Math.floor(Math.random() * 20)}`;
        blackmd.sendMessage(from, {
            image: {url: 'https://files.catbox.moe/dh1zod.jpg'},
            caption: `*Eita, machista! kkk*\n\n‚áí *@${menc_os2.split('@')[0]}*\n\nVoc√™ tem ‚úÆ${random}%‚úÆ de chance de ser machista üò≥\n\n${NomeDoBot}üéñÔ∏è`,
            mentions: [menc_os2]
        }, {quoted: seloctt});
    }, 7000);
    break;

case 'feminista':
    setTimeout(() => {reagir(from, "üò≥")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo);
    if (!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`);

    if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
    if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

    blackmd.sendMessage(from, {audio: {url: './database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info});

    blackmd.sendMessage(from, {
        text: `*Verificando se voc√™ √© feminista...* üò≥\n\n‚áí *@${menc_os2.split('@')[0]}*\n\n*Calma ae kkk...*`,
        mentions: [menc_os2]
    }, {quoted: info});

    setTimeout(async() => {
        const random = `${Math.floor(Math.random() * 20)}`;
        blackmd.sendMessage(from, {
            image: {url: 'https://files.catbox.moe/dh1zod.jpg'},
            caption: `*Feminista, n√©? kkk*\n\n‚áí *@${menc_os2.split('@')[0]}*\n\nVoc√™ tem ‚úÆ${random}%‚úÆ de chance de ser feminista üò≥\n\n${NomeDoBot}üéñÔ∏è`,
            mentions: [menc_os2]
        }, {quoted: seloctt});
    }, 7000);
    break;
case 'infiel':
  setTimeout(() => {reagir(from, "üò≥")}, 300);
  if (!isGroup) return reply(enviar.msg.grupo);
  if (!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`);

  blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info});
  
  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  blackmd.sendMessage(from, {
    text: `*Detectando se voc√™ √© infiel...* üò≥\n\n‚áí *@${menc_os2.split('@')[0]}*\n\n*Calma ae kkk...*`,
    mentions: [menc_os2]
  }, {quoted: info});
  
  setTimeout(async () => {
    random = `${Math.floor(Math.random() * 20)}`;
    blackmd.sendMessage(from, {
      image: {url: 'https://files.catbox.moe/unyqp9.jpg'},
      caption: `*Olha o infiel kkkk*\n\n‚áí *@${menc_os2.split('@')[0]}*\n\nVoc√™ tem ‚úÆ${random}%‚úÆ de chance de ser infiel üò≥\n\n${NomeDoBot}üéñÔ∏è`,
      mentions: [menc_os2]
    }, {quoted: seloctt});
  }, 7000);
  break;
case 'clt':
  setTimeout(() => {reagir(from, "ü§î")}, 300);
  if (!isGroup) return reply(`Esse comando s√≥ pode ser usado em grupos.`);
  if (!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modobrincadeira 1`);
  
  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  const targetUserIdClt = menc_os2.split('@')[0]; 
  const messageCaptionClt = `Ih, mano! O ${pushname} levou o @${targetUserIdClt} pra virar CLT! ü•≤üí•`;

  // Enviar a mensagem corretamente com a men√ß√£o
  await blackmd.sendMessage(from, {
    video: { url: 'https://raw.githubusercontent.com/floxcloud/uploadsFlox/main/videos/1728153313349.mp4' },
    gifPlayback: true,
    caption: messageCaptionClt,
    mentions: [menc_os2] // Corrigido para usar o JID completo
  }, { quoted: info });
  break;
case 'pegarpau':
  setTimeout(() => {reagir(from, "ü§î")}, 300);
  if (!isGroup) return reply('Este comando s√≥ pode ser usado em grupos.');
  if (!isModobn) return reply(`Ative o modo brincadeira usando ${prefix}modobrincadeira 1`);

  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  await blackmd.sendMessage(from, {
    video: { url: 'https://telegra.ph/file/5073ba8be6b099ed812a7.mp4' },
    gifPlayback: true,
    caption: `Voc√™ acabou de pegar no pau do(a) *@${menc_os2.split('@')[0]}*`, // A men√ß√£o correta aqui
    mentions: [menc_os2] // Passando o id correto para a men√ß√£o
  }, { quoted: info }); 
  break;

case 'matar2':
case 'mata2':
  setTimeout(() => {reagir(from, "ü§î")}, 300);
  if (!isGroup) return reply('Este comando s√≥ pode ser usado em grupos.');
  if (!isModobn) return reply(`Ative o modo brincadeira usando ${prefix}modobrincadeira 1`);

  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  await blackmd.sendMessage(from, {
    video: { url: matarcmd }, // Certifique-se de que 'matarcmd' esteja definido
    gifPlayback: true,
    caption: `Voc√™ acabou de matar o(a) *@${menc_os2.split('@')[0]}*, seu... üòµ‚Äçüí´üíÖüèª`, // Men√ß√£o corretamente aplicada
    mentions: [menc_os2]
  }, { quoted: info });
  break;
case 'pegarbunda':
  setTimeout(() => {reagir(from, "ü§î")}, 300);
  if (!isGroup) return reply('Este comando s√≥ pode ser usado em grupos.');
  if (!isModobn) return reply(`Ative o modo brincadeira usando ${prefix}modobrincadeira 1`);

  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  await blackmd.sendMessage(from, {
    video: { url: 'https://telegra.ph/file/e62de1e6863c59d284b2e.mp4' },
    gifPlayback: true,
    caption: `Voc√™ acabou de pegar na bunda do(a) *@${menc_os2.split('@')[0]}*`, // Ajustada a men√ß√£o corretamente
    mentions: [menc_os2]
  }, { quoted: info });
  break;

case 'pegarpeito':
  setTimeout(() => {reagir(from, "ü§î")}, 300);
  if (!isGroup) return reply('Este comando s√≥ pode ser usado em grupos.');
  if (!isModobn) return reply(`Ative o modo brincadeira usando ${prefix}modobrincadeira 1`);

  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  await blackmd.sendMessage(from, {
    video: { url: 'https://telegra.ph/file/52d46e2c58318b8cfcacc.mp4' },
    gifPlayback: true,
    caption: `Voc√™ acabou de pegar nos peitos do(a) *@${menc_os2.split('@')[0]}*`, // Marca√ß√£o correta aplicada
    mentions: [menc_os2]
  }, { quoted: info });
  break;
case 'lavar':
  setTimeout(() => {reagir(from, "ü§î")}, 300);
  if (!isGroup) return reply(enviar.msg.grupo);
  if (!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modobrincadeira 1`);

  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  var susp = `Ih, mano! O ${pushname} mandou o @${menc_os2.split('@')[0]} lavar a lou√ßa, esse(a) pregui√ßoso(a)! üò¨üí¶`;

  await blackmd.sendMessage(from, {
    video: { url: 'https://raw.githubusercontent.com/floxcloud/uploadsFlox/main/videos/1728153184856.mp4' },
    gifPlayback: true,
    caption: susp,
    mentions: [menc_os2]
  }, { quoted: info });
  break;

case 'sentar':
  setTimeout(() => {reagir(from, "ü§î")}, 300);
  if (!isGroup) return reply(enviar.msg.grupo);
  if (!isModobn) return reply(enviar.msg.modobz);

  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  await blackmd.sendMessage(from, {
    video: { url: 'https://telegra.ph/file/d695e05443043ff9a254d.mp4' },
    gifPlayback: true,
    caption: `Voc√™ acabou de dar uma sentadinha no(a) *@${menc_os2.split('@')[0]}*`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;

case 'tirarft':
  setTimeout(() => {reagir(from, "ü§î")}, 300);
  if (!isGroup) return reply(enviar.msg.grupo);
  if (!isModobn) return reply(enviar.msg.modobz);

  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  await blackmd.sendMessage(from, {
    video: { url: 'https://blackstorage.store/midia/1745792804104.mp4' },
    gifPlayback: true,
    caption: `Voc√™ acabou de tirar a foto do(a) *@${menc_os2.split('@')[0]}*`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;

case 'apaixonar':
  setTimeout(() => {reagir(from, "ü§î")}, 300)
  if (!isGroup) return reply(enviar.msg.grupo)
  if (!isModobn) return reply(enviar.msg.modobz)

  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  await blackmd.sendMessage(from, {
    video: { url: 'https://blackstorage.store/midia/1745792640603.mp4' },
    gifPlayback: true,
    caption: `Voc√™ acabou de apaixonar o(a) *@${menc_os2.split('@')[0]}*`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;
case 'abra√ßar':
case 'abracar':
  setTimeout(() => {reagir(from, "ü§î")}, 300)
  if (!isGroup) return reply(enviar.msg.grupo)
  if (!isModobn) return reply(enviar.msg.modobz)

  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  await blackmd.sendMessage(from, {
    video: { url: 'https://blackstorage.store/midia/1745792700683.mp4' },
    gifPlayback: true,
    caption: `Voc√™ acabou de abra√ßar o(a) *@${menc_os2.split('@')[0]}*`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;
case 'beijar':
  setTimeout(() => {reagir(from, "ü§î")}, 300)
  if (!isGroup) return reply(enviar.msg.grupo)
  if (!isModobn) return reply(enviar.msg.modobz)

  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  await blackmd.sendMessage(from, {
    video: { url: 'https://telegra.ph/file/c9b5ed858237ebc9f7356.mp4' },
    gifPlayback: true,
    caption: `Voc√™ acabou de beijar o(a) *@${menc_os2.split('@')[0]}*`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;

case 'dar':
  setTimeout(() => {reagir(from, "ü§î")}, 300)
  if (!isGroup) return reply(enviar.msg.grupo)

  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  await blackmd.sendMessage(from, {
    video: { url: "https://telegra.ph/file/8d6c8af967fad0fe77ba8.mp4" },
    gifPlayback: true,
    caption: `Voc√™ deu com vontade na *@${menc_os2.split('@')[0]}*, ela(e) at√© gozou.`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;

case 'morder':
  setTimeout(() => {reagir(from, "ü§î")}, 300)
  if (!isGroup) return reply(enviar.msg.grupo)
  if (!isModobn) return reply(enviar.msg.modobz)

  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  await blackmd.sendMessage(from, {
    video: { url: "https://telegra.ph/file/75e4c0273be625a2363ce.mp4" },
    gifPlayback: true,
    caption: `Voc√™ acabou de dar uma mordida no(a) *@${menc_os2.split('@')[0]}*`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;
case 'carinho':
  setTimeout(() => {reagir(from, "ü§î")}, 300)
  if (!isGroup) return reply(enviar.msg.grupo)
  if (!isModobn) return reply(enviar.msg.modobz)

  // Verifica a men√ß√£o
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que voc√™ quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono, mexeu comigo üëäüèΩ');

  await blackmd.sendMessage(from, {
    video: { url: "https://blackstorage.store/midia/1745793186254.mp4" },
    gifPlayback: true,
    caption: `Voc√™ acabou de dar um carinho no(a) *@${menc_os2.split('@')[0]}*`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;
case 'mamar':
    setTimeout(() => {reagir(from, "ü§î")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo)
    if (!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que voc√™ quer mamar, a mensagem ou o @')

    var susp = `@${menc_os2.split('@')[0]} Voc√™ recebeu uma mamada gostosa(a)!`
    var jrq = { url: "https://telegra.ph/file/3ad3be6f2ceec10ced5e8.mp4" }

    await blackmd.sendMessage(from, {
        video: jrq,
        gifPlayback: true,
        caption: susp,
        mentions: [menc_os2]
    }, { quoted: seloctt })
    break;
case 'comer':
    setTimeout(() => {reagir(from, "üè≥Ô∏è‚Äçüåà")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo)
    if (!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que voc√™ quer comer, a mensagem ou o @')

    var susp = `Voc√™ comeu o chocolate branco @${menc_os2.split('@')[0]} com prazer ü•µüç´`
    
    const pegarBuffer = async (url) => {
        const { data } = await axios.get(url, { responseType: 'arraybuffer' })
        return data;
    }

    var jrq = await pegarBuffer("https://telegra.ph/file/6804014b0f3b42711b257.mp4")

    await blackmd.sendMessage(from, { 
        video: jrq, 
        gifPlayback: true, 
        caption: susp, 
        mentions: [menc_os2] 
    }, { quoted: seloctt })
    break;

case 'mamar2':
    setTimeout(() => {reagir(from, "ü§î")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo)

    // Verifica se foi mencionada algu√©m, caso contr√°rio usa o sender
    var target = menc_os2 ? menc_os2 : sender;

    var susp = `@${target.split('@')[0]} Voc√™ recebeu um boquete espetacular.`
    var jrq = { url: "https://telegra.ph/file/7c6960abcb8c3364ba175.mp4" }

    await blackmd.sendMessage(from, {
        video: jrq,
        gifPlayback: true,
        caption: susp,
        mentions: [target]
    }, { quoted: seloctt })
    break;

case 'dar2':
    setTimeout(() => {reagir(from, "ü§î")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo)

    // Verifica se foi mencionada algu√©m, caso contr√°rio usa o sender
    var target = menc_os2 ? menc_os2 : sender;

    var susp = `Voc√™ deu com vontade para @${target.split('@')[0]}! üò≥`
    var jrq = { url: "https://telegra.ph/file/d72e1d4dba05d2b054fd8.mp4" }

    await blackmd.sendMessage(from, {
        video: jrq,
        gifPlayback: true,
        caption: susp,
        mentions: [target]
    }, { quoted: seloctt })
    break;

case 'comer2':
    setTimeout(() => {reagir(from, "ü§î")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo)

    // Verifica se foi mencionada algu√©m, caso contr√°rio usa o sender
    var target = menc_os2 ? menc_os2 : sender;

    var susp = `Voc√™ tratou da(o) @${target.split('@')[0]} com muito cuidado e dedica√ß√£o üòàüî•`
    var jrq = { url: "https://telegra.ph/file/cd28a1938d70cf025e207.mp4" }

    await blackmd.sendMessage(from, {
        video: jrq,
        gifPlayback: true,
        caption: susp,
        mentions: [target]
    }, { quoted: seloctt })
    break;

case 'chance':
setTimeout(() => {reagir(from, "ü§î")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
var avb = body.slice(7)
if(args.length < 1) return blackmd.sendMessage(from, {text: `Voc√™ precisa digitar da forma correta\nExemplo: ${prefix}chance do M4 ganhar na loteria`}, {quoted: seloctt})
random = `${Math.floor(Math.random() * 100)}`
hasil = `A chance ${body.slice(8)}\n\n√© de... ${random}% ü§∑üèª‚Äç‚ôÇÔ∏è`
mention(hasil)
break

case 'nazista':
  setTimeout(() => {reagir(from, "üíÇüèº‚Äç‚ôÇÔ∏è")}, 300)
  if(!isGroup) return reply(enviar.msg.grupo)
  if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for um, apenas digite ${prefix}modozoeira`)

  // Verifica se foi mencionada algu√©m, caso contr√°rio usa o sender
  var target = menc_os2 ? menc_os2 : sender;

  var susp = `*Salve Hitler* üíÇüèº‚Äç‚ôÇÔ∏è\n\n‚áí @${target.split('@')[0]}\n\n*Sai dessa vida...*`

  // Envia a mensagem com a men√ß√£o
  blackmd.sendMessage(from, {
    text: susp,
    mentions: [target]
  })

  blackmd.sendMessage(from, {
    audio: {url:'./database/audios/aguarde.m4a'},
    mimetype: 'audio/mp4',
    ptt: true
  }, {quoted: info})

  setTimeout(async () => {
    random = `${Math.floor(Math.random() * 110)}`
    // Envia a imagem com a men√ß√£o
    blackmd.sendMessage(from, {
      image: {url: links.nazista},
      caption: `*O QUANTO VOC√ä √â NAZISTA ?* \n\n‚áí @${target.split('@')[0]} \n\nVOC√ä √â  ‚úÆ${random}%‚úÆ  NAZISTA Âçê\n\n${NomeDoBot}üéñÔ∏è`,
      mentions: [target]
    }, {quoted: seloctt})
  }, 7000)
break

case 'gay':
  setTimeout(() => {reagir(from, "üè≥Ô∏è‚Äçüåà")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {text: `*Mn... Tu √© ?* ü´µüèΩü§®üè≥Ô∏è‚Äçüåà

‚áí @${sender_ou_n.split("@")[0]}

*Pesquisando...*`, mentions: [sender_ou_n]})
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
feio = random
boiola = random
if(boiola < 20 ) {var bo = 'hmm... voc√™ √© heteroüòî'} else if(boiola == 21 ) {var bo = '+/- boiola'} else if(boiola == 23 ) {var bo = '+/- boiola'} else if(boiola == 24 ) {var bo = '+/- boiola'} else if(boiola == 25 ) {var bo = '+/- boiola'} else if(boiola == 26 ) {var bo = '+/- boiola'} else if(boiola == 27 ) {var bo = '+/- boiola'} else if(boiola == 2 ) {var bo = '+/- boiola'} else if(boiola == 29 ) {var bo = '+/- boiola'} else if(boiola == 30 ) {var bo = '+/- boiola'} else if(boiola == 31 ) {var bo = 'tenho minha desconfian√ßa...üòë'} else if(boiola == 32 ) {var bo = 'tenho minha desconfian√ßa...üòë'} else if(boiola == 33 ) {var bo = 'tenho minha desconfian√ßa...üòë'} else if(boiola == 34 ) {var bo = 'tenho minha desconfian√ßa...üòë'} else if(boiola == 35 ) {var bo = 'tenho minha desconfian√ßa...üòë'} else if(boiola == 36 ) {var bo = 'tenho minha desconfian√ßa...üòë'} else if(boiola == 37 ) {var bo = 'tenho minha desconfian√ßa...üòë'} else if(boiola == 3 ) {var bo = 'tenho minha desconfian√ßa...üòë'} else if(boiola == 39 ) {var bo = 'tenho minha desconfian√ßa...üòë'} else if(boiola == 40 ) {var bo = 'tenho minha desconfian√ßa...üòë'} else if(boiola == 41 ) {var bo = 'voc√™ √© n√©?üòè'} else if(boiola == 42 ) {var bo = 'voc√™ √© n√©?üòè'} else if(boiola == 43 ) {var bo = 'voc√™ √© n√©?üòè'} else if(boiola == 44 ) {var bo = 'voc√™ √© n√©?üòè'} else if(boiola == 45 ) {var bo = 'voc√™ √© n√©?üòè'} else if(boiola == 46 ) {var bo = 'voc√™ √© n√©?üòè'} else if(boiola == 47 ) {var bo = 'voc√™ √© n√©?üòè'} else if(boiola == 4 ) {var bo = 'voc√™ √© n√©?üòè'} else if(boiola == 49 ) {var bo = 'voc√™ √© n√©?üòè'} else if(boiola == 50 ) {var bo = 'voc√™ √© ou n√£o?üßê'} else if(boiola > 51) {var bo = 'voc√™ √© gayüôà'
}
blackmd.sendMessage(from, {image: {url: links.gay}, caption: `*O QUANTO VOC√ä √â GAY ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  GAY üåà

${bo}

‚è§ÕüÕûÕüÕû Í¶ø${NomeDoBot}`, mentions: [sender_ou_n], thumbnail:null}, {quoted: seloctt})
}, 7000)
break

case 'feio': case 'feia':
  setTimeout(() => {reagir(from, "ü§°")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {text: `*Kkk pesquisando sua ficha de feio (a)* ü§°

‚áí @${sender_ou_n.split("@")[0]}

*Um segundo...*`, mentions: [sender_ou_n]})
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
feio = random
if(feio < 20 ) {var bo = '√â n√£o √© feio'} else if(feio == 21 ) {var bo = '+/- feio'} else if(feio == 23 ) {var bo = '+/- feio'} else if(feio == 24 ) {var bo = '+/- feio'} else if(feio == 25 ) {var bo = '+/- feio'} else if(feio == 26 ) {var bo = '+/- feio'} else if(feio == 27 ) {var bo = '+/- feio'} else if(feio == 2 ) {var bo = '+/- feio'} else if(feio == 29 ) {var bo = '+/- feio'} else if(feio == 30 ) {var bo = '+/- feio'} else if(feio == 31 ) {var bo = 'Ainda t√° na m√©dia'} else if(feio == 32 ) {var bo = 'Da pra pegar umas(ns) novinha(o) ainda'} else if(feio == 33 ) {var bo = 'Da pra pegar umas(ns) novinha(o) ainda'} else if(feio == 34 ) {var bo = '√â fein, mas tem baum cora√ß√£o'} else if(feio == 35 ) {var bo = 'T√° na m√©dia, mas n√£o deixa de ser feii'} else if(feio == 36 ) {var bo = 'Bonitin mas √© feio com orgulho'} else if(feio == 37 ) {var bo = 'Feio e pregui√ßoso(a), vai se arrumar praga feia'} else if(feio == 3 ) {var bo = 'tenho '} else if(feio == 39 ) {var bo = 'Feio, mas um banho E se arrumar, deve resolver'} else if(feio == 40 ) {var bo = 'FeiN,  mas n√£o existe gente feia, existe gente que n√£o conhece os produtos jequity'} else if(feio == 41 ) {var bo = 'voc√™ √© Feio, mas √© legal, continue assim'} else if(feio == 42 ) {var bo = 'Nada que uma maquiagem e se arrumar, que n√£o resolva ü•¥'} else if(feio == 43 ) {var bo = 'Feio que d√≥i de ver, compra uma m√°scara que melhora'} else if(feio == 44 ) {var bo = 'Feio mas nada que um saco na cabe√ßa n√£o resolva n√©!?'} else if(feio == 45 ) {var bo = 'voc√™ √© feio, mas tem bom gosto'} else if(feio == 46 ) {var bo = 'Feio mas tem muitos amigos'} else if(feio == 47 ) {var bo = 'Feio mas tem l√°bia pra pegar v√°rias novinha'} else if(feio == 4 ) {var bo = 'Feio e ainda n√£o sabe se vestir, vixi'} else if(feio == 49 ) {var bo = 'Feiooo'} else if(feio == 50 ) {var bo = 'voc√™ √© Feio, mas n√£o se encherga üßê'} else if(feio > 51) {var bo = 'voc√™ √© Feio demais üôà'} 

blackmd.sendMessage(from, {image: {url: links.feio}, caption: `*O QUANTO VOC√ä √â FEIO (A)?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  FEIO (A) ü§°
 
 ${bo}

‚è§ÕüÕûÕüÕû Í¶ø${NomeDoBot}`, mentions: [sender_ou_n], thumbnail:null}, {quoted: seloctt})
}, 7000)
break 

case 'corno': case 'corna':
  setTimeout(() => {reagir(from, "ü§üüèΩ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Foi um chifre desse que a NASA usou pra fazer contato com os ETs* üêÇ

‚áí @${sender_ou_n.split("@")[0]}

*Tamanho desse trem... kk*`, mentions: [sender_ou_n]})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.corno}, caption: `*O QUANTO VOC√ä √â CORNO (A)?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  CORNO ü§üüèΩ

${NomeDoBot}üéñÔ∏è`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'hetero': case 'h√©tero':
  setTimeout(() => {reagir(from, "üèÅ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Puxando sua ficha de h√©tero* üèÅ

‚áí @${sender_ou_n.split("@")[0]}

*Aguarde...*`, mentions: [sender_ou_n]})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.hetero}, caption: `*O QUANTO VOC√ä √â H√âTERO ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  H√âTERO üèÅ

${NomeDoBot}üéñÔ∏è`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'vesgo': case 'vesga':
  setTimeout(() => {reagir(from, "üëÄ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
if(command == `vesgo`) {
var txt = `irm√£o`
} else {
var txt = `irm√£`
}
blackmd.sendMessage(from, {text:`*Olha pra c√° ${txt} kakakaka* üôÑ

‚áí @${sender_ou_n.split("@")[0]}

*Um segundo...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.vesgo}, caption: `*O QUANTO VOC√ä √â VESGO (A) ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  VESGO üëÅÔ∏èüëÑüëÅÔ∏è

${NomeDoBot}üéñÔ∏è`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break 

case 'bebado': case 'b√™bada':
  setTimeout(() => {reagir(from, "ü•¥")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Bebe n√£o mn, isso faz mal...* ü•¥

‚áí @${sender_ou_n.split("@")[0]}

*Salvo se for pra esquecer o/a ex...* üò≠`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.bebado}, caption:`*O QUANTO VOC√ä √â B√äBADO ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  B√äBADO ü•¥

${NomeDoBot}üéñÔ∏è`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break 

case 'gado': case 'gada':
  setTimeout(() => {reagir(from, "üêÇ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Ui, ${command} d+* üêÇ

‚áí @${sender_ou_n.split("@")[0]}

*Calma ae kkk...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.gado}, caption: `*O QUANTO VOC√ä √â GADO(A)?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  GADO üëâüèΩ üêÇüëàüèΩ

${NomeDoBot}üéñÔ∏è`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break 

case 'gostoso':
  setTimeout(() => {reagir(from, "üòè")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Vamos ver o quanto voc√™ √© gostoso üòè

‚áí @${sender_ou_n.split("@")[0]}

*Um momento...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.gostoso}, caption: `*O QUANTO VOC√ä √â GOSTOSO ?*

‚áí @${sender_ou_n.split("@")[0]}

Voc√™ √© ‚úÆ${random}‚úÆ gostoso üòè

${NomeDoBot}üéñÔ∏è`, gifPlayback: true, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break 

case 'gostosa':
  setTimeout(() => {reagir(from, "üò≥")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Pesquisando sua ficha de gostosa* üò≥

‚áí @${sender_ou_n.split("@")[0]}

*Um momento...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.gostosa}, caption: `*O QUANTO VOC√ä √â GOSTOSA ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  GOSTOSA üò≥

${NomeDoBot}üéñÔ∏è`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'pau':
  setTimeout(() => {reagir(from, "üò≥")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Medindo o tamanho do seu pau* üò≥\n\n‚áí @${sender_ou_n.split("@")[0]}\n\n*Calma ae kkk...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 30)}`
blackmd.sendMessage(from, {image: {url: links.pau}, caption: `*Oh mds*

‚áí @${sender_ou_n.split("@")[0]}

Seu pau mede ‚úÆ${random}cm‚úÆ üò≥

${NomeDoBot}üéñÔ∏è`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'bct':
case 'buceta':
case 'xrc':
case 'xereca':
  setTimeout(() => {reagir(from, "üò≥")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Medindo o tamanho da sua ${command}* üò≥\n\n‚áí @${sender_ou_n.split("@")[0]}\n\n*Calma ae kkk...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 20)}`
blackmd.sendMessage(from, {image: {url: links.buceta}, caption: `*Eita kkkk*

‚áí @${sender_ou_n.split("@")[0]}

Sua ${command} mede ‚úÆ${random}cm‚úÆ üò≥

${NomeDoBot}üéñÔ∏è`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'pocoto':
  setTimeout(() => {reagir(from, "üê¥")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/pocoto.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Cavalgando e pesquisando... O quanto voc√™ √© pocoto* üê¥

‚áí @${sender_ou_n.split("@")[0]}

*Um momento...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.pocoto}, caption: `*O QUANTO VOC√ä √â POCOTO ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  POCOTO üê¥

${NomeDoBot}üéñÔ∏è`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'dojob': case 'puta': case 'prostituta':
  setTimeout(() => {reagir(from, "üòà")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Pesquisando o quanto voc√™ √© puta* üòà

‚áí @${sender_ou_n.split("@")[0]}

*Um momento...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.puta}, caption: `*O QUANTO VOC√ä √â PUTA ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  PUTA üòà

${NomeDoBot}üéñÔ∏è`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'calvo': case 'calva':
  setTimeout(() => {reagir(from, "üë®üèº‚Äçü¶≤")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Vai comprar um produto a√≠, enquanto eu pesquiso o quanto voc√™ √© ${command}* üë®üèº‚Äçü¶≤

‚áí @${sender_ou_n.split("@")[0]}

*Um momento...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.calvo}, caption: `*O QUANTO VOC√ä √â CALVO (A) ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  ${command.toUpperCase()} üë®üèº‚Äçü¶≤

${NomeDoBot}üéñÔ∏è`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'rico': case 'rica':
  setTimeout(() => {reagir(from, "ü§ë")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Eitah kkk J√° faz o pix enquanto eu puxo sua conta do banco* ü§ë

‚áí @${sender_ou_n.split("@")[0]}

*Um momento...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.rico}, caption: `*O QUANTO VOC√ä √â RICO (A) ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  RICO ü§ë

${NomeDoBot}üéñÔ∏è`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'pobre':
  setTimeout(() => {reagir(from, "ü§£")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Zero coment√°rios... Kkkk vamos ver o quanto voc√™ √© pobre* ü§£

‚áí @${sender_ou_n.split("@")[0]}

*Um momento...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.pobre}, caption: `*O QUANTO VOC√ä √â POBRE ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  POBRE ü§£

${NomeDoBot}üéñÔ∏è`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'lindo': case 'bonito':
setTimeout(() => {reagir(from, "ü§©")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Que que isso papai* ü§©

‚áí @${sender_ou_n.split("@")[0]}

*Olha essa lindeza...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.lindo}, caption: `*O QUANTO VOC√ä √â LINDO ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  LINDO ü§©

‚è§ÕüÕûÕüÕû Í¶ø${NomeDoBot}`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'linda': case 'bonita':
  setTimeout(() => {reagir(from, "üòç")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Opaisso ADM... c√™ t√° vendo isso ?* üòç

‚áí @${sender_ou_n.split("@")[0]}

*Xonei nela...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.linda}, caption: `*O QUANTO VOC√ä √â LINDA ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  LINDA üòç

‚è§ÕüÕûÕüÕû Í¶ø${NomeDoBot}`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'noia':
  setTimeout(() => {reagir(from, "üëΩ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*iqjakdksjgaijduaha eu sla* üëΩ

‚áí @${sender_ou_n.split("@")[0]}

*Calma ae, kkk...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.noia}, caption: `*O QUANTO VOC√ä √â NOIA ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  NOIA üëΩ

‚è§ÕüÕûÕüÕû Í¶ø${NomeDoBot}`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'sigma':
  setTimeout(() => {reagir(from, "üç∑")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Conversa de alto n√≠vel senhores* üóøüç∑

‚áí @${sender_ou_n.split("@")[0]}

*Aguarde...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.sigma}, caption: `*O QUANTO VOC√ä √â SIGMA ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  SIGMA üóøüç∑

‚è§ÕüÕûÕüÕû Í¶ø${NomeDoBot}`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'beta':
  setTimeout(() => {reagir(from, "ü§ì")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Processando seu n√≠vel de beta* ü§ì

‚áí @${sender_ou_n.split("@")[0]}

*Aguarde...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.beta}, caption: `*O QUANTO VOC√ä √â BETA ?* 

‚áí  @${sender_ou_n.split("@")[0]}

 VOC√ä √â  ‚úÆ${random}%‚úÆ  BETA ü§ì

‚è§ÕüÕûÕüÕû Í¶ø${NomeDoBot}`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'amor':
case 'odio':
if(!isModobn) return reply(enviar.msg.modobz)
if(command == `amor`) {
if(!menc_os2) return reply(`Marque a pessoa para quem voc√™ quer dedicar o seu amor...`)
blackmd.sendMessage(from, {text: `Ol√° @${menc_os2.split('@')[0]}, ${tempo} ^^
@${sender.split('@')[0]} mandou dizer que te ama ü•∫üíñ`, mentions: [menc_os2, sender]}, {quoted: seloctt})
enviarfigu(`./database/figu/loveyou.webp`)
} else {
if(!menc_os2) return reply(`Marque a pessoa para quem voc√™ quer dedicar o seu √≥dio...`)
blackmd.sendMessage(from, {text: `Ol√° @${menc_os2.split('@')[0]}, ${tempo} '-'
@${sender.split('@')[0]} mandou dizer que te odeia com todas as for√ßas üñïüèΩüòù`, mentions: [menc_os2, sender]}, {quoted: seloctt})
enviarfigu(`./database/figu/hateyou.webp`)
}
break

case 'matar':
case 'mata':
  setTimeout(() => {reagir(from, "üíÄ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
if(!menc_os2 || menc_jid2[1]) return reply('marque o alvo que voc√™ quer matar, a mensagem ou o @')
if(JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('N√£o irei matar o meu dono... Mas posso matar voc√™ üòà')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.matar}, gifPlayback: true, caption: `*‚öîÔ∏èVOC√ä ACABA DE MATAR O (A)‚öîÔ∏è*

‚áí @${menc_os2.split('@')[0]} üó°Ô∏èüë∫

${NomeDoBot} ‚ú®`, mentions: [menc_os2]})
break 


case 'beijo': case 'beijar':
  setTimeout(() => {reagir(from, "üíã")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
if(!menc_os2 || menc_jid2[1]) return reply('marque a pessoa que voc√™ quer beijar, a mensagem ou o @')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.beijo}, gifPlayback: true, caption: `*VOC√ä DEU UM BEIJO TOTOSO NA (O)*

  ‚áí  @${menc_os2.split('@')[0]} üëâüèΩüíûüëàüèΩü•∫

 ‚úÆ${NomeDoBot}‚úÆ` , mentions: [menc_os2]})
break

case 'biografia':
case 'bio':
try {
status = (await blackmd.fetchStatus(sender_ou_n)).status
} catch {
status = "üîí Privada üîí"
}
reply(status)
break

case 'tapa':
  setTimeout(() => {reagir(from, "üòè")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for, apenas digite ${prefix}modozoeira`)
if(!menc_os2 || menc_jid2[1]) return reply('marque o alvo que voc√™ quer da um tapa, a mensagem ou o @')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.tapa}, gifPlayback: true, caption: `*VOC√ä DEU UM TAPA NA RABA DA*

 ‚áí   @${menc_os2.split('@')[0]} üëâüèΩüëàüèΩüòè

‚úÆ${NomeDoBot}‚úÆ`, mentions: [menc_os2]})
break

case 'chute':
case 'chutar':
  setTimeout(() => {reagir(from, "ü§°")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for um, apenas digite ${prefix}modozoeira 1`)
if(!menc_os2 || menc_jid2[1]) return reply('marque o alvo que voc√™ quer da um chute, a mensagem ou o @')
if(JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Voc√™ n√£o est√° autorizado a chutar meu dono... üòê')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.chute}, gifPlayback: true, caption: `*VOC√ä DEU UMA BICUDA NO(A)*

 ‚áí @${menc_os2.split('@')[0]} üëâüèΩüëàüèΩü§°

‚úÆ${NomeDoBot}‚úÆ`, mentions: [menc_os2]})
break 

case 'abraco':
case 'abra√ßo':
case 'abra√ßar':
  setTimeout(() => {reagir(from, "ü§ó")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for um, apenas digite ${prefix}modozoeira`)
if(!menc_os2 || menc_jid2[1]) return reply('marque a pessoa que voc√™ quer dar um abra√ßo, a mensagem ou o @')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.abraco}, gifPlayback: true, caption: `*VOC√ä DEU UM ABRA√áO APERTADO NO (A)*

 ‚áí @${menc_os2.split('@')[0]} ü´Ç

${NomeDoBot} ü§ó`, mentions: [menc_os2]})
break

case 'soco':
case 'socar':
  setTimeout(() => {reagir(from, "üëäüèΩ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for um, apenas digite ${prefix}modozoeira`)
if(!menc_os2 || menc_jid2[1]) return reply('marque a pessoa que voc√™ quer dar um soco, a mensagem ou o @')
if(JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irm√£o... Mexeu com meu dono; mexeu comigo üëäüèΩ')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.socar}, gifPlayback: true, caption: `*VOC√ä DEU UM MURRO NA CARA DO (A)*

 ‚áí @${menc_os2.split('@')[0]} ü§°

${NomeDoBot} üëäüèΩ`, mentions: [menc_os2]})
break

case 'mano':
case 'bro':
case 'brother':
case 'toque':
case 'tocar':
setTimeout(() => {reagir(from, "ü§ùüèΩ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
if(!menc_os2 || menc_jid2[1]) return reply('marque a pessoa que voc√™ quer dar um aperto de m√£o, a mensagem ou o @')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.bro}, gifPlayback: true, caption: `*VOC√ä DEU UM APERTO DE M√ÉO NO (A)*

 ‚áí @${menc_os2.split('@')[0]} ü§úüèΩü§õüèΩ

${NomeDoBot} ü§ùüèΩ`, mentions: [menc_os2]})
break

case 'estuprar': case 'estupro':
setTimeout(() => {reagir(from, "üåö")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
if(!isNsfw) return reply(enviar.msg.modonsfw)
if(!menc_os2 || menc_jid2[1]) return reply('marque a pessoa que voc√™ quer estuprar, a mensagem ou o @')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.estuprar}, gifPlayback: true, caption: `*VOC√ä ACABOU DE ESTUPRAR O (A)*

 ‚áí @${menc_os2.split('@')[0]} üï≥Ô∏èüôà

${NomeDoBot} üåöüç∑`, mentions: [menc_os2]})
break

case 'namorar': case 'namoracomigo':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
reagir(from, "‚ù§")
if(!menc_os2) return reply(`Marque um usu√°rio para pedir este em namoro, a mensagem ou o @`)
if(botNumber.includes(menc_os2)) return reply(`N√£o pode pedir o bot em namoro kkk üòÇ`)
if(sender.includes(menc_os2)) return reply(`Tu n√£o pode pedir tu msm em namoro kkk üòÇ`)
if(userEstaNamorando(sender)) {
  mention(`üíû Voc√™ j√° est√° ${userEstaCasado(sender) ? "casado" : "em um relacionamento s√©rio"} com o/a @${getDBFZuser(sender).usu2}.. ü•∞`)
  await sleep(500)
  return blackmd.sendMessage(identArroba(getDBFZuser(sender).usu2), {text: `üêÇ A√≠ ${getname(getDBFZuser(sender).usu2)}, tua dupla @${sender.split("@")[0]} t√° pedido outra pessoa em namoro ali...`, mentions: [sender]}, {quoted: info})
}
if(userEstaNamorando(menc_os2)) {
  mention(`C√™ para lek, O/a @${menc_os2.split("@")[0]} ${userEstaCasado(sender) ? "√© casado/a" : "est√° namorando"} com o/a @${getDBFZuser(menc_os2).usu2}`)
  await sleep(500)
  return blackmd.sendMessage(identArroba(getDBFZuser(menc_os2).usu2), {text: `üêÇ A√≠ ${getname(getDBFZuser(menc_os2).usu2)}, t√£o pedindo a tua dupla @${menc_os2.split("@")[0]} em namoro ali...`, mentions: [menc_os2]}, {quoted: info})
}
deletarAntigoPedidoDeNamoro(sender)
deletarAntigoPedidoDeNamoro(menc_os2)
gerarPedidoDeNamoro(sender, menc_os2, from)
txt = `${tempo_emoji} *${tempo.toUpperCase()}*
‚áí @${menc_os2.split('@')[0]}
  
_${pushname} est√° te pedindo em namoro... Digite„Äé s „Äècaso queira aceitar, ou„Äé n „Äècaso queira recusar_ ü•∞`
blackmd.sendMessage(from, {video: {url: links.namoracomigo}, caption: txt, gifPlayback: true, mentions: [menc_os2]}, {quoted: seloctt})
break

case 'casar': case 'casacomigo':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
reagir(from, "üíç")
if(!menc_os2) return reply(`Marque um usu√°rio para pedir este em casamento, a mensagem ou o @`)
if(botNumber.includes(menc_os2)) return reply(`N√£o pode pedir o bot em casamento kkk üòÇ`)
if(sender.includes(menc_os2)) return reply(`Tu n√£o pode pedir tu msm em casamento kkk üòÇ`)
if(!userEstaNamorando(sender)) return reply(`Para pedir algu√©m em casamento, voc√™ precisa primeiro estar namorando essa pessoa...`)
if(userEstaCasado(sender)) {
  mention(`üíû Voc√™ j√° est√° casado/a com o/a @${getDBFZuser(sender).usu2}.. ü•∞`)
  await sleep(500)
  return blackmd.sendMessage(identArroba(getDBFZuser(sender).usu2), {text: `üêÇ A√≠ ${getname(getDBFZuser(sender).usu2)}, tua dupla @${sender.split("@")[0]} t√° pedido outra pessoa em casamento ali...`, mentions: [sender]}, {quoted: info})
}
if(menc_os2 != identArroba(getDBFZuser(sender).usu2)) {
  mention(`Sua dupla √© o/a @${getDBFZuser(sender).usu2}... Fica esperto em üêÇ`)
  await sleep(500)
  return blackmd.sendMessage(identArroba(getDBFZuser(sender).usu2), {text: `üêÇ A√≠ ${getname(getDBFZuser(sender).usu2)}, tua dupla @${sender.split("@")[0]} t√° pedido outra pessoa em casamento ali...`, mentions: [sender]}, {quoted: info})
}
if(isWaitUsuFZ_casamento(sender)) return mention(`üëª Voc√™ j√° pediu sua dupla @${getDBFZuser(sender).usu2} em casamento... Aguarde resposta ou use ${prefix}cancelar`)
gerarPedidoDeCasamento(sender, from)
txt = `${tempo_emoji} *${tempo.toUpperCase()}*
‚áí @${menc_os2.split('@')[0]}
  
_${pushname} est√° te pedindo em casamento... Digite„Äé s „Äècaso queira aceitar, ou„Äé n „Äècaso queira recusar_ ü´¥üèΩüíç`
blackmd.sendMessage(from, {video: {url: links.casacomigo}, caption: txt, gifPlayback: true, mentions: [menc_os2]}, {quoted: seloctt})
break

case 'terminar': case 'termino': case 'divorciar': case 'divorcio':
if(Number(args[0]) !== 1) return reply(`Tem crtz disso ${pushname} ? Se estiver mesmo disposto a ${command.startsWith("termi") ? "terminar" : "divorciar"} com sua dupla, use ${prefix+command} 1`)
if(!userEstaNamorando(sender)) return reply(`Voc√™ n√£o est√° se relacionando com ningu√©m para terminar ou se divorciar...`)
terminarOuDivorciar(sender)
reply(`${command.startsWith("termi") ? "T√©rmino" : "Div√≥rcio"} efetuado com sucesso üíî`)
break

case 'cancelar':
if(userPediuAlguemEmNamoro(sender)) {
cancelarPedidoDeNamoro(sender)
} else if(userPediuAlguemEmCasamento(sender)) {
cancelarPedidoDeCasamento(sender)
} else return reply(`N√£o h√° pedidos de namoro nem casamento...`)
reply(`üëª O pedido a sua dupla foi cancelado com sucesso...`)
break

case 'minhadupla': case 'dupla':
reagir(from, "‚ù§Ô∏è‚Äçü©π")
if(!userEstaNamorando(sender)) return reply(`Voc√™ n√£o est√° casado (a) com ningu√©m... Sinto muito üòï`)
if(isWaitUsuFZ_namoro(sender)) return reply(`A pessoa quem voc√™ pediu em namoro n√£o aceitou o pedido ainda... Portanto, n√£o √© poss√≠vel consultar os dados da dupla üò∂‚Äçüå´Ô∏è`)
i = getDBFZuser(sender)
n = i.namoro
c = i.casamento

//============contador de tempo================\\

data_pedido = `üìÜ‚É§ Namorando desde ${n.day}/${n.mm}/${n.year}`

if(!userEstaCasado(sender)) {
  tipo = "Namoro"
  tempo_total = "_Namorando a "
  sub = contarDias(sendHours("DD/MM/YYYY")) - contarDias(`${n.day}/${n.mm}/${n.year}`)
  horas = (sub * 24) + (Number(sendHours("HH")) - n.hora)
  if(horas <= 0) {
    sec = "aproximadamente "
    if((Number(sendHours("mm")) - n.minuto) <= 0) {
      sec += Number(sendHours("ss")) - n.segundo
      sec += ` segundo${(Number(sendHours("ss")) - n.segundo) != 1 ? "s" : ""}`
    } else {
      sec += Number(sendHours("mm")) - n.minuto
      sec += ` minuto${(Number(sendHours("mm")) - n.minuto) != 1 ? "s" : ""}`
    }
    tempo_total += sec
  } else if(horas > 0 && horas <= 24) {
    tempo_total += `aproximadamente ${horas} hora${horas != 1 ? "s" : ""}`
  } else tempo_total += converterDias(sub)
  tempo_total += "_\n"
  if(Number(sendHours("DD")) === Number(n.day) && horas > 24) {
    if(Number(sendHours("MM")) === Number(n.mm) && Number(sendHours("YYYY")) !== Number(n.year)) {
      ano = Number(sendHours("YYYY")) - Number(n.year)
      tempo_total = `_Namorando a exatamente ${ano} ano${ano != 1 ? "s" : ""}_`
      tempo_total += "\n\t\t"
      tempo_total += "*_Parab√©ns_* üíóüòç"
    } else {
      m√™s = ((Number(sendHours("YYYY")) - Number(n.year)) * 12) + (Number(sendHours("MM")) - Number(n.mm))
      tempo_total = `_Namorando a exatamente ${m√™s} m${m√™s != 1 ? "eses" : "√™s"}_`
      tempo_total += "\n\t\t"
      tempo_total += "*_Parab√©ns_* üíñ‚ú®"
    }
  }
} else {
  tipo = "Casamento"
  tempo_total = "_Casados a "
  sub = contarDias(sendHours("DD/MM/YYYY")) - contarDias(`${c.day}/${c.mm}/${c.year}`)
  horas = (sub * 24) + (Number(sendHours("HH")) - c.hora)
  if(horas <= 0) {
    sec = "aproximadamente "
    if((Number(sendHours("mm")) - c.minuto) <= 0) {
      sec += Number(sendHours("ss")) - c.segundo
      sec += ` segundo${(Number(sendHours("ss")) - c.segundo) != 1 ? "s" : ""}`
    } else {
      sec += Number(sendHours("mm")) - c.minuto
      sec += ` minuto${(Number(sendHours("mm")) - c.minuto) != 1 ? "s" : ""}`
    }
    tempo_total += sec
  } else if(horas > 0 && horas <= 24) {
    tempo_total += `aproximadamente ${horas} hora${horas != 1 ? "s" : ""}`
  } else tempo_total += converterDias(sub)
  tempo_total += "_\n"
  data_pedido += `\nüíç‚É§ Casados desde ${c.day}/${c.mm}/${c.year}`
  if(Number(sendHours("DD")) === Number(c.day) && horas > 24) {
    if(Number(sendHours("MM")) === Number(c.mm) && Number(sendHours("YYYY")) !== Number(c.year)) {
      ano = Number(sendHours("YYYY")) - Number(c.year)
      tempo_total = `_Casados a exatamente ${ano} ano${ano != 1 ? "s" : ""}_ üéÇ`
      tempo_total += "\n\t\t\t\t"
      tempo_total += "*_Feliz anivers√°rio_* üòçüíç"
    } else {
      m√™s = ((Number(sendHours("YYYY")) - Number(c.year)) * 12) + (Number(sendHours("MM")) - Number(c.mm))
      tempo_total = `Casados a exatamente ${m√™s} m${m√™s != 1 ? "eses" : "√™s"}_ üéÇ`
      tempo_total += "\n\t\t\t\t"
      tempo_total += "*_Feliz anivers√°rio_* üíòüõê"
    }
  }
}

//===================fotos=======================\\
db = getDBFZuser(sender)

try { foto1 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${db.usu1.split("@")[0]}@c.us`, 'image'))}`)).data
} catch(e) { foto1 = semfoto }

try { foto2 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${db.usu2}@c.us`, 'image'))}`)).data
} catch(e) { foto2 = semfoto }

logocasal = site+`/api/canvas/ship?foto1=${foto1}&foto2=${foto2}&mat=100&fundo=https://telegra.ph/file/070ced9a362da470ae3f9.jpg`

//=========distribui√ß√£o de informa√ß√µes===========\\

txt = `
üíï ${tipo} entre ‚Ü¥
„Äéüòç„Äè@${db.usu1.split('@')[0]}
„Ö§ &
„Äò‚ù§Ô∏è‚Äçü©π„Äô@${db.usu2}
‚áí ${tempo_total}
---------------------------------------------------------
${data_pedido}`
mencionarIMG(txt, logocasal)
break

case 'dogolpe': case 'golpe': case 'golpista':
setTimeout(() => {reagir(from, "üò≥")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for um, apenas digite ${prefix}modozoeira 1`)
if(!menc_os2 || menc_jid2[1]) return reply(`Marque a mensagem da pessoa ou use:\n${prefix+command} @algu√©m do grupo`)
random = `${Math.floor(Math.random() * 100)}`
golpenmr = random
if(golpenmr < 25){var golpetxt = `N√£o √© golpe`}; if(golpenmr >= 25 && golpenmr < 50){var golpetxt = `Varia de pessoa pra pessoa`}; if(golpenmr >=50 && golpenmr < 75){var golpetxt = `Idiota gosta de ferir sentimentos`}; if(golpenmr > 75){var golpetxt = `Famoso destr√≥i cora√ß√µes`}
blackmd.sendMessage(from, {text:`@${menc_os2.split("@")[0]} √© golpe ? ü§î

*CALCULANDO GOLPE‚ü©* ‚úÆ${random}%‚úÆ

${golpetxt} üíîü§°`, mentions: [menc_os2]})
break

case 'shipo': case 'shippe': case 'shipe': case 'shipar':
setTimeout(() => {reagir(from, "üòè")}, 300)
if(!menc_os2) return reply(`Marque a mensagem da pessoa ou use:\n${prefix+command} @algu√©m do grupo`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/shipo.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
mention(`*Hmm... Eu shipo o (a):*
 ‚è§ÕüÕûÕüÕû Í¶øüòç‚ßΩ @${menc_os2.split("@")[0]}
*Com o (a):*
 ‚è§ÕüÕûÕüÕû Í¶øüòè‚ßΩ @${groupMembers[Math.floor(Math.random() * groupMembers.length)].id.split('@')[0]}

 Com uma porcentagem de‚ßΩ ‚úÆ${Math.floor(Math.random() * 100)+"%"}‚úÆ ‚ù§Ô∏è`)
break

case 'casal':
setTimeout(() => {reagir(from, "üòç")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for um, apenas digite ${prefix}modozoeira`)
txt = `*Hmmm.... Eu Shipo eles 2üíòüíò*
1= @${groupMembers[alerandom(groupMembers.length)].id.split("@")[0]}
e esse
2= @${groupMembers[alerandom(groupMembers.length)].id.split("@")[0]}
com uma porcentagem de: ${alerandom(100)}%`
mention(txt)
break

case 'rankativos':
case 'rankativo':  
if(!isGroup) return reply(enviar.msg.grupo)
AB = countMessage.map(a => a.groupId).indexOf(from)
if(AB < 0) return reply(`N√£o h√° dados de mensagens deste grupo salvos na database do bot...`)
grupo = countMessage[AB].participants.map(i => i)
rank = grupo.sort((a, b) => ((a.mensagens + a.comandos) < (b.mensagens + b.comandos)) ? 0 : -1)
caixa = []
for(i = 0; i < (countMessage[AB].participants.length < 5 ? countMessage[AB].participants.length : 5); i++) {
caixa.push({nmr: i+1, id: rank[i].id, mensagens: rank[i].mensagens, comandos: rank[i].comandos})

}
if(caixa.length <= 0) return reply(`N√£o h√° membros suficientes no grupo para efetuar o rank...`)
txt = `‚ù§Ô∏è‚Äçüî• *${countMessage[AB].participants.length < 5 ? countMessage[AB].participants.length : 5} mais ativos do grupo ‚Ü¥*
‚è§ÕüÕûÕüÕû Í¶ø${groupName}

${caixa.map(c => `¬ª${c.nmr}¬´ @${c.id.split('@')[0]}
\t‚áíùôºùöéùöóùöúùöäùöêùöéùöóùöú: ${largeNumber(c.mensagens)}
\t\t‚áíùô≤ùöòùöñùöäùöóùöçùöòùöú: ${largeNumber(c.comandos)}`).join(`\n\n`)}`
mention(txt)
break

case 'rankinativo':
case 'rankinativos':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = countMessage.map(a => a.groupId).indexOf(from)
if(AB < 0) return reply(`N√£o h√° dados de mensagens deste grupo salvos na database do bot...`)
grupo = countMessage[AB].participants.map(i => i)
rank = grupo.sort((a, b) => ((a.mensagens + a.comandos) < (b.mensagens + b.comandos)) ? -1 : 0)
caixa = []
for(i = 0; i < (countMessage[AB].participants.length < 5 ? countMessage[AB].participants.length : 5); i++) {
caixa.push({nmr: i+1, id: rank[i].id, mensagens: rank[i].mensagens, comandos: rank[i].comandos})

}
if(caixa.length <= 0) return reply(`N√£o h√° ghosts neste grupo...`)
txt = `üëª *Top ${countMessage[AB].participants.length < 5 ? countMessage[AB].participants.length : 5} mais ghosts deste grupo ‚Ü¥*

${caixa.map(c => `¬ª${c.nmr}¬´ @${c.id.split('@')[0]}
*Mensagens:* ${c.mensagens}
*Comandos:* ${c.comandos}`).join(`\n\n`)}`
mention(txt)
break

case 'check':
if(menc_os2) {
mark = menc_os2
} else {
mark = sender
}
wppuser(mark)
try {
checkimg = await blackmd.profilePictureUrl(`${mark.split('@')[0]}@c.us`, 'image')
} catch {
checkimg = "https://telegra.ph/file/5446d1f9da3df07e98699.jpg"
}
check = `
‚è§ÕüÕûÕüÕû ‚ñë‚Éü‚Éõ ‚ûÆ @${mark.split('@')[0]}
‚ï≠‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïÆ
‚ïü ‚ñß‚ÉØ‚Éüüî± *ADM„Äé ${groupAdmins.includes(mark) ? `‚úÖ` : `‚ùå`} „Äè*
‚ïü ‚ñß‚ÉØ‚Éü‚öúÔ∏è *CRIADOR (A)„Äé ${groupMetadata.owner.includes(mark) ? `‚úÖ` : `‚ùå`} „Äè*
‚ïü ‚ñß‚ÉØ‚Éüüíé *VIP„Äé ${isJsonIncludes(vip, mark) ? `‚úÖ` : isJsonIncludes(vipgp, from) ? `‚úÖ` : `‚ùå`} „Äè*
‚ïü ‚ñß‚ÉØ‚Éüüëë *DONO„Äé ${numerodono.includes(mark) ? `‚úÖ` : `‚ùå`} „Äè*
‚ï∞‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïØ`
blackmd.sendMessage(from, {image: {url: checkimg}, caption: check, mentions: [mark]})
break

case 'checkativo':
setTimeout(() => {reagir(from, "üìñ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
AB = countMessage.map(a => a.groupId).indexOf(from)
if(AB < 0) return reply(`N√£o h√° dados de mensagens deste grupo salvos na database do bot...`)
if(!menc_os2 || menc_jid2[1]) return reply('Marque o @ de quem deseja puxar a atividade / S√≥ pode um por vez..')
if(menc_os2.includes(sender)) return reply(`Para puxar os pr√≥prios dados, use ${prefix}checkme`)
AC = countMessage[AB].participants.map(b => b.id).indexOf(menc_os2)
if(AC <= 0) return reply(enviar.msg.notusu)
usu = AC >= 0 ? countMessage[AB].participants[AC] : {}
mention(`
‚ñÑÔ∏ªÃ∑Ãø‚îªÃø‚ïê‚îÅ‰∏Ä üÖ≤üÖ∑üÖ¥üÖ≤üÖ∫
‚áí@${menc_os2.split('@')[0]}
________________________________________

‚è§ÕüÕûÕüÕû Í¶øùôºùöéùöóùöúùöäùöêùöéùöóùöú *‚Ü¥*
‚áí( ${AC >= 0 ? usu.mensagens : 0} )

‚è§ÕüÕûÕüÕû Í¶øùô≤ùöòùöñùöäùöóùöçùöòùöú *‚Ü¥*
‚áí( ${AC >= 0 ? usu.comandos : 0} )
________________________________________

‡≥à·çùÕ°Õúüìñ ${NomeDoBot}
`)
break

case 'checkme':
setTimeout(() => {reagir(from, "üìñ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
AB = countMessage.map(a => a.groupId).indexOf(from)
if(AB < 0) return reply(`N√£o h√° dados de mensagens deste grupo salvos na database do bot...`)
AC = countMessage[AB].participants.map(b => b.id).indexOf(sender)
usu = AC >= 0 ? countMessage[AB].participants[AC] : {}
txt =
`
„Ö§„Ö§¬ª‚ü© SÃ∑UÃ∑AÃ∑ AÃ∑TÃ∑IÃ∑VÃ∑IÃ∑DÃ∑AÃ∑DÃ∑EÃ∑ ‚ü®¬´
‚ï≠‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïØ
 | üßæ‚É§ grupœÉ: ${groupName}
 | ‚úèÔ∏è‚É§ n√≠ck: ${pushname}
 | üìñ‚É§ m—însŒ±g—îns: ${AC >= 0 ? usu.mensagens : 0}
 | üíª‚É§ cœÉmŒ±ndœÉs: ${AC >= 0 ? usu.comandos : 0}
‚ï∞‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïÆ
`
try {img = await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image')
} catch { img = semfoto }
sendUrlText(from, txt, NomeDoBot, ``, img, `https://wa.me/`+sender.split("@")[0], seloctt)
break

case 'rankcorno':
if(!isGroup) return reply(`[‚ùó] Este comando s√≥ pode ser usado em grupo...`)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for um, apenas digite ${prefix}modozoeira 1`)
membr = []
const corno1 = groupMembers
const corno2 = groupMembers
const corno3 = groupMembers
const corno4 = groupMembers
const corno5 = groupMembers
const cornos1 = corno1[Math.floor(Math.random() * corno1.length)]
const cornos2 = corno2[Math.floor(Math.random() * corno2.length)]
const cornos3 = corno3[Math.floor(Math.random() * corno3.length)]
const cornos4 = corno4[Math.floor(Math.random() * corno4.length)]
const cornos5 = corno5[Math.floor(Math.random() * corno5.length)]
var porcentagemcorno = ["1%", `2%`, `3%`, `4%`, `5%`, `6%`, `7%`, `8%`, `9%`, `10`, `11%`, `12%`,`13%`, `14%`, `15%`, `16%`, `17%`, `1%`, `19%`, `20%`, `21%`, `22`, `23%`, `24%`, `25%`, `26%`, `27%`, `2%`, `27%`, `2%`, `29%`, `30%`, `31%`, `32%`, `33%`, `34%`, `35%`, `36%`, `37%`, `3%`, `39%`, `40%`, `41%`, `42%`, `43%`, `44%`, `45%`, `46%`, `47%`, `4%`, `49%`, `50%`, `51%`, `52%`, `53%`, `54%`, `55%`, `56%`, `57%`, `5%`, `59%`, `60%`, `61%`, `62%`, `63%`, `64%`, `65%`, `66%`, `67%`, `6%`, `69%`, `70%`, `71%`, `72%`, `73%`, `74%`, `75%`, `76%`, `77%`, `7%`, `79%`, `0%`, `1%`, `2%`, `5%`, `4%`, `5%`, `6%`, `7%`, `%`, `9%`, `90%`, `91%`, `92%`, `93%`, `94%`, `95%`, `96%`, `97%`, `9%`, `99%`, `O chifre desse ai bate na lua ksksksk`]
const porcentagemc = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const porcentag = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const porcent = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const porcl = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const porg = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const prg = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
ABC = `
*Esses s√£o os cornos do grupo* ${groupName}\n@${cornos1.id.split('@')[0]}\nCom uma porcentagem de ${porcent}\n@${cornos2.id.split('@')[0]}\nCom uma porcentagem de ${porcentag}\n@${cornos3.id.split('@')[0]}\nCom uma porcentagem de ${porcl}\n@${cornos4.id.split('@')[0]}\nCom uma porcentagem de ${porg}\n@${cornos5.id.split('@')[0]}\nCom uma porcentagem de ${prg}\n\n‚úÆ${setting.NomeDoBot}‚úÆ`
membr.push(cornos1.id)
membr.push(cornos2.id)
membr.push(cornos3.id)
membr.push(cornos4.id)
membr.push(cornos5.id)
mentions(ABC, membr, true)
break

case 'rankgostoso': case 'rankgostosos':
if(!isGroup) return reply(`[‚ùó] Este comando s√≥ pode ser utilizado em grupo`)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for um, apenas digite ${prefix}modozoeira 1`)
membr = []
const ogstz1 = groupMembers
const ogstz2 = groupMembers
const ogstz3 = groupMembers
const ogstz4 = groupMembers
const ogstz5 = groupMembers
const ogstzs1 = ogstz1[Math.floor(Math.random() * ogstz1.length)]
const ogstzs2 = ogstz2[Math.floor(Math.random() * ogstz2.length)]
const ogstzs3 = ogstz3[Math.floor(Math.random() * ogstz3.length)]
const ogstzs4 = ogstz4[Math.floor(Math.random() * ogstz4.length)]
const ogstzs5 = ogstz5[Math.floor(Math.random() * ogstz5.length)]
const ogstzmsg = [`trabalhando em nossa ag√™ncia de modelos üòä by: ${NomeDoBot}`, ` mandando nuds no pv do dono ‚ò∫Ô∏è by: ${NickDono}`]
const ogstzmsg_ = ogstzmsg[Math.floor(Math.random() * (ogstzmsg.length))]
ABC = `
Parados !‚úãüèΩüò∂ü§öüèΩ

1= ‚úãüèΩüò∂@${ogstzs1.id.split('@')[0]}üò∂ü§öüèΩ


2= ‚úãüèΩüò∂@${ogstzs2.id.split('@')[0]}üò∂ü§öüèΩ


3= ‚úãüèΩüò∂@${ogstzs3.id.split('@')[0]}üò∂ü§öüèΩ


4= ‚úãüèΩüò∂@${ogstzs4.id.split('@')[0]}üò∂ü§öüèΩ


5= ‚úãüèΩüò∂@${ogstzs5.id.split('@')[0]}üò∂ü§öüèΩ


Multa por serem gostosos dms üò≥ pague pena ${ogstzmsg_}`
membr.push(ogstzs1.id)
membr.push(ogstzs2.id)
membr.push(ogstzs3.id)
membr.push(ogstzs4.id)
membr.push(ogstzs5.id)
mentions(ABC, membr, true)
break

case 'rankgostosa': case 'rankgostosas':
if(!isGroup) return reply(`[‚ùó] Este comando s√≥ pode ser utilizado em grupo`)
if(!isModobn) return reply(`Este tipo de comando s√≥ pode ser utilizado com o modozoeira ativo, fale com um adm ou se voc√™ for um, apenas digite ${prefix}modozoeira 1`)
membr = []
const agstz1 = groupMembers
const agstz2 = groupMembers
const agstz3 = groupMembers
const agstz4 = groupMembers
const agstz5 = groupMembers
const agstzs1 = agstz1[Math.floor(Math.random() * agstz1.length)]
const agstzs2 = agstz2[Math.floor(Math.random() * agstz2.length)]
const agstzs3 = agstz3[Math.floor(Math.random() * agstz3.length)]
const agstzs4 = agstz4[Math.floor(Math.random() * agstz4.length)]
const agstzs5 = agstz5[Math.floor(Math.random() * agstz5.length)]
const agstzmsg = [`trabalhando em nossa ag√™ncia de modelos üòä by: ${NomeDoBot}`, ` mandando nuds no pv do dono ‚ò∫Ô∏è by: ${NickDono}`]
const agstzmsg_ = agstzmsg[Math.floor(Math.random() * (agstzmsg.length))]
ABC = `
Paradas !‚úãüèΩüò∂ü§öüèΩ

1= ‚úãüèΩüò∂@${agstzs1.id.split('@')[0]}üò∂ü§öüèΩ


2= ‚úãüèΩüò∂@${agstzs2.id.split('@')[0]}üò∂ü§öüèΩ


3= ‚úãüèΩüò∂@${agstzs3.id.split('@')[0]}üò∂ü§öüèΩ


4= ‚úãüèΩüò∂@${agstzs4.id.split('@')[0]}üò∂ü§öüèΩ


5= ‚úãüèΩüò∂@${agstzs5.id.split('@')[0]}üò∂ü§öüèΩ


Multa por serem gostosas dms üò≥ pague pena ${agstzmsg_}`
membr.push(agstzs1.id)
membr.push(agstzs2.id)
membr.push(agstzs3.id)
membr.push(agstzs4.id)
membr.push(agstzs5.id)
mentions(ABC, membr, true)
break

case 'rankgay': case 'rankgays':
setTimeout(() => {reagir(from, "üåà")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS GAYS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `üåà‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break;

case 'rankhetero':
  setTimeout(() => {reagir(from, "üèÅ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS H√âTEROS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `üèÅ‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankgado': case 'rankgados':
setTimeout(() => {reagir(from, "üêÇ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS GADOS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `üêÇ‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break;

case 'ranknazista': case 'ranknazistas':
  setTimeout(() => {reagir(from, "üíÇüèº‚Äç‚ôÇÔ∏è")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS NAZISTAS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `üíÇüèº‚Äç‚ôÇÔ∏è‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break;

case 'rankotaku': case 'rankotakus':
  setTimeout(() => {reagir(from, "üßΩ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS OTAKUS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `üßΩ‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break;

case 'rankpau':
  setTimeout(() => {reagir(from, "üçÜ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*Esses s√£o os cara com maior e menor pau do grupo* ${groupName}\n\n`
TMPAU = ["Min√∫sculo", `Pequenininho chega ser at√© fofo ü•∫`, `Pequeno`, `Mediano`, `Grandinho ü•µ`, `Grande at√©`, `Gigantesco`, `Enorme`, `QUEIMADO !! T√£o grande que bateu no sol e queimou`, `Ponte Rio Niter√≥i`, "Nem existe"]
for (var i = 0; i < 5; i++) {
ABC += `@${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n${TMPAU[Math.floor(Math.random() * TMPAU.length)]}\n`
}
ABC += `\nBy üî• ${NomeDoBot} üî•`
mention(ABC);
break;

case 'rankbct':
case 'rankbuceta':
case 'rankxrc':
case 'rankxereca':
setTimeout(() => {reagir(from, "üòè")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSAS S√ÉO AS MAIS BUCETUDAS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `üòè‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankpocoto':
setTimeout(() => {reagir(from, "üê¥")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS POCOTO DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `üê¥‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'ranklindo':
case 'ranklinda':
case 'rankbonito':
case 'rankbonita':
setTimeout(() => {reagir(from, react2)}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
lindo = ["Base da Virg√≠nia", "Sem coment√°rios...", "Feio que d√° d√≥", "Feio mas engra√ßado", "Feio (a)", "Nada que uma maquiagem n√£o resolva", "Na m√©dia", "Nem um, nem outro", "Bonito (a)", "Nada mal", "Lindo (a)", "Extremamente lindo (a)", "Perfeito (a)"]
ABC = `*GRAU DE LINDEZA DO GRUPO‚ü©*
‚áí${groupName}\n`
for (var i = 0; i < 5; i++) {
ABC += `‚úÆ @${groupMembers[Math.floor(Math.random() * groupMembers.length)].id.split("@")[0]}\n„Ö§‚áí${lindo[Math.floor(Math.random()*lindo.length)]}\n\n`
}
mention(ABC);
break

case 'rankputa':
setTimeout(() => {reagir(from, "üòà")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSAS S√ÉO AS MAIS PUTAS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `üòà‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankcalvo':
  setTimeout(() => {reagir(from, "üë®üèº‚Äçü¶≤")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS CALVOS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `üë®üèº‚Äçü¶≤‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankrico':
  setTimeout(() => {reagir(from, "ü§ë")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS RICOS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `ü§ë‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankpobre':
  setTimeout(() => {reagir(from, "ü§£")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS POBRES DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `ü§£‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankpobre':
  setTimeout(() => {reagir(from, "ü§£")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS POBRES DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `ü§£‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankfeio':
  setTimeout(() => {reagir(from, "ü§°")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS FEIOS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `ü§°‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break
case 'rankvesgo':
  setTimeout(() => {reagir(from, "üëÄ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS VESGO DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `üëÄ‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'ranknoia':
  setTimeout(() => {reagir(from, "üëΩ")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS NOIA DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `üëΩ‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'ranksigma':
  setTimeout(() => {reagir(from, "üóø")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS SIGMA DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `üóøüç∑‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankbeta':
  setTimeout(() => {reagir(from, "ü§ì")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES S√ÉO OS MAIS BETAS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `ü§ì‚ßΩ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'piadas': case 'piada':
setTimeout(() => {reagir(from, "üòÇ")}, 300)
reply(`*_Sorteando_*

${pia[Math.floor(Math.random() * (pia.length))]}
________________________________________
*_By Black 2K25_*`)
break

case 'cantada':
case 'cantadas':
setTimeout(() => {reagir(from, "üòè")}, 300)
const cantm1 = ['Voc√™ n√£o √© mexicana mas mexicomigo', 'Eu n√£o sou gato, mas me miamarro em vc', 'Pra virar bombom, s√≥ falta a valsa... Pq vc j√° √© um sonho', 'Eu n√£o sou astronauta mas eu posso te fazer chegar aos c√©us', 'Se beleza fosse crime, vc seria inocente', 'Se beleza fosse merda, vc estaria toda cagada', 'Se o universo soubesse o quanto eu te amo... Ele teria vergonha de ser t√£o pequeno', 'A lua deve estar cansada de me ouvir falar de vc', 'Cansei de correr atr√°s de vc... Agora eu vou de moto', 'Me chame de thur, pq o Ar eu perdi quando te vi', 'Me passa seu insta a√≠... Minha m√£e disse pra eu seguir meu sonho', 'Vc √© um eixo terrestre ? Pq meu mundo gira em torno de vc', 'Tem algo de errado no meu celular... N√£o consigo encontrar seu n√∫mero nele', 'Rosas s√£o vermelhas, violetas s√£o azuis... Eu n√£o sei rimar, mas posso namorar com vc ?', 'T√° calor n√© ? Mas n√£o √© de hj que eu me derreto por vc...', 'Estou sentindo uma dor no peito... Espero que seja amor, porque se for infarto, eu nunca mais te verei', 'Se te amar um dia me matar, saiba que eu morri sorrindo', 'Eu tenho uma mem√≥ria terr√≠vel... Felizmente, vc √© inesquec√≠vel', 'Seu nome √© Google ? Pq em vc, tem tudo o que eu preciso...']
const cantm2 = cantm1[Math.floor(Math.random() * (cantm1.length))]
cantmtxt = `*_Chega na mina e fala assim..._*

_"${cantm2}"_ üòè
*_By ~M4TH 2K25_*`
blackmd.sendMessage(from, {text: cantmtxt, mentions: [menc_os2]})
blackmd.sendMessage(from, {audio: {url:'./database/audios/shipo.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
break

case 'cantada+18':
case 'cantadas+18':
if(!isNsfw) return reply(`*Este comando s√≥ pode ser executado com o modo+18 ativo...*
*Para ativa-lo, digite* ${prefix}modo+18`)
setTimeout(() => {reagir(from, "üåö")}, 300)
const cantf1 = ['N√£o quero problema para cima de mim, s√≥ se o problema for voc√™', 'Minha roupa ficaria linda jogada no ch√£o do seu quarto', 'Me chama de videogame e me joga no sof√°', 'Sabe que horas s√£o? hora da gente se pegar', 'Eu n√£o sei fazer seu mundo girar, mas sei fazer sua cama balan√ßar', 'Estou pegando no sono, mas queria estar pegando voc√™', 'Minha boca na sua, rola? Se quiser, a gente tira a v√≠rgula...', 'Gosto de caf√© assim como de sexo... Quente, forte e todos os dias', 'Oi, a minha cama mandou perguntar se voc√™ quer dormir aqui', 'Queria ser o seu sabonete, para deslizar no seu corpo', 'Vc √© fazendeira ? Pq vc fez o meu pepino crescer...', 'Posso te chamar de picol√© de uva ? Pra vc deixar minha boca roxa...', 'Me chama de Buzz Lightyear e deixa eu te mostrar o infinito e al√©m...', 'Deixa eu te ensinar o que eu aprendi com Danone... Enquanto voc√™ me ensina o que aprendeu com pirulito']
const cantf2 = cantf1[Math.floor(Math.random() * (cantf1.length))]
cantftxt = `*Cantadas +18 pra vc...*

_"${cantf2}"_ ü•µ
*_By_* üî• ${NomeDoBot} üî•`
reply(cantftxt)
break

case 'akinator':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(akinator).includes(from) && akinator.length > 0 && Number(akinator[0].dia) === Number(moment.tz('America/Sao_Paulo').format('DD'))) return reply("Volte mais tarde...")
if(!JSON.stringify(akinator).includes(from) && akinator.length > 0 && Number(akinator[0].dia) !== Number(moment.tz('America/Sao_Paulo').format('DD'))) {
jogo.now = true
akinator.splice(0, 1)
fs.writeFileSync("./armor/jogo/akinator.json", JSON.stringify(akinator, null, 2))
}
if(!JSON.stringify(akinator).includes(from)) {
reply(`Aten√ß√£o ${pushname}, irei iniciar o jogo do akinator... Responda com "Sim", "N√£o", "N√£o sei", "Provavelmente Sim" ou "Provavelmente n√£o" (sem as aspas)`)
dateAKI = moment.tz('America/Sao_Paulo').format('DD')
var region = 'pt'
var childMode = false;
var proxy = undefined;
let startAki = async () => {
global.aki = new Aki({ region, childMode, proxy });
await aki.start()
}
await startAki()
jogo.now = false
jogo.jogador = sender
akinator.push({id: from, jogador: sender, finish: 0, dia: dateAKI})
fs.writeFileSync("./armor/jogo/akinator.json", JSON.stringify(akinator, null, 2))
reply(`*‚è§ÕüÕûÕüÕû Í¶øAKINATOR* üßôüèº‚Äç‚ôÇÔ∏è
üîÆ‚É§ ${aki.question}`)
} else return mention(`@${akinator[akinator.map(i => i.id).indexOf(from)].jogador.split('@')[0]} j√° iniciou a partida, espere ele/a terminar...`)
break

case 'resetaki':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(akinator).includes(from) && !isOwner) return reply("Nenhuma sess√£o em andamento... üßôüèº‚Äç‚ôÇÔ∏è")
if(akinator.length <= 0) return reply("Nenhuma sess√£o em andamento... üßôüèº‚Äç‚ôÇÔ∏è")
matheuzinho = isOwner ? 0 : akinator.map(i => i.id).indexOf(from)
if(akinator[matheuzinho].jogador == sender || isGroupAdmins || isOwner) {
jogo.now = true
akinator.splice(matheuzinho, 1)
fs.writeFileSync("./armor/jogo/akinator.json", JSON.stringify(akinator, null, 2))
reply("üßôüèº‚Äç‚ôÇÔ∏è Akinator resetado com sucesso ‚ú®")
} else {
reply("[ ‚ùó ] Somente admins do grupo ou a pessoa que iniciou o jogo podem finalizar o akinator ‚ùå")
}
break

case 'infowa':
datewa = sendHours('MM');
datetime = `${(Number(datewa) - 3) + 12}`
infowa2 = `${tempo} ${pushname} ${tempo_emoji}

Aproximadamente ${datetime} meses atr√°s, Mark Zuckerberg, dono do whatsapp, atualizou o mesmo, quebrando assim, a nossa conex√£o com a Baileys.

A Baileys √© uma web criptopasta em que todos os bot de whatsapp puxam, de forma hiperb√≥lica, in√∫meras informa√ß√µes para seu funcionamento... Desde ent√£o, as listas e bot√µes pararam de funcionar. Com um esfor√ßo incans√°vel, n√≥s, criadores e desenvolvedores, conseguimos uma baileys, em que os bot√µes estavam funcionando perfeitamente em grupos, e as listas no privado. Bem, parece que at√© isso foi retirado de n√≥s...

Novamente houve uma atualiza√ß√£o na conex√£o do whatsapp, e dessa vez, o bot√µes foram realmente de base...

O bot est√° funcionando em perfeito estado, em rela√ß√£o a outros comandos... Apenas os bot√µes e listas foram desativados, devido n√£o estarem funcionando.

Caso haja ainda algum bug que necessite de conserto, use o comando ${prefix}bug para reportar o mesmo... Se houver solu√ß√£o, irei imediatamente arrumar. Caso contr√°rio, s√≥ podemos esperar que seja descoberto ou criada uma nova conex√£o para os bot, pq a Baileys, n√£o funciona mais.

Conto com a sua compreens√£o ${pushname}... Repasse para a maioria de usu√°rios de bot de whatsapp que conseguir, pois isso √© um problema global. N√£o √© problema no Black, nem no bot que voc√™ usa, nem na hospedagem... √â problema no pr√≥prio whatsapp, e como todos os bot utilizam a mesma conex√£o *(por ser a √∫nica que existe)*, todos est√£o sofrendo com esse problema.

Nosso grupo tbm est√° dispon√≠vel no comando ${prefix}blackgp. L√°, voc√™ tem um contato maior com v√°rios usu√°rios, obtendo maiores informa√ß√µes assim tbm.

‚úÖ *Ass:* ${NickDono}
„Ö§‚úçüèΩ *BY:* ${NomeDoBot}`
reply(infowa2)
break

case 'dado':
if(!isModobn) {
setTimeout(() => {reagir(from, "‚ùå")}, 300)
return reply(enviar.msg.modobz)
} else {
setTimeout(() => {reagir(from, "üé≤")}, 300)
reply(`‚ñß‚ÉØ‚ÉüùöÇùöòùöõùöùùöéùöäùöóùöçùöò ùô≥ùöäùöçùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
dadoale = Math.floor(Math.random() * 5) + 1
enviarfigu(`./database/figu/${dadoale}.webp`)
}
break

case 'caraoucoroa':
setTimeout(() => {reagir(from, "ü™ô")}, 300)
if(!isModobn) {
setTimeout(() => {reagir(from, "‚ùå")}, 300)
return reply(enviar.msg.modobz)
} else {
enviarfigu(`./database/figu/caraoucoroa.webp`)
setTimeout(async() => {
cr1 = [`cara üòé`, `coroa üëë`]
txtcr = `‡≥à·çùÕ°ÕúùôàùôäùôÄùòøùòº ùôéùôäùôçùôèùôÄùòºùòøùòº:
> ${cr1[Math.floor(Math.random()*cr1.length)]}`
reply(txtcr)
}, 1000)
}
break

case 'jogodavelha':
if(!isGroup) return reply(enviar.msg.grupo)
if(!menc_jid2) return reply("Marque junto com o comando, o @ do usu√°rio que deseja desafiar..")
if(menc_os2.includes(botNumber)) return reply("Estou aqui para ser mediador e n√£o jogador...")
joguinhodavelhajs.push(sender)
fs.writeFileSync('./database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.push(from)
fs.writeFileSync('./database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
if(fs.existsSync(`./armor/tictactoe/db/${from}.json`)) {
const boardnow = setGame(`${from}`);
const matrix = boardnow._matrix;
const chatMove = `*üéÆ·èÄÃ∏·é™Ã∏·é∑Ã∏·é¨Ã∏ ·é†Ã∏·é™Ã∏ ·èôÃ∏·é¨Ã∏·èûÃ∏·éªÃ∏·é™Ã∏üïπÔ∏è*
     
[‚ùó] Algu√©m est√° jogando no momento...\n\n@${boardnow.X} VS @${boardnow.O}
     
‚ùå : @${boardnow.X}
‚≠ï : @${boardnow.O}
     
 Sua vez : @${boardnow.turn == "X" ? boardnow.X : boardnow.O}
     
${matrix[0][0]}  ${matrix[0][1]}  ${matrix[0][2]}
${matrix[1][0]}  ${matrix[1][1]}  ${matrix[1][2]}
${matrix[2][0]}  ${matrix[2][1]}  ${matrix[2][2]}
`;
blackmd.sendMessage(from, {text: chatMove}, {quoted: seloctt,
mentions: [
boardnow.X + "@s.whatsapp.net",
boardnow.O + "@s.whatsapp.net",
]});
return;
}
if(argss.length === 1)
return reply(`*‚üÖ‚ùó‚üÜ Jogue com Alguem!!!!*
*para inicar a partida : ${prefix + command} @membro do gp*`);
const boardnow = setGame(`${from}`);
console.log(`Start No jogodavelha ${boardnow.session}`);
boardnow.status = false;
boardnow.X = sender.replace("@s.whatsapp.net", "");
boardnow.O = argss[1].replace("@", "");
var blabord = [`${boardnow.X}`, `${boardnow.O}`]
fs.writeFileSync(`./armor/tictactoe/db/${from}.json`,
JSON.stringify(boardnow, null, 2)
);
const strChat = `*„Äéüìå·é¨’è·è¢·é¨·é°·é™Œù·é†œ¥ œ¥ œ¥·è¢œ¥Œù·é¨ŒùÕ≤·é¨‚öîÔ∏è„Äè*
     
@${sender.replace("@s.whatsapp.net",
"")} _est√° te desafiando para uma partida de jogo da velha..._
_[ ${argss[1]} ] Use *„ÄéS„Äè* para aceitar ou *„ÄéN„Äè* para n√£o aceitar..._\n\nEm caso de problemas, marque algum administrador para resetar o jogo com o comando ${prefix}rv`;
b = [sender, menc_jid]
mentions(strChat, b, true)
break

case 'resetarvelha':
case 'resetavelha':  
case 'resetarv':
case 'resetav': 
case 'resetvelha':
case 'rv': 
if(!isJoguin && !isGroupAdmins) return reply(`Fale com quem iniciou o jogo, s√≥ ele pode resetar, ou ent√£o algum ADM`)
if(fs.existsSync("./armor/tictactoe/db/" + from + ".json")) {
DLT_FL("./armor/tictactoe/db/" + from + ".json");
reply(`Jogo da velha resetado com sucesso nesse grupo!`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
} else {
reply(`N√£o a nenhuma sess√£o em andamento...`);
}
break

case 'ppt':
if(args.length < 1) return reply(`Voc√™ deve digitar ${prefix}ppt pedra, ${prefix}ppt papel ou ${prefix}ppt tesoura`)
ppt = ["pedra", "papel", "tesoura"]
ppy = ppt[Math.floor(Math.random() * ppt.length)]
ppg = Math.floor(Math.random() * 1) + 10
pptb = ppy
if((pptb == "pedra" && args == "papel") ||
(pptb == "papel" && args == "tesoura") ||
(pptb == "tesoura" && args == "pedra")) {
var vit = "vitoria"
} else if((pptb == "pedra" && args == "tesoura") ||
(pptb == "papel" && args == "pedra") ||
(pptb == "tesoura" && args == "papel")) {
var vit = "derrota"
} else if((pptb == "pedra" && args == "pedra") ||
(pptb == "papel" && args == "papel") ||
(pptb == "tesoura" && args == "tesoura")) {
var vit = "empate"
} else if(vit = "undefined") {
return reply(`Voc√™ deve digitar ${prefix}ppt pedra, ${prefix}ppt papel ou ${prefix}ppt tesoura`)
}
if(vit == "vitoria") {
var tes = "*Vit√≥ria do jogador* üôáüèª‚Äç‚ôÇÔ∏è"
}
if(vit == "derrota") {
var tes = "*A vit√≥ria √© do BOT* ü§ñ"
}
if(vit == "empate") {
var tes = "*O jogo terminou em empate* ü§úüèΩü§õüèΩ"
}
reply(`${NomeDoBot} *jogou:*
> ${pptb}

${pushname} *jogou:*
> ${args}`)
setTimeout(async() => {
reply(tes)
}, 2000)
break

case 'cassino':
inicio_frutas = ['üçä', 'üçí', 'üçê', 'üîî', 'üçá', 'üçå']
total_frutas = []
for(a of inicio_frutas) {
  for(b = 0; b < inicio_frutas.length; b++) {
    for(c = 0; c < inicio_frutas.length; c++) {
      total_frutas.push(`${a}/${inicio_frutas[b]}/${inicio_frutas[c]}`)
    }
  }
}
random_frutas = total_frutas[alerandom(total_frutas.length)]
var [ft1, ft2, ft3] = random_frutas.split("/")
if(ft1 == ft2 && ft2 == ft3) { victory = "VOC√ä GANHOU !!!"
addCoinsInVirtualBalance(sender, 0.1)
} else { victory = "„Ö§Voc√™ perdeu..." }
const cassino = (result, vic) => {return `
„Ö§„Ö§„Ö§‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚ù™üé∞‚ù´‚îÅ‚îÅ‚îÅ‚îÅ\t\t\t\t
„Ö§„Ö§„Ö§‚î£‚ñ∫ ${result}‚óÑ‚îõ
„Ö§„Ö§„Ö§‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚ù™üí∞‚ù´‚îÅ‚îÅ‚îÅ‚îÅ

„Ö§„Ö§„Ö§  ${vic ? `*`+vic+`*` : ``}`}
let { key } = await blackmd.sendMessage(from, {text: cassino(`‚ùó : ‚ùó : ‚ùó`)}, {quoted: info})
await sleep(700)
await blackmd.sendMessage(from, {text: cassino(`‚ùì : ‚ùì : ‚ùì`), edit: key}, {quoted: info})
await sleep(700)
await blackmd.sendMessage(from, {text: cassino(`${ft1} : ‚ùì : ‚ùì`), edit: key}, {quoted: info})
await sleep(700)
await blackmd.sendMessage(from, {text: cassino(`${ft1} : ${ft2} : ‚ùì`), edit: key}, {quoted: info})
await sleep(700)
await blackmd.sendMessage(from, {text: cassino(`${ft1} : ${ft2} : ${ft3}`), edit: key}, {quoted: info})
await sleep(700)
await blackmd.sendMessage(from, {text: cassino(`${ft1} : ${ft2} : ${ft3}`, victory), edit: key}, {quoted: info})
break

case 'eununca':
reagir(from, "‚ù§Ô∏è‚Äçüî•")
if(!isModobn) return reply(enviar.msg.modobz)
const euja1 = ['Eu nunk fiquei com dois/duas numa festa', 'Eu nunk meti chifre no namorado (a)', 'Eu nunk fui corno', 'Eu nunk roubei nada do supermercado', 'Eu nunk beijei algu√©m do mesmo sexo que eu', 'Eu nunk parei algu√©m na rua achando que era um conhecido', 'Eu nunk joguei fora a comida e fiz que comi', 'Eu nunk fuji de casa', 'Eu nunk fiz coisas +18 em casa', 'Eu nunk fumei ou usei drogas']
euja2 = euja1[Math.floor(Math.random() * (euja1.length))]
eununcatxt = `*_Sorteando..._*

> _"${euja2}"_`
sendAsPoll(from, eununcatxt, ["Eu j√° üåö", "Eu nunca üåù"])
break

//==(AUDIOS/DE-MUSICA/ZOUEIRA/ETC..)===\\

case 'bot': case 'boot':
setTimeout(() => {reagir(from, "üò°")}, 300)
const soundft = fs.readFileSync('./database/audios/qsaco.m4a')
blackmd.sendMessage(from, {audio: soundft, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
break

case 'infobot':
setTimeout(() => {reagir(from, "üëª")}, 300)
const cmdoo = fs.readFileSync('./database/audios/infobot.m4a')
blackmd.sendMessage(from, {audio: cmdoo, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
break 

//=======================================\\


//=====(ALTERADOR-DE-AUDIO/VIDEO)=======\\

case 'videocontrario':
case 'reversemp4':
if((isMedia && info.message.videoMessage || !isQuotedImage) && !q.length <= 1) { 
reply(enviar.espere)
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -vf reverse -af areverse ${ran}`, (err) => {
DLT_FL(media)
if(err) return reply(`Err: ${err}`)
buffer453 = fs.readFileSync(ran)
blackmd.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: seloctt})
DLT_FL(ran)
})
} else {
reply("Marque um v√≠deo..")
}
break 

case 'videolento':
case 'slowvid':  
if((isMedia && info.message.videoMessage || !isQuotedImage) && !q.length <= 1) {
reply(enviar.espere) 
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -filter_complex "[0:v]setpts=2*PTS[v];[0:a]atempo=0.5[a]" -map "[v]" -map "[a]" ${ran}`, (err) => {
DLT_FL(media)
if(err) return reply(`Err: ${err}`)
buffer453 = fs.readFileSync(ran)
blackmd.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: seloctt })
DLT_FL(ran)
})
} else {
reply("Marque um v√≠deo..")
}
break

case 'videorapido':
case 'fastvid':  
if((isMedia && info.message.videoMessage || !isQuotedImage) && !q.length <= 1) {
reply(enviar.espere)
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -filter_complex "[0:v]setpts=0.5*PTS[v];[0:a]atempo=2[a]" -map "[v]" -map "[a]" ${ran}`, (err) => {
DLT_FL(media)
if(err) return reply(`Err: ${err}`)
buffer453 = fs.readFileSync(ran)
blackmd.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: seloctt })
DLT_FL(ran)
})	
} else {
reply("Marque o v√≠deo..")
}
break

case 'grave2':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=1.6,asetrate=22100" ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o √°udio..")
}
break

case 'grave':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=44100" ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o √°udio..")
}
break

case 'adolesc':
case 'vozmenino':  
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a atempo=1.06,asetrate=44100*1.25 ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o √°udio..")
}
break  

case 'tomp3':
case 'viraraudio':
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
if((isMedia && !info.message.imageMessage || isQuotedVideo)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.videoMessage
reply(`‚ù™‚àòÃ•‚Éü‚∏Ω‚Éüùô≤ùöòùöóùöüùöéùöõùöùùöéùöóùöçùöò ùô¥ùöñ √Åùöûùöçùöíùöò‚àòÃ•‚Éü‡ß¥‚ñ∏`)
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane 
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} ${ran}`, (err) => { 
DLT_FL(media)
if(err) return reply('‚ùå Falha ao converter v√≠deo para mp3 ‚ùå')
buffer = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: buffer, mimetype: 'audio/mp4'}, {quoted: seloctt})
DLT_FL(ran)
})
} else {
reply("Marque o v√≠deo para transformar em √°udio por favor..")
}
break

case 'shazam': {
    if (!isVip) return reply(enviar.msg.vip);
    if (!isQuotedAudio) return reply('‚ö†Ô∏è Envie o √°udio para eu detectar o nome da m√∫sica!');

    try {
        let music = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage, 'audio');
        let mime = info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage.mimetype;
        let m = mime.split('/')[1];
        let filePath = `./armor/assets/${sender}.${m}`;
        fs.writeFileSync(filePath, music);
        let base64 = fs.readFileSync(filePath, { encoding: "base64" });

        // Detectar m√∫sica com a fun√ß√£o arcloud
        let resultado = await arcloud(base64);

        if (!resultado || !resultado[0] || !resultado[0].titulo) {
            DLT_FL(filePath);
            return reply('Desculpe, n√£o consegui identificar a m√∫sica. Por favor, tente novamente!');
        }

        // Nova pesquisa com o t√≠tulo retornado pelo arcloud
        let data = await fetchJson(`https://world-ecletix.onrender.com/api/pesquisayt?query=${encodeURIComponent(resultado[0].titulo)}`);

        if (!data || !data.formattedVideos || data.formattedVideos.length === 0) {
            DLT_FL(filePath);
            return reply("Desculpe, n√£o consegui encontrar a m√∫sica.");
        }

        const firstResult = data.formattedVideos[0];
        let N_E = " N√£o encontrado.";
        let txt = `
        üéôÔ∏è‚É§ T√≠tulo: ${firstResult.title || N_E}
        ‚è∞‚É§ Tempo: ${firstResult.duration || N_E}
        üìπ‚É§ Canal: ${firstResult.channel || N_E}
        üëÅÔ∏è‚É§ Visualiza√ß√µes: ${firstResult.views || N_E}

        ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ† 100%

        Se desejar baixar o v√≠deo, use ${prefix}play_video ${firstResult.link.trim()}
        `;

        reagir(from, `‚ö°`);
        blackmd.sendMessage(from, {
            image: { url: firstResult.thumbnail || logoslink?.logo },
            caption: txt
        }, { quoted: info });

        // Enviar m√∫sica como nota de voz
        blackmd.sendMessage(from, {
            audio: {
                url: `https://world-ecletix.onrender.com/api/musica?name=${encodeURIComponent(firstResult.title)}`
            },
            mimetype: "audio/mpeg",
            fileName: firstResult.title || "shazam.mp3",
            ptt: true
        }, { quoted: info });

        DLT_FL(filePath);
    } catch (e) {
        console.log(e);
        return reply("Erro ao identificar ou buscar a m√∫sica.");
    }
}
break;

case 'bass3':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=20:width_type=o:width=2:g=15 ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o √°udio..")
}
break

case 'bass': 
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=20:width_type=o:width=2:g=15 ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o √°udio..")
}
break

case 'bass2': 
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=94:width_type=o:width=2:g=30 ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o √°udio..")
}
break

case 'estourar': 
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=90:width_type=o:width=2:g=30 ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o √°udio..")
}
break

case 'fast':
case 'audiorapido':  
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=95100" ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o √°udio...")
}
break

case 'esquilo':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.7,asetrate=65100" ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o √°udio...")
}
break

case 'audiolento': 
case 'slow':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=44100" ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o √°udio..")
}
break

//==========(EFEITOS-MARCAR)==========\\
// CANVA // CANVAS // EDI√á√ÉO DE FOTOS
case 'togif':
if(!isQuotedSticker) return reply('*[ ‚ùó ] Marque a figurinha animada!*')
if(info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.stickerMessage && info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.stickerMessage?.isAnimated) {
let media = await downloadAndSaveMediaMessage(info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.stickerMessage)
try {
reply('[‚ùó] convertendo em gif, aguarde ‚ô®')
a = await webp_mp4(media)
mp4 = await getBuffer(a.result)
blackmd.sendMessage(from, {video: mp4, gifPlayback: true, filename: `stick.gif`}, {quoted: info})
} catch(e) {
console.log(e)
reply('Erro ao converter para gif')
}
await fs.unlinkSync(media)
} else {
reply('*[ ‚ùó ] Marque a figurinha animada!*')
}
break

case 'cartonizar': case 'cartoon':
try { 
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
link = await upload(owgi)
reply(`[‚ùó] Desenhando pixel a pixel, isso pode demorar üí¢`)
blackmd.sendMessage(from, {image: {url:`http://br3.bronxyshost.com.br:4017/imagem/cartoon?img=${link}&apitoken=Yuta-Channel`}}, {quoted: info}).catch(e => {
return reply("Erro..")
})
} else {
reply('Marque uma imagem com rosto vis√≠vel!') 
}
} catch (e) {
reply('ERROR!!')
}
break

case 'toanime': case 'tohd': case 'tozombie':
if(!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
link = await upload(owgi)
reply(`[‚ùó] Desenhando pixel a pixel, isso pode demorar üí¢`)
ABC = await fetchJson(`https://blacksystemofc.com.br/api/ia/${command}?link=${link}&apikey=black`)
sendImage(from, ABC.resultado.image_data).catch(e => {
return reply("Erro ao converter a imagem")
})
} else {
reply('Marque uma imagem para eu atribuir o efeito')
}
break

case 'perfilzap':
    try {
        if (!q.includes('/')) {
            return reply('‚öôÔ∏è Use o formato: .perfilzap Nome/N√∫mero/Bio/Horas marcando a foto.');
        }

        let imageUrl;
        
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            imageUrl = await upload(owgi); // Gera o link da imagem marcada
        } else {
            return reply('‚öôÔ∏è Voc√™ precisa marcar uma foto para usar nesta fun√ß√£o.');
        }

        const [nome, numero, bio, horas] = q.split('/');

        reply(`‚úçÔ∏è Criando seu perfil zap personalizado, aguarde...`);

        const perfilZapApi = `https://kamuiapi.shop/api/canvas/perfilzap?nome=${encodeURIComponent(nome)}&numero=${encodeURIComponent(numero)}&bio=${encodeURIComponent(bio)}&horas=${encodeURIComponent(horas)}&perfil=${encodeURIComponent(imageUrl)}&apikey=YT8q4bUNXV`;

        const response = await axios.get(perfilZapApi, { responseType: 'arraybuffer' });
        const resultImage = Buffer.from(response.data, 'binary');

        await blackmd.sendMessage(from, {
            image: resultImage,
            caption: `‚úÖ Aqui est√° seu perfil zap personalizado!`,
        }, { quoted: info });

    } catch (error) {
        console.error('Erro no .perfilzap:', error);
        reply('üö® Ocorreu um erro ao tentar gerar seu perfil zap.');
    }
    break;
case 'Vasco-edit':
case 'vasco-edit':
    try {
        if (!q.includes('/')) {
            return reply('‚öôÔ∏è Use o formato: .vasco-edit T√≠tulo/Nome marcando a foto.');
        }

        let imageUrl;
        
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            imageUrl = await upload(owgi); // Aqui ele gera o link da foto marcada
        } else {
            return reply('‚öôÔ∏è Voc√™ precisa marcar uma foto para usar nesta fun√ß√£o.');
        }

        const [titulo, nome] = q.split('/');

        reply(`‚úçÔ∏è Processando a imagem do ${nome}, aguarde...`);

        const vascoApi = `https://kamuiapi.shop/api/canvas/vasco?titulo1=${encodeURIComponent(titulo)}&nome=${encodeURIComponent(nome)}&perfil=${encodeURIComponent(imageUrl)}&apikey=YT8q4bUNXV`;

        const response = await axios.get(vascoApi, { responseType: 'arraybuffer' });
        const resultImage = Buffer.from(response.data, 'binary');

        await blackmd.sendMessage(from, {
            image: resultImage,
            caption: `‚úÖ Aqui est√° a imagem personalizada do ${nome}!`,
        }, { quoted: info });

    } catch (error) {
        console.error('Erro no .vasco-edit:', error);
        reply('üö® Ocorreu um erro ao tentar gerar a imagem do Vasco.');
    }
    break;
    case 'editvermelha':
case 'editbranca':
case 'editroxo':
    try {
        if (!q) {
            return reply('‚öôÔ∏è Envie o nome que deseja usar. Exemplo: .editvermelha Dantes');
        }

        let imagemFixa;
        if (command === 'editvermelha') {
            imagemFixa = 'https://telegra.ph/file/d3f32c55c57b738806acf.png';
        } else if (command === 'editbranca') {
            imagemFixa = 'https://i.pinimg.com/564x/96/70/98/967098685058d9b14f5b715fd43e88d1.jpg';
        } else if (command === 'editroxo') {
            imagemFixa = 'https://telegra.ph/file/edd98b4aefa226c05e60d.jpg';
        }

        const urlApi = `https://kamuiapi.shop/api/canvas/${command}?nick=${encodeURIComponent(q)}&img=${encodeURIComponent(imagemFixa)}&apikey=YT8q4bUNXV`;

        const { data } = await axios.get(urlApi, { responseType: 'arraybuffer' });

        await blackmd.sendMessage(from, {
            image: Buffer.from(data, 'binary'),
            caption: `‚úÖ Aqui est√° sua imagem personalizada!`,
        }, { quoted: info });
    } catch (error) {
        console.error('Erro ao gerar imagem edit:', error);
        reply('üö® Ocorreu um erro ao gerar a imagem.');
    }
    break;

case 'interro':
case 'brasil':    
case 'adorartv':
case 'lolifofaa':
case 'lolifofa':
case 'lolinopc':
case 'carinho':
    try {
        let imageUrl;

        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            imageUrl = await upload(owgi); // gera link da imagem
        } else {
            return reply('‚öôÔ∏è Marque uma foto para usar.');
        }

        reply('üîÑ Processando sua imagem, aguarde...');

        const endpoint = command; // pega o nome do comando atual (.adorartv, .lolifofaa, etc)
        const apiUrl = `https://kamuiapi.shop/api/canvas/${endpoint}?img=${encodeURIComponent(imageUrl)}&apikey=YT8q4bUNXV`;

        const response = await axios.get(apiUrl, { responseType: 'arraybuffer' });
        const mediaBuffer = Buffer.from(response.data, 'binary');

        const mediaType = endpoint === 'carinho' ? { video: mediaBuffer } : { image: mediaBuffer };

        await blackmd.sendMessage(from, {
            ...mediaType,
        }, { quoted: info });

    } catch (error) {
        console.error(`Erro no .${command}:`, error);
        reply('üö® Erro ao tentar gerar a imagem.');
    }
    break;    
case 'affect': case 'comunismo': case 'mms': case 'bobross': case 'bolsonaro': case 'blur': case 'beautiful': case 'circle': case 'del': case 'invert': case 'facepalm': case 'rip': case 'wasted': case 'wanted': case 'trash': case 'sepia': case 'pixelate': case 'lgbt':
if(!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
try {
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
link = await upload(owgi)
reply(`[‚ùó] Desenhando pixel a pixel, isso pode demorar üí¢`)
sendImage(from, `https://blacksystemofc.com.br/api/canvas/${command}?link=${link}&apikey=black`)
} catch {
return reply("Erro ao converter a imagem")
}
} else {
reply('Marque uma imagem para eu atribuir o efeito')
}
break

//=======(FIM-EFEITOS-MARCAR)=========\\

default:

if(isGroup && isBotGroupAdmins && !isGroupAdmins) {
if(isAntiCtt || Antiloc || isAnticatalogo) {
if(type === 'contactMessage' || type === 'contactsArrayMessage' || type === 'locationMessage' || type === 'productMessage') {
if(isGroupAdmins) return blackmd.sendMessage(from, {text: `Uma dessas op√ß√µes est√£o ativada, mas por voc√™ ser ADM, n√£o ser√° removido(a) _(ANTI CONTATO - ANTI CATALOGO - ANTI LOCALIZA√á√ÉO)`}, {quoted: seloctt})
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
clear = `üóë${"\n".repeat(255)}üóëÔ∏è\n‚ù≤‚ùó‚ù≥ *L…™·¥ç·¥ò·¥á·¥¢·¥Ä ·¥Ö·¥á C ú·¥Ä·¥õ C·¥è…¥·¥Ñ ü·¥ú…™ÃÅ·¥Ö·¥Ä* ‚úÖ`
blackmd.sendMessage(from, {text: clear, contextInfo : { forwardingScore: 500, isForwarded:true}})
blackmd.sendMessage(from, {text: 'reporte aos adm o ocorrido ', mentions: groupAdmins})
}}}

if(isGroup && isAntiFlood && !isOwner && !isVip && !isnit && isBotGroupAdmins && !isGroupAdmins && !isBot) { 
if(isLimitec == null){
var limitefl = limitefll.limitefl
} else {
var limitefl = isLimitec
}
if(budy.length >= limitefl){
setTimeout( () => {
return reply('Muitas Caracteres enviadas, isto √© contra as normas do grupo, por precau√ß√£o, eu irei remover.')
console.log(colors.red('Deram Spam de caracteres..'))
}, 100)
setTimeout(async () => {
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return  
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}
}

switch(testat){
}

const EnvAudio_SMP = async (direcao, nome1, nome2, nome3, nome4, nome5) => {
bla = [nome1, nome2, nome3, nome4, nome5]
for ( i of bla) {
if(i == undefined) return  
if(messagesC.includes(i)) {
blackmd.sendMessage(from, {audio: {url: direcao}, mimetype: "audio/mp4", ptt:true})
}}}

const EnvAudio2_SMP = async (direcao, nome1, nome2, nome3, nome4, nome5) => {
bla = [nome1, nome2, nome3, nome4, nome5]
for ( i of bla) {
if(i == undefined) return  
if(messagesC.includes(i)) {
blackmd.sendMessage(from, {audio: {url: direcao}, mimetype: "audio/mp4", ptt:true})
}}}

const EnvTXT_SMP = async (texto, nome1, nome2, nome3, nome4, nome5) => {
bla = [nome1, nome2, nome3, nome4, nome5]
for ( i of bla) {
if(i == undefined) return  
if(messagesC.includes(i)) {
blackmd.sendMessage(from, {text: texto})
}}}

const EnvAudio2_GTTS = async (lingua, texto, txt1, txt2, txt3, txt4, txt5) => {
bla = [txt1, txt2, txt3, txt4, txt5]
for ( i of bla) {
if(i == undefined) return
if(budy2.includes(i)) {
var gtt = require('./armor/funcoes/gtts')(lingua)
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
gtt.save(ranm, texto, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
DLT_FL(ranm)
buffer = fs.readFileSync(rano)
blackmd.sendMessage(from, {audio: buffer, ptt:true}, {quoted: seloctt})
DLT_FL(rano)
})
})
}}}

var hora_sla = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

EnvAudio2_GTTS("pt", `S√£o ${realtime()}`, "que horas sao?")

/*EnvTXT_SMP(prefix, "prefixo")*/

if(budy2.includes("luan") && !isOwner){
matheustxt = [`T√° falando do meu programador ? ü´µüèΩü§®`, `O que voc√™ quer com meu dono ? üî™`, `O que voc√™ quer com meu programador ? üò°`, `Vou falar pro meu dono que voc√™ anda falando dele por a√≠ üòêüëçüèΩ`]
sendButton(from, {text: matheustxt[Math.floor(Math.random()*matheustxt.length)], footer: NomeDoBot}, blackmd, sender, [{type: `cmd`, text: `üëë ùôàùôÄùôê ùòøùôäùôâùôä üëë`, command: `${prefix}dono`}], seloctt)
await sleep(500)
blackmd.sendMessage(obrigadoEXT.idprivategp, {text: `${pushname} tava falando de tu ${isGroup ? `no grupo ${groupName} üòêüëçüèΩ` : `no meu PV...`}`}, {quoted: info})
}

if(budy2 === `abrir grupo` && isGroup && isGroupAdmins && isBotGroupAdmins && groupMetadata.announce == true) {
setTimeout(() => {reagir(from, "‚úÖ")}, 300)
blackmd.groupSettingUpdate(from, 'not_announcement')
reply(`‚úÖ *${tempo} √† todos... O grupo foi aberto novamente*`)
}

if(budy2 === `fechar grupo` && isGroup && isGroupAdmins && isBotGroupAdmins && groupMetadata.announce == false) {
setTimeout(() => {reagir(from, "üö´")}, 300)
blackmd.groupSettingUpdate(from, 'announcement')
reply(`üö´ *Grupo fechado... As suas ordens vossa senhoria*`)
}

if(budy2 === 'prefixo' && !isBanchat) {
reagir(from, "ü•∞")
reply(`*Prefixo de comandos usado„Äò ${prefix} „Äô ‚ù§Ô∏è‚Äçüî•*`)
}

if(!isNaN(budy2) && isJsonIncludes(nicks, sender)) {
  AB = nicks.map(i => i.id).indexOf(sender)
  caixa = []
  for(i of nicks[AB].titulos) {
    if(Number(budy2) === Number(i.nmr)) caixa.push(i.txt)
  }
  if(caixa.length > 0) {
    blackmd.sendMessage(from, {text: caixa[0], contextInfo: {isForwarded: true, forwardingScore: 1}}, {quoted: seloctt})
    if(nicks[AB].quant > 1) {
      nicks[AB].quant -= 1
      saveJSON(nicks, "./basededados/nicks.json")
    } else {
      nicks.splice(AB, 1)
      saveJSON(nicks, "./basededados/nicks.json")
    }
  }
}

if(isJsonIncludes(waitFriendZone, sender)) {
  mini = rmLetras(budy2)
  if(isGroup && isGroupOfPedidoFriendZone(sender, from)) {
    if(isWaitUsuFZ_namoro(sender)) {
      if(mini == "sim" || mini == "s") {
        aceitarPedidoDeNamoro(sender)
        return sendButton(from, {text: `üíû Felicita√ß√µes @${getDBFZuser(sender).usu2}, parece que o @${sender.split("@")[0]} aceitou seu pedido de namoro... Seus dados podem ser acessados no comando ${prefix}dupla ü•∞`, mentions: [identArroba(getDBFZuser(sender).usu2), sender], footer: NomeDoBot}, blackmd, sender, [{type: `cmd`, text: `ùôàùôÑùôâùôÉùòº ùòøùôêùôãùôáùòº üíò`, command: prefix+`dupla`}], seloctt)
      }
      if(mini == "nao" || mini == "n") {
        A1 = waitFriendZone.map(i => i.id).indexOf(sender)
        mention(`üòî Sinto muito @${waitFriendZone[A1].pedido}, parece que o usu ${pushname} recusou seu pedido de namoro...`)
        return recusarPedidoDeNamoro(sender)
      }
    }
    if(isWaitUsuFZ_casamento(sender)) {
      if(mini == "sim" || mini == "s") {
        aceitarPedidoDeCasamento(sender)
        return sendButton(from, {text: `üíç Felicita√ß√µes @${getDBFZuser(sender).usu2}, parece que o @${sender.split("@")[0]} aceitou seu pedido de casamento... Seus dados foram atualizados no comando ${prefix}dupla üëª`, mentions: [identArroba(getDBFZuser(sender).usu2), sender], footer: NomeDoBot}, blackmd, sender, [{type: `cmd`, text: `ùôàùôÑùôâùôÉùòº ùòøùôêùôãùôáùòº üíû`, command: prefix+`dupla`}], seloctt)
      }
      if(mini == "nao" || mini == "n") {
        recusarPedidoDeCasamento(sender)
        mention(`üò™ Sinto muito @${getDBFZuser(sender).usu2}, parece que o usu @${sender.split("@")[0]} recusou seu pedido de casamento... Felizmente, voc√™s ainda s√£o um casal de namorados ü•∞`)
      }
    }
  }
}

//fim das fun√ß√µes do namoro/casamento

//ads func
// FUN√á√ïES DE AUDIO E AUTORESPOSTA
if(isGroup && isGroupAdmins && existAdminAds(from, sender) && budy2.length > 1) {
  letra = budy2.toLowerCase().slice(budy2.length - 1, budy2.length)
  if((letra == "h" || letra == "m") && Number(budy2.split(letra)[0])) {
    gaa = getAdminAds(from, sender)
    isimg = gaa.imagem.length > 0 ? true : false
    addAds(from, sender, budy2)
    mention(`*O an√∫ncio foi setato no grupo ${groupName} a cada ${budy2} pelo adm @${sender.split("@")[0]} com sucesso* ‚úÖ\n\n*Caso queira ativar a men√ß√£o do ads, use* ${prefix}ama ${gaa.id}`)
    setTimeout(() => {
      if(isimg) {
        blackmd.sendMessage(from, {image: {url: gaa.imagem[0]}, caption: gaa.text, contextInfo: {forwardingScore: 1, isForwarded: true}})
      } else {
        blackmd.sendMessage(from, {text: gaa.text, contextInfo: {forwardingScore: 1, isForwarded: true}})
      }
    }, 500)
  }
}
if (budy2.toLowerCase() === "oi") {
  console.log('[DEBUG] Mensagem "oi" detectada');
  const nome = pushname || "usu√°rio";
  const resp = [
    `${tempo} ${nome}, posso ajudar em algo?`,
    `${tempo} ${nome}, como voc√™ est√°?`,
    `${tempo} ${nome}, tudo bem por aqui?`
  ];
  reply(resp[alerandom(resp.length)]);
}

if (budy2.toLowerCase().startsWith('chatgpt') && args.length > 0) {
  reagir(from, "ü§ñ")
  try {
    const ABC = await fetchJson(`https://world-ecletix.onrender.com/api/chatgpt?texto=` + encodeURIComponent(q))
    reply(ABC.response) // Corrigido de resultado para resposta
  } catch (e) {
    reply('Erro')
  }
}

if(budy2 === "menu" && !isBanchat && !isBotoff) {
reagir(from, "üëÄ")
sendButton(from, {text: "Fl ‚úãüèΩüò≥ü§öüèΩ", footer: `${tempo} ${pushname}`}, blackmd, sender, [{type: `cmd`, text: `ùôàùôÄùôâùôê ‚ú®`, command: prefix+`menu`}], seloctt)
}

if(isAutorepo) {

if(audios.length > 0 && isGroup) {
  for(i of audios) {
    caminho = `./database/audios/save/${i.rm}`
    if(rmLetras(budy2).includes(i.txt) && fs.existsSync(caminho)) {
      if(i.emoji.length > 0) reagir(from, i.emoji)
      blackmd.sendMessage(from, {audio: {url: caminho}, mimetype: `audio/mpeg`, ptt: true}, {quoted: seloctt})
    }
  }
}


if (budy2.toLowerCase().startsWith('lady') && args.length > 0) {
  reagir(from, "ü§©")
  try {
    const ABC = await fetchJson(`https://world-ecletix.onrender.com/api/lady?texto=` + encodeURIComponent(q))
    reply(ABC.resposta) // Corrigido de resultado para resposta
  } catch (e) {
    reply('Erro')
  }
}
 
if(budy2.toLowerCase().startsWith('simi') && args.length > 0 && isGroup) {
setTimeout(() => {reagir(from, "üòç")}, 300)
try {
datasimi = await fetchJson(`https://api.simsimi.vn/v1/simtalk`, {method: 'POST',
headers: {'content-type': "application/x-www-form-urlencoded"},
body: "text="+q+"&lc=pt"})
const gtts = require('./armor/funcoes/gtts')(`pt`)
dtt = datasimi.message
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
gtts.save(ranm, dtt, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
blackmd.sendMessage(from, {audio: fs.readFileSync(ranm), ptt:true, mimetype: "audio/mp4"}, {quoted: seloctt}).catch(e => {
return reply("Erro..")
})
DLT_FL(ranm)
DLT_FL(rano)
})
})
} catch (e){
return reply("Nsei")
}
}

if(budy2.toLowerCase().startsWith('jeff') && args.length > 0 && isGroup) {
setTimeout(() => {reagir(from, "ü§ì")}, 300)
try {
datasimi = await fetchJson(`https://api.simsimi.vn/v1/simtalk`, {method: 'POST',
headers: {'content-type': "application/x-www-form-urlencoded"},
body: "text="+q+"&lc=pt"})
return reply(datasimi.message)
} catch (e){
return reply("Nsei")
}
}

if(budy2 === "bot") {
blars = ["Oi del√≠cia", "Oi amor da minha vida", "Oi princesa do meu cora√ß√£o"] 
blarnd = blars[Math.floor(Math.random() * blars.length)]
reply(blarnd)
}

if(budy2.includes("bot corno")){
if(info.key.fromMe) return 
reply("Corno √© voc√™, seu animal")
}

if(budy2 === ":)") {
blackmd.sendMessage(from, {text: `hihi ^-^`})
}

if(budy2.toLowerCase() === "f") {
blackmd.sendMessage(from, {text: '```Press F no chat```'})
}

if(budy2.toLowerCase() === "kkkk") {
reagir(from, "üòÇ")
}

if(budy2.toLowerCase() === "bot fdp") {
setTimeout(() => {reagir(from, "ü§¨")}, 300)
reply(`FILHO DA PUTA, VOU COMER SEU CU.¬†ARROMBADO DO CARALHO, SUA M√ÉE ALUGA A BUCETA PRA COMPRAR FIXADOR DE DENTADURA PRO SEU PAI, AQUELE CORNO BROXA.¬†CHIFRUDO, VOU ENFIAR MEU BRA√áO NO SEU √ÇNUS E ARRANCAR SEU INTESTINO. LOGO DEPOIS VOU ENFORCAR SUA AV√ì COM ELE, AQUELA VELHA BISCATE QUE FAZ CROCH√ä PRA FORA EM TROCA DE PICA.\n\nSUAS TIAS T√äM P√äLO NO DENTE E SUA IRM√É TEM POLENGUINHO NA VIRILHA, SEU GRANDE FILHO DA PR√äULA.¬†SUA M√ÉE DAVA LEITE DA CABE√áA DO PAU DO SEU PAI PRA VOC√ä BEBER, FILHO DA PUTA. ISSO MESMO, VOC√ä TOMAVA MAMADEIRA DE PORRA DESDE CRIAN√áA. POR ISSO √â O RETARDADO MENTAL QUE √â HOJE, SEU Z√â BEBEDOR DE SUCO DE CARALHO.\n\nO PADRE TE BENZEU COM √ÅGUA PARADA, HOJE VOC√ä SOFRE OS EFEITOS RETARDADOS DO AEDES AEGYPT QUE SE ALOJA DENTRO DO SEU OUVIDO, SEU MONTE DE ESTERCO.¬†SEU AV√î ARROMBADO USA FRALDA E TE OBRIGA A LIMPAR OS CAG√ïES DELE COM UMA COLHER DE DANONINHO, SEU CAPACHO DO CARALHO.\n\nSUA M√ÉE TE FAZ DORMIR COM O REX, AQUELE CHIUAUA FILHO DA PUTA E CHEIO DE SARNA. E DURANTE A MADRUGADA O REX ABUSA SEXUALMENTE DE VOC√ä,¬†AT√ìLA A PATINHA DENTRO DESSE SEU CU PEL√öDO, SEU FRACASSADO. LEMBRA DA JANDIRA, AQUELA SUA PRIMA MONOTETA ? POIS √â, ENFIEI UM TACO DE BASEBALL NO CU DELA. A M√ÉE DELA DEU O FLAGRANTE NA GENTE E AO INV√âS DE FICAR BRAVA, PEDIU O TACO EMPRESTADO. VADIA DO CARALHO ESSA SUA TIA, S√ì PODE TER APRENDIDO COM SUA M√ÉE, AQUELA BISCATE.\n\nQUE ALI√ÅS, CONTINUA CHUPANDO O CARALHO DO Z√â DO PACOTE, O TRAFICANTE QUE MORA A√ç DO LADO DA SUA CASA DE BARRO, SEU FILHO DUMA MACONHEIRA VAGABUNDA.¬†O CABELO DA SUA M√ÉE √â T√ÉO RUIM QUE ELA FAZ CHAPINHA NOS P√äLOS DO SOVACO E USA UM DESODORANTE COM CONDICIONADOR CAPILAR, AQUELA VELHA CARCOMIDA DESGRA√áADA.\n\nVOC√ä FOI ENCONTRADO NO LIXO, SEU MERDA. E AT√â HOJE SUA M√ÉE PEDE DESCULPAS PRA DEUS PELO PEDA√áO DE MERDA QUE PARIU. AT√â TE EMBALOU NUM SACO PRETO ANTES DE JOGAR NO LIXO, MAS VOC√ä √â T√ÉO HORR√çVEL QUE UM MENDIGO TE ENCONTROU E QUASE TE COMEU ACHANDO QUE TU ERA UMA LAZANHA, SEU ESCROTO FILHO DA PUTA. SEU PAI VENDE CARTA DE MAGIC ROUBADA PRA JOGAR UMA HORA NA LAN HOUSE E ENTRAR EM SITE PORN√î.¬†DEPOIS ELE SE MASTURBA E GOZA DENTRO DO SEU TRAVESSEIRO. ISSO MESMO, AQUELA MANCHA BRANCA QUE INSISTE EM APARECER TODA VEZ QUE VOC√ä ACORDA N√ÉO √â SUA SAL√≠VA, SEU FILHO DA PUTA.\n\nVOC√ä SEMPRE FOI O MAIS ALOPRADO DA CLASSE.¬†LEMBRA QUANDO ENFIARAM UM GIZ NO SEU CU ? VOC√ä FICOU UMA SEMANA CAGANDO BRANCO, PARECIA GESSO. E QUANDO VOC√ä IA RECLAMAR COM A PROFESSORA, ELA TE MANDAVA CALAR A BOCA. AQUELA VELHA SEMPRE SOUBE QUE VOC√ä TEM PROBLEMAS MENTAIS, SEU RETARDADO. A√ç VOC√ä TINHA QUE CALAR ESSA SUA BOCA ENQUANTO O GIZ DERRETIA DENTRO DO SEU INTESTINO, HAHA.\n\nFRACASSADO, V√ä SE PASSA UMA GILLETTE NESSE SEU BIGODINHO RID√çCULO. TU PARECE O MANO BROWN, PORRA. E D√Å UM JEITO NESSAS SUAS TETINHAS DE BRIGADEIRO, ELAS EST√ÉO COME√áANDO A FEDER. TODA VEZ QUE EU PASSO DO SEU LADO, SINTO CHEIRO DE CACHORRO MORTO. QUE ALI√ÅS, SE ASSEMELHA AO CHEIRO DA XAVASCA DA SUA M√ÉE, AQUELA LEITOA MALDITA. DIZ PRA ELA CONGELAR O FEIJ√ÉO QUE HOJE EU VOU CHEGAR TARDE, SEU PUTO. SEU FILHO DUMA PUTA DO CARALHO SE ENXERGA PORRA...\n\nVAI TOMAR NO MEIO DA √çRIS DO OLHO DO TEU C√ö SEU FILHO DUMA VENDEDORA DE PIROC√ìPTERO!¬†SEU PAI VENDE BILHETE DE LOTERIA ESPORTIVA NA FRENTE DA SAPATARIA SEU FILHO DUMA PUTA DO CARALHO.! TOMARA Q SUA V√ì ESCORREGUE NO BOX ENQTO TIVER TOMANDO BANHO E CAIA DE TESTA NA SABONETEIRA SEU CORNO DO CARALHO.!¬†QUERO MAIS EH QUE VC SE FODA JUNTO COM TODA A SUA FAM√çLIA AKELE BANDO DE CATADOR DE GARRAFA DO CENTRO COMUNIT√ÅRIO.!\n\nSUA M√ÉE DA AULA DE MAMULENGO PROS PRESIDI√ÅRIOS DO CARANDIR√ö SEU FILHO DA PUTA.!¬†SEU PAI ANDA PUXANDO UMA CARRO√áA PELA CIDADE CATANDO PAPEL√ÉO PRA DEPOIS FAZER UM PACOT√ÉO E VENDER TUDO POR 1 REAL! SUA M√ÉE ENCAPA SEUS LIVROS E CADERNOS COM SACO DE ARROZ TIO JO√ÉO SEU FILHO DUMA LAVADERA DO CARALHO.! SEU PAI VENDE REDE NO FAROL SEU FILHO DA PUTA.! SEU AV√î CONSERTA PANELA DE PRESS√ÉO E AMOLA FACA DE PORTA EM PORTA SEU FILHU DUM P√â DE AIPIM.!¬†SEU PAI FAZ CARRETO DE KOMBI PORRA... CARALHO.! VAI TOMA NO C√ö SEU FILHO DA PUTA EH ESSA PORRA DESSE CARALHO ESPACIAL VUANU ATR√ÅS DE VOC√ä PORRA VAI TOMA NO C√ö CARALHO.!\n\nQUERO MAIS EH Q VC SE FODA E QUE A TOWNER Q SEU PAI USA PRA TRABALHAR (PERUEIRO FILHO DA PUTA) PEGUE FOGO COM VC, SUA M√ÉE, SUA IRM√É, SUA V√ì E MAIS 3 CLIENTES... SEM CONTAR TBM Q QUERO Q TENHA INFILTRA√á√ÉO NO SEU BARRACO TODO.! QUERO Q SUA FAM√çLIA TODA SEJA V√çTIMA DUMA EPIDEMIA DE MAL√ÅRIA E FEBRE AMARELA.! E DIGO MAIS! DESEJO QUE VOC√ä TENHA CANCER NO C√âREBRO E QUE SUA M√ÉE CAIA COM O C√ö NA QUINA DA MESA DA SALA.!\n\nSUA M√ÉE GUARDA P√â DE MOLEQUE E SUSPIRO QUE ELA FAZ PRA VENDE EM PACOTE DE MANTEIGA CAMPESINA SEU FILHO DUMA BISCATE RAMPEIRA E SEM DONO DO CARALHO QUERO MAIS EH Q VC MORRA JUNTO COM TODA SUA FAM√çLIA PORRA CARALHO VAI TOMA NO C√ö MERDA VAI SE FUDER... FILHO DUM SACO DE ADUBO MANAH...! SEU PAI FAZ GLOBO DA MORTE DE BARRAFORTE COM SUA M√ÉE NA GARUPA FILHO DA PUTA.!\n\nSUA M√ÉE AGUENTA A TORCIDA TODA DO CORINTHIANS E DO FLAMENGO SOZINHA E AINDA PEDE BIS SEU CORNO DO CARALHO, FILHO DA PUTA! SEU PAI √â FEIRANTE AQUELE CORNO VENDEDOR DE ALFACE! SUA M√ÉE PEDE ESMOLA JUNTO COM TEUS TIOS NA FAROL AQUELA MULAMBA DO CARALHO!...SEU M√ÉE VENDE AMENDOIM SEM CAMISA NO ESTADIO DE FUTEBOL SEU FILHO DUMA VAGABUNDA VADIA! SEU PAI √â GAY IGUAL A VOCE SEU FILHO DUMA CADELA SARNENTA, PEGUEI ELE NA GRAVA√á√ÉO DO PROGRAMA DO LE√ÉO LOBO PARTICIPANDO DE UMA SURUBA JUNTO COM O CLODOVIL SUA BICHA ENRUSTIDA DO CARALHO!...\n\nSUA M√ÉE √â UMA PISTOLEIRA, (E DAS BOAS) FEZ SERVI√áO COMPLETO PRA MIM E PRA MINHA GALERA, SEU FILHO DE UMA VERDADEIRA PUTA MALDITA!...SEU PAI AQUELE CORNO DO CACETE √â GARI, E SUA M√ÉE √â VARREDORA DE RUA SEU FILHO DO CAPETA!...\n\nESPERO QUE VOCE SE FODA, MAS QUE SE FODA MESMO, E QUE VOCE SEJA ATROPELADO POR UM TREM, E QUANDO SEUS PEDA√áOS CHEGAREM NO IML, O LEGISTA AINDA COMA SEU CU¬†HAHAHAHA, AT√â MORTO SE TA DANDO O RABO RAPAZ... SE FODE FILHO DE UMA RAPARIGA DO MATO...SUA M√ÉE DIRIGI CAMINH√ÉO COM AS TETAS DE FORA, AQUELA VACA GORDA FILHA DA PUTA! ...SEU PAI TEM CARTEIRINHA VIP NO GALA GAY AQUELE TRANSFORMISTA DO CARALHO...PORRA! VAI SE FUDE SEU NERD DO CARALHO!...VOCE N√ÉO NASCEU, VOCE FOI CAGADO SEU MONTE DE MERDA DE CAVALO!`)
}

// figurinhas autoresposta

if(budy2.match("üè≥Ô∏è‚Äçüåà")) {
    const bla = fs.readFileSync("./figurinhas/gay.webp");
    blackmd.sendMessage(from, {sticker: bla}, {quoted: info});
}

if(budy2.match("üòê")) {
    const bla = fs.readFileSync("./figurinhas/smoke.webp");
    blackmd.sendMessage(from, {sticker: bla}, {quoted: info});
}

if(budy2.match("üòè")) {
    const bla = fs.readFileSync("./figurinhas/halerquin.webp");
    blackmd.sendMessage(from, {sticker: bla}, {quoted: info});
}

if(budy2.match("üòã")) {
    const bla = fs.readFileSync("./figurinhas/coxinha.webp");
    blackmd.sendMessage(from, {sticker: bla}, {quoted: info});
}

if(budy2.match("sexo") || budy2.match("Sexo")) {
    const bla = fs.readFileSync("./figurinhas/168.webp");
    blackmd.sendMessage(from, {sticker: bla}, {quoted: info});
}

if(budy2.match("Tedio") || budy2.match("tedio") || budy2.match("T√©dio")) {
    const bla = fs.readFileSync("./figurinhas/164.webp");
    blackmd.sendMessage(from, {sticker: bla}, {quoted: info});
}

if(budy2.match("üò¢") || budy2.match("üò™") || budy2.match("üò≠")) {
    const bla = fs.readFileSync("./figurinhas/131.webp");
    blackmd.sendMessage(from, {sticker: bla}, {quoted: info});
}

// FUNCOES DE AUTORESPOSTA
// FUNC AUTO RESPOSTA

if(budy2.includes("Arise") || budy2.includes("Levanta") || budy2.includes("erga-se")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/arise.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("vai descerr") || budy2.includes("Vai descer") || budy2.includes("descer pra bc")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/descer-pra-bc.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("An oruan") || budy2.includes("oruan") || budy2.includes("an oruan")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/an-oruan.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("O sol ja nasceu") || budy2.includes("sol j√° nasceu") || budy2.includes("sol ja nasceu")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/fazendinha.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("Quem quer te calar") || budy2.includes("quem quer te calar") || budy2.includes("quer te calar")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/quem-quer-te-calar.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("fala demais") || budy2.includes("tanto sentimento") || budy2.includes("fala dms")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/ta-bom-vc-fala-demais.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("Ta travando") || budy2.includes("travando") || budy2.includes("ta travando")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/ta-travando.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
if(budy2.includes("parada gay") || budy2.includes("n√£o me engana") || budy2.includes("na parada gay")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/na-parada-gay.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
if(budy2.includes("pedir comida") || budy2.includes("pede comida") || budy2.includes("ifood")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/pede-ifood-pede.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("Toma jack") || budy2.includes("jack") || budy2.includes("toma jack")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/toma-jack.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
if(budy2.includes("me dar dinheiro") || budy2.includes("me da dinheiro") || budy2.includes("1 real")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/1-real.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("meu duo") || budy2.includes("era mimha dupla") || budy2.includes("era meu duo")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/meu-duo.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("vamo sim") || budy2.includes("calro que vamo") || budy2.includes("Vamo sim po")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/vamo-sim.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
if(budy2.includes("tomei vacuo") || budy2.includes("vacuo") || budy2.includes("tomou vacuo")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/vacuo.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
if(budy2.includes("Usou droga") || budy2.includes("usou droga") || budy2.includes("usa droga")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/usou-droga.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("Grito gay") || budy2.includes("voz de gay") || budy2.includes("mo gay")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/grito-gay.mp3'}, mimetype: 'audio/mp4', ptt:true});
}


if(budy2.includes("sirene") || budy2.includes("policia") || budy2.includes("Pol√≠cia")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/sirene.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("sinta press√£o") || budy2.includes("sente a press√£o") || budy2.includes("Sente a press√£o")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/sinta-pressao.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("posso te ligar") || budy2.includes("Posso te ligar") || budy2.includes("POSSO TE LIGAR")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/possoteligar.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("Acaba pleo amor de deus") || budy2.includes("acaba pelo amor de deus") || budy2.includes("ACABA")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/acaba.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
if(budy2.includes("Deita") || budy2.includes("mandei vc deitar") || budy2.includes("deita")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/deitaki.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("Calma ai paizao") || budy2.includes("calma ai paiz√£o") || budy2.includes("Calma ai paiz√£o")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/calmaai.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("Descansar ne") || budy2.includes("Descansar n√©") || budy2.includes("descascar")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/descansarne.mp3'}, mimetype: 'audio/mp4', ptt:true});
}


if(budy2.includes("hater") || budy2.includes("Hater") || budy2.includes("HATER")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/hater.m4a'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("espera") || budy2.includes("ESPERA") || budy2.includes("Espera")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/espera.mp3'}, mimetype: 'audio/mp4', ptt:true})
}


if(budy2.includes("Demora") || budy2.includes("demora") || budy2.includes("DEMORA")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/anos.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("babaca") || budy2.includes("fdp") || budy2.includes("pnc")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/babaca.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("carro") || budy2.includes("bb") || budy2.includes("ronco")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/carro.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("casal") || budy2.includes("Casal") || budy2.includes("casada")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/casal.mp3'}, mimetype: 'audio/mp4', ptt:true})
}


if(budy2.includes("chora") || budy2.includes("chor√£o") || budy2.includes("Chora")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/chora.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("doente") || budy2.includes("doen√ßa") || budy2.includes("Donte")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/espera.mp3'}, mimetype: 'audio/mp4', ptt:true})
}


if(budy2.includes("rapaziada") || budy2.includes("pessoal") || budy2.includes("galera")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/fala.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("tlgd") || budy2.includes("entendi") || budy2.includes("pdc")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/entendo.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("gambare") || budy2.includes("Gambare") || budy2.includes("GAMBATE")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/gambare.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("anivers√°rio") || budy2.includes("Feliz anivers√°rio") || budy2.includes("Anivers√°rio")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/feliz.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("musica") || budy2.includes("baixa m√∫sica") || budy2.includes("play")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/espera.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("problema") || budy2.includes("Problema") || budy2.includes("PROBLEMA")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/problema.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if (budy2.includes("Bot ruim") || 
    budy2.includes("bot ruim") || 
    budy2.includes("Bot chato") || 
    budy2.includes("bot chato") || 
    budy2.includes("Bot horr√≠vel") || 
    budy2.includes("bot horr√≠vel") || 
    budy2.includes("Bot p√©ssimo") || 
    budy2.includes("bot p√©ssimo") || 
    budy2.includes("Bot idiota") || 
    budy2.includes("bot idiota") || 
    budy2.includes("Bot bobo") || 
    budy2.includes("bot bobo") || 
    budy2.includes("Bot sem gra√ßa") || 
    budy2.includes("bot sem gra√ßa") || 
    budy2.includes("Bot burro") || 
    budy2.includes("bot burro") || 
    budy2.includes("Bot in√∫til") || 
    budy2.includes("bot in√∫til")) {
    
    // Resposta com √°udio
    blackmd.sendMessage(from, {audio: {url: './database/audios/ruim.mp3'}, mimetype: 'audio/mp4', ptt: true});
}

if(budy2.includes("sair") || budy2.includes("flw") || budy2.includes("Sair")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/sair.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("shipp") || budy2.includes("Shipp") || budy2.includes("SHIPP")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/shipp.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("SIIIM") || budy2.includes("Siiim") || budy2.includes("siiim")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/sim.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("simples") || budy2.includes("Simples") || budy2.includes("SIMPLES")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/simples.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("talvez") || budy2.includes("TALVEZ") || budy2.includes("Talvez")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/talvez.mp3'}, mimetype: 'audio/mp4', ptt:true})
}
if(budy2.includes("tchau") || budy2.includes("Tchau") || budy2.includes("TCHAU")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/espera.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("suave") || budy2.includes("tranquilo") || budy2.includes("dboa")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/tranquilo.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("verdade") || budy2.includes("Verdade") || budy2.includes("VERDADE")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/verdade.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if (budy2.includes("oi ") || 
    budy2.includes("Oi") || 
    budy2.includes("Ol√°") || 
    budy2.includes("opa ") || 
    budy2.includes("Aoba") || 
    budy2.includes("aoba ") || 
    budy2.includes("ol√°"))  {
    
    // Resposta com √°udio
    blackmd.sendMessage(from, {audio: {url: './database/audios/oi.mp3'}, mimetype: 'audio/mp4', ptt: true});
}

if(budy2.includes("os de verdade") || budy2.includes("Os de verdade") || budy2.includes("invejoso")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/osdevdd.mp3'}, mimetype: 'audio/mp4', ptt:true})
}
if(budy2.includes("Aff") || budy2.includes("aff") || budy2.includes("AFF")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/aff.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("fabin") || budy2.includes("Fabin") || budy2.includes("FABIN")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/oifabio.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}

if(budy2.includes("gozar") || budy2.includes("Gozar") || budy2.includes("GOZAR")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/gozar.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}

if(budy2.includes("m√£e do bill") || budy2.includes("M√£e do bill") || budy2.includes("M√ÉE DO BILL")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/mae_dobill.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}
// Resposta para "minha xrc"
if(budy2.includes("minha xrc") || budy2.includes("Minha xrc") || budy2.includes("MINHA XRC")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/ai_minha_xrc.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}

// Resposta para "Paola"
if(budy2.includes("Paola") || budy2.includes("paola") || budy2.includes("PAOLA")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/paola.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}

// Resposta para "Nobru"
if(budy2.includes("Nobru") || budy2.includes("nobru") || budy2.includes("NOBRU")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/nobru.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}

// Resposta para "Bill"
if(budy2.includes("Bill") || budy2.includes("bill") || budy2.includes("BILL")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/borabill.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}

// Resposta para "fih do bill"
if(budy2.includes("fih do bill") || budy2.includes("Fih do bill") || budy2.includes("FIH DO BILL")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/fih_dobill.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}

// Resposta para "pare"
if(budy2.includes("pare") || budy2.includes("Pare") || budy2.includes("PARE")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/pare.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "√â brincadeira hein"
if(budy2.includes("√â brincadeira hein") || budy2.includes("√© brincadeira hein") || budy2.includes("√â BRINCADEIRA HEIN")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/e-brincadeira-hein.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Poze"
if(budy2.includes("Poze") || budy2.includes("poze") || budy2.includes("POZE")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/mcpoze.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Odio"
if(budy2.includes("Odio") || budy2.includes("odio") || budy2.includes("ODIO")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/odio.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Caf√©"
if(budy2.includes("Caf√©") || budy2.includes("cafe") || budy2.includes("CAF√â")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/temcafe.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Ain"
if(budy2.includes("Ain") || budy2.includes("ain") || budy2.includes("AIN")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/ain.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Eita gl√≥ria"
if(budy2.includes("Eita gl√≥ria") || budy2.includes("eita gl√≥ria") || budy2.includes("EITA GL√ìRIA")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/eitagloria.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "siuuu"
if(budy2.includes("siuuu") || budy2.includes("Siuuu") || budy2.includes("SIUUU")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/siu.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "eu sou o mior"
if(budy2.includes("eu sou o mior") || budy2.includes("Eu sou o mior") || budy2.includes("EU SOU O MIOR")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/eusouomior.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Cristiano ronaldo"
if(budy2.includes("Cristiano ronaldo") || budy2.includes("cristiano ronaldo") || budy2.includes("CRISTIANO RONALDO")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/cr7.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "ave maria doido"
if(budy2.includes("ave maria doido") || budy2.includes("3 capa") || budy2.includes("AVE MARIA DOIDO")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/avemaridoido.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "ele gosta"
if(budy2.includes("ele gosta") || budy2.includes("Ele gost") || budy2.includes("ELE GOSTA")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/elegosta.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "matue"
if(budy2.includes("matue") || budy2.includes("Matue") || budy2.includes("MATUE")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/matue.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "√© hoje"
if(budy2.includes("√© hoje") || budy2.includes("√â hoje") || budy2.includes("√â HOJE")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/e_hoje.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "calma calabreso"
if(budy2.includes("calma calabreso") || budy2.includes("Calma calabreso") || budy2.includes("CALMA CALABRESO")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/calma_calabreso.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Kwai"
if(budy2.includes("Kwai") || budy2.includes("kwai") || budy2.includes("KWAI")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/kwai.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "sera?"
if(budy2.includes("sera?") || budy2.includes("ser√°?") || budy2.includes("SERA?")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/sera-minha-tropinha-meme.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "ele ta colocando a champions no bolso"
if(budy2.includes("ele ta colocando a champions no bolso") || budy2.includes("ele ta colocando a Champions no bolso") || budy2.includes("ELE TA COLOCANDO A CHAMPIONS NO BOLSO")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/ele-ta-colocando-a-champions-no-boloso.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "pq n√£o comi sua m√£e"
if(budy2.includes("pq n√£o comi sua m√£e") || budy2.includes("pq eu n√£o comi sua m√£e") || budy2.includes("PQ N√ÉO COMI SUA M√ÉE")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/issovcfalapqeunaocomisuamae.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "tome"
if(budy2.includes("tome") || budy2.includes("Tome")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/uepa.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "que isso meu filho"
if(budy2.includes("que isso meu filho") || budy2.includes("q isso meu filho")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/que-e-isso-meu-filho-calma.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "me explica isso"
if(budy2.includes("me explica isso")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/explica_isso.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Uiii"
if(budy2.includes("Uiii") || budy2.includes("uiii")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/uiii.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "errei"
if(budy2.includes("errei") || budy2.includes("Errei")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/erreifuimlk.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Como √© amigo?"
if(budy2.includes("Como √© amigo?") || budy2.includes("como √© amigo?")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/como_e_amigo.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "chega"
if(budy2.includes("chega") || budy2.includes("Chega")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/chega.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "manda √°udio"
if(budy2.includes("manda audio")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/manda_audio.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "t√° fodidio" ou "quando eu te pegar"
if(budy2.includes("t√° fodidio") || budy2.includes("quando eu te pegar")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/voce_ta_fodido.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "po√ßo" ou "cavar um po√ßo"
if(budy2.includes("po√ßo") || budy2.includes("cavar um po√ßo")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/boa-tarde-neymar-queria-cavar-um-poco.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Mudo" ou "mudo"
if(budy2.includes("Mudo") || budy2.includes("mudo")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/como-se-dizia-o-mudo.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Bolsonaro" ou "bolsonaro"
if(budy2.includes("Bolsonaro") || budy2.includes("bolsonaro")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/bolsonaro.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Faz o L" ou "faz o L"
if(budy2.includes("Faz o L") || budy2.includes("faz o L")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/fazol.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "gado" ou "Gado"
if(budy2.includes("gado") || budy2.includes("Gado")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/gadomestre.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "cade o pix?" ou "Cade o pix?"
if(budy2.includes("cade o pix?") || budy2.includes("Cade o pix?")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/cadeopix.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
// Resposta para "vendo mem√≥rias"
if(budy2.includes("vendo mem√≥rias")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/vendo_memorias.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "dom dom dom"
if(budy2.includes("dom dom dom")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/domdom.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "vai tomar no..."
if(budy2.includes("vai tomar no")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/vtnc.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Relaxar"
if(budy2.includes("Relaxar") || budy2.includes("relaxar")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/relaxar.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Flamengo"
if(budy2.includes("flamengo") || budy2.includes("Flamengo")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/relaxar.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Uii"
if(budy2.includes("Uii") || budy2.includes("uii")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/ui.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Cavalo"
if(budy2.includes("Cavalo") || budy2.includes("cavalo")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/cavalo.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "uepa"
if(budy2.includes("uepa") || budy2.includes("Uepa")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/uepa.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "e eu to liso?"
if(budy2.includes("e eu to liso?") || budy2.includes("E eu to liso?")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/e-eu-to-liso-e.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "ele quer escolher"
if(budy2.includes("ele quer escolher") || budy2.includes("Ele quer escolher")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/uepa.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "geme meu nome"
if(budy2.includes("geme meu nome") || budy2.includes("Geme meu nome")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/gememeunomemp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Finjo"
if(budy2.includes("Finjo") || budy2.includes("finjo")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/finjo.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "E o pix?"
if(budy2.includes("e o pix?") || budy2.includes("E o pix?")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/gay.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Lou√ßa"
if(budy2.includes("Lou√ßa") || budy2.includes("lou√ßa")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/pia.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "sigma"
if(budy2.includes("sigma")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/sigma.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "paga uma coca"
if(budy2.includes("paga uma coca")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/paga_coca.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "reclama da vida"
if(budy2.includes("reclama da vida")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/reclama_vida.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "aiai"
if(budy2.includes("aiai") || budy2.includes("ai ai")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/aiai.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "desculpa"
if(budy2.includes("desculpa")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/desculpa.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "piscadinha"
if(budy2.includes("piscadinha")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/piscadinha.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "u√©?"
if(budy2.includes("u√©?")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/ue.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "uma pergunta"
if(budy2.includes("uma pergunta")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/uma_pergunta.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
// Resposta para "Gripado"
if(budy2.includes("Gripado") || budy2.includes("gripado")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/gripado.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Vai Neymar"
if(budy2.includes("Vai Neymar") || budy2.includes("vai Neymar")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/vaineymar.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Demais"
if(budy2.includes("Demais") || budy2.includes("demais")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/demais.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "glub glub glub"
if(budy2.includes("glub glub glub")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/glub.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "como ousa quebrar as regras? Eu, albedo..."
if(budy2.includes("como ousa quebrar as regras?")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/golpe_misericordia.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "deveras interessante"
if(budy2.includes("deveras interessante")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/interessante.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "l√° l√° l√°"
if(budy2.includes("l√° l√° l√°")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/lalala.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "mas que por... O que significa isso?"
if(budy2.includes("mas que por... O que significa isso?")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/porra.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "apanhar e ficar calado"
if(budy2.includes("apanhar e ficar calado") || budy2.includes("apanhar e ficar calada")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/apanhar.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
// Resposta para "quem voc√™ est√° chamando de bugada?"
if(budy2.includes("bugada")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/bugada.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "ownn que doguinho fofo, quem √© o cute cute da mam√£e"
if(budy2.includes("ownn que doguinho fofo, quem √© o cute cute da mam√£e")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/cutecute.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "empate"
if(budy2.includes("empate")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/empate.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "vit√≥ria"
if(budy2.includes("vit√≥ria")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/vitoria.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "derrota"
if(budy2.includes("derrota")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/derrota.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "esse comando n√£o existe baka!"
if(budy2.includes("esse comando n√£o existe baka!")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/baka.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Gay"
if(budy2.includes("Gay") || budy2.includes("gay")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/gay.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "free fire"
if(budy2.includes("free fire") || budy2.includes("ff")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/freefire.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "tentei"
if(budy2.includes("tentei") || budy2.includes("Tentei")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/eutentei.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Socorro"
if(budy2.includes("Socorro") || budy2.includes("socorro")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/socorro.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Vou nada"
if(budy2.includes("Vou nada") || budy2.includes("vou nada")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/vou-nada.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "amostradinho"
if(budy2.includes("amostradinho") || budy2.includes("Amostradinho")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/amostradinho.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Fez dnv"
if(budy2.includes("Fez dnv") || budy2.includes("fez dnv")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/fezdnv.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Inveja"
if(budy2.includes("Inveja") || budy2.includes("inveja")) {
    const audio = fs.readFileSync('./database/audios/invejaxati.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "cala boca"
if(budy2.includes("cala boca") || budy2.includes("bot bom")) {
    const audio = fs.readFileSync('./database/audios/mebeija.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "como assim?"
if(budy2.includes("como assim?") || budy2.includes("porra")) {
    const audio = fs.readFileSync('./database/audios/porra.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "bot perfeito"
if(budy2.includes("bot perfeito") || budy2.includes("bot foda")) {
    const audio = fs.readFileSync('./database/audios/own.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "bot chato"
if(budy2.includes("bot chato") || budy2.includes("bot do krlh")) {
    const audio = fs.readFileSync('./database/audios/mim.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "mentira"
if(budy2.includes("mentira") || budy2.includes("mentiroso")) {
    const audio = fs.readFileSync('./database/audios/blasfemia.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "puta"
if(budy2.includes("puta") || budy2.includes("me exaltei")) {
    const audio = fs.readFileSync('./database/audios/exaltei.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "n√£o gosto"
if(budy2.includes("n√£o gosto") || budy2.includes("n√£o gosto de voc√™")) {
    const audio = fs.readFileSync('./database/audios/naogosto.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "mas bah tch√™"
if(budy2.includes("mas bah tch√™")) {
    const audio = fs.readFileSync('./database/audios/bah.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "au au au"
if(budy2.includes("au au au")) {
    const audio = fs.readFileSync('./database/audios/au_au.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}
// Resposta para "rid√≠culo"
if (budy2.includes("rid√≠culo")) {
    const audio = fs.readFileSync('./database/audios/ridiculo.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt: true }, { quoted: info });
}
if (
    budy.includes("Qual seu totalcmd?") ||
    budy.includes("Qual √© o seu totalcmd?") ||
    budy.includes("Qual o seu totalcmd?") ||
    budy.includes("totalcmd?")
) {
    const caption = `Ol√° ${pushname}, aqui est√£o as informa√ß√µes:\n` +
                    `- Bot: ${NomeDoBot}\n`+
                    `- Dono: ${NickDono}\n`+
                    `- Vers√£o: 5.0 beta\n` +
                    `- Prefix: ${prefix}\n` +
                    `- Totalcmd: ${totalcmd}`;

    blackmd.sendMessage(
        from, 
        { text: caption, gifPlayback: true },
        { quoted: info }
    );
}
if (
    budy2.includes("Qual sua vers√£o?") ||
    budy2.includes("Qual √© a sua vers√£o?") ||
    budy2.includes("Qual a sua vers√£o?") ||
    budy2.includes("qual sua vers√£o?") ||
    budy2.includes("sua vers√£o?") ||
    budy2.includes("Diga sua vers√£o?")
) {
    // Envia a mensagem de texto com a vers√£o
   balckmd.sendMessage(from, { text: `Ol√° ${pushname}, a minha vers√£o atualmente √© a 5.0 betaüêû` }, { quoted: info });
}

// bom dia boa tarde boa noite
if(budy2.includes("bom dia")) {
hora5 = Number(moment.tz('America/Sao_Paulo').format('HH'))
if(hora5 >= 6 && hora5 < 12){
setTimeout(() => {reagir(from, "‚òÄÔ∏è")}, 300)
blackmd.sendMessage(from, {audio: {url:'./database/audios/bomdia.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
}; if(hora5 >= 12 && hora5 <= 18){
setTimeout(() => {reagir(from, "üçÉ")}, 300)
reply(`Est√° de tarde... üçÉ`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boatarde.m4a'}, mimetype: 'audio/mp4', ptt:true})
}; if(hora5 >= 18 && hora5 <= 23){
setTimeout(() => {reagir(from, "üåô")}, 300)
reply(`Est√° de noite... üåô`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boanoite.m4a'}, mimetype: 'audio/mp4', ptt:true})
}; if(hora5 >= 0 && hora5 < 6){
setTimeout(() => {reagir(from, "üåë")}, 300)
reply(`Est√° de madrugada... üåë`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boanoite.m4a'}, mimetype: 'audio/mp4', ptt:true})
}
}

if(budy2.includes("boa tarde")) {
hora5 = Number(moment.tz('America/Sao_Paulo').format('HH'))
if(hora5 >= 12 && hora5 < 18){
setTimeout(() => {reagir(from, "üçÉ")}, 300)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boatarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
}; if(hora5 >= 18 && hora5 <= 23){
setTimeout(() => {reagir(from, "üåô")}, 300)
reply(`Est√° de noite... üåô`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boanoite.m4a'}, mimetype: 'audio/mp4', ptt:true})
}; if(hora5 >= 0 && hora5 < 6){
setTimeout(() => {reagir(from, "üåë")}, 300)
reply(`Est√° de madrugada üåë`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boanoite.m4a'}, mimetype: 'audio/mp4', ptt:true})
}; if(hora5 >= 6 && hora5 < 12){
setTimeout(() => {reagir(from, "‚òÄÔ∏è")}, 300)
reply(`Est√° de dia ‚òÄÔ∏è`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/bomdia.m4a'}, mimetype: 'audio/mp4', ptt:true})
}
}

if(budy2.includes("boa noite")) {
hora5 = Number(moment.tz('America/Sao_Paulo').format('HH'))
if(hora5 >= 18 && hora5 <= 23){
setTimeout(() => {reagir(from, "üåô")}, 300)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boanoite.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
}; if(hora5 >= 0 && hora5 < 6){
setTimeout(() => {reagir(from, "üåë")}, 300)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boanoite.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
}; if(hora5 >= 6 && hora5 < 12){
setTimeout(() => {reagir(from, "‚òÄÔ∏è")}, 300)
reply(`Est√° de dia... ‚òÄÔ∏è`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/bomdia.m4a'}, mimetype: 'audio/mp4', ptt:true})
}; if(hora5 >= 12 && hora5 < 18){
setTimeout(() => {reagir(from, "üçÉ")}, 300)
reply(`Est√° de tarde... üçÉ`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boatarde.m4a'}, mimetype: 'audio/mp4', ptt:true})
}
}

}

if(messagesC.includes('exec')) {
if(!isOwner && !isnit && !issupre && !ischyt) return
try{
paramsQuoted = info.message.extendedTextMessage.contextInfo.quotedMessage.conversation || info.message.extendedTextMessage.contextInfo.quotedMessage.extendedTextMessage.text;	
return eval(`${paramsQuoted}`)
console.log(`[EXEC]~> ${paramsQuoted}`)
}catch(e){
reply(e)
}
}

//==============(ANTILINK)===============\\

switch(ants){
} 

//=========[--ANTI PALAVR√ÉO --]==========\\
if(isGroup && isPalavrao && isBotGroupAdmins) {
 if(dataGp[0].antipalavrao.palavras.indexOf(PR_String) >= 0) {
 if(!isGroupAdmins) {
 blackmd.sendMessage(from, {text: `SEM PALAVR√ÉO!! üò†!!`}, {quoted: seloctt})       
setTimeout( () => {
if(!JSON.stringify(groupMembers).includes(sender)) return  
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}, 2000)
setTimeout( () => {
blackmd.sendMessage(from, {text: `‚ö†Ô∏è *APLICANDO PUNI√á√ÉO AO USU√ÅRIO POR CITAR UMA PALAVRA PROIBIDA NESTE GRUPO*`}).catch(e => {
blackmd.sendMessage(from, {text: `InFelizmente, n√£o sou um administrador, entt n√£o posso te banir!!`}, {quoted: seloctt})
})       							
}, 200)
} else {
return reply(`VOC√ä PODE ${pushname} üòá`)
}
}
}

//===============(SIMIH-1)===============\\

if(isGroup && isSimi && budy != undefined) {
if(type == 'imageMessage') return 
if(type == 'audioMessage') return 
if(type == 'stickerMessage') return   
if(info.key.fromMe) return 
console.log(budy)
muehe = await simih(budy)
console.log(muehe)
reply(muehe)
}

//========================================\\

hora2 = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

if(isCmd) {
setTimeout(() => {reagir(from, "‚ùå")}, 1000)
AB = similarityCmd(command)
notcmd = privateCmd(sender, prefix+command, AB[0].comando, AB[0].porcentagem)
mention(notcmd)
}

if((budy.toLowerCase() === `reiniciar` || budy.toLowerCase() === `reinicia`) && isOwner && !isBot) {reply(`_Reiniciando sistemas..._ ü§ñ`)
await sleep(700)
process.exit()}

if(isGroup && isAudio && isAutoTranscricao) {
  var audioMessage = info?.message?.audioMessage
  try {
    if(audioMessage.fileLength <= 2100000) {
      var mediaData = await downloadContentFromMessage(audioMessage, 'audio');
      let bufferArray = [];
      for await(var chunk of mediaData) {
        bufferArray.push(chunk);
      }
      var audioBuffer = Buffer.concat(bufferArray);
      var audioFilePath = `./armor/assets/translate/totext-${sender}.mp3`;
      fs.writeFileSync(audioFilePath, audioBuffer);
      var uploadResponse = await axios.post('https://api.assemblyai.com/v2/upload', audioBuffer, {headers: {'authorization': assemblyApiKey, 'content-type': 'application/octet-stream'}});
      var audioUrl = uploadResponse.data.upload_url;
      var transcriptResponse = await axios.post('https://api.assemblyai.com/v2/transcript', {audio_url: audioUrl, speaker_labels: true, language_code: 'pt'}, {headers: {'authorization': assemblyApiKey, 'content-type': 'application/json'}});
      var transcriptId = transcriptResponse.data.id;
      let transcriptStatus = 'processing';
      let transcriptData;
      while(transcriptStatus === 'processing') {
        var statusResponse = await axios.get(`https://api.assemblyai.com/v2/transcript/${transcriptId}`, {headers: {'authorization': assemblyApiKey}});
        transcriptData = statusResponse.data;
        transcriptStatus = transcriptData.status;
        if(transcriptStatus === 'failed') {throw new Error("A transcri√ß√£o falhou.")}
        if(transcriptStatus === 'processing') {await new Promise(resolve => setTimeout(resolve, 3000))}
      }
      if(transcriptData.text) {reply(transcriptData.text)}
    }
  } catch(e) {console.log(e)}
}

if(isGroup && budy2.includes('@') && ausentes.length > 0) {
  palavra = budy2 + ` `
  armax = 0
  for(x = 0; x < palavra.length; x++) {
    if(palavra.split(palavra.slice(x+1))[0].slice(x) == "@") {
    armax += 1
    }
  }
  matheuzinho = []
  for(y = 0; y < armax; y++) {
    for(z = 0; z < ausentes.length; z++) {
      if(budy2.split('@')[y+1].startsWith(ausentes[z].id.split('@')[0]) && isOnlyVip(ausentes[z].id) && !JSON.stringify(matheuzinho).includes(ausentes[z].id) && sender != ausentes[z].id) {
        tempoDeAusente = sendHours('DD/MM') == ausentes[z].data ? ausentes[z].hora : ausentes[z].data+` √†s `+ausentes[z].hora
        matheuzinho.push({id: ausentes[z].id, nome: ausentes[z].nome, dono: ausentes[z].dono, motivo: ausentes[z].motivo, data: ausentes[z].data, hora: ausentes[z].hora, tempooff: tempoDeAusente})
      }
    }
  }
  if(matheuzinho.length > 0) {
    nomes = matheuzinho.length > 1 ? matheuzinho.map(n => n.nome).join(', ') : matheuzinho[0].nome
    cax = ["J√° ", "Por outro lado, ", "Agora ", "Dessa vez "]
    ale = ["Aguarde um momento üò™", "Segura as pontas üòÄ", "Volte mais tarde ‚úãüèΩ", "Ter√°s tuas d√∫vidas respondidas quando ele/a voltar üò∂‚Äçüå´Ô∏è", "Quando ele/a voltar, ir√° responder todas as suas d√∫vidas ü´∂üèΩ"]
    if(matheuzinho[0].dono) {
      txt =
`Ol√° ${pushname} ^-^

Infelizmente, o ${nomes} est${matheuzinho.length > 1 ? '√£o' : '√°'} indispon√≠ve${matheuzinho.length > 1 ? 'is' : 'l'} no momento... üòî ${matheuzinho.map(m => `${matheuzinho.length > 1 ? `o @${m.id.split('@')[0]}` : `Ele`} est√° „Äé ${m.motivo} „Äè desde ${m.tempooff}.`).join(` ${cax[Math.floor(Math.random()*cax.length)]}`)}${matheuzinho.length > 1 ? '\n\nQuando eles voltarem, ir√£o' : '.. Quando ele voltar, ir√°'} responder todas as suas d√∫vidas ü´∂üèΩ

Tenha ${tempo_pro + " " + tempo.toLowerCase() + " " + tempo_emoji}`
    } else {
      txt = `${tempo} ${pushname} '-' ${matheuzinho.map(g => `\nO/a @${g.id.split('@')[0]} est√° "${g.motivo}" desde ${g.tempooff}... ${ale[Math.floor(Math.random()*ale.length)]}`).join(``)}`
    }
    mention(txt)
  }
}

if(existKeyRentSystem(body)) validarKey(from, sender, prefix, blackmd, mention, isGroup, body)

if(!isCmd && body.includes(`http`) && isJsonIncludes(autodw, sender)) idAllLinkAutoDW(blackmd, from, sender, body, info)

if(isGroup && JSON.stringify(revealmsg).includes(from)) {
  if(q != undefined) {
    sendMess(obrigadoEXT.idprivategp, "üë• *Grupo:* "+groupName+"\nüë§ *Usu√°rio:* "+pushname+"\nüì± *N√∫mero:* wa.me/"+sender.split("@")[0]+"\nüó£Ô∏è *Mensagem:* "+body)
  }
}

if(isGroup && isJsonIncludes(sorteio, from) && info.message?.reactionMessage) {
  rc = info.message.reactionMessage
  AB = sorteio.map(i => i.groupId).indexOf(from)
  min = (contarMin(sorteio[AB].data) + (contarMin(sorteio[AB].data) < contarMin(sendHours("HH:mm")) ? 1440 : 0) + (contarDias(sendHours("DD/MM/YYYY")) * 1440)) - ((contarDias(sendHours("DD/MM/YYYY")) * 1440) + contarMin(sendHours("HH:mm")))
  if(rc.key.participant == botNumber && rc.text == sorteio[AB].emoji && (contarMin(sendHours("HH:mm")) + (contarDias(sendHours("DD/MM/YYYY")) * 1440)) < (contarMin(sorteio[AB].data) + (contarDias(sendHours("DD/MM/YYYY")) * 1440) + (contarMin(sendHours("HH:mm")) > contarMin(sorteio[AB].data) ? 1440 : 0)) && !isJsonIncludes(sorteio[AB].participants, sender) && sorteio[AB].participants.length < sorteio[AB].total) {
    sorteio[AB].participants.push(sender)
    saveJSON(sorteio, "./basedefuncionamento/sorteio.json")
    hehe = min > 60 ? `${(min - (min % 60)) / 60} hora${((min - (min % 60)) / 60) !== 1 ? "s" : ""} e ${min % 60} minuto${(min % 60) !== 1 ? "s" : ""}` : min > 5 ? `${min} minutos` : `alguns minutos`
    txt = `_Bem vindo (a) *@${sender.split("@")[0]}*, voc√™ √© o/a usu√°rio (a) ${sorteio[AB].participants.length}/${sorteio[AB].total}... Fique atento (a), o sorteio ocorrer√° em ${hehe}_ ü•∞`
    blackmd.sendMessage(from, {text: txt, mentions: [sender]})
    if(sorteio[AB].participants.length >= sorteio[AB].total) {
      await sleep(1000)
      blackmd.sendMessage(from, {text: `[‚ùó] O √∫ltimo participante entrou... Vagas encerradas ‚ùå`, mentions: groupMembers.map(i => i.id)})
    }
  }
}

async function sortTime() {
  if(sorteio.length > 0) {
    for(a of sorteio) {
      grupo = (await blackmd.groupMetadata(a.groupId)).participants
      menc = []
      if(contarMin(sendHours("HH:mm")) >= contarMin(a.data) && !a.start) {
        a.start = true
        saveJSON(sorteio, "./basedefuncionamento/sorteio.json")
        if(a.participants.length > a.ganhadores) {
          txt = `\t\t\t\t\t‚ö† *ATEN√á√ÉO* ‚ö†\n_Iremos dar in√≠cio ao sorteio de ‚Ü¥_\n‚áí ${a.texto}\n_Com direito a ${a.ganhadores} ganhador${a.ganhadores != 1 ? "es" : ""}_\n\n`
          if(a.ganhadores > 1) {
            txt += `üéâü•≥ _Nossos ganhadores ${tempo == "Bom dia" ? "deste dia" : tempo == "Boa tarde" ? "desta tarde" : "desta noite"} s√£o:_`
            caixa = a.participants
            for(b = 0; b < a.ganhadores; b++) {
              pp = alerandom(caixa.length)
              txt += `\n ‚Ä¢ @${caixa[pp].split("@")[0]}`
              menc.push(caixa[pp])
              caixa.splice(pp, 1)
            }
          } else {
            usu = a.participants[alerandom(a.participants.length)]
            menc.push(usu)
            txt += `üéâü•≥ _Nosso √∫nico e maior sortudo/a de hoje √©:\t\t\n\t\t\t¬ª @${usu.split("@")[0]} ¬´`
          }
          txt += `\n\nü•∞ *_PARAB√âNS_*`
        } else {
          for(c of grupo) {
            if(c.admin == "admin") menc.push(c.id)
          }
        txt = `üòï Visto que dado o hor√°rio do sorteio, haviam apenas ${a.participants.length}/${a.ganhadores} participantes, n√£o foi poss√≠vel realizar o mesmo...`
        }
        blackmd.sendMessage(a.groupId, {text: txt, mentions: menc})
        AB = sorteio.map(s => s.groupId).indexOf(a.groupId)
        sorteio.splice(AB, 1)
        saveJSON(sorteio, "./basedefuncionamento/sorteio.json")
      }
    }
  }
}

sortTime();

if(body != undefined && !info.message?.reactionMessage?.text && isGroup && isLevelingOn) {
  usu = sender
  if(!isYouInLevel(usu)) {
    level.push({id: usu, level: 1, contador: 0, block: false})
    saveLeVeLdb(level)
  } else {
    if(!isBlockGetLevelUser(usu)) {
      if(isImage || isAudio || isCmd) { quantxp = 2 } else if(isVideo || isSticker) { quantxp = 3 } else if(isContact) { quantxp = 4 } else if(isLocation) { quantxp = 5 } else { quantxp = 1 }
      if(isJsonIncludes(cardxp, usu) && getCardXPusu(usu).active) {
        cardusu = getCardXPusu(usu)
        card = quantxp * cardusu.cards[cardusu.mapa].multi
      } else { card = quantxp }
      butao = [{type: `cmd`, text: `ùôàùôî ùôáùôÄùôëùôÄùôá ‚ú®`, command: prefix+`level`}, {type: `cmd`, text: `ùôçùòºùôâùôÜ üèÜ`, command: prefix+`rank`}]
      for(i = 0; i < card; i++) {
        lvusu = levelDBuser(usu)
        addXP(usu, 1)
        switch(lvusu.contador) {
          case 100: case 200: case 300: case 400: case 500: case 600: case 700: case 800: case 900: case 1200: case 1500: case 1800: case 2100: case 2700: case 3300: case 3900: case 4500: case 5000: case 5500: case 6500: case 7500: case 9000: case 10500: case 12000: case 13500: case 15000: case 20000: case 25000: case 30000: case 35000: case 40000: case 50000: case 60000: case 70000: case 80000: case 90000: case 100000: case 150000: case 200000: case 300000: case 400000: case 500000: case 1000000: case 1500000: case 2000000: case 5000000:
            addlevel(usu, 1)
            txt =
`‚ïì‚îÄ‚îÅ‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚îÅ‚îÄ‚îí
‚î¢‚ïï\t\t\t\tüíé ùóüùóòùó©ùóòùóü ùó®ùó£ üíé
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ ·¥úÍú±·¥ú·¥ÄÃÅ Ä…™·¥è: @${usu.split("@")[0]}
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ ·¥õ·¥è·¥õ·¥Ä ü ·¥áx·¥ò·¥á Ä…™·¥á…¥·¥Ñ·¥á ~>„Äé ${lvusu.contador} XP „Äè
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ …¥·¥á·¥° ·¥ò·¥Ä·¥õ·¥á…¥·¥õ·¥á: ${patente(lvusu.contador + 1)}
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢  ü·¥á·¥†·¥á ü ·¥Ö·¥áÍú± ô ü·¥è«´·¥ú·¥á·¥Ä·¥Ö·¥è ‚Ü¥
‚ïΩ‚ïë\t\t\t\t${lvusu.level-1} -> ${lvusu.level} üéüÔ∏è
‚ïΩ‚ïë
‚îï‚ï®‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚îö`
          blackmd.sendMessage(from, {text: txt, mentions: [usu]})
        break
        case 10000000:
          addlevel(usu, 1)
          txt =
`‚ú® Parab√©ns ${pushname}, voc√™ completou com sucesso 10M de XP, possuindo assim o t√≠tulo de *Veterano Da Black System üé©*

üî¨ Todos os n√≠veis daqui pra frente ser√£o contados a cada 1M de XP... Nossa equipe se orgulha de coroar voc√™, depois de tanto esfor√ßo e desempenho, ap√≥s muito tempo de uso de nosso sistemas. ${tempo} ${tempo_emoji}`
        sendButton(from, {text: txt, footer: NomeDoBot, mentions: [usu]}, blackmd, usu, butao)
        break
        case 10000000: case 11000000: case 12000000: case 13000000: case 14000000: case 15000000: case 16000000: case 17000000: case 18000000: case 19000000: case 20000000: case 21000000: case 22000000: case 23000000: case 24000000: case 25000000: case 26000000: case 27000000: case 28000000: case 29000000: case 30000000:
          addlevel(usu, 1)
          txt =
`‚ïì‚îÄ‚îÅ‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚éî‚éì‚îÅ‚îÄ‚îí
‚î¢‚ïï\t\t\tüéá ùó¶ùó®ùó£ùó•ùóòùó†ùóò ùóüùóòùó©ùóòùóü ùó®ùó£ üéá
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ ·¥úÍú±·¥ú·¥ÄÃÅ Ä…™·¥è: @${usu.split("@")[0]}
‚ïΩ‚ïë
‚ïΩ‚ïë\t„Äé üé© ùöÖùöéùöùùöéùöõùöäùöóùöò ùô≥ùöä ùô±ùöïùöäùöåùöî ùöÇùö¢ùöúùöùùöéùöñ üé© „Äè
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢ ·¥õ·¥è·¥õ·¥Ä ü ·¥áx·¥ò·¥á Ä…™·¥á…¥·¥Ñ·¥á ~>„Äé ${lvusu.contador} XP „Äè
‚ïΩ‚ïë
‚ïΩ‚ïü ‚Ä¢  ü·¥á·¥†·¥á ü ·¥Ö·¥áÍú± ô ü·¥è«´·¥ú·¥á·¥Ä·¥Ö·¥è ‚Ü¥
‚ïΩ‚ïë\t\t\t\t${lvusu.level-1} -> ${lvusu.level} üéüÔ∏è
‚ïΩ‚ïë
‚îï‚ï®‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚öã‚îö`
          blackmd.sendMessage(from, {text: txt, mentions: [usu]})
          break
        }
      }
    }
  }
}

if(isGroup && fs.existsSync(`./armor/jogo/mina-game/campo-minado-${from}.json`)) {
  game = `./armor/jogo/mina-game/campo-minado-${from}.json`
  campominado = JSON.parse(fs.readFileSync(game))
  if(campominado.come√ßou == false) {
    mini = budy2.toLowerCase().replace("√£", "a")
    if(campominado.chamado == sender) {
      if(mini === "sim" || mini === "s") {
        campominado.come√ßou = true
        campominado.jogadores.push({id: sender, erros: 3})
        saveJSON(campominado, game)
        txt = `‚ö†Ô∏è Aten√ß√£o @${campominado.criador.split("@")[0]}, ${getname(sender)} aceitou seu desafio üí£üòú\nEscreva a coordenada do campo para jogar e ${prefix}infominagame para obter mais informa√ß√µes\n\n${`‚ò∏Ô∏è1Ô∏è‚É£2Ô∏è‚É£3Ô∏è‚É£4Ô∏è‚É£5Ô∏è‚É£6Ô∏è‚É£7Ô∏è‚É£8Ô∏è‚É£9Ô∏è‚É£`.slice(0, Number(campominado.totalquad * 3) + 2)}`
        for(i = 1; i < (campominado.totalquad + 1); i++) {
          txt += `\n`
          if(i == 1) txt += ` Ôº° `
          if(i == 2) txt += ` Ôº¢ `
          if(i == 3) txt += ` Ôº£ `
          if(i == 4) txt += ` Ôº§ `
          if(i == 5) txt += ` Ôº• `
          if(i == 6) txt += ` Ôº¶ `
          if(i == 7) txt += ` Ôºß `
          if(i == 8) txt += ` Ôº® `
          if(i == 9) txt += ` Ôº© `
          txt += `üü´`.repeat(campominado.totalquad)
        }
        mention(txt)
      }
      if(mini === "nao" || mini === "n") {
        mention(`üòì Sinto muito @${campominado.criador.split("@")[0]}, ${getname(sender)} n√£o aceitou seu desafio (mata ele ${getname(campominado.criador)} üòà) üí£`)
        fs.unlinkSync(game)
      }
    }
  } else {
    if(isJsonIncludes(campominado.jogadores, sender)) {
      hehe = campominado.play == 0 ? 1 : 0
      mxm = campominado.totalquad
      delt = []
      for(v = 1; v < (mxm + 1); v++) {
        for(r = 1; r < (mxm + 1); r++) {
          if(r == 1) w = "a"
          if(r == 2) w = "b"
          if(r == 3) w = "c"
          if(r == 4) w = "d"
          if(r == 5) w = "e"
          if(r == 6) w = "f"
          if(r == 7) w = "g"
          if(r == 8) w = "h"
          if(r == 9) w = "i"
          delt.push(v+w)
        }
      }
      caixa = []
      for(a = 1; a < (mxm + 1); a++) {
        if(a == 1) { c = ` Ôº° `; c2 = "a" }
        if(a == 2) { c = ` Ôº¢ `; c2 = "b" }
        if(a == 3) { c = ` Ôº£ `; c2 = "c" }
        if(a == 4) { c = ` Ôº§ `; c2 = "d" }
        if(a == 5) { c = ` Ôº• `; c2 = "e" }
        if(a == 6) { c = ` Ôº¶ `; c2 = "f" }
        if(a == 7) { c = ` Ôºß `; c2 = "g" }
        if(a == 8) { c = ` Ôº® `; c2 = "h" }
        if(a == 9) { c = ` Ôº© `; c2 = "i" }
        caixa.push({letra: c, exp: []})
        for(b = 1; b < (mxm + 1); b++) {
          d = `${b + c2}`
          e = campominado.plantado.includes(d) ? campominado.minas.includes(d) ? `üí£` : `üü©` : `üü´`
          caixa[a - 1].exp.push({nmr: d, esc: e})
        }
      }
      rev = budy2.toLowerCase()
      miniletra = Number(rev.slice(0, 1)) ? rev : reverse(rev)
      if(delt.includes(miniletra)) {
        if(campominado.jogadores[campominado.play].id == sender) {
          if(campominado.plantado.includes(miniletra)) return reply("Coordenada j√° escolhida ü§¶üèª‚Äç‚ôÇÔ∏è")
          campominado.plantado.push(miniletra)
          campominado.play = hehe
          saveJSON(campominado, game)
          for(a1 = 0; a1 < caixa.length; a1++) {
            for(a2 = 0; a2 < caixa[a1].exp.length; a2++) {
              if(isJsonIncludes(campominado.plantado, miniletra) && miniletra == caixa[a1].exp[a2].nmr) {
                caixa[a1].exp[a2].esc = `üü©`
              }
            }
          }
          if(campominado.minas.includes(miniletra)) {
            AB = campominado.jogadores.map(t => t.id).indexOf(sender)
            if(campominado.jogadores[AB].erros > 1) {
              campominado.jogadores[AB].erros -= 1
              saveJSON(campominado, game)
              for(b1 = 0; b1 < caixa.length; b1++) {
                for(b2 = 0; b2 < caixa[b1].exp.length; b2++) {
                  if(isJsonIncludes(campominado.minas, miniletra) && miniletra == caixa[b1].exp[b2].nmr) {
                    caixa[b1].exp[b2].esc = `üí£`
                  }
                }
              }
              reply(`BOOM!! üí£ c√™ explodiu meu pr√ß üòÇ felizmente c√™ ainda tem +${campominado.jogadores[AB].erros} chance${Number(campominado.jogadores[AB].erros) > 1 ? "s" : ""}`)
            } else {
              for(b1 = 0; b1 < caixa.length; b1++) {
                for(b2 = 0; b2 < caixa[b1].exp.length; b2++) {
                  if(isJsonIncludes(campominado.minas, miniletra) && miniletra == caixa[b1].exp[b2].nmr) {
                    caixa[b1].exp[b2].esc = `üí£`
                  }
                }
              }
              mention(`„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§üèÜ *WIN!!!* üèÜ\n\n${`‚ò∏Ô∏è1Ô∏è‚É£2Ô∏è‚É£3Ô∏è‚É£4Ô∏è‚É£5Ô∏è‚É£6Ô∏è‚É£7Ô∏è‚É£8Ô∏è‚É£9Ô∏è‚É£`.slice(0, Number(campominado.totalquad * 3) + 2)}\n${caixa.map(x => x.letra+`${x.exp.map(y => y.esc).join("")}`).join(`\n`)}\n\n*@${sender.split("@")[0]} explodiu haha* üí£üòú\n*Parab√©ns @${campominado.jogadores[hehe].id.split("@")[0]} por ter sobrevivido... Voc√™ ganhou* üéâü•≥`)
              return fs.unlinkSync(game)
            }
          }
          //reboot
          await sleep(500)
          mention(`*Sua vez @${campominado.jogadores[hehe].id.split("@")[0]} üòú*\n${`‚ò∏Ô∏è1Ô∏è‚É£2Ô∏è‚É£3Ô∏è‚É£4Ô∏è‚É£5Ô∏è‚É£6Ô∏è‚É£7Ô∏è‚É£8Ô∏è‚É£9Ô∏è‚É£`.slice(0, Number(campominado.totalquad * 3) + 2)}\n${caixa.map(x => x.letra+`${x.exp.map(y => y.esc).join("")}`).join(`\n`)}`)
        } else return mention(`*Agora √© vez do @${campominado.jogadores[campominado.play].id.split("@")[0]} jogar* üí£`)
      }
    }
  }
}

if(isGroup && isJsonIncludes(adivinharnmr, from)) {
  AB = adivinharnmr.map(i => i.groupId).indexOf(from)
  AC = adivinharnmr[AB].participants.map(i => i.id).indexOf(sender)
  if(AC >= 0) {
    advnrnmr = adivinharnmr[AB].participants[AC]
    mini = rmLetras(budy2)
    if(!advnrnmr.fim) {
      if(mini == "pronto") {
        if(advnrnmr.progresso != 5) {
          if(advnrnmr.progresso == 0) txt = `üßôüèΩ‚Äç‚ôÇÔ∏è _*Passo n¬∫1:* pense em um n√∫mero aleat√≥rio entre 5-50_`
          if(advnrnmr.progresso == 1) txt = `üßôüèΩ‚Äç‚ôÇÔ∏è _*Passo n¬∫2:* multiplique esse n√∫mero por 2_`
          if(advnrnmr.progresso == 2) {
            nmr = (alerandom(14) + 1) * 2
            advnrnmr.resultado = nmr / 2
            saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
            txt = `üßôüèΩ‚Äç‚ôÇÔ∏è _*Passo n¬∫3:* agora adicione +${nmr} a este resultado_`
          }
          if(advnrnmr.progresso == 3) txt = `üßôüèΩ‚Äç‚ôÇÔ∏è _*Passo n¬∫4:* feito isso, divida o resultado por 2_`
          if(advnrnmr.progresso == 4) txt = `üßôüèΩ‚Äç‚ôÇÔ∏è _*Passo n¬∫5:* agora subtraia este resultado pelo primeiro n√∫mero que voc√™ pensou_`
          advnrnmr.progresso += 1
          saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
          return reply(txt)
        } else {
          advnrnmr.fim = true
          saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
          return reply(`üßôüèΩ‚Äç‚ôÇÔ∏è _Pela minha extrema sabedoria, posso presumir que o resultado final seja igual a ‚Ü¥_\n\t\t\t\t\t\t\t¬ª ${advnrnmr.resultado} ¬´\n\n_Se eu acertei, digite *"sim"...* Caso contr√°rio, digite *"n√£o"* (sem as aspas √© claro)_`)
        }
      }
    } else {
      if(mini == "sim" || mini == "nao") {
        snrp = mini == "sim" ? "üßôüèΩ‚Äç‚ôÇÔ∏è O grande s√°bio sempre tem todas as respostas ‚ú®" : "üßôüèΩ‚Äç‚ôÇÔ∏è Podes mentir o quanto quiser, mas n√≥s dois sabemos a resposta..."
        adivinharnmr[AB].participants.splice(AC, 1)
        saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
        return reply(snrp)
      }
    }
  }
}

//in√≠cio do anagrama
if(fs.existsSync(`./armor/jogo/anagrama/anagrama-${from}.json`) && isGroup && isModobn) {
  ana = alerandom(palavrasANA.length)
  anagrama = `./armor/jogo/anagrama/anagrama-${from}.json`
  dataAnagrama = JSON.parse(fs.readFileSync(anagrama))
  if(rmLetras(budy2.toLowerCase().slice(0, 4)) == rmLetras(dataAnagrama.original.toLowerCase().slice(0, 4)) && rmLetras(budy2.toLowerCase()) != rmLetras(dataAnagrama.original.toLowerCase())) return reply(`Quase l√° ${pushname}`)
  if(rmLetras(budy2.toLowerCase()) == rmLetras(dataAnagrama.original.toLowerCase())) {
    var bglh = [
      `[ ‚ùó ] Irei reiniciar o jogo em 3Ô∏è‚É£`,
      `[ ‚ùó ] Irei reiniciar o jogo em 2Ô∏è‚É£`,
      `[ ‚ùó ] Irei reiniciar o jogo em 1Ô∏è‚É£`,
      `‚úÖ START THE GAME ‚úÖ`
    ]
    let { key } = await blackmd.sendMessage(from, {text: `Parab√©ns ${pushname}, voc√™ acertou a palavra do anagrama... üéâü•≥`}, {quoted: info})//primeira mensagem
    await sleep(1000)
    for(let i = 0; i < bglh.length; i++) {
      await sleep(1000)
      await blackmd.sendMessage(from, {text: bglh[i], edit: key }, {quoted: info})
    }
    saveJSON(palavrasANA[ana], anagrama)
    blackmd.sendMessage(from, {text: `
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚âΩ„Äå üëæ ANAGRAMA üëæ „Äç
‚îÇ‚ûΩ *DESCUBRA A PALAVRA*
‚îÇ‚ûΩ *ANAGRAMA:* ${shuffle(palavrasANA[ana].embaralhada)}
‚îÇ‚ûΩ *DICA:* ${palavrasANA[ana].dica}
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
`}, {quoted: info})
  }
}
//fim do anagrama

if(fs.existsSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`) && budy2.includes(`${JSON.parse(fs.readFileSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)).original.toLowerCase().replace("√£", "a").replace("√°", "a").replace("√™", "e").replace("√©", "e").replace("√≠", "i").replace("√≥", "o").replace("√¥", "o").replace("√∫", "u")}`) && isGroup && args.length <= 2) {
fs.unlinkSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)
var bglh = [
`[ ‚ùó ] Irei reiniciar o jogo em 3Ô∏è‚É£`,
`[ ‚ùó ] Irei reiniciar o jogo em 2Ô∏è‚É£`,
`[ ‚ùó ] Irei reiniciar o jogo em 1Ô∏è‚É£`,
`‚úÖ START THE GAME ‚úÖ`
]
let { key } = await blackmd.sendMessage(from, {text: `Parab√©ns, voc√™ acertou o animal üéâ`}, {quoted: seloctt})//primeira mensagem
await sleep(1000)
for(let i = 0; i < bglh.length; i++) {
await sleep(1000)
await blackmd.sendMessage(from, {text: bglh[i], edit: key }, {quoted: seloctt})
}
matheuzinho = Math.floor(Math.random() * quizanimais.length)
fs.writeFileSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`, `${JSON.stringify(quizanimais[matheuzinho])}`)
blackmd.sendMessage(from, {image: {url: quizanimais[matheuzinho].foto}, caption: `\n‚úîÔ∏è ùôåùôêùôÑùôï ùòºùôâùôÑùôàùòºùôÑùôé ‚úîÔ∏è\n\nüåö‚É§ ùòøùôöùô®ùôòùô™ùôóùôßùôñ ùôä ùòºùô£ùôûùô¢ùôñùô° ‚Üë‚Üë‚Üë\n`})
}

if(body != undefined) {
  if(!isJsonIncludes(pushnames, botNumber)) {
      pushnames.push({id: botNumber, nick: NomeDoBot})
      saveJSON(pushnames, "./basededados/pushnames.json")
    } else {
      AC = pushnames.map(i => i.id).indexOf(botNumber)
      pushnames[AC].nick = NomeDoBot
      saveJSON(pushnames, "./basededados/pushnames.json")
    }
    if(!isJsonIncludes(pushnames, sender)) {
      pushnames.push({id: sender, nick: pushTestName})
      saveJSON(pushnames, "./basededados/pushnames.json")
    } else {
      AB = pushnames.map(i => i.id).indexOf(sender)
      pushnames[AB].nick = pushTestName
      saveJSON(pushnames, "./basededados/pushnames.json")
    }
  }

//fun√ß√£o do mute
if(body != undefined && !info.message?.reactionMessage?.text && isJsonIncludes(mute, from) && isBotGroupAdmins) {
  A1 = mute.map(i => i.gpid).indexOf(from)
  if(isJsonIncludes(mute[A1].mutados, sender)) {
    A2 = mute[A1].mutados.map(a => a.id).indexOf(sender)
    if(mute[A1].mutados[A2].sn == false) {
      mute[A1].mutados[A2].sn = true
      saveJSON(mute, "./basededados/mute.json")
      reply(`Voc√™ foi avisado ${pushname}... Voc√™ tem 30 segundos para declarar suas √∫ltimas palavras üò•`)
      await sleep(30000)
      B1 = mute.map(i => i.gpid).indexOf(from)
      if(isJsonIncludes(mute[B1].mutados, sender)) {
        B2 = mute[B1].mutados.map(a => a.id).indexOf(sender)
        mute[B1].mutados.splice(B2, 1)
        saveJSON(mute, "./basededados/mute.json")
        remover(from, sender)
        await sleep(2000)
        sendMess(from, `Falta de aviso n√£o foi...`)
      }
    }
  }
}

if(JSON.stringify(music).includes(from) && isGroup) {
  AB = music.map(i => i.groupId).indexOf(from)
  if(JSON.stringify(music[AB].usus).includes(sender)) {
    BC = music[AB].usus.map(i => i.id).indexOf(sender)
    if(budy2.toLowerCase().replace("√°", "a") === `audio` && isGroup) {
      link = music[AB].usus[BC].urlAudio.replace(`#API_KEY_ALEATORY#`, API_KEY_ALEATORY).replace(`#API_KEY_SABRINA#`, API_KEY_SABRINA).replace(`#API_KEY_BLACK#`, API_KEY_BLACK)
      music[AB].usus.splice(BC, 1)
      fs.writeFileSync("./basededados/music.json", JSON.stringify(music, null, 2))
      try {
        reply(`‚ñß‚ÉØ‚Éüùô¥ùöóùöüùöíùöäùöóùöçùöò ùöÇùöûùöä ùôº√∫ùöúùöíùöåùöäÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
        blackmd.sendMessage(from, {audio: {url: link}, mimetype: "audio/mpeg"}, {quoted: seloctt}).catch(e => {
          return reply(downon)
        })
      } catch (e) {
        return reply(downoff)
      }
    }
    if(budy2.toLowerCase().replace("√≠", "i") === `video` && isGroup) {
      link = music[AB].usus[BC].urlVideo.replace(`#API_KEY_ALEATORY#`, API_KEY_ALEATORY).replace(`#API_KEY_SABRINA#`, API_KEY_SABRINA).replace(`#API_KEY_BLACK#`, API_KEY_BLACK)
      music[AB].usus.splice(BC, 1)
      fs.writeFileSync("./basededados/music.json", JSON.stringify(music, null, 2))
      try {
        reply(`‚ñß‚ÉØ‚Éüùô¥ùöóùöüùöíùöäùöóùöçùöò ùöÖ√≠ùöçùöéùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
        blackmd.sendMessage(from, {video: {url: link}, mimetype: "video/mp4"}, {quoted: seloctt}).catch(e => {
          return reply(downon)
        })
      } catch (e) {
        return reply(downoff)
      }
    }
    if(budy2.toLowerCase() === `doc` && isGroup) {
      link = music[AB].usus[BC].urlAudio.replace(`#API_KEY_ALEATORY#`, API_KEY_ALEATORY).replace(`#API_KEY_SABRINA#`, API_KEY_SABRINA).replace(`#API_KEY_BLACK#`, API_KEY_BLACK)
      nome = music[AB].usus[BC].title
      music[AB].usus.splice(BC, 1)
      fs.writeFileSync("./basededados/music.json", JSON.stringify(music, null, 2))
      try {
        reply(`‚ñß‚ÉØ‚Éüùô¥ùöóùöüùöíùöäùöóùöçùöò ùô≥ùöòùöåùöûùöñùöéùöóùöùùöòÕò‡∏∫.‚Ä¢üõ∏ ›á›à‚îÄ`)
        blackmd.sendMessage(from, {document: {url: link}, fileName: nome+'.mp3', mimetype: "audio/mpeg"}, {quoted: info}).catch(e => {
          return reply(downon)
        })
      } catch (e) {
        return reply(downoff)
      }
    }
  }
}

if(JSON.stringify(vdddsf).includes(from) && isGroup) {
  AB = vdddsf.map(b => b.idgp).indexOf(from)
  if(JSON.stringify(vdddsf[AB].jogadores).includes(sender)) {
    BC = vdddsf.map(a => a.idvd).indexOf("matheuzinho")
    CD = vdddsf[AB].jogadores.map(i => i.id).indexOf(sender)
    if(budy2.toLowerCase() === "verdade") {
      if(vdddsf[AB].jogadores[CD].tipo == 1) {
        vdddsf[AB].jogadores.splice(CD, 1)
        fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
        sendStickerFromUrl(from, `https://telegra.ph/file/4b43ac115d66362540612.jpg`)
      } else if(vdddsf[AB].jogadores[CD].tipo <= 0) {
        alevdd = Math.floor(Math.random() * vdddsf[BC].verdades.length)
        vdddsf[AB].jogadores[CD].vdouds = vdddsf[BC].verdades[alevdd].vdd
        vdddsf[AB].jogadores[CD].tipo = 1
        fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
        reply(`\`\`\`üòá Verdade Ou Desafio üòà\`\`\`
„Äé VERDADE „Äè
‚úì -> ${vdddsf[BC].verdades[alevdd].vdd}

_(responda com verdade ou mentira)_`)
      }
    }
    if(budy2.toLowerCase() === "mentira") {
      vdddsf[AB].jogadores.splice(CD, 1)
      fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
      sendStickerFromUrl(from, `https://telegra.ph/file/22e467ada05df439e3401.jpg`)
    }
    if(budy2.toLowerCase() === "desafio") {
      aledsf = Math.floor(Math.random() * vdddsf[BC].desafios.length)
      vdddsf[AB].jogadores[CD].vdouds = vdddsf[BC].desafios[aledsf].dsf
      vdddsf[AB].jogadores[CD].tipo = 2
      fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
      reply(`\`\`\`üòá Verdade Ou Desafio üòà\`\`\`
„Äé DESAFIO „Äè
‚úì -> ${vdddsf[BC].desafios[aledsf].dsf}

_(quando concluir o desafio, use ${prefix}pronto)_`)
    }
  }
}

if(body != undefined && isGroup && bcgp.length > 0) {
  AB = bcgp.map(i => i.tipo).indexOf("mensagem")
  AC = bcgp.map(i => i.tipo).indexOf("grupos")
  if(bcgp[AB].msg.length <= 0) return
  if(bcgp[AC].gps.length <= 0) return
  if(!JSON.stringify(bcgp[AC].gps).includes(from)) {
    grupo = from
    m = bcgp[AB].msg[0]
    if(m.cobrado == false) {
      msgEmMassa = m.txt
      m.cobrado = true
      fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
      for(i of somembros) {
        blackmd.sendMessage(i, {text: msgEmMassa})
      }
      await sleep(5000)
      blackmd.groupLeave(grupo)
      bcgp[AB].msg.splice(0, 1)
      fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
      if(bcgp[AB].msg.length > 0) {
        bcgp[AC].gps.push({groupId: grupo})
        fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
      } else {
        bcgp[AC].gps = []
        fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
      }
    }
  }
}

//in√≠cio do akinator

if(isGroup && isJsonIncludes(akinator, from)) {
  AB = akinator.map(i => i.id).indexOf(from)
  if(akinator[AB].jogador == sender && Number(akinator[AB].dia) === Number(sendHours("DD"))) {
    mini = budy2.toLowerCase().replace("√£", "a")
    if(mini == "sim" || mini == "s" || mini == "nao" || mini == "n" || mini == "nao sei" || mini == "nsei" || mini == "provavelmente sim" || mini == "tlvz sim" || mini == "talvez sim" || mini == "provavelmente nao" || mini == "tlvz nao" || mini == "talvez nao") {
      if(akinator[AB].finish > 0) {
        if(mini == "sim" || mini == "s") {
          akinator.splice(AB, 1)
          saveJSON(akinator, "./armor/jogo/akinator.json")
          reply(`Sabia mlk, eu sou demais ü•≥`)
        } else if(mini == "nao" || mini == "n") {
          akinator.splice(AB, 1)
          saveJSON(akinator, "./armor/jogo/akinator.json")
          reply(`Hmm n√£o foi dessa vez... Quem sabe na pr√≥xima üßôüèº‚Äç‚ôÇÔ∏è`)
        }
      } else {
        if(aki.progress >= 90 || aki.currentStep >= 90) {
          await aki.win()
          jogo.now = true
          akinator[AB].finish += 1
          saveJSON(akinator, "./armor/jogo/akinator.json")
          i = aki.answers[0]
          txt = `„Äé ${i.name}: ${i.description} „Äè\nüßôüèº‚Äç‚ôÇÔ∏è Hmm, acho que o seu personagem √© esse aqui... Acertei ? _(responda com "sim" ou "n√£o", sem as aspas)_`
          sendImage(from, i.absolute_picture_path, txt, seloctt)
        } else {
          if(mini == "sim" || mini == "s") nmr = "0"
          if(mini == "nao" || mini == "n") nmr = "1"
          if(mini == "nao sei" || mini == "nsei") nmr = "2"
          if(mini == "provavelmente sim" || mini == "tlvz sim" || mini == "talvez sim") nmr = "3"
          if(mini == "provavelmente nao" || mini == "tlvz nao" || mini == "talvez nao") nmr = "4"
          per = progresso(aki.progress, 100)
          await aki.step(nmr)
          reply(`*‚è§ÕüÕûÕüÕû Í¶øAKINATOR* üßôüèº‚Äç‚ôÇÔ∏è\nüîÆ‚É§ ${aki.question}\n\n${per}`)
        }
      }
    }
  }
}

//fim do akinator

async function msgGlobal() {
  if(gbmsg[1].msg.length > 0) {
    if(gbmsg[0].gp.length > 0) {
      horacerta = moment.tz('America/Sao_Paulo').format('HH:mm')
      day = moment.tz('America/Sao_Paulo').format('DD')
      for(a of gbmsg[1].msg) {
        if(Number(a.time.replace(":", "")) === Number(horacerta.replace(":", ""))) {
          if(Number(a.save) !== Number(day)) {
            a.save = day
            fs.writeFileSync("./basededados/gbmsg.json", JSON.stringify(gbmsg, null, 2))
            for(b of gbmsg[0].gp) {
              setTimeout(() => {
                blackmd.sendMessage(b.id, {text: a.frase})
              }, 1000)//1 segundo
            }
          }
        }
      }
    }
  }
}

msgGlobal();

async function funcgpByM4() {
  if(funcgp.length > 0) {
    for(a of funcgp) {
      config = funcgp.map(i => i.id).indexOf(a.id)
      if(a.tabela.length > 0) {
        for(b of a.tabela) {
          if(b.tipo == 1) tgp = "ss"
          if(b.tipo == 2) tgp = "mm"
          if(b.tipo == 3) tgp = "HH"
          if(Number(b.save) !== Number(moment.tz('America/Sao_Paulo').format(tgp))) {
            b.save = Number(moment.tz('America/Sao_Paulo').format(tgp))
            fs.writeFileSync("./basedefuncionamento/funcgp.json", JSON.stringify(funcgp, null, 2))
            if(b.tempo > 1) {
              b.tempo -= 1
              fs.writeFileSync("./basedefuncionamento/funcgp.json", JSON.stringify(funcgp, null, 2))
            } else {
              if(b.poder == 1) {
                blackmd.groupSettingUpdate(a.id, 'announcement')
                sendMess(a.id, `[ ‚ùó ] O grupo foi fechado ap√≥s ${b.ordem} pelo ADM ${b.nome} ‚ùå`)
                closegp = funcgp[config].tabela.map(i => i.idfunc).indexOf(b.idfunc)
                funcgp[config].tabela.splice(closegp, 1)
                fs.writeFileSync("./basedefuncionamento/funcgp.json", JSON.stringify(funcgp, null, 2))
              } else {
                blackmd.groupSettingUpdate(a.id, 'not_announcement')
                sendMess(a.id, `[ ‚ùï ] O grupo foi aberto ap√≥s ${b.ordem} pelo ADM ${b.nome} ‚úÖ`)
                opengp = funcgp[config].tabela.map(i => i.idfunc).indexOf(b.idfunc)
                funcgp[config].tabela.splice(opengp, 1)
                fs.writeFileSync("./basedefuncionamento/funcgp.json", JSON.stringify(funcgp, null, 2))
              }
            }
          }
        }
      }
    }
  }
}

funcgpByM4();


async function avisosByMath() {
  if(avisos.length != 0) {
    for( i of avisos ) {
      if(i.groupId != "matheuzinho") {
        if(i.module == true) {
          if(i.mensagens.length != 0) {
            for( w of i.mensagens ) {
              if(Number(w.tempo.replace(":", "")) === Number(moment.tz('America/Sao_Paulo').format('HHmm')) && Number(w.dia) !== Number(moment.tz('America/Sao_Paulo').format('DD'))) {
                blackmd.sendMessage(i.groupId, {text: w.msg})
                w.dia = moment.tz('America/Sao_Paulo').format('DD')
                fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
              }
            }
          }
          BH = avisos.map(n => n.groupId).indexOf("matheuzinho")
          if(i.aleatory.length != 0) {
            for( a of i.aleatory ) {
              if(Number(a.tempo.replace(":", "")) === Number(moment.tz('America/Sao_Paulo').format('HHmm')) && Number(a.dia) !== Number(moment.tz('America/Sao_Paulo').format('DD'))) {
                if(a.ativation == 1 && i.globalAleatory.length <= 1) return
                if(a.ativation == 2 && avisos[BH].mensagens.length <= 1) return
                if(Number(a.ativation) <= 1) {
                  testMsg1 = i.globalAleatory
                  testMsg2 = testMsg1[Math.floor(Math.random()*testMsg1.length)]
                } else {
                  testMsg1 = avisos[BH].mensagens
                  testMsg2 = testMsg1[Math.floor(Math.random()*testMsg1.length)]
                }
                blackmd.sendMessage(i.groupId, {text: testMsg2})
                a.dia = moment.tz('America/Sao_Paulo').format('DD')
                fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
              }
            }
          }
        }
      }
    }
  }
}

avisosByMath();

if(budy2 === `${Number(body.split('!')[0])}!` && Number(body.split('!')[0]) > 2 && isGroup) {
  nmrX = Number(body.split('!')[0])
  nmrY = nmrX - 1
  for(i = nmrY; i > 0; i--) {
    nmrX *= i
  }
  reply(`${nmrX}`)
}

//========================================\\
}
}
}
msgupsrt().catch(async(e) => {
if(JSON.stringify(e).includes(API_KEY_BLACK)) {
return console.log("A api caiu ou n√£o foi possivel executar esta a√ß√£o., espere retornar")   
} else if(String(e).includes("Erro: aborted")) {
file = require.resolve("./start.js")  
delete require.cache[file]
require(file)
} else {
return console.log(e)
}
})
}
}
}
startBlack().catch(e => {
return console.log(e+" -INDEX..ERROS")
})

// Atualizar a Index.js automaticamente sempre que modificar alguma coisa \\
// Cr√©ditos: Victor Gabriel / Sabrina-bot
let file = require.resolve(__filename)
fs.watchFile(file, () => {
fs.unwatchFile(file);
console.log(colors.red(`Altera√ß√µes salvas - '${__filename}'`));
delete require.cache[file]
require(file)
})

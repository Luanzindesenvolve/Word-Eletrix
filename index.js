//｡☆✼★━━━━━━━━━━━━━━━━★✼☆｡
//.        LADY BUG BUTECA
//｡☆✼★━━━━━━━━━━━━━━━━★✼☆｡
//const express = require('express');
//const app = express();
//const PORT = process.env.PORT || 3000;

// Define a porta aqui

// Rota básica
//app.get('/', (req, res) => {
//  res.send('Lady bot esta online!');
//});

// Inicia o servidor
//app.listen(PORT, () => {
//  console.log(`Servidor rodando na porta ${PORT}`);
//});

//=======================================*/

const { downloadContentFromMessage, relayWAMessage, mentionedJid, processTime, MediaType, Browser, MessageType, Presence, Mimetype, Browsers, delay, getLastMessageInChat, prepareWAMessageMedia } = require('@whiskeysockets/baileys');

//_-_-_-__-_-_-_-_-_-MODULOS/FUNÇÕES-_-_-_-_-_-__-_-_-_-_-\\

const { fs, Boom, axios, yts, crypto, util, P, linkfy, request, cheerio, ms, ffmpeg, webp_mp4, qrterminal, exec, spawn, execSync, moment, color, time, hora, date, getBuffer, convertSticker, recognize, fetchJson, fetchText, getBase64, createExif, response, addLimit, upload, nit, sesc, validmove, setGame, addComandosId, deleteComandos, getComandoBlock, getComandos, addComandos, palavrasANA, quizanimais, getpc, supre, wait, getExtension, generateMessageID, getGroupAdmins, getMembros, getRandom, banner2, banner3, isFiltered, addFilter, temporizador, chyt, kyun, simih, botoff, colors, comand, sendButton, sendListB, sendRoulette, sendPayment, RSM_FUNC, saveJSON, isJsonIncludes, alerandom, letras, randomLetra, getname, addNumberMais, identArroba, iniMai, contar, gerarkey, sendHours, rmLetras, replaceAll, contarMin, contarDias, converterDias, converterMin, allvaluerent, sendFutureTime, isIDacc, GenerateQRpix, sendRouletteButton, nicks } = require('./config.js');

const jimp = require('jimp')

const { arcloud } = require('./arcc.js')

const AssemblyAI = require("assemblyai");

const assemblyApiKey = '1448709aa4044b21934de9aca30509c2'

const { payment } = require("./mercado-pago-API/index.js")

const dataMP = JSON.parse(fs.readFileSync(`./dono/mercado pago.json`))

const { superimg } = require("./database/superimg.js")

//-_-_-_-_-_--_-_-_-_-JS-MENUS/INFORMAÇÕES-_-_-_-_-_-_-_-_-_-_\\

const { anotacao, infocontador, infobemvindo, infolistanegra, infotransmitir, infopalavrao, infobancarac, configbot, cmd_termux, destrava, destrava2, tabela, conselhob, palavrasc, joguinhodavelhajs, joguinhodavelhajs2, obrigadoEXT, setting, logoslink, globegroup, music, tinder, amongus, vdddsf, akinator, mute, figname, countMessage, sendVideoAsSticker, sendImageAsSticker, sendVideoAsSticker2, sendImageAsSticker2, sotoy, daily, comandos, limitefll, addVote, delVote, antispam, anotar, enviarfiguUrl, getFileBuffer, DLT_FL, sleep, antiModLetra, convertBytes, pushnames, ausentes, avisos, funcgp, revealmsg, adsgp, bcgp, rankcmd } = require('./config.js');

//_-_-_-_-_-_-_-_-_-_-_-_-(INFOS)_-_-_-_-_-_-_-_-_-_-_-_-_-_-_--\\
var { botoes, forwarding, crtt, visualizarmsg, modoaluguel, API_KEY_ALEATORY, API_KEY_SABRINA, API_KEY_BLACK, API_KEY_CONSULT, stopcmdlist, site, blackchannel, idchatofc, idprivategp, dono1, dono2, dono3, dono4, dono5, dono6 } = require("./dono/config-all.json");

var { NomeDoBot, NickDono, prefix } = require("./dono/settings.json");

const { __esModule } = require('cheerio');

const figurinhas = JSON.parse(fs.readFileSync("./database/data/figurinhas.json"));

const recolherLNK = JSON.parse(fs.readFileSync("./armor/funcoes/recolherLNK.json"));

const links = JSON.parse(fs.readFileSync('./basededados/links.json'));

//====================≠≠===============\\
 
var numerodono_ofc = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "");

var nmrdnCmMais = "+" + numerodono_ofc.slice(0, 2) + " " + numerodono_ofc.slice(2, 4) + " " + numerodono_ofc.slice(4, numerodono_ofc.length - 4) + "-" + numerodono_ofc.slice(numerodono_ofc.length - 4, numerodono_ofc.length)

async function reiniciarBLK() {
file = require.resolve("./start.js");
delete require.cache[file];
require(file);
}

var AsMsg = [];

// ABAIXO: INÍCIO DE CONEXÃO

async function startBlack() {

module.exports = blackmd = async(blackmd, qrcode) => {
module.exports = upsert = async(upsert, blackmd) => {
async function msgupsrt() {
const nmrdn_dono2 = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "") + "@s.whatsapp.net";

var hora120 = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

RSM_FUNC(blackmd, nmrdn_dono2, hora120, upsert);

for (const info of upsert?.messages || []) {

const from = info.key.remoteJid;
const isGroup = from.endsWith('@g.us');

if(fs.existsSync(`./basededados/grupos/${from}.json`)) {
var jsonGp = JSON.parse(fs.readFileSync(`./basededados/grupos/${from}.json`));
}

// 🇸 🇮 🇲 🇵 🇱 🇮 🇫 🇮 🇨 🇦 🇨 🇴 🇪 🇸 \\
// RODAR COMANDOS DE OUTROS BOTS \\

var conn = blackmd
var japa = blackmd
var aqua = blackmd
var lukaz = blackmd
var pl = blackmd
var vieno = blackmd
var mikasa = blackmd
var sabrina = blackmd
var chris = blackmd
var kaic = blackmd
var kimbler = blackmd
var vitu = blackmd
var lulu = blackmd
var loli = blackmd

if(fs.existsSync(`./basededados/grupos/${from}.json`) && jsonGp[0].x9 && info.messageStubType){
switch(info.messageStubType){
case 29:
await delay(1000);
blackmd.sendMessage(info.key.remoteJid, {text: `@${info.participant.split("@")[0]} *acaba de promover o/a* @${info.messageStubParameters[0].split("@")[0]} *à ADM do grupo...* 👑`
, mentions: [info.messageStubParameters[0], info.participant]});
break;
case 30:
await delay(1000);
blackmd.sendMessage(info.key.remoteJid, {
text: `@${info.participant.split("@")[0]} *acaba de rebaixar o/a* @${info.messageStubParameters[0].split("@")[0]} *à membro comum do grupo...* 🥲`
, mentions: [info.messageStubParameters[0], info.participant]});
break;
}}
  
if(!info.message) return;
if(upsert.type == "append") return;  
const baileys = require('@whiskeysockets/baileys');
const type = baileys.getContentType(info.message);
const content = JSON.stringify(info.message);
const pushTestName = info.pushName ? info.pushName : 'Usuário';
if(visualizarmsg) {
await blackmd.readMessages([info.key]);
} else {
if(from == "status@broadcast") return;
}

global.prefix;
global.blocked;

const speed = require('performance-now');

//==============(BODY)================\\

var body = type === "conversation" ? info.message.conversation : type == "editedMessage" ? info.message.editedMessage.message.protocolMessage.editedMessage?.conversation || info.message.editedMessage.message.protocolMessage.editedMessage?.imageMessage?.caption || info.message.editedMessage.message.protocolMessage.editedMessage?.videoMessage?.caption || info.message.editedMessage.message.protocolMessage.editedMessage?.documentMessage?.caption : type === "viewOnceMessageV2" ? info.message.viewOnceMessageV2.message.imageMessage ? info.message.viewOnceMessageV2.message.imageMessage.caption : info.message.viewOnceMessageV2.message.videoMessage.caption : type === "imageMessage" ? info.message.imageMessage.caption : type === "videoMessage" ? info.message.videoMessage.caption : type === "extendedTextMessage" ? info.message.extendedTextMessage.text : type === "viewOnceMessage" ? info.message.viewOnceMessage.message.videoMessage ? info.message.viewOnceMessage.message.videoMessage.caption : info.message.viewOnceMessage.message.imageMessage.caption : type === "documentWithCaptionMessage" ? info.message.documentWithCaptionMessage.message.documentMessage.caption : type === "buttonsMessage" ? info.message.buttonsMessage.imageMessage.caption : type === "buttonsResponseMessage" ? info.message.buttonsResponseMessage.selectedButtonId : type === "listResponseMessage" ? info.message.listResponseMessage.singleSelectReply.selectedRowId : type === "templateButtonReplyMessage" ? info.message.templateButtonReplyMessage.selectedId : type === "groupInviteMessage" ? info.message.groupInviteMessage.caption : type === "pollCreationMessageV3" ? info.message.pollCreationMessageV3 : type === "interactiveResponseMessage" ? JSON.parse(info.message.interactiveResponseMessage.nativeFlowResponseMessage.paramsJson).id : type === "text" ? info.text : ""

var Procurar_String = info.message?.conversation || info.message?.viewOnceMessageV2?.message?.imageMessage?.caption || info.message?.viewOnceMessageV2?.message?.videoMessage?.caption || info.message?.imageMessage?.caption || info.message?.videoMessage?.caption || info.message?.extendedTextMessage?.text || info.message?.viewOnceMessage?.message?.videoMessage?.caption || info.message?.viewOnceMessage?.message?.imageMessage?.caption || info.message?.documentWithCaptionMessage?.message?.documentMessage?.caption || info.message?.buttonsMessage?.imageMessage?.caption || ""

const args = body.trim().split(/ +/).slice(1);

var budy2 = body.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

if(isGroup && fs.existsSync(`./basededados/grupos/${from}.json`) && jsonGp[0].multiprefix) {
var prefix = jsonGp[0]?.prefixos[jsonGp[0]?.prefixos?.indexOf(String(body)?.trim()?.charAt(0))] || jsonGp[0].prefixos[0]
}

if(isGroup && fs.existsSync(`./basededados/grupos/${from}.json`) && !jsonGp[0].multiprefix) {
var prefix = setting.prefix;
} else if(!isGroup) {
var prefix = setting.prefix
};

var isCmd = body.trim().startsWith(prefix);

const command = isCmd ? budy2.trim().slice(1).split(/ +/).shift().toLocaleLowerCase(): null;

const q_2 = budy2.trim().split(/ +/).slice(1).join(' ');

const q = args.join(' ');

var budy = (type === 'conversation') ? info.message?.conversation : (type === 'extendedTextMessage') ? info.message?.extendedTextMessage?.text : '';

var budy3 = budy.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

var PR_String = Procurar_String.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

const q_ofc = PR_String.trim().split(/ +/).slice(1).join(" ");

//======================================\\

try {var groupMetadata = isGroup ? await blackmd.groupMetadata(from): ""} catch {return}

const groupName = isGroup ? groupMetadata.subject : '';

const sender = isGroup ? info.key.participant.includes(':') ? info.key.participant.split(':')[0] +'@s.whatsapp.net': info.key.participant : info.key.remoteJid;

const pushname = JSON.stringify(pushnames).includes(sender) ? pushnames[pushnames.map(i => i.id).indexOf(sender)].nick : pushTestName

const messagesC = PR_String.slice(0).trim().split(/ +/).shift().toLowerCase();

const arg = body.substring(body.indexOf(' ') + 1);

const botNumber = await blackmd.user.id.split(':')[0]+'@s.whatsapp.net';
const argss = body.split(/ +/g);
const testat = body;
const ants = body;

const groupDesc = isGroup ? groupMetadata.desc : ''

const groupMembers = isGroup ? groupMetadata.participants : ''

const isnit = nit.includes(sender) 

const issupre = supre.includes(sender)

const ischyt = chyt.includes(sender)

const isSesc = sesc.includes(sender)

const groupAdmins = isGroup ? getGroupAdmins(groupMembers) : ''

const somembros = isGroup ? getMembros(groupMembers) : ''

const apikeymeta = `https://raw.githubusercontent.com/iamriz7/kopel_/main/kopel.json`

//=======================================\\

const nmrdn = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` || isnit

const numerodono = [`${nmrdn}`, `${dono1}@s.whatsapp.net`, `${dono2}@s.whatsapp.net`, `${dono3}@s.whatsapp.net`, `${dono4}@s.whatsapp.net`, `${dono5}@s.whatsapp.net`, `${dono6}@s.whatsapp.net`]

//============(SORTEIO-CONST)============\\

const { infosorteio } = require('./armor/js/infosorteio.js')

//===========(enviar.espere)=============\\

const { pia } = require('./armor/js/piadas.js');

const { mensagens } = require('./armor/js/aleatoria.js');

const { sortear } = require('./armor/js/aleatoria.js');

var enviarmen = mensagens[Math.floor(Math.random() * mensagens.length)];

react1 = ['❤️', '🧡', '💛', '💚', '💙', '💜', '🖤', '🤍', '🤎', '❤‍🔥', '❤‍🩹', '💞', '💗', '💖'];

react2 = react1[Math.floor(Math.random()*react1.length)]

//================BANNED===================\\

const { banned, saveBannedUsu, isBanned, banirUsuario, desbanirUsuario, getBannedUsu, bannedExpired, isBannedMessageUsu } = require("./basededados/banusu/ban.js")

//================ALL-VIP===================\\

const { vip, saveVip, addVip, rmVip, delVip, getUsuVip, isOnlyVip, isAdvencedVip, isInfinityVip, vipTime, vipgp, saveGroupVip, addGroupVip, delGroupVip, getGroupVip, isOnlyGroupVip, isAdvencedGroupVip, isInfinityGroupVip, vipGroupTime, valoresVIP } = require("./basededados/all-vip/vip-config.js")

//================RPG-FUNC===================\\
//SISTEMA RPG\\

const caussa = JSON.parse(fs.readFileSync('./funcoes_rpg/caussa/caussa.json'));

const anotar = JSON.parse(fs.readFileSync('./database/func/tabela/anotar.json'));

const tagrico = JSON.parse(fs.readFileSync('./funcoes_rpg/tagrico/tagrico.json'));

const sapato = JSON.parse(fs.readFileSync('./funcoes_rpg/sapato/sapato.json'));

const palitor = JSON.parse(fs.readFileSync('./funcoes_rpg/palitor/palitor.json'));
const carab = JSON.parse(fs.readFileSync('./funcoes_rpg/carab/carab.json'));
const casa = JSON.parse(fs.readFileSync('./funcoes_rpg/casa/casa.json'));
const aguacoco = JSON.parse(fs.readFileSync('./funcoes_rpg/agua/aguacoco.json'));

const roupab = JSON.parse(fs.readFileSync('./funcoes_rpg/roupa/roupab.json'));

const dindin = JSON.parse(fs.readFileSync("./funcoes_rpg/dinheiro/dindin.json"));
const espada = JSON.parse(fs.readFileSync('./funcoes_rpg/espada/espada.json'));
// RPG

// Agora sim pode fazer includes
const isRoupab = roupab.includes(sender)
const iscasa = casa.includes(sender)
const isaguacoco = aguacoco.includes(sender)
const isCarab = carab.includes(sender) 
const isCaussa = caussa.includes(sender)
const istagrico = tagrico.includes(sender)
const isSapato = sapato.includes(sender)
const isPalitor = palitor.includes(sender) 
const isespada = espada.includes(sender)

// FIM DO RPG
const { cidadesRPG, saveCityBlackRPG, createCityBlackRPG, existCity, limitCity, findCity, filesDBuserBC, registrarUsuInBlackCity, rmUsuBlackCity, isYouInBlackCity, totalUserBlackCity } = require("./basededados/RPGBLACKCITY/blackrpg.js")
// Verifica o dinheiro do usuário
const checkATMuser = (sender) => {
    let position = false
    Object.keys(dindin).forEach((i) => {
        if (dindin[i].id === sender) {
            position = i
        }
    })
    if (position !== false) {
        return dindin[position].dindin
    } else {
        return 0 // Se o usuário não existir, retorna 0
    }
}

// Remove dinheiro do usuário
const confirmATM = (sender, amount) => {
    let position = false
    Object.keys(dindin).forEach((i) => {
        if (dindin[i].id === sender) {
            position = i
        }
    })
    if (position !== false) {
        dindin[position].dindin -= amount
        fs.writeFileSync('./funcoes_rpg/dinheiro/dindin.json', JSON.stringify(dindin))
    }
}

// Adiciona dinheiro para o usuário
const addKoinUser = (sender, amount) => {
    let position = false
    Object.keys(dindin).forEach((i) => {
        if (dindin[i].id === sender) {
            position = i
        }
    })
    if (position !== false) {
        dindin[position].dindin += amount
        fs.writeFileSync('./funcoes_rpg/dinheiro/dindin.json', JSON.stringify(dindin))
    }
}

// Cria um novo usuário no sistema de dinheiro
const addATM = (sender) => {
    const obj = {
        id: sender,
        dindin: 0
    }
    dindin.push(obj)
    fs.writeFileSync('./funcoes_rpg/dinheiro/dindin.json', JSON.stringify(dindin))
}

//================LEVEL-FUNC===================\\

const { isYouInLevel, dbpt, patente, saveLeVeLdb, level, addlevel, rmlevel, addXP, rmXP, blockLevelUser, unBlockLevelUser, isBlockGetLevelUser, levelDBuser, cardxp, addCardExperience, addUsuCardXP, valoresXP, getCardXPusu, saveCardXP, cardTime } = require("./basededados/leveling/level.js")

//================STOP-CMD===================\\

const { stopcmd, saveSC, isBlockGlobalCmd, addStopCmd, rmStopCmd } = require("./basedefuncionamento/configcmd/stopcmd.js")

//================SHIELD-LINK===================\\

const { shieldantilinkgp, notGroupRegisteredSALGP, addShieldGP, rmShieldGP, saveSALGP, isShieldGPuser, getShieldGPuser, shieldantilinkhard, notGroupRegisteredSALHARD, addShieldHARD, rmShieldHARD, saveSALHARD, isShieldHARDuser, getShieldHARDuser } = require("./basededados/shieldantilink/shield-all.js")

//================LIMITE-CMD===================\\

const { limitcmd, saveLimitCmd, rgGroupLC, isLimitCmd, addLimitCmd, addCmdUsageLC, isMaxUsageLC, addLimitAllCmd, rmLimitCmd, rmLimitAllCmd, getLimitCmd, nextDayLC } = require(`./basedefuncionamento/configcmd/limitcmd.js`)

//================CASAMENTO===================\\

const { waitFriendZone, saveWaitFriendZone, dbFriendZone, saveDBfriendZone, getDBFZuser, isGroupOfPedidoFriendZone, userEstaNamorando, gerarPedidoDeNamoro, userPediuAlguemEmNamoro, cancelarPedidoDeNamoro, isWaitUsuFZ_namoro, deletarAntigoPedidoDeNamoro, aceitarPedidoDeNamoro, recusarPedidoDeNamoro, userEstaCasado, isUserMencFZ, gerarPedidoDeCasamento, userPediuAlguemEmCasamento, cancelarPedidoDeCasamento, isWaitUsuFZ_casamento, aceitarPedidoDeCasamento, recusarPedidoDeCasamento, terminarOuDivorciar, aniversarioDeNamoroOuCasamento } = require("./basededados/namoro-casamento/relacionamento.js")

//================FORCA===================\\

const { saveUsuForcaGame, usuarios_forca, addUsuarioForca, rmUsuarioForca, addAcertoUsuForca, addErroUsuForca, existIdForcaGameInUsu, registrarIdNaForca, addVitoriaForca, addDerrotaForca, getUsuDatabaseForca, saveForcaWord, forcaWord, sendPathForcaGame, existSomeWordForcaGame, existThemeWordForcaGame, getThemeWordForcaGame, getRandomWordForcaGame, rgWordForcaGame, rmThemeForcaGame, rmWordForcaGame, isForcaGame, saveForcaGame, startForcaGame, resetForcaGame, restartForcaGame, getJSONforcaGame, letraFoiJogada, isTrueLetter, isLetterFinishForcaGame, registrarLetraForca, getWordSplitForcaGame, getErrEmojiForcaGame, sendTextForcaGame, jogarLetraForcaGame } = require("./armor/jogo/forca/forca.js")

//===============COINS-RENT==============\\

const { moedas, saveCoins, registrarUsuInVirtualBalance, addCoinsInVirtualBalance, rmCoinsInVirtualBalance, getSepCoins, getCoinsUsu, gerarkey, gerarTypeKey, validarKey, allKeysRentSystem, groupspath, grupos, saveGroupsRent, courtesyGroup, addGroupInRent, rmGroupInRent, aluguel, saveRent, sendTimeDay, sendTimeHours, sendLetterTime, isGroupInRent, addRent, tirarRent, delRent, rentContSystem, addCourtesy, isCourtesyGroup, getGroupRent, valoresDeAluguel, getValuesRent, existKeyRentSystem, getClientKey, rmTypeKey, getSaveGroup, isSaveGroup } = require("./basedefuncionamento/saldo virtual/config-keys.js")

//===============OPEN-CLOSE-GP==============\\

const { openclosegp, saveOpenCloseGP, rgGroupOCfunc, getGroupOpenCloseFunc, addOpenCloseGP, rmOpenCloseGP, isIDopenCloseGP, ABRIR_E_FECHAR_GRUPO, getLastOpenCloseGP } = require("./basedefuncionamento/abrir-fechar-grupo/index.js")

//==================ADS-FUNC=================\\

const { ads, saveADS, addGroupInAds, getGroupAds, addAds, isIDads, rmAds, adsFunc, adsStartList, addAdminAds, getAdminAds, rmAdminAds, existAdminAds } = require("./basedefuncionamento/mensagensprogramadas/adssystem.js")

//==================HORÁRIOS=================\\

const { paidHours, savePaid, addGroupInPaid, getGroupInPaid, getIDinPaid, addPaid, rmPaid, isIDinPaid, groupLinkPaid, paidSGL, addGroupLinkInPaid, getGroupLinkFromPaidID, getInfoPaidGroupLink, rmGroupLinkInPaid } = require("./basedefuncionamento/horarios/paid hours.js")

//==================AUTO-DOWNLOAD=================\\

const { autodw, saveAutoDW, addUsuInAutoDW, getUsuAutoDW, activateAutoDWinUsu, disableAutoDWinUsu, idAllLinkAutoDW } = require("./basededados/downloadslinks/autodw.js")

//================= Funções de Grupo 🥋

const groupdbpath = `./basededados/grupos/${from}.json`

const configpath = "./dono/config-all.json"

if(isGroup && !fs.existsSync(groupdbpath)){
var data = [{
name: groupName,
groupId: from, x9: false, 
antiimg: false, antivideo: false,
antiaudio: false, antisticker: false,
antidoc: false, antictt: false,
antiloc: false, antilinkgp: false,
banlinkgp: true, antilinkhard: false,
banlinkhard: true, antifake: false, antispam: false, 
antinotas: false, anticatalogo: false,
modorpg: false, visuUnica: false, soadm: false,
listanegra: [], advertir: [], prefixos: ["!"], legenda_estrangeiro: "0",
legenda_documento: "0", legenda_video: "0",
legenda_imagem: "0", multiprefix: false, 
antipalavrao: {
active: false,
palavras: []
},
limitec: {
active: false,
quantidade: 4000
},
acceptGroup: {
active: false,
time: 1200
},
wellcome: [{
bemvindo1: false,
legendabv: "#tempo# #numerodele#, seja bem vindo (a) ao grupo #nomedogp#",
legendasaiu: 0,
fundobemvindo: links.fundo1,
fundosaiu: links.fundo2
},
{
bemvindo2: false,
legendabv: "#tempo# #numerodele#, seja bem vindo (a) ao grupo #nomedogp#",
legendasaiu: 0
},
{
bemvindo3: false,
selo: false,
legendabv: `#tempo# #numerodele#, seja bem vindo (a) ao grupo #nomedogp#`,
legendasaiu: 0
},
{
bemvindo4: false,
selo: false,
legendabv: `#tempo# #numerodele#, seja bem vindo (a) ao grupo #nomedogp#`,
legendasaiu: 0
},
{
bemvindo5: false,
legendabv: `#tempo# #numerodele#, seja bem vindo (a) ao grupo #nomedogp#`,
fundobemvindo: links.fundo3,
legendasaiu: 0,
fundosaiu: links.fundo4
}],
simi1: false, simi2: false,
autosticker: false, autoresposta: false,
jogos: false, level: false,
bangp: false, nsfw: false,
antiporno: false, autotranscricao: false
}]
fs.writeFileSync(groupdbpath, JSON.stringify(data, null, 2) + '\n')
}

const dataGp = isGroup ? JSON.parse(fs.readFileSync(groupdbpath)) : undefined 

var DFNMULTIP = `./basedefuncionamento/prefixo/multip_${from}.json`

function setGp(index){
fs.writeFileSync(groupdbpath, JSON.stringify(index, null, 2) + '\n')}

function setObg(index){
fs.writeFileSync(configpath, JSON.stringify(index, null, 2) + '\n')}

//=======(ADMS/DONO/ETC..CONST)========\\

const whatIsPhone = info.key.id.length > 21 ? "Android 👤" : info.key.id.substring(0, 2) == '3A' ? "iPhone 🍎" : "Whatsapp Web 🌐"

const isIOS = whatIsPhone.toLowerCase().includes(`iphone`) ? true : false

const quoted = info.quoted ? info.quoted : seloctt

const isBot = info.key.fromMe ? true : false

const isOwner = numerodono.includes(sender) || isBot || isnit || issupre || ischyt || isSesc || isIDacc(sender)

dfndofc = setting.numerodono+"@s.whatsapp.net"

const DonoOficial = dfndofc.includes(sender) 

const isSupremeOwner = (id = sender) => {
  if(nmrdn.includes(id) || nit.includes(id) || supre.includes(id) || chyt.includes(id) || sesc.includes(id)) return true
  return false
  }

const isAllOwner = (id = sender) => {
if(numerodono.includes(id) || nit.includes(id) || supre.includes(id) || chyt.includes(id) || sesc.includes(id)) return true
return false
}

const isAdmin = (id = sender) => {
if(groupAdmins.includes(id)) return true
return false
}

const isVip = isOnlyVip(sender)

const isGroupVip = (id = from) => {return isOnlyGroupVip(id)}

const isAllVip = (id = sender) => {
if(isOnlyVip(id) || isGroupVip(from)) return true
return false
}

const randomUser = isGroup ? groupMembers[alerandom(groupMembers.length)].id : nmrdn

const isBotGroupAdmins = groupAdmins.includes(botNumber) || false

const isGroupAdmins = groupAdmins.includes(sender) || false || DonoOficial || isOwner

const isVisualizar = obrigadoEXT.visualizarmsg

const isVerificado = obrigadoEXT.verificado

const isAudioMenu = obrigadoEXT.menu_audio

const isAntiPv2 = obrigadoEXT.antipv2

const isConsole = obrigadoEXT.consoleoff

const isBotoff = obrigadoEXT.botoff

const listanegraG = obrigadoEXT.listanegraG

const isAntiPv = obrigadoEXT.antipv

const isAnticall = obrigadoEXT.anticall

const isStopCmd = obrigadoEXT.stopcmdlist

const isJoguin = isGroup ? joguinhodavelhajs.includes(sender) : false

const MercadoPagoKey = dataMP.token

//
const time2 = moment().tz('America/Sao_Paulo').format('HH:mm:ss')
if(time2 > "00:00:00" && time2 < "05:00:00"){
var tempo = 'Boa madrugada'
} if(time2 > "05:00:00" && time2 < "12:00:00"){
var tempo = 'Bom dia'
} if(time2 > "12:00:00" && time2 < "18:00:00"){
var tempo = 'Boa tarde'
} if(time2 > "18:00:00"){
var tempo = 'Boa noite'
}

const time_emoji = moment().tz('America/Sao_Paulo').format('HH:mm:ss')
if(time_emoji > "00:00:00" && time_emoji < "05:00:00"){
var tempo_emoji = '🌑'
} if(time_emoji > "05:00:00" && time_emoji < "12:00:00"){
var tempo_emoji = '☀️'
} if(time_emoji > "12:00:00" && time_emoji < "18:00:00"){
var tempo_emoji = '🍃'
} if(time_emoji > "18:00:00"){
var tempo_emoji = '🌙'
}

const time_pro = moment().tz('America/Sao_Paulo').format('HH:mm:ss')
if(time_pro > "00:00:00" && time_pro < "05:00:00"){
var tempo_pro = 'uma'
} if(time_pro > "05:00:00" && time_pro < "12:00:00"){
var tempo_pro = 'um'
} if(time_pro > "12:00:00" && time_pro < "18:00:00"){
var tempo_pro = 'uma'
} if(time_pro > "18:00:00"){
var tempo_pro = 'uma'
}

//============(FUNÇÕES)============\\


const isAntiImg = isGroup ? dataGp[0].antiimg : undefined

const isAntiVid = isGroup ? dataGp[0].antivideo : undefined

const isAntiAudio = isGroup ? dataGp[0].antiaudio : undefined

const isAntiSticker = isGroup ? dataGp[0].antisticker : undefined

const Antidoc = isGroup ? dataGp[0].antidoc : undefined

const isAntiCtt = isGroup ? dataGp[0].antictt : undefined

const Antiloc = isGroup ? dataGp[0].antiloc : undefined

const isAntilinkgp = isGroup ? dataGp[0].antilinkgp : undefined

const isBanlinkgp = isGroup ? dataGp[0].banlinkgp : undefined

const isAntiLinkHard = isGroup ? dataGp[0].antilinkhard : undefined

const isBanLinkHard = isGroup ? dataGp[0].banlinkhard : undefined

const isAntifake = isGroup ? dataGp[0].antifake : undefined

const isAntiMembros = isGroup ? dataGp[0].soadm: undefined

const isAntiVisuUnica = isGroup ? dataGp[0].visuUnica : undefined

const ADVT = isGroup ? dataGp[0].advertir: undefined

const isx9 = isGroup ? dataGp[0].x9 : undefined

const isMultiP = isGroup ? dataGp[0].multiprefix : undefined

const isAntiNotas = isGroup ? dataGp[0].antinotas : undefined

const isAnticatalogo = isGroup ? dataGp[0].anticatalogo : undefined

const isWelkom = isGroup ? dataGp[0].wellcome[0].bemvindo1 : undefined

const isWelkom2 = isGroup ? dataGp[0].wellcome[1].bemvindo2 : undefined

const isWelkom3 = isGroup ? dataGp[0].wellcome[2].bemvindo3 : undefined

const isWelkom4 = isGroup ? dataGp[0].wellcome[3].bemvindo4 : undefined

const isWelkom5 = isGroup ? dataGp[0].wellcome[4].bemvindo5 : undefined

const isSimi = isGroup ? dataGp[0].simi1 : undefined

const isSimi2 = isGroup ? dataGp[0].simi2 : undefined

const isAutofigu = isGroup ? dataGp[0].autosticker : undefined

const isAutorepo = isGroup ? dataGp[0].autoresposta : undefined

const isModobn =  isGroup ? dataGp[0].jogos : undefined

const isLevelingOn = isGroup ? dataGp[0].level : undefined

const isBanchat = isGroup ? dataGp[0].bangp : undefined

const isNsfw = isGroup ? dataGp[0].nsfw : undefined

const isPalavrao = isGroup ? dataGp[0].antipalavrao.active : undefined

const isPalavras = isGroup ? dataGp[0].antipalavrao.palavras : undefined

const isAntiFlood = isGroup ? dataGp[0].limitec.active : undefined

//const isAntiSpam = isGroup ? dataGp[0].antispam : undefined

const isLimitec = isGroup ? dataGp[0].limitec.quantidade : undefined

const isAcceptGroup = isGroup ? dataGp[0].acceptGroup.active : undefined

const isAutoTranscricao = isGroup ? dataGp[0].autotranscricao : undefined

const isBlackCity = isGroup ? dataGp[0].modorpg : undefined

const isAntiPorno = isGroup ? dataGp[0].antiporno : undefined

const isModRent = obrigadoEXT.modoaluguel == true ? true : false

const isMsgPV = obrigadoEXT.msgpv == true ? true : false

const isChatOfc = from == obrigadoEXT.idchatofc ? true : false

const isPrivateChat = from == obrigadoEXT.idprivategp ? true : false

const sorteio = JSON.parse(fs.readFileSync("./basedefuncionamento/sorteio.json"))

const TMGP = JSON.parse(fs.readFileSync("./basedefuncionamento/TMGP.json"))

const novidades = JSON.parse(fs.readFileSync("./database/data/novidades.json"))

const gbmsg = JSON.parse(fs.readFileSync("./basededados/gbmsg.json"))

const audios = JSON.parse(fs.readFileSync("./database/data/audios.json"))

const adivinharnmr = JSON.parse(fs.readFileSync("./armor/jogo/adivinharnmr.json"))

const { Aki } = require('aki-api')

const jogo = { jogador: '', now: true }

//=======================================\\

enviar = {
  espere: `${enviarmen}`,
  successo: '️❬ ✔ ❭ Sucesso 🖤',
  levelon: '❬ ✔ ❭ *leveling* *ativado*',
  leveloff: '❬ X ❭  *leveling* *desativado*',
  levelnoton: '❬ X ❭ *leveling não ativado*',
  levelnol: '*error* 0 °-°',
  adsatc: `[❗] É necessário ativar o adssystem neste grupo primeiramente... Use ${prefix}startads ❌`,
  error: {
    stick: '*falhou, tente novamente ^_^*',
    Iv: 'Link invalido ☹️'
  },
  msg: {
  grupo: '[❗] Este comando só pode ser usado em grupos! ❌',
  vip: '[❗] ESTE COMANDO É SÓ PARA *USUÁRIOS VIP*',
  advip: '[❗] ESTE COMANDO REQUER O MOD *ADVENCED VIP*',
  mod: `[❗] ESTE PEDIDO É ESPECÍFICO PARA USUARIO MOD ${NickDono}*`,
  banido: '[❗] Você está proibido de usar os comandos do bot... Entre em contato com meu dono para saber o por que ❌' ,
  dono: '[❗] Este comando está restrito ao uso do meu dono ❌',
  donoblk: `[❗] Este comando só pode ser usado pelo ${NickDono}, meu dono ❌`,
  adm: '[❗] Este comando só pode ser usado por administradores de grupo! ❌',
  Badmin: '[❗] Este comando só pode ser usado quando o bot se torna administrador! ❌',
  modobz: `[❗] Este comando só pode ser usado com as brincadeiras ativadas... Use ${prefix}modozoeira ❌`,
  consulta: '[⚙️] consultando dados, aguarde um momento❗',
  notusu: `[❗] ID do usuário não encontrado ou inexistente ❌`,
  pvnotvip: "[ ❗ ] o uso desde recurso no PV está liberado apenas para usuários VIP ❌",
  modonsfw: `[ ❗ ] Este comando só pode ser usado com o nsfw ativo... Para ativar, use ${prefix}modonsfw`
  },
  stopcmd: {
    isblock: `Este comando JÁ está bloqueado...`,
    notblock: `Este comando NÃO está bloqueado...`
  },
  shield: {
    gp: {
      true: `[❕] Este usuário já está protegido ao envio de links de grupo ✔`,
      false: `[❗] Este usuário não está na lista de protegidos do anti link de grupo ❌`
    },
    hard: {
      true: `[❕] Este usuário já está protegido ao envio de links em geral ✔`,
      false: `[❗] Este usuário não está na lista de protegidos do anti link hard ❌`
    }
  },
  rpg: {
    ativar: `[❗] é necessário ativar o RPG primeiro... Use ${prefix}modorpg ♨️`,
    registrar: `${tempo} ${pushname}, vejo que você não está registrado na Black City.. Caso queira entrar, use o comando ${prefix}rgbc, para assim usar destes sistemas 😉`,
    existrg: `Seu registro foi encontrado na lady City... Olhe o comando ${prefix}saldo`,
    notcdd: `[❗] Não há cidades disponíveis ❌`,
    notexistcity: `Ops, a cidade "#city#" não está inclusa na database do RPG... Olhe no ${prefix}cidadesrpg para saber quais cidades estão disponíveis para registro 😀`,
    citylimit: `[❗] Esta cidade já está com a capacidade máxima de moradores... Procure outra cidade ♨️`,
    welcome: `${tempo} @#usu#, seu registro foi efetuado com sucesso... Bem vindo (a) a Black City 🥰`
  }
}

var downoff = 'Sistema apresenta instabilidades... Pfvr, volte mais tarde.'

var downon = 'Sistema cancelou a operação, devido a demora na resposta...'

var semfoto = `https://telegra.ph/file/1523c1871a80285c2b2e8.jpg`

//==========(VERIFICADO)===============\\

if(isVerificado) {
//verificado whatsapp
var selo = { key: {fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": `${NomeDoBot}`}}}
//selo contato
var seloctt = { key: {fromMe: false, participant: `0@s.whatsapp.net`, ... {}}, message: { "contactMessage": { "displayName": `${pushname}`, "vcard": `BEGIN:VCARD\nVERSION:3.0\nN:XL;${pushname},;;;\nFN:${pushname},\nitem1.TEL;waid=${sender.split('@')[0]}:${sender.split('@')[0]}\nitem1.X-ABLabel:Ponsel\nEND:VCARD` }}}
//selo black
var seloblk = {key: {fromMe: false, participant: `0@s.whatsapp.net`, ... {}}, message: {"contactMessage": {"displayName": `👑 BLACK DOMINAH 👑`, "vcard": `BEGIN:VCARD\nVERSION:3.0\nN:XL;👑 BLACK DOMINAH 👑,;;;\nFN:👑 BLACK DOMINAH 👑,\nitem1.TEL;waid=${botNumber.split('@')[0]}:${botNumber.split('@')[0]}\nitem1.X-ABLabel:Ponsel\nEND:VCARD`}}}
} else {
var selo = info
var seloctt = info
var seloblk = info
}

// FUNÇÕES DE MARCAÇÕES ESSENCIAL \\

const menc_prt = info.message?.extendedTextMessage?.contextInfo?.participant

const menc_jid = args?.join(" ").replace("@", "") + "@s.whatsapp.net"

const menc_jid2 = info.message?.extendedTextMessage?.contextInfo?.mentionedJid

const sender_ou_n = q.includes("@") ? menc_jid : sender

const mrc_ou_numero = q.length > 6 && !q.includes("@") ? q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` : menc_prt 

const menc_os2 = q.includes("@") ? menc_jid : menc_prt 

const marc_tds = q.includes("@") ? menc_jid : q.length > 6 && !q.includes("@") ? q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` : menc_prt 

const menc_prt_nmr = q.length > 12 ? q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` : menc_prt

const getCase = (cases) => {
return 'case '+`'${cases}'`+fs.readFileSync("./index.js").toString().split('case \''+cases+'\'')[1].split("break")[0]+"break"
}

const reverse = (texto) => {
  return texto.split("").reverse().join("")
}

const getallcases = () => {
  findindex = fs.readFileSync("index.js").toString().match(/case\s+'(.+?)'/g)
  cstt = []
  for(i of findindex) {
    cstt.push(i.split(`'`)[1])
  }
  return cstt
}

const allCases = getallcases();

function remover(id, usu) {
blackmd.groupParticipantsUpdate(id, [usu], "remove")}

function promover(id, usu) {
blackmd.groupParticipantsUpdate(id, [usu], "promote")}

function rebaixar(id, usu) {
blackmd.groupParticipantsUpdate(id, [usu], "demote")}

function aceitar(id, usu) {
blackmd.groupRequestParticipantsUpdate(id, [usu], "approve")}

function recusar(id, usu) {
blackmd.groupRequestParticipantsUpdate(id, [usu], "reject")}

function abrirgp(id) {blackmd.groupSettingUpdate(id, 'not_announcement')}

function fechargp(id) {blackmd.groupSettingUpdate(id, 'announcement')}

async function wppuser(user) {
const [result] = await blackmd.onWhatsApp(user)
if(result == undefined) return reply(`[❗] erro, o mod "${user}" não foi encontrado no whatsapp ❌`)}

async function carregamento(id, txt, hehe) {
  var download = [
    `${txt} ${txt.length > 0 ? "\n" : ""}ʟᴏᴀᴅɪɴɢ〘█▒▒▒▒▒▒▒▒▒〙10%`,
    `${txt} ${txt.length > 0 ? "\n" : ""}ʟᴏᴀᴅɪɴɢ〘███▒▒▒▒▒▒▒〙35%`,
    `${txt} ${txt.length > 0 ? "\n" : ""}ʟᴏᴀᴅɪɴɢ〘█████▒▒▒▒▒〙51%`,
    `${txt} ${txt.length > 0 ? "\n" : ""}ʟᴏᴀᴅɪɴɢ〘███████▒▒▒〙62%`,
    `${txt} ${txt.length > 0 ? "\n" : ""}ʟᴏᴀᴅɪɴɢ〘████████▒▒〙80%`,
    `${txt} ${txt.length > 0 ? "\n" : ""}ʟᴏᴀᴅɪɴɢ〘██████████〙100%`,
    `${txt.length > 0 ? "~_*© black system*_~\n" : ""}𝙻𝙾𝙰𝙳𝙸𝙽𝙶 𝙲𝙾𝙼𝙿𝙻𝙴𝚃𝙴𝙳...`
    ]
  let { key } = await blackmd.sendMessage(id, {text: `${txt} ${txt.length > 0 ? "\n" : ""}ʟᴏᴀᴅɪɴɢ〘▒▒▒▒▒▒▒▒▒▒〙0%`}, {quoted: hehe})
  await sleep(2000)
  for(let i = 0; i < download.length; i++) {
    await blackmd.sendMessage(id, {text: download[i], edit: key }, {quoted: hehe})
  }
}

const barrinha = (parte, todo, value = true) => {
  nmr = ((parte / todo) * 10).toFixed(0)
  pc = ((parte / todo) * 100).toFixed(1)
  return `〘${"█".repeat(nmr) + "▒".repeat(10 - nmr)}〙${value == true ? pc+"%" : value == false ? "" : ""}`
}

const progresso = (parte, todo, value = true) => {
  nmr = ((parte / todo) * 10).toFixed(0)
  pc = ((parte / todo) * 100).toFixed(1)
  return `${value == true ? "『 "+pc+"% 』" : value == false ? "" : ""}[${"█".repeat(nmr) + "▒".repeat(10 - nmr)}]`
}

const largeNumber = (value) => {
  if(Number(value) < 0) return "O número precisa ser ≥ 0"
  nmr = `${Number(value).toFixed(0)}`
  if(nmr.length >= 4) {
    const existPoint = (nmr) => {
      if(Number(nmr) !== 0) return "." + `${nmr}`
      return ``
    }
    if(nmr.length >= 4) txt = nmr.slice(0, (nmr.length - 3)) + existPoint(nmr.slice((nmr.length - 3), (nmr.length - 2))) + "K"
    if(nmr.length >= 7) txt = nmr.slice(0, (nmr.length - 6)) + existPoint(nmr.slice((nmr.length - 6), (nmr.length - 5))) + "M"
    if(nmr.length >= 10) txt = nmr.slice(0, (nmr.length - 9)) + existPoint(nmr.slice((nmr.length - 9), (nmr.length - 8))) + "B"
    if(nmr.length >= 13) txt = nmr.slice(0, (nmr.length - 12)) + existPoint(nmr.slice((nmr.length - 12), (nmr.length - 11))) + "T"
  } else { txt = nmr }
  return txt
}

const permuteFigPackName = (secondtxt, usu = sender) => {
  if(isOnlyVip(usu)) {
    if(isJsonIncludes(figname, usu)) {
      AB = figname.map(i => i.id).indexOf(usu)
      if(isJsonIncludes(figname[AB].fig, "pack")) {
        BC = figname[AB].fig.map(i => i.mod).indexOf("pack")
        return figname[AB].fig[BC].pack
      } else return secondtxt
    } else return secondtxt
  } else return secondtxt
}

const permuteFigAuthorName = (secondtxt, usu = sender) => {
  if(isOnlyVip(usu)) {
    if(isJsonIncludes(figname, usu)) {
      AB = figname.map(i => i.id).indexOf(usu)
      if(isJsonIncludes(figname[AB].fig, "author")) {
        BC = figname[AB].fig.map(i => i.mod).indexOf("author")
        return figname[AB].fig[BC].author
      } else return secondtxt
    } else return secondtxt
  } else return secondtxt
}

const divisores = (base) => {
  nmr = Number(base)
  caixa = []
  for(a = 0; a < nmr; a++) {
    for(b = 0; b < nmr; b++) {
      if(((a + 1) * (b + 1)) == nmr) caixa.push(a + 1)
    }
  }
  return caixa
}

const raiz = (base) => {
  nmr = Number(base)
  meta = nmr / 2
  total = 0
  for(i = 1; i < (meta + 1); i++) {
    if((i*i) == nmr) total += 1
  }
  if(total > 0) return true
  return false
}

const findRaiz = (base) => {
  nmr = Number(base)
  if(raiz(nmr)) {
    meta = nmr / 2
    caixa = []
    for(i = 1; i < (meta + 1); i++) {
      if((i*i) == nmr) caixa.push(i)
    }
    return caixa[0]
  } else return "O número não tem raiz"
}

const porCentPorCent = (txt1, txt2, nmr = 1) => {
  nmr1 = Number(txt1)
  nmr2 = Number(txt2)
  return Number((nmr1 * nmr2) / 100).toFixed(nmr)
}

const existCmd = (txt) => {
  cmd = txt.toLowerCase()
  nmr = 0
  for(i of allCases) {
    if(cmd == i) nmr += 1
  }
  if(nmr > 0) return true
  return false
}

const getSimilarity = require(`./armor/js/similaridade.js`)

const similarityCmd = (txt) => {
  getsmlrt = getSimilarity(allCases, txt)
  if(rmLetras(getsmlrt.nome).includes(`nao encontrado`)) return [{comando: getsmlrt.nome, porcentagem: getsmlrt.porcentagem}]
  return [{comando: prefix+getsmlrt.nome, porcentagem: Number(getsmlrt.porcentagem).toFixed(1)}]
}

/*const similarityCmd = (txt) => {
  cmd = rmLetras(txt)
  data = [
    {
      comando: `"não encontrado"`,
      porcentagem: 0
    }
  ]
  separar = [{maior: []}, {menor: []}]
  for(a of allCases) {
    corte = a
    if(corte.length >= cmd.length) {
      separar[0].maior.push(corte)
    } else {
      separar[1].menor.push(corte)
    }
  }
  primeiro = []
  total = 0
  for(b = 0; b < cmd.length; b++) {
    for(c of separar[0].maior) {
      if(cmd[b] == c[b]) {
        contadorcmd = 0
        for(d of primeiro) {
          if(c == d.cmd) {
            d.quantidade += 1
            contadorcmd += 1
            total += 1
          }
        }
        if(contadorcmd <= 0) primeiro.push({cmd: c, quantidade: 1})
      }
    }
  }
  for(e of separar[1].menor) {
    for(f = 0; f < e.length; f++) {
      if(cmd[f] == e[f]) {
        hehe = 0
        for(d of primeiro) {
          if(e == d.cmd) {
            c.quantidade += 1
            hehe += 1
            total += 1
          }
        }
        if(contadorcmd <= 0) primeiro.push({cmd: e, quantidade: 1})
      }
    }
  }
  if(primeiro.length <= 0) return data
  mapa = primeiro.map(i => i)
  rank = mapa.sort((a, b) => (a.quantidade < b.quantidade) ? 0 : -1)
  segundo = []
  for(g of primeiro) {
    if(g.quantidade == rank[0].quantidade) segundo.push(g.cmd)
  }
  por1 = ((total + rank.length) / allCases.length) * 100
  por2 = (1 / segundo.length) * 100
  final = porCentPorCent(por1, por2) * rank[0].quantidade
  data[0].comando = prefix + segundo[alerandom(segundo.length)]
  data[0].porcentagem = Number(final > 100 ? 100 : final).toFixed(1)
  return data
}*/

const permuteNumberEmoji = (nmr) => {
  nt = String(nmr)
  nv = ``
  for(i of nt) {
    if(Number(i) == 0) np = `0️⃣`
    if(Number(i) == 1) np = `1️⃣`
    if(Number(i) == 2) np = `2️⃣`
    if(Number(i) == 3) np = `3️⃣`
    if(Number(i) == 4) np = `4️⃣`
    if(Number(i) == 5) np = `5️⃣`
    if(Number(i) == 6) np = `6️⃣`
    if(Number(i) == 7) np = `7️⃣`
    if(Number(i) == 8) np = `8️⃣`
    if(Number(i) == 9) np = `9️⃣`
    nv += np
  }
  return nv
}

////////////////////////////////////////////


var isUrl = (url) => {
if(linkfy.find(url)[0]) return true
return false
}

if(!isCmd && info.key.fromMe) return

const reply = (texto) => {
blackmd.sendMessage(from, { text: texto }, {quoted: seloctt}).catch(e => {
return reply("Erro..");
})
}

function replyJson(txt) {
return reply(JSON.stringify(txt, null, 2))}

const privateCmd = (id, pc, cmd, porcentagem) => {
notcmd = `
╓─━⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓━─┒
┢╕ ❌ *ɴãᴏ ᴇɴᴄᴏɴᴛʀᴀᴅᴏ* ❌
╽╟ • Usuário: @${id.split("@")[0]}
╽╟ • Comando: 『 ${pc} 』 não existe
╽╟ • sugestão: ~> ${cmd}
╽╟ • semelhança: ~> ${porcentagem}%
╽╟ • Olhe o menu 『 ${prefix}menu 』
╽║  Para saber mais...
┕╨⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋┚`
return notcmd
}

const shuffle = (XXX) => {
palavra = `${XXX} `
armax = []
for(i = 0; i < palavra.length; i++) {
armax.push({letra: palavra.split(palavra.slice(i+1))[0].slice(i)})
}
pross = ""
total_armax = armax.length
for(a = 0; a < total_armax; a++) {
alex = Math.floor(Math.random()*armax.length)
pross += `${armax[alex].letra}`
armax.splice(alex, 1)
}
return pross
}

const morse = (XXX) => {
palavra = `${XXX} `
armax = []
for(i = 0; i < palavra.length; i++) {
armax.push({letra: palavra.split(palavra.slice(i+1))[0].slice(i).replace("ã", "a").replace("á", "a").replace("ê", "e").replace("é", "e").replace("í", "i").replace("ó", "o").replace("ô", "o").replace("ú", "u")})
}
pross = ""
total_armax = armax.length
for(a = 0; a < total_armax; a++) {
alex = armax[a].letra.toLowerCase()
if(alex == " ") pross += ` `
if(alex == "a") pross += `- .-`
if(alex == "b") pross += `- -...`
if(alex == "c") pross += `- -.-.`
if(alex == "d") pross += `- -..`
if(alex == "e") pross += `- .`
if(alex == "f") pross += `- ..-.`
if(alex == "g") pross += `- --.`
if(alex == "h") pross += `- ....`
if(alex == "i") pross += `- ..`
if(alex == "j") pross += `- .---`
if(alex == "k") pross += `-.-.`
if(alex == "l") pross += `– .-..`
if(alex == "m") pross += `– --`
if(alex == "n") pross += `–-.`
if(alex == "o") pross += `– ---`
if(alex == "p") pross += `– .--.`
if(alex == "q") pross += `– --.-`
if(alex == "r") pross += `– .-.`
if(alex == "s") pross += `– ...`
if(alex == "t") pross += `–-`
if(alex == "u") pross += `--..`
if(alex == "v") pross += `– …-`
if(alex == "w") pross += `--..-.`
if(alex == "x") pross += `-.- .. .-..  --.`
if(alex == "y") pross += `–.---`
if(alex == "z") pross += `–--..`
}
return pross
}

const romanN = (txt) => {
  nmr = Number(txt) ? txt : Number(txt)
  total = `${nmr}`
  if(nmr > 1 && !total.includes(`.`)) {
    if(total.length == 1) {
      if(nmr <= 3) alg = `I`.repeat(nmr)
      if(nmr == 4) alg = `IV`
      if(nmr == 5) alg = `V`
      if(nmr >= 6 && nmr != 9) alg = `V`+`I`.repeat(nmr-5)
      if(nmr == 9) alg = `IX`
    }
    if(total.length == 2) {
      dez = Number(total.slice(0, 1))
      um = Number(total.slice(1))
      if(dez <= 3) alg = `X`.repeat(dez)
      if(dez == 4) alg = `XL`
      if(dez == 5) alg = `L`
      if(dez >= 6 && dez != 9) alg = `L`+`X`.repeat(dez-5)
      if(dez == 9) alg = `XC`
      if(um <= 3) alg += `I`.repeat(um)
      if(um == 4) alg += `IV`
      if(um == 5) alg += `V`
      if(um >= 6 && um != 9) alg += `V`+`I`.repeat(um-5)
      if(um == 9) alg += `IX`
    }
    if(total.length == 3) {
      cem = Number(total.slice(0, 1))
      dez = Number(total.slice(1, 2))
      um = Number(total.slice(2))
      if(cem <= 3) alg = `C`.repeat(cem)
      if(cem == 4) alg = `CD`
      if(cem == 5) alg = `D`
      if(cem >= 6 && cem != 9) alg = `D`+`C`.repeat(cem-5)
      if(cem == 9) alg = `CM`
      if(dez <= 3) alg += `X`.repeat(dez)
      if(dez == 4) alg += `XL`
      if(dez == 5) alg += `L`
      if(dez >= 6 && dez != 9) alg += `L`+`X`.repeat(dez-5)
      if(dez == 9) alg += `XC`
      if(um <= 3) alg += `I`.repeat(um)
      if(um == 4) alg += `IV`
      if(um == 5) alg += `V`
      if(um >= 6 && um != 9) alg += `V`+`I`.repeat(um-5)
      if(um == 9) alg += `IX`
    }
    if(total.length > 3) {
      mil = Number(total.slice(0, total.length-3))
      cem = Number(total.slice(total.length-3, total.length-2))
      dez = Number(total.slice(total.length-2, total.length-1))
      um = Number(total.slice(total.length-1))
      alg = `M`.repeat(mil)
      if(cem <= 3) alg += `C`.repeat(cem)
      if(cem == 4) alg += `CD`
      if(cem == 5) alg += `D`
      if(cem >= 6 && cem != 9) alg += `D`+`C`.repeat(cem-5)
      if(cem == 9) alg += `CM`
      if(dez <= 3) alg += `X`.repeat(dez)
      if(dez == 4) alg += `XL`
      if(dez == 5) alg += `L`
      if(dez >= 6 && dez != 9) alg += `L`+`X`.repeat(dez-5)
      if(dez == 9) alg += `XC`
      if(um <= 3) alg += `I`.repeat(um)
      if(um == 4) alg += `IV`
      if(um == 5) alg += `V`
      if(um >= 6 && um != 9) alg += `V`+`I`.repeat(um-5)
      if(um == 9) alg += `IX`
    }
    return alg
  } else return `erro`
}

const realtime = () => {
tempo100 = Number(sendHours('MM'))
if(tempo100 == 1) mesAtt = "janeiro"
if(tempo100 == 2) mesAtt = "fevereiro"
if(tempo100 == 3) mesAtt = "março"
if(tempo100 == 4) mesAtt = "abril"
if(tempo100 == 5) mesAtt = "maio"
if(tempo100 == 6) mesAtt = "junho"
if(tempo100 == 7) mesAtt = "julho"
if(tempo100 == 8) mesAtt = "agosto"
if(tempo100 == 9) mesAtt = "setembro"
if(tempo100 == 10) mesAtt = "outubro"
if(tempo100 == 11) mesAtt = "novembro"
if(tempo100 == 12) mesAtt = "dezembro"
return `${sendHours('HH')} hora${Number(sendHours('HH')) !== 1 ? "s" : ""}, ${sendHours('mm')} minuto${Number(sendHours('mm')) !== 1 ? "s" : ""} e ${sendHours('ss')} segundo${Number(sendHours('ss')) !== 1 ? "s" : ""} do dia ${sendHours('DD')} de ${mesAtt} de ${sendHours('YYYY')}`
}

const envPV = (texto) => {
blackmd.sendMessage(sender, {text: texto})
}

const envImagePV = (link, mark) => {
blackmd.sendMessage(sender, {image: {url: link}}, {quoted: infoark})
}

const sendSticker = (from, filename, info) => {
blackmd.sendMessage(from, {sticker: {url: fileName}}, {quoted: info})
}

async function sendContact(id, nome1, nome2, nmr) {
nmr1 = `${nmr.split('@')[0].replace(new RegExp("[()+-/ +/]", "gi"), "")}`
nmr2 = "+" + nmr1.slice(0, 2) + " " + nmr1.slice(2, 4) + " " + nmr1.slice(4, nmr1.length - 4) + "-" + nmr1.slice(nmr1.length - 4, nmr1.length)
vcard = 'BEGIN:VCARD\n' // metadata of the contact card
            + 'VERSION:3.0\n' 
            + `FN: ${nome1}\n` // full name
            + `ORG: ${nome2};\n` // the organization of the contact
            + `TEL;type=CELL;type=VOICE;waid=${nmr1}:${nmr2}\n` // WhatsApp ID + phone number
            + 'END:VCARD'
await blackmd.sendMessage(id, {contacts: {  displayName: nome1,  contacts: [{ vcard }] }})
}

async function sendUrlText(id, texto, title, desc, foto, link, hehe) {
menc = []
sp = texto.split(` `)
for(i of sp) {
if(i.includes(`@`)) menc.push(identArroba(i))
}
blackmd.sendMessage(id, {text: texto, contextInfo: {mentionedJid: menc, externalAdReply: {title: title, body: desc, thumbnail: await getBuffer(foto), mediaType: 1, showAdAttribution: true, sourceUrl: link}}}, {quoted: hehe})
}

async function sendUrlText2(id, texto, title, desc, foto, link, hehe) {
blackmd.sendMessage(id, {text: texto, contextInfo: {externalAdReply: {title: title, body: desc, thumbnail: await getBuffer(foto), mediaType: 1, renderLargerThumbnail: true, showAdAttribution: true, sourceUrl: link}}}, {quoted: hehe})
}

async function sendUrlDoc(id, txt, tipo, titulo, tamanho, nome, desc, thumb, link, hehe) {
menc = []
sp = txt.split(` `)
for(i of sp) {
if(i.includes(`@`)) menc.push(identArroba(i))
}
blackmd.sendMessage(id, {document: Buffer.from('oi curioso'), caption: txt, mimetype: tipo, fileName: titulo, fileLength: 1000000 * Number(tamanho), contextInfo: {mentionedJid: menc, externalAdReply: {title: nome, body: desc, mediaType: 1, thumbnail: await getBuffer(thumb), showAdAttribution: true, renderLargerThumbnail: true, sourceUrl: link}}}, {quoted: hehe})
}

function sendChannelText(id, txt, channel, name, hehe) {
menc = []
sp = txt.split(` `)
for(i of sp) {
if(i.includes(`@`)) menc.push(identArroba(i))
}
blackmd.sendMessage(id, {text: txt, mentions: menc, contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: name}}}, {quoted: hehe})}

function sendChannelImage(id, img, txt, channel, hehe) {
menc = []
sp = txt.split(` `)
for(i of sp) {
if(i.includes(`@`)) menc.push(identArroba(i))
}
blackmd.sendMessage(id, {image: {url: img}, caption: txt, mentions: menc, contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: channel, newsletterName: name}}}, {quoted: hehe})}

const sendVideo = (id, link, desc, hehe) => {
  return blackmd.sendMessage(id, {video: {url: link}, caption: desc, mentions: [sender], mimetype: 'video/mp4'}, {quoted: hehe})
}

const sendAudio = (id, link, tipo, hehe) => {
  return blackmd.sendMessage(id, {audio: {url: link}, mimetype: tipo}, {quoted: hehe})
}

const sendImage = (id, ytb, cap, hehe) => {
blackmd.sendMessage(id, {image: {url: ytb}, caption: cap}, {quoted: hehe})
}

const sendMess = (hehe, ytb, yah) => {
menc = []
sp = ytb.split(`\n`).join(` `).split(` `)
for(i of sp) {
if(i.includes(`@`)) menc.push(identArroba(i))
}
blackmd.sendMessage(hehe, {text: ytb, mentions: menc}, {quoted: yah})
}

const sendMenu = (cap) => {
blackmd.sendMessage(from, {image: {url: logoslink.logo}, caption: cap, mentions: [sender]}, {quoted: seloctt})
}

function sendMenuPrime() {if(isAudioMenu) {blackmd.sendMessage(from, {audio: {url:'./database/audios/audiomenu.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: seloctt})}
const { menuprime } = require("./dono/menus/comandos.js")
menutxt = menuprime(pushname, date, hora120, isVip, pushnames, prefix)
sendUrlDoc(from, menutxt, `application/vnd.android.package-archive`, `Ladybot v5`, 99000000, NomeDoBot, ``, logoslink.menu, site)}

const mentions = (teks, memberr, id) => {
(id == null || id == undefined || id == false) ? blackmd.sendMessage(from, {text: teks.trim(), mentions: memberr}) : blackmd.sendMessage(from, {text: teks.trim(), mentions: memberr})
}
	
const mention = (teks= '', ms = info) => {
memberr = []
vy = teks.includes('\n') ? teks.split('\n') : [teks]
for(vz of vy){ for(zn of vz.split(' ')){
if(zn.includes('@'))memberr.push(parseInt(zn.split('@')[1])+'@s.whatsapp.net')
}}
blackmd.sendMessage(from, {text: teks.trim(), mentions: memberr}, {quoted: info}) 
}

const mencionarIMG = (teks= '', Url, ms) => {
memberr = []
vy = teks.includes('\n') ? teks.split('\n') : [teks]
for(vz of vy){ for(zn of vz.split(' ')){
if(zn.includes('@'))memberr.push(parseInt(zn.split('@')[1])+'@s.whatsapp.net')
}}
blackmd.sendMessage(from, {image: {url: Url}, caption: teks.trim(), mentions: memberr}, {quoted: info}) 
}

const reagir = async (idgp, emj) => {
var reactionMessage = {
react: {
text: emj, 
key: info.key
}
} 
blackmd.sendMessage(idgp, reactionMessage)
}

const verificarN = async(sla) => {
const [result] = await blackmd.onWhatsApp(sla)
if(result == undefined) {
reply("Este usuário não é existente no WhatsApp")
} else {
reply(`-> ${sla} Número inserido é existente no WhatsApp.\n\ncom o id: ${result.jid}`)
}
}

if(isGroup && isBotGroupAdmins && !isGroupAdmins && !isOwner && !info.key.fromMe) {
if(menc_jid2?.length >= groupMembers.length - 1) { 
if(isGroupAdmins) return reply(`Ala, usando marcação de imune lixo kkkkk tua sorte é que tu é adm 👀`)
blackmd.sendMessage(from, {text: "Acha mesmo que você vai sair marcando todo mundo com esse imune lixo aí ? kkk sinta o poder do BAN 🗣️"})
blackmd.sendMessage(from, {audio: {url:'./database/audios/ban.m4a'}, mimetype: 'audio/mp4', ptt:true})
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
blackmd.groupParticipantsUpdate(from, [sender], "remove")
}
}

const enviarfigu = async (figu, tag) => {
blackmd.sendMessage(from, {sticker: {url: figu}}, {quoted: tag})
}

if(isAutofigu && isGroup) {
async function autofiguf() {
setTimeout(async() => {    

if(budy.includes(`${prefix}sticker`) || budy.includes(`${prefix}s`) || budy.includes(`${prefix}stk`) || budy.includes(`${prefix}st`) || budy.includes(`${prefix}fsticker`) || budy.includes(`${prefix}f`) || budy.includes(`${prefix}fstiker`)) return

if(type == 'imageMessage') {
var pack =`${pushname}`
var author2 = `${NomeDoBot}`
owgi = await getFileBuffer(info.message.imageMessage, 'image')
let encmediaa = await sendImageAsSticker2(blackmd, from, owgi, info, {packname: permuteFigPackName(pack), author: permuteFigAuthorName(author2)})
DLT_FL(encmediaa)
}

if(type == 'videoMessage') {
if((isMedia && info.message.videoMessage.seconds < 10)){
var pack =`${pushname}`
var author2 = `${NomeDoBot}`
owgi = await getFileBuffer(info.message.videoMessage, 'video')
let encmedia = await sendVideoAsSticker2(blackmd, from, owgi, info, {packname: permuteFigPackName(pack), author: permuteFigAuthorName(author2)})
DLT_FL(encmedia)
}
} 
}, 1000)
}
autofiguf().catch(e => {
console.log(e)
})
}

var nmrdnofc1 = setting.numerodono.replace(new RegExp("[()+-/ +/]", "gi"), "")

const semana = sendHours("dddd")

if(isOwner && budy.includes("reiniciar-lady") || info.key.fromMe && budy.includes("reiniciar-bot")) {
fs.writeFileSync("./cnt-upd.json",JSON.stringify([], null, 2))
setTimeout(() => {
file = require.resolve("./start.js")  
delete require.cache[file]
require(file)  
}, 500)
setTimeout(() => {
DLT_FL("./cnt-upd.json")
}, 1500)
}

//========================================\\

if(isGroup && !isJsonIncludes(openclosegp, from)) rgGroupOCfunc(from)

if(isGroup && !isJsonIncludes(ads, from)) addGroupInAds(from)

if(isGroup && !isJsonIncludes(paidHours, from)) addGroupInPaid(from)

if(isGroup && !isJsonIncludes(groupLinkPaid, from)) addGroupLinkInPaid(blackmd, from)

async function paidFunc() {
    if(paidHours.length > 0) {
        totalpaid = 0
        for(p of paidHours) {
            if(p.horarios.length > 0) totalpaid += 1
        }
        if(totalpaid > 0) {
            try {
                ABC = await fetchJson(`https://blacksystemofc.com.br/vip/horarios?apikey=black`)
                for(a of paidHours) {
                    if(a.horarios.length > 0 && a.start) {
                        for(b of a.horarios) {
                            if(b.dias <= 0) {
                                if(contarMin(sendHours(`HH:mm`)) >= contarMin(b.tempo)) {
                                    multiplicador = b.nmr
                                    if(b.letra == `h`) multiplicador *= 60
                                    atual = sendHours(`HH:`) + (b.letra == `m` ? !String(b.nmr / 5).includes(`.`) ? String(Number(sendHours(`mm`)) - (Number(sendHours(`mm`)) % 5)) : sendHours(`mm`) : `00`)
                                    soma = contarMin(atual) + multiplicador
                                    if(soma >= 1440) {
                                        b.tempo = converterMin(soma % 1440)
                                        savePaid()
                                        b.dias += (soma - (soma % 1440)) / 1440
                                        savePaid()
                                    } else {
                                        b.tempo = converterMin(soma)
                                        savePaid()
                                    }
                                    blackmd.sendMessage(a.groupId, {image: {url: getGroupLinkFromPaidID(a.groupId)}, caption: `🍀 *HORÁRIOS PAGANTES DAS ${sendHours("HH")}h* 💰

${ABC.resultado.map(h => `*${h.name}*
${h.times.map(p => `⥲ ${p}`).join(`\n`)}`).join(`\n\n`)}

${ABC.dica}`, contextInfo: {forwardingScore: 999, isForwarded: true}})
                                }
                            } else {
                                if(Number(sendHours(`DD`)) !== Number(b.save)) {
                                    b.save = sendHours(`DD`)
                                    savePaid()
                                    b.dias -= 1
                                    savePaid()
                                }
                            }
                        }
                    }
                }
            } catch(e) {console.log(e)}
        }
    }
}

//executores de ambas as funções
if(body != undefined && from != undefined) { rentContSystem(blackmd, sendMess, tempo); cardTime(blackmd, tempo); ABRIR_E_FECHAR_GRUPO(blackmd); adsFunc(blackmd); paidFunc(); }

//BAN GRUPO & BOT OFF
if(isGroup && isCmd && isBanchat && !isOwner) return

if(isGroup && isCmd && isAntiMembros && !isOwner && !isGroupAdmins) return

if(isBotoff && !isOwner) return

let isCmdKey = Array(`alugar`, `aluguel`, `recarga`, `recarregar`, `rp`, `me`, `buygp`, `buycort`, `buykeygp`, `buyvip`, `buyvipgp`, `buycard`, `buycardxp`, `reembolsar`, `loja`, `store`, `lojalista`, `storelist`, `transferirgp`).some(item => item === command)

if(isCmd && isCmdKey) registrarUsuInVirtualBalance(sender)

bannedExpired()

if(isCmd) isBannedMessageUsu(from, sender, blackmd, `[❗] Atenção @${sender.split("@")[0]}, você está impedido de usar o bot... Caso tenha alguma dúvida, chame meu dono para saber o pq 📵`)

if(isBanned(sender)) return

if(isGroup && isCmd && !isOwner && !isCmdKey && isModRent) {
  if(!isSaveGroup(from)) addGroupInRent(from)
  gp = getSaveGroup(from)
  if(!gp.validado && !isGroupInRent(from)) {
    if(gp.limite <= 1) {
      rmGroupInRent(from)
      reply(`Visto que os senhores não se vêem interessados em adquirir uma key, vou indo...`)
      await sleep(3000)
      return blackmd.groupLeave(from)
    } else {
      gp.limite -= 1
      saveGroupsRent()
      return reply(`✋🏽😳🤚🏽 PAROU !! Não encontrei esse grupo em meus registros... Pfvr, caso o mesmo seja alugado, será necessário o uso de uma chave de acesso para ativar os comandos. Caso não tenha uma, podes comprar no comando ${prefix}buykeygp`)
    }
  }
}

if(isGroup && !isOwner && isModRent && !existKeyRentSystem(body) && !isJsonIncludes(grupos, from) && !isJsonIncludes(aluguel, from)) return

if(isGroup && isCmd) {
  caixa = []
  for(i of allCases) {
    if(type == "conversation" && command == i) caixa.push(i)
  }
  if(caixa.length > 0) {
    var contadorcmd = 0
    for(c of rankcmd) {
      if(caixa[0] == c.cmd) {
        c.usado += 1
        saveJSON(rankcmd, "./basededados/rankcmd.json")
        contadorcmd += 1
      }
    }
    if(contadorcmd <= 0) {
      rankcmd.push({cmd: caixa[0], usado: 1})
      saveJSON(rankcmd, "./basededados/rankcmd.json")
    }
  }
}

//=======================================\\

const sendStickerFromUrl = async(to, url) => {
try {
var names = Date.now() / 10000;
var download = function (uri, filename, callback) {
request.head(uri, function (err, res, body) {
request(uri).pipe(fs.createWriteStream(filename)).on('close', callback);
});
};
download(url, './sticker' + names + '.png', async function () {
console.log('enviando sticker');
let filess = './sticker' + names + '.png'
let asw = './sticker' + names + '.webp'
exec(`ffmpeg -i ${filess} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${asw}`, (err) => {
let media = fs.readFileSync(asw)
blackmd.sendMessage(to, {sticker: media}, {sendEphemeral: true, contextInfo: { forwardingScore: 50, isForwarded: true}, quoted: seloctt}).catch(e => {
return reply("Erro..")
})
DLT_FL(filess)
DLT_FL(asw)
});
});
} catch {
return reply("Erro.. FNC")
}
}

const sendStickerFromImageLink = async(id, image, packname, author, hehe) => {
  img = await prepareWAMessageMedia({image: image}, {upload: blackmd.waUploadToServer})
  getfile = await getFileBuffer(img, `image`)
  envst = await sendImageAsSticker(blackmd, from, getfile, hehe, {packname: packname, author: author})
  DLT_FL(envst)
}

//=========(isQuoted/consts)=============\\
const isImage = type == 'imageMessage'
const isVideo = type == 'videoMessage'
const isVisuU2 = type == 'viewOnceMessageV2'
const isAudio = type == 'audioMessage'
const isSticker = type == 'stickerMessage'
const isContact = type == 'contactMessage'
const isLocation = type == 'locationMessage'
const isProduct = type == 'productMessage'
const isMedia = (type === 'imageMessage' || type === 'videoMessage' || type === 'audioMessage' || type == "viewOnceMessage" || type == "viewOnceMessageV2")
typeMessage = body.substr(0, 50).replace(/\n/g, '')
if(isImage) typeMessage = "Image"
else if(isVideo) typeMessage = "Video"
else if(isAudio) typeMessage = "Audio"
else if(isSticker) typeMessage = "Sticker"
else if(isContact) typeMessage = "Contact"
else if(isLocation) typeMessage = "Location"
else if(isProduct) typeMessage = "Product"

const isQuotedMsg = type === 'extendedTextMessage' && content.includes('conversation')

const isQuotedMsg2 = type === 'extendedTextMessage' && content.includes('text')

const isQuotedImage = type === 'extendedTextMessage' && content.includes('imageMessage')

const isQuotedVisuU = type === 'extendedTextMessage' && content.includes('viewOnceMessage')

const isQuotedVisuU2 = type === 'extendedTextMessage' && content.includes('viewOnceMessageV2')

const isQuotedVideo = type === 'extendedTextMessage' && content.includes('videoMessage')

const isQuotedDocument = type === 'extendedTextMessage' && content.includes('documentMessage')

const isQuotedDocW = type === 'extendedTextMessage' && content.includes('documentWithCaptionMessage')

const isQuotedAudio = type === 'extendedTextMessage' && content.includes('audioMessage')

const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')

const isQuotedContact = type === 'extendedTextMessage' && content.includes('contactMessage')

const isQuotedLocation = type === 'extendedTextMessage' && content.includes('locationMessage')

const isQuotedProduct = type === 'extendedTextMessage' && content.includes('productMessage')
            
//////BLOCK CMD///////
//(CREDITOS AO KAUAN GAY)\\
if(isGroup){
const checar = getComandos(from)
if(checar === undefined) addComandosId(from)
}
if(isGroup && isCmd && !isOwner && !isnit && getComandoBlock(from).includes(command)) return reply('⚠️ *COMANDO BLOQUEADO* ⚠️')

if(isGroup && isCmd && isStopCmd && isBlockGlobalCmd(command) && !isOwner) return reply("⚠️ *INDISPONÍVEL TEMPORARIAMENTE* ⚠️")

if(isGroup) {
  if(!isJsonIncludes(limitcmd, from)) rgGroupLC(from)
  if(isCmd && !isOwner) {
    getcmd = isLimitCmd(from, command)
    if(getcmd.boolean) {
      if(isMaxUsageLC(from, command)) return reply(`⚠ _Este comando atingiu o máximo de uso neste grupo por hoje... Por favor, volte amanhã_ 🥰`)
      addCmdUsageLC(from, command)
    }
  }
}

nextDayLC();

aniversarioDeNamoroOuCasamento(blackmd);

////FIMMMMMMMMM/////
if(isConsole) {
if(isGroup && info.message?.reactionMessage?.text) {
console.log(colors.cyan(`
╓─━${"⎓⎔".repeat(20)}⎓━─┒
┢╕\t\t${colors.white(NomeDoBot)}
╽╟ • usuário ~> ${colors.brightYellow(pushname)}
╽║
╽╟ • número ~> ${colors.brightMagenta(sender.includes(`status`) ? `status` : addNumberMais(sender))}
╽║
╽╟ • grupo ~> ${isGroup ? colors.blue(groupName) : colors.red(`"privado"`)}
╽║
╽╟ • reação ~>『 ${info.message.reactionMessage.text} 』
┕╨${"⚋".repeat(44)}┚
`))
} else if(isGroup && !isCmd) {
console.log(colors.cyan(`
╓─━${"⎓⎔".repeat(20)}⎓━─┒
┢╕\t\t${colors.white(NomeDoBot)}
╽╟ • usuário ~> ${colors.brightYellow(pushname)}
╽║
╽╟ • número ~> ${colors.brightMagenta(sender.includes(`status`) ? `status` : addNumberMais(sender))}
╽║
╽╟ • grupo ~> ${colors.blue(groupName)}
╽║
╽╟ • tipo ~> ${colors.white(type == "stickerMessage" ? `"figurinha"` : type == "documentMessage" ? `"documento"` : type == "locationMessage" ? `"localização"` : type == "audioMessage" ? `"áudio"` : type == "videoMessage" ? `"vídeo"` : type == "imageMessage" ? `"imagem"` : `"mensagem"`)}
┕╨${"⚋".repeat(44)}┚
`))
} else if(isCmd && !isGroup) {
console.log(colors.cyan(`
╓─━${"⎓⎔".repeat(20)}⎓━─┒
┢╕\t\t${colors.white(NomeDoBot)}
╽╟ • usuário ~> ${colors.brightYellow(pushname)}
╽║
╽╟ • número ~> ${colors.brightMagenta(sender.includes(`status`) ? `status` : addNumberMais(sender))}
╽║
╽║『 ${colors.red("privado")} 』
╽║
╽╟ • comando ~> ${colors.white(prefix+command)}
┕╨${"⚋".repeat(44)}┚
`)) 
} else if(isCmd && isGroup) {
console.log(colors.cyan(`
╓─━${"⎓⎔".repeat(20)}⎓━─┒
┢╕\t\t${colors.white(NomeDoBot)}
╽╟ • usuário ~> ${colors.brightYellow(pushname)}
╽║
╽╟ • número ~> ${colors.brightMagenta(sender.includes(`status`) ? `status` : addNumberMais(sender))}
╽║
╽╟ • grupo ~> ${colors.blue(groupName)}
╽║
╽╟ • comando ~> ${colors.white(prefix+command)}
┕╨${"⚋".repeat(44)}┚
`))
} else {
console.log(colors.cyan(`
╓─━${"⎓⎔".repeat(20)}⎓━─┒
┢╕\t\t${colors.white(NomeDoBot)}
╽╟ • usuário ~> ${colors.brightYellow(pushname)}
╽║
╽╟ • número ~> ${colors.brightMagenta(sender.includes(`status`) ? `status` : addNumberMais(sender))}
╽║
╽║『 ${colors.red("privado")} 』
┕╨${"⚋".repeat(44)}┚
`))
}
}

//======(JOGO-DA-VELHA)=======(Função)===\\

async function joguinhodavelha() {
if(joguinhodavelhajs2.includes(from) || joguinhodavelhajs.includes(sender)) {
const cmde = budy.toLowerCase().split(" ")[0] || "";
let arrNum = ["1", "2", "3", "4", "5", "6", "7", "8", "9"];
if(fs.existsSync(`./armor/tictactoe/db/${from}.json`)) {
const boardnow = setGame(`${from}`);
if(budy == "Cex") return reply("why");
if(
budy.toLowerCase() == "s" ||
budy.toLowerCase() == "sim" ||
budy.toLowerCase() == "ok"
) {
if(boardnow.O == sender.replace("@s.whatsapp.net", "")) {
if(boardnow.status)
return reply(`O jogo já começou antes!`);
const matrix = boardnow._matrix;
boardnow.status = true;
fs.writeFileSync(`./armor/tictactoe/db/${from}.json`,
JSON.stringify(boardnow, null, 2)
);
const chatAccept = `*🎮Ꮐ̸Ꭺ̸Ꮇ̸Ꭼ̸ Ꭰ̸Ꭺ̸ Ꮩ̸Ꭼ̸Ꮮ̸Ꮋ̸Ꭺ̸🕹️*
                    
❌ : @${boardnow.X}
⭕ : @${boardnow.O}
               
Sua vez... : @${boardnow.turn == "X" ? boardnow.X : boardnow.O}

${matrix[0][0]}  ${matrix[0][1]}  ${matrix[0][2]}
${matrix[1][0]}  ${matrix[1][1]}  ${matrix[1][2]}
${matrix[2][0]}  ${matrix[2][1]}  ${matrix[2][2]}
`;
mention(chatAccept);
}
} else if(
budy.toLowerCase() == "n" ||
budy.toLowerCase() == "não" ||
budy.toLowerCase() == "no"
) {
if(boardnow.O == sender.replace("@s.whatsapp.net", "")) {
if(boardnow.status)
return reply(`O jogo já começou!`);
DLT_FL(`./armor/tictactoe/db/${from}.json`);
mention(`@${boardnow.X} *_Infelizmente seu oponente não aceitou o desafio ❌😕_*`)
joguinhodavelhajs.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
}
}
}

if(arrNum.includes(cmde)) {
const boardnow = setGame(`${from}`);
if(!boardnow.status) return reply(`Parece que seu oponente não aceitou o desafio ainda...`)
if(
(boardnow.turn == "X" ? boardnow.X : boardnow.O) !=
     
sender.replace("@s.whatsapp.net", "")
)
return;
const moving = validmove(Number(budy), `${from}`);
const matrix = moving._matrix;
if(moving.isWin) {
if(moving.winner == "SERI") {
const chatEqual = `*🎮Ꮐ̸Ꭺ̸Ꮇ̸Ꭼ̸ Ꭰ̸Ꭺ̸ Ꮩ̸Ꭼ̸Ꮮ̸Ꮋ̸Ꭺ̸🕹️*
          
Jogo termina empatado 😐
`;
reply(chatEqual);
DLT_FL(`./armor/tictactoe/db/${from}.json`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs)) 
joguinhodavelhajs2.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
return;
}
const abt = Math.ceil(Math.random() + 4000)
const winnerJID = moving.winner == "O" ? moving.O : moving.X;
const looseJID = moving.winner == "O" ? moving.X : moving.O;
const limWin = Math.floor(Math.random() * 1) + 10;
const limLoose = Math.floor(Math.random() * 1) + 5;
const chatWon = `*🎮Ꮐ̸Ꭺ̸Ꮇ̸Ꭼ̸ Ꭰ̸Ꭺ̸ Ꮩ̸Ꭼ̸Ꮮ̸Ꮋ̸Ꭺ̸🕹️*
          
Vencido por @${winnerJID} 😎👑
`;

blackmd.sendMessage(from, {text: chatWon, mentions: [identArroba(winnerJID)]}, {quoted: seloctt,
mentions: [
moving.winner == "O" ?
moving.O + "@s.whatsapp.net" :
moving.X + "@s.whatsapp.net"]
});
setTimeout( () => {
if(fs.existsSync("./armor/tictactoe/db/" + from + ".json")) {
DLT_FL("./armor/tictactoe/db/" + from + ".json");
reply(`*🕹️JOGO DA VELHA RESETADO... 🕹️*

*⚠️ JOGADORES DEMORARAM MUITO ⚠️*`);
} else {
console.log(colors.red(time, "red"), colors.magenta("[ EXPIRADO ]"), colors.red('Jogo da velha espirado'));
}
joguinhodavelhajs.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
}, 300000) //5 minutos
DLT_FL(`./armor/tictactoe/db/${from}.json`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs)) 
joguinhodavelhajs2.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
} else {
const chatMove = `*🎮Ꮐ̸Ꭺ̸Ꮇ̸Ꭼ̸ Ꭰ̸Ꭺ̸ Ꮩ̸Ꭼ̸Ꮮ̸Ꮋ̸Ꭺ̸🕹️*
          
❌ : @${moving.X}
⭕ : @${moving.O}

Sua vez : @${moving.turn == "X" ? moving.X : moving.O}

${matrix[0][0]}  ${matrix[0][1]}  ${matrix[0][2]}
${matrix[1][0]}  ${matrix[1][1]}  ${matrix[1][2]}
${matrix[2][0]}  ${matrix[2][1]}  ${matrix[2][2]}
`;
mention(chatMove);
}
} 
} 
}

//=================================\\

joguinhodavelha()

if(isGroup && !isGroupAdmins && !isOwner && info?.message?.requestPaymentMessage && isBotGroupAdmins) {
  fechargp(from)
  await sleep(1500)
  remover(from, sender)
  await sleep(2000)
  for(i = 0; i < 5; i++) {
    await sleep(500)
    sendMess(from, `${`\t`.repeat(10)}\n${i == 4 ? "LIMPEZA CONCLUÍDA 🗑️" : ""}`.repeat(50))
  }
  await sleep(1500)
  abrirgp(from)
}

if(isGroup) {
  notGroupRegisteredSALGP(from);
  notGroupRegisteredSALHARD(from);
}

if(isAntilinkgp && isGroup && isBotGroupAdmins && !isGroupAdmins) {
  if(Procurar_String.includes("chat.whatsapp.com/")){
    if(isBot) return 
    link_dgp = await blackmd.groupInviteCode(from)
    if(Procurar_String.match(link_dgp)) return reply(`Como esse é o link do nosso grupo, não irei remover... Você deu sorte dessa vez 😰`)
    if(!JSON.stringify(groupMembers).includes(sender)) return
    function delgp() {blackmd.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})}
    //aqui começa o escudo anti link
    if(isShieldGPuser(from, sender)) {
      pessoa = getShieldGPuser(from, sender)
      isInfinity = pessoa.infinito
      if(isInfinity) {
        delgp()
        await sleep(2000)
        return sendMess(from, `Sem links pfvr ${pushname}...`)
      } else {
        if(pessoa.quant > 0) {
          pessoa.quant -= 1
          saveSALGP();
          await sleep(2000)
          nmr = getShieldGPuser(from, sender).quant + 1
          return sendMess(from, `Anti link GP está ativado ${pushname}... Pra sua sorte, você ainda tem direito a enviar +${nmr} link${nmr != 1 ? `s` : ``} 🥰`)
        } else {
          rmShieldGP(from, sender)
          delgp()
          await sleep(1000)
          remover(from, sender)
          await sleep(1000)
          return sendMess(from, `Suas chances acabaram ${pushname}... Falta de aviso não foi 😪`)
        }
      }
    } else if(!isBanlinkgp) {
      delgp()
      await sleep(1500)
      AB = dataGp[0].advertir.map(i => i.id).indexOf(sender)
      if(AB >= 0) {
        if(dataGp[0].advertir[AB].adv < 2) {
          dataGp[0].advertir[AB].adv += 1
          setGp(dataGp)
          return blackmd.sendMessage(from, {text: `[❗] Atenção @${sender.split("@")[0]}, você foi advertido ${dataGp[0].advertir[AB].adv} vezes... O próximo envio de link resultará em banimento 💢`, mentions: [sender]})
        } else {
          blackmd.sendMessage(from, {text: `[❗] Você não me deu escolha @${sender.split("@")[0]}... Por desacato a autoridade, irei te aplicar a devida punição 💢`, mentions: [sender]})
          dataGp[0].advertir.splice(AB, 1)
          setGp(dataGp)
          await sleep(1500)
          return remover(from, sender)
        }
      } else {
        dataGp[0].advertir.push({id: sender, adv: 1})
        setGp(dataGp)
        return blackmd.sendMessage(from, {text: `[❗] Atenção @${sender.split("@")[0]}, é terminantemente proibido o envio de links neste grupo... Por sorte, o sistema de ban está desativado, mas isso não lhe isenta de ser advertido 💢`, mentions: [sender]})
      }
    } else {
      blackmd.sendMessage(from, {text: `[❗] aplicando punição ao usuário @${sender.split("@")[0]} por enviar link ❌`, mentions: [sender]})
      await sleep(1000)
      remover(from, sender)
      await sleep(1000)
      delgp()
    }
  }
}

if(isUrl(PR_String) && isAntiLinkHard && !isGroupAdmins && isBotGroupAdmins && !info.key.fromMe) {
  if(Procurar_String.includes("chat.whatsapp.com")) {
    link_dgp = await blackmd.groupInviteCode(from)
    if(Procurar_String.match(link_dgp)) return reply('Link do nosso grupo, não irei remover.. ') 
  }
  if(isCmd && isTrueFalse) return
  if(!JSON.stringify(groupMembers).includes(sender)) return
  function delhard() {blackmd.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})}
  //aqui começa o escudo anti link
  if(isShieldHARDuser(from, sender)) {
    pessoa = getShieldHARDuser(from, sender)
    isInfinity = pessoa.infinito
    if(isInfinity) {
      delhard()
      await sleep(2000)
      return sendMess(from, `Sem links pfvr ${pushname}...`)
    } else {
      if(pessoa.quant > 0) {
        pessoa.quant -= 1
        saveSALHARD();
        await sleep(2000)
        nmr = getShieldHARDuser(from, sender).quant + 1
        return sendMess(from, `Anti link HARD está ativado ${pushname}... Pra sua sorte, você ainda tem direito a enviar +${nmr} link${nmr != 1 ? `s` : ``} 🥰`)
      } else {
        rmShieldHARD(from, sender)
        delhard()
        await sleep(1000)
        remover(from, sender)
        await sleep(1000)
        return sendMess(from, `Suas chances acabaram ${pushname}... Falta de aviso não foi 😪`)
      }
    }
  } else if(!isBanLinkHard) {
    delhard()
    await sleep(1500)
    AB = dataGp[0].advertir.map(i => i.id).indexOf(sender)
    if(AB >= 0) {
      if(dataGp[0].advertir[AB].adv < 2) {
        dataGp[0].advertir[AB].adv += 1
        setGp(dataGp)
        return blackmd.sendMessage(from, {text: `[❗] Atenção @${sender.split("@")[0]}, você foi advertido ${dataGp[0].advertir[AB].adv} vezes... O próximo envio de link resultará em banimento 💢`, mentions: [sender]})
      } else {
        blackmd.sendMessage(from, {text: `[❗] Você não me deu escolha @${sender.split("@")[0]}... Por desacato a autoridade, irei te aplicar a devida punição 💢`, mentions: [sender]})
        dataGp[0].advertir.splice(AB, 1)
        setGp(dataGp)
        await sleep(1500)
        return remover(from, sender)
      }
    } else {
      dataGp[0].advertir.push({id: sender, adv: 1})
      setGp(dataGp)
      return blackmd.sendMessage(from, {text: `[❗] Atenção @${sender.split("@")[0]}, é terminantemente proibido o envio de links neste grupo... Por sorte, o sistema de ban está desativado, mas isso não lhe isenta de ser advertido 💢`, mentions: [sender]})
    }
  } else {
    blackmd.sendMessage(from, {text: `[❗] aplicando punição ao usuário @${sender.split("@")[0]} por enviar link ❌`, mentions: [sender]})
    await sleep(1000)
    remover(from, sender)
    await sleep(1000)
    delhard()
  }
}

if(isCmd && !isVip) {
if(isFiltered(sender)) {
return mention(`🛑 Para evitar spam, aguarde 5s @${sender.split("@")[0]} 📵`)
} else {
addFilter(sender)
}
}

const allGroupIDcountMessage = [];
for(i of countMessage) {
allGroupIDcountMessage.push(i.groupId);
}

const isGroupCountMessage = (grupo = from) => {return allGroupIDcountMessage.indexOf(grupo) >= 0 ? true : false}

const getCountGroupMessage = isGroup && allGroupIDcountMessage.indexOf(from) >= 0 ? countMessage[allGroupIDcountMessage.indexOf(from)] : {}

const usuInCountMessage = (usu = sender) => {
  if(!isGroupCountMessage(from)) return false
  return isJsonIncludes(getCountGroupMessage.participants, usu)
}

const getUsuCountMessage = (usu = sender) => {
  AB = getCountGroupMessage.participants.map(i => i.id).indexOf(usu)
  return getCountGroupMessage.participants[AB]
}

//========(CONTADOR-DE-MENSAGENS)========\\
if(budy2 != undefined && isGroup) {
  if(!isJsonIncludes(countMessage, from)) {
    countMessage.push({groupId: from, participants: []})
    saveJSON(countMessage, `./basededados/countmsg.json`)
  } else {
    AB = countMessage.map(a => a.groupId).indexOf(from)
    if(!isJsonIncludes(countMessage[AB].participants, sender)) {
      countMessage[AB].participants.push({id: sender, mensagens: 0, comandos: 0})
      saveJSON(countMessage, `./basededados/countmsg.json`)
    } else {
      AC = countMessage[AB].participants.map(b => b.id).indexOf(sender)
      usu = countMessage[AB].participants[AC]
      msg = 0
      cmd = 0
      if(isCmd) cmd += 1
      else msg += 1
      usu.mensagens += msg
      usu.comandos += cmd
      saveJSON(countMessage, `./basededados/countmsg.json`)
    }
  }
}

const downloadAndSaveMediaMessage = async (message, filename, attachExtension = true) => {
  const FileType = require("file-type");
  let quoted = message.msg ? message.msg : message
  let mime = (message.msg || message).mimetype || ''
  let messageType = mime.split('/')[0].replace('application', 'document') ? mime.split('/')[0].replace('application', 'document') : mime.split('/')[0]
  const stream = await downloadContentFromMessage(quoted, messageType)
  let buffer = Buffer.from([])
  for await (const chunk of stream) {
      buffer = Buffer.concat([buffer, chunk])
  }
  let type = await FileType.fromBuffer(buffer)
  filedesbug = `${Math.floor(Math.random() * 9999)}`
  trueFileName = attachExtension ? (filedesbug + '.' + type.ext) : filename
  // save to file
  await fs.writeFileSync(trueFileName, buffer)
  return trueFileName
}

const { Sticker } = require("./armor/sticker/rename/sticker.js");

async function renameSticker2024(pack, autor, hehe) {
  try {
    getfile = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker');
    var _sticker = new Sticker()
    _sticker.addFile(getfile); 
    _sticker.options.metadata = {pack: pack, author: autor, emojis: ['🤠', '🥶', '😻']};
    resultadoSt = await _sticker.start();
    await blackmd.sendMessage(from, {sticker: fs.readFileSync(resultadoSt[0].value)}, {quoted: hehe})
    await fs.unlinkSync(resultadoSt[0].value)
  } catch(e) {console.log(e)}
}

async function renameContextSticker(pack, autor, txt = ``, hehe) {
  try {
    getfile = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker');
    var _sticker = new Sticker()
    _sticker.addFile(getfile); 
    _sticker.options.metadata = {pack: pack, author: autor, emojis: ['🤠', '🥶', '😻']};
    resultadoSt = await _sticker.start();
    await blackmd.sendMessage(from, {sticker: fs.readFileSync(resultadoSt[0].value), contextInfo: {externalAdReply: {title: txt, body:"", previewType:"PHOTO", thumbnail: fs.readFileSync(resultadoSt[0].value)}}}, {quoted: hehe})
    await fs.unlinkSync(resultadoSt[0].value)
  } catch(e) {console.log(e)}
}

//============(EVAL-EXECUÇÕES)===========\\

if(budy.startsWith('>')){
try {
if(info.key.fromMe) return 
if(!isOwner && !isnit && !issupre && !ischyt && !issupre && !ischyt) return
console.log('[', colors.cyan('EVAL'),']', colors.yellow(moment(info.messageTimestamp * 1000).format('DD/MM HH:mm:ss')), colors.green(budy))
return blackmd.sendMessage(from, {text: JSON.stringify(eval(budy.slice(2)),null,'\t')}).catch(e => {
return reply(String(e))
})
} catch (e){
return reply(String(e))
}
}

if(budy.startsWith('(>')){
try {
if(info.key.fromMe) return   
if(!isOwner && !isnit && !issupre && !ischyt && !issupre && !ischyt) return 
var konsol = budy.slice(3)
Return = (sul) => {
var sat = JSON.stringify(sul, null, 2)
bang = util.format(sat)
if(sat == undefined){
bang = util.format(sul)
}
return blackmd.sendMessage(from, {text: bang}, {quoted: seloctt})
}

blackmd.sendMessage(from, {text: util.format(eval(`;(async () => { ${konsol} })()`))}).catch(e => { 
return reply(String(e))
})
console.log('\x1b[1;37m>', '[', '\x1b[1;32mEXEC\x1b[1;37m', ']', time, colors.green(">"), 'from', colors.green(sender.split('@')[0]), 'args :', colors.green(args.length))
} catch(e) {
return reply(String(e))
console.log(e)
}
}

if(body.startsWith('$')) {
if(info.key.fromMe) return 
if(!isOwner && !isnit) return 
exec(q, (err, stdout) => {
if(err) return reply(`${err}`)
if(stdout) {
reply(stdout)
}
})
}

//======================================\\


//======(ANTI-IMAGEM)========\\
if(isAntiImg && isBotGroupAdmins && type == 'imageMessage') {
if(info.key.fromMe) return
if(isGroupAdmins) return blackmd.sendMessage(from, {text:'O ban já ia cantar kkkkk cê deu sorte que é admin 🤪'}, {quoted: seloctt})
if(dataGp[0].legenda_imagem != "0") {
blackmd.sendMessage(from, {text: dataGp[0].legenda_imagem}, {quoted: seloctt})  
}
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return  
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}

//======(ANTI-STICKER)========\\
if(isAntiSticker && isBotGroupAdmins && type == 'stickerMessage') {
if(info.key.fromMe) return
if(isGroupAdmins) return blackmd.sendMessage(from, {text:'O ban já ia cantar kkkkk cê deu sorte que é admin 🤪'}, {quoted: seloctt})
blackmd.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: seloctt})
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return  
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}

if(Antidoc && isBotGroupAdmins && type == 'documentMessage') {
if(info.key.fromMe) return
if(isGroupAdmins) return blackmd.sendMessage(from, {text:'O ban já ia cantar kkkkk cê deu sorte que é admin 🤪'}, {quoted: seloctt})
if(dataGp[0].legenda_documento != "0") {
blackmd.sendMessage(from, {text: dataGp[0].legenda_documento}, {quoted: seloctt}) 
}
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return  
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}

let isTrueFalse = Array("play", "play2", "play3", "play4", "play5", "spotify", "playlist", "ytsearch", "ytmp4", "ytmp4-2", "ytmp3", "ytmp3-2", "tiktok", "tiktok2", "tiktokimg", "instamp3", "facebook", "facebook2", "twitter").some(item => item === command)

// ANTI NOTAS FAKES ======================>

if(isAntiNotas && budy2.toString().match(/(💳|💎|💸|💵|💷|💶|🪙|💰|🤑|⚖️)/gi) && isBotGroupAdmins && !isGroupAdmins && !isOwner && !info.message?.reactionMessage?.text && budy2.length > 20) {
let verificar = budy2.toString().match(/(💳|💎|💸|💵|💷|💶|🪙|💰|🤑|⚖️)/gi)
if(verificar && budy.length < 100) return  
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return  
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}

//FINALZIN ==============================>

//======(ANTI-PORNO)========\\

if(isGroup && isAntiPorno && isImage && isBotGroupAdmins) {
  try {
    getimg = info.message.imageMessage
    getfi = await getFileBuffer(getimg, 'image')
    upl = await upload(getfi)
    ABC = await fetchJson(`https://blacksystemofc.com.br/api/antiporno?url=${upl}&apikey=black`)
    if(ABC.porno) {
      if(isGroupAdmins || isVip) {
        blackmd.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
        await sleep(1000)
        return sendMess(from, `🔞 Anti porno ativado... Punição revogada por participante ser ${isGroupAdmins ? `ADM` : `VIP`} ❌`)
      } else {
        remover(from, sender)
        await sleep(1000)
        blackmd.sendMessage(from, {text: `🔞 Anti porno ativado... Aplicando punição ao usuário @${sender.split("@")[0]} ❌`, mentions: [sender]})
        await sleep(1000)
        blackmd.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
      }
    }
  } catch(e) {console.log(`Não foi possível rodar o anti porno - `, e)}
}

//======(ANTI-VIDEO)========\\

if(isAntiVid && isBotGroupAdmins && type == 'videoMessage') {
if(isGroupAdmins) return blackmd.sendMessage(from,{text:'O ban já ia cantar kkkkk cê deu sorte que é admin 🤪'}, {quoted: seloctt})
if(dataGp[0].legenda_video == "0") {
blackmd.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: seloctt})
} else {
blackmd.sendMessage(from, {text: dataGp[0].legenda_video}, {quoted: seloctt})  
}
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}

//======(ANTI-AUDIO)=======\\
if(isAntiAudio && isBotGroupAdmins && type == 'audioMessage') {
if(isGroupAdmins) return blackmd.sendMessage(from, {text:'O ban já ia cantar kkkkk cê deu sorte que é admin 🤪'}, {quoted: seloctt})
blackmd.sendMessage(from, {text: '*mensagem proibida detectada, banindo...*'}, {quoted: seloctt})
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}

//========(ANTI-PV-QUE-BLOQUEIA)======\\

if(isAntiPv) {
if(!isGroup && !isOwner && !isnit && !isVip && !isCmdKey){ 
reply(`[❗] Modo ANTI PV está ativo ${pushname}... Sinto muito, mas não vejo outra opção a não ser te bloquear 🚫`)
await sleep(2500)
return blackmd.updateBlockStatus(sender, 'block')
}
}

//=========(ANTIPV-QUE-SÓ-FALA)==========\\

if(!isGroup && !isVip && !isOwner && !isnit && !issupre && !ischyt && !info.key.fromMe && isAntiPv2 && isCmd && !isCmdKey) return sendUrlText(from, `[❗] Atenção ${pushname}, o modo ANTI PV está ativo... Recebi ordens para não responder usuários inferiores aqui ❌`, NomeDoBot, ``, logoslink.menu, `https://wa.me/`+nmrdn.split("@")[0], seloctt)

//======================================\\

// ANTI_LIGAR \\

if(!isGroup && isAnticall) {
blackmd.ws.on('CB:call', async (B) => {
if(B.content[0].tag == 'offer') {
blackmd.sendMessage(B.content[0].attrs['call-creator'], {text: `[ ❌ ] É proibido ligar pro bot... BLOQUEADO!! 🚫`}).then(() => {
setTimeout(() => {
blackmd.updateBlockStatus(B.content[0].attrs['call-creator'], "block")
}, 2500)
})
}
})
}

//======================================\\

if(isAntiVisuUnica) {
if(info.message?.viewOnceMessageV2 || type == "viewOnceMessage") {
if(JSON.stringify(info).includes("videoMessage")) {
var px = info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage
px.viewOnce = false
px.video = {url: px.url}
px.caption += "\n\n👁 *REVELANDO ONE VISION* 👁"
blackmd.sendMessage(from, px)
} else {
var px = info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage
px.viewOnce = false
px.image = {url: px.url}
px.caption += "\n\n👁 *REVELANDO ONE VISION* 👁"
blackmd.sendMessage(from, px)
}}}

//X9 de fixação de msg
if(fs.existsSync(`./basededados/grupos/${from}.json`) && jsonGp[0].x9 && info.message?.messageContextInfo?.messageAddOnDurationInSecs) {
duration = info.message?.messageContextInfo?.messageAddOnDurationInSecs
fixedTime = Number(duration) === 0 ? `0` : duration == (60 * 60 * 24) ? `24h` : duration == (60 * 60 * 24 * 7) ? `7d` : `30d`
action = Number(fixedTime) === 0 ? `desafixar uma mensagem 📌` : `fixar uma mensagem por ${fixedTime} 📍`
blackmd.sendMessage(from, {text: `*O admin @${sender.split("@")[0]} acaba de ${action}*`, contextInfo: {mentionedJid: [sender], forwardingScore: 999, isForwarded: true}})
}

//convite no pv
if(info?.message?.groupInviteMessage?.inviteCode) {
  invite_info = info?.message?.groupInviteMessage
  id_of_group = invite_info?.groupJid
  group_name = invite_info?.groupName
  if(isOwner || isJsonIncludes(aluguel, sender)) {
    let { key } = await blackmd.sendMessage(sender, {text: `Um segundo mestre, estou entrando no grupo... 🚶🏻‍♂️`}, {quoted: info})
    await sleep(1200)
    try {
      if(isOwner) {
        await blackmd.groupAcceptInviteV4(info.key, invite_info)
        await sleep(2000)
        blackmd.sendMessage(id_of_group, {text: `*Olá mestre, aqui estou eu* 🙇🏻‍♂️`})
      } else {
        if(isGroupInRent(id_of_group)) {
          ggrt = getGroupRent(id_of_group)
          if(ggrt.cliente != sender) {
            client_groups = []
            for(c of client_groups) {
              if(c.cliente == sender) client_groups.push(c)
            }
            blackmd.sendMessage(sender, {text: `Você não é o cliente responsável por esse grupo @${sender.split("@")[0]}... ${client_groups.length > 1 ? `Os grupos registrados no seu número são:\n${client_groups.map(gp => `• ${gp.nome}`).join(`\n`)}` : `O único grupo registrado no seu número é o "${client_groups[0].nome}" 💰`}`, mentions: [sender], edit: key}, {quoted: info})
          } else {
            await blackmd.groupAcceptInviteV4(info.key, invite_info)
            await sleep(1000)
            blackmd.sendMessage(id_of_group, {text: `*Voltei família, foi tudo um mal entendido ksksks* 🥱`})
          }
        }
      }
    } catch(e) {
      console.log(e)
      blackmd.sendMessage(sender, {text: `[❗] Erro, não foi possível entrar no grupo ❌`, edit: key}, {quoted: info})
    }
  } else {
    if(!isModRent) return blackmd.sendMessage(sender, {text: `Não @${sender.split("@")[0]}, você não tem permissão de me adicionar em grupos... Pare agora, ou terei que te bloquear 😡`, mentions: [sender]}, {quoted: seloctt})
    blackmd.sendMessage(sender, {text: `⚠ Atenção @${sender.split("@")[0]}, este bot é alugado... Caso queira me adicionar no grupo ${group_name}, será necessário alugar algum dos planos via pix 💎`, mentions: [sender]}, {quoted: seloctt})
    await sleep(1200)
    blackmd.sendMessage(sender, {text: `${valoresDeAluguel.map(a => `${permuteNumberEmoji(a.id)}⧽ R$ ${Number(a.valor).toFixed(2)} (${a.tempo} dias)`).join(`\n`)}\n\n${NomeDoBot}`})
    await sleep(1200)
    blackmd.sendMessage(sender, {text: `Basta usar os comandos ${prefix}recarga, ${prefix}buykeygp e ${prefix}buygp para alugar o bot... Após gerada a key, basta copiar e colar a mesma dentro de seu grupo.\nQualquer dúvida, chame meu dono no PV através do comando ${prefix}dono 👑`})
    await sleep(1200)
    blackmd.sendMessage(nmrdn, {text: `Houve uma tentativa de adição no grupo ${group_name} vindo do @${sender.split("@")[0]}... Já alertei o mesmo sobre o fato do bot ser alugado, e agora estou avisando o senhor tbm 💁🏻‍♂️`, mentions: [sender]})
  }
}

/////\\\\\\//////\\\\\\////\\\\////\\\///\\\///\\\\

const resptinder = (txt) => {
  return txt.replace("#p#", prefix).replace("#p#", prefix).replace("#pc#", prefix+command).replace("#pc#", prefix+command)
}

if(isGroup && isAcceptGroup) {
  setTimeout(async() => {
    req = await blackmd.groupRequestParticipantsList(from)
    for(r of req) {
      await sleep(500)
      aceitar(from, r.jid)
    }
  }, dataGp[0].acceptGroup.time * 1000)
}

async function deleteAllCore() {
  exec(`ls`, (err, rstd) => {
    if(err) return console.log(err)
    findcore = rstd.split(`\n`)
    getcore = []
    for(linecore of findcore) {
      if(linecore.toLowerCase().includes(`core`)) getcore.push(`./`+linecore)
    }
    if(getcore.length > 0) {
      for(deletecore of getcore) {
        fs.unlinkSync(deletecore)
      }
    }
  })
}

deleteAllCore();

const sendAsPoll = (jid, name = '', values = [], selectableCount = 0) => { return blackmd.sendMessage(jid, { poll: { name, values, selectableCount }}) }

// CONST PROS COMANDOS POR FIGURINHAS \\

const vitinhufds = Object.keys(info.message)[0] == "stickerMessage" ? info.message.stickerMessage.fileSha256.toString('base64') : ""

// INICIO DAS CASES / COMANDOS COM PREFIXO --- DEIXE ACIMA DO >SWITCH(COMMAND) {< E NÃO APAGUE O MESMO \\

switch(vitinhufds){
case '182,225,49,156,25,159,250,104,25,137,69,83,226,69,129,120,1,169,157,154,77,16,224,101,7,31,21,7,43,22,104,212':
if(!isGroup) return
if(!isGroupAdmins) return
if(!isBotGroupAdmins) return
if(groupMetadata.announce == false) return
reagir(from, "🔓")
blackmd.groupSettingUpdate(from, 'not_announcement')
reply(`*GRUPO ABERTO COM SUCESSO* ✅`)
break

case '157,134,71,247,237,171,192,2,85,112,158,0,102,229,213,19,146,60,72,178,236,161,138,84,170,78,178,40,199,220,154,76':
if(!isGroup) return
if(!isGroupAdmins) return
if(!isBotGroupAdmins) return
if(groupMetadata.announce == true) return
reagir(from, "🔒")
blackmd.groupSettingUpdate(from, 'announcement')
reply(`*GRUPO FECHADO COM SUCESSO* ❌`)
break

case '116,49,181,215,210,140,250,126,169,228,144,22,131,130,134,241,222,247,1,236,137,113,118,240,225,39,0,97,190,65,187,192':
if(!isGroup) return
if(!isBotGroupAdmins) return
if(!isOwner) return
buff = await getFileBuffer(info.message.stickerMessage, 'sticker')
await sleep(200)
blackmd.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
await sleep(700)
blackmd.sendMessage(from, {audio: {url: `./database/audios/paitaon.m4a`}, mimetype: `audio/mpeg`, ptt: true, contextInfo: {mentionedJid: groupMembers.map(i => i.id), forwardingScore: 999, isForwarded: true}})
await sleep(700)
blackmd.sendMessage(from, {sticker: buff})
break
}

//INICIO DE COMANDO DE PREFIXO
switch(command){

case 'comprarbot':
reagir(from, `💬`)
txt = `⚠️ *Atenção ${pushname}*\n\nA *Lady Bot v5* ainda *não está à venda* no momento.\n\nCaso tenha alguma dúvida ou queira conversar diretamente com o criador, clique no link abaixo:\n\n👉 wa.me/5585998603654`
sendUrlText(
  from,
  txt,
  `⛔ LADY BOT ⛔`,
  `Entre em contato diretamente com o criador para mais informações.`,
  `https://i.imgur.com/uh2Pxmw.jpeg`,
  `https://wa.me/5585998603654`,
  seloctt
)
break
case 'rgtinder':
try {
ABC = await fetchJson(`https://blacksystemofc.com.br/tinder/login?usu=${sender}&${q && !isQuotedImage ? `rg=${q}&` : ``}apikey=black`)
try {
data = await fetchJson(`https://blacksystemofc.com.br/tinder/perfil?usu=${sender}&apikey=black`)
} catch { return reply("Erro ao tentar acessar o registro") }
fini = data.nome != 0 && data.idade != 0 && data.gene != 0 && data.sexualidade != 0 && data.filtro != 0 && data.bio != 0 && data.foto == 0
if(fini && isQuotedImage) {
try {
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
img = await upload(owgi)
BCD = await fetchJson(`https://blacksystemofc.com.br/tinder/login?usu=${sender}&rg=${img}&apikey=black`)
return reply(resptinder(BCD.message))
} catch { return reply("Erro ao salvar a imagem... Tente novamente") }
}
reply(resptinder(ABC.message))
} catch(e) {
console.log(e)
reply("Erro")
}
break

case 'tinder':
reagir(from, "🔥")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
try {
ABC = await fetchJson(`https://blacksystemofc.com.br/tinder/find?usu=${sender}&apikey=black`)
data = await fetchJson(`https://blacksystemofc.com.br/tinder/perfil?usu=${sender}&apikey=black`)
txt = `
ㅤㅤㅤ🔥 𝒃𝒍𝒂𝒄𝒌 𝒕𝒊𝒏𝒅𝒆𝒓 🔥
╔══════════════════╣
╟ ❪😍ฺ࣭࣪͘ꕸ▸ ɴᴏᴍᴇ: ${ABC.dados[0].nome}
║
╟ ❪😏ฺ࣭࣪͘ꕸ▸ ᴡʜᴀᴛꜱᴀᴩᴩ: wa.me/${ABC.dados[0].nmr}
║
╟ ❪🤫ฺ࣭࣪͘ꕸ▸ ɪᴅᴀᴅᴇ: ${ABC.dados[0].idade} anos
║
╟ ❪🤭ฺ࣭࣪͘ꕸ▸ ꜱᴇxᴜᴀʟɪᴅᴀᴅᴇ: ${ABC.dados[0].sexualidade}
║
╟ ❪🫣ฺ࣭࣪͘ꕸ▸ ɢêɴᴇʀᴏ: ${ABC.dados[0].gene}
║
╩ 𖥨ํ∘̥⃟⸽⃟💌৴▸ ʙɪᴏ: ${ABC.dados[0].bio}

_Exibindo perfil nº${ABC.dados[0].id} de ${ABC.dados[0].total} usuário${ABC.dados[0].total > 1 ? 's' : ''} registrado${ABC.dados[0].total > 1 ? 's' : ''}_
`
blackmd.sendMessage(from, {image: {url: ABC.dados[0].foto}, caption: txt}, {quoted: seloctt})
} catch { reply(resptinder(ABC.message || "Erro")) }
break

case 'tindernome':
case 'tinderidade':
case 'tinderbio':
case 'setgene':
case 'setsex':
case 'setfiltro':
case 'tinderfoto':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
try {
ABC = await fetchJson(`https://blacksystemofc.com.br/tinder/config?usu=${sender}&mod=${command}&${q && !isQuotedImage ? `q=${q}&` : ``}apikey=black`)
if(command == "tinderfoto" && isQuotedImage) {
try {
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
img = await upload(owgi)
BCD = await fetchJson(`https://blacksystemofc.com.br/tinder/config?usu=${sender}&mod=${command}&q=${img}&apikey=black`)
return reply(resptinder(BCD.message))
} catch { return reply("Erro ao salvar a imagem... Tente novamente") }
}
reply(resptinder(ABC.message))
} catch { reply("Erro") }
break

case 'meutinder':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
try {
ABC = await fetchJson(`https://blacksystemofc.com.br/tinder/perfil?usu=${sender}&apikey=black`)
txt = `
╔══════════════════╣
╟ • ${ABC.dados[0].gene.replace("ã", "a") == "nao declarar" ? `ɴᴏᴍᴇ` : `ᴜꜱᴜáʀɪ${ABC.dados[0].gene == "masculino" ? "ᴏ" : "ᴀ"}`}: ${ABC.dados[0].nome}
║
╟ • ɪᴅᴀᴅᴇ: ${ABC.dados[0].idade} anos
║
╟ • ᴡʜᴀᴛꜱᴀᴩᴩ: wa.me/${ABC.dados[0].nmr}
║
╟ • ꜱᴇxᴜᴀʟɪᴅᴀᴅᴇ: ${ABC.dados[0].sexualidade}
║
╟ • ɢêɴᴇʀᴏ: ${ABC.dados[0].gene}
║
╟ • ꜰɪʟᴛʀᴏ: ${ABC.dados[0].filtro == 3 ? `sem preferências` : `pesquisar por ${ABC.dados[0].filtro == 1 ? ` homens` : `mulheres`}`}
║
╩ • ʙɪᴏ: ${ABC.dados[0].bio}

_${ABC.dados[0].gene.replace("ã", "a") == "nao declarar" ? `Deu entrada no tinder` : `Registrad${ABC.dados[0].gene == "masculino" ? "o" : "a"}`} em ${ABC.dados[0].registro[0]}, às ${ABC.dados[0].registro[1]}_
`
blackmd.sendMessage(from, {text: txt, contextInfo: {
  externalAdReply: {
    title: `ㅤㅤㅤ🔥 𝒃𝒍𝒂𝒄𝒌 𝒕𝒊𝒏𝒅𝒆𝒓 🔥`,
    body: ``,
    thumbnail: await getBuffer(`${ABC.dados[0].foto}`),
    mediaType: 1,
    showAdAttribution: true,
    sourceUrl: `${site}`
  }
}}, {quoted: seloctt})
} catch { reply(resptinder(ABC.message || "Erro")) }
break

case 'sairtinder':
case 'rmtinder':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
if(command == 'rmtinder') {
  if(!isOwner) return reply(enviar.msg.dono)
  if(!q && !menc_os2) return reply("Retorne após o comando o número ou @ do usuário que você quer deletar do tinder")
  deletar = identArroba(q)
} else { deletar = sender }
try {
ABC = await fetchJson(`https://blacksystemofc.com.br/tinder/delete?usu=${deletar}&apikey=black`)
reply(resptinder(ABC.message))
} catch { reply("Erro") }
break

case 'envvdd':
if(!isOwner) return reply("Só meu dono pode usar esse comando...")
if(!JSON.stringify(vdddsf).includes("lady")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
if(!q) return reply(`KD a verdade ?`)
BC = vdddsf.map(a => a.idvd).indexOf("matheuzinho")
vdddsf[BC].verdades.push({vdd: q})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
reply(`✓ Verdade enviada com sucesso...`)
break

case 'envdsf':
if(!isOwner) return reply("Só meu dono pode usar esse comando...")
if(!JSON.stringify(vdddsf).includes(" | ೈ፝͜͡🤑 ${prefix}")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
if(!q) return reply(`KD o desafio ?`)
BC = vdddsf.map(a => a.idvd).indexOf("lady")
vdddsf[BC].desafios.push({dsf: q})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
reply(`✓ Desafio enviado com sucesso...`)
break

case 'vdsflist':
if(!isOwner) return reply("Só meu dono pode usar esse comando...")
if(!JSON.stringify(vdddsf).includes("lady")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
BC = vdddsf.map(a => a.idvd).indexOf("lady")
txt = `😇 Lista de verdades:\n`
for(i = 0; i < vdddsf[BC].verdades.length; i++) {
txt += `• ${i} -> ${vdddsf[BC].verdades[i].vdd}\n`
}
txt += `\n😈 Lista de desafios:\n`
for(i = 0; i < vdddsf[BC].desafios.length; i++) {
txt += `• ${i} -> ${vdddsf[BC].desafios[i].dsf}\n`
}
reply(txt)
break

case 'rmvdd':
if(!isOwner) return reply("Só meu dono pode usar esse comando...")
if(!JSON.stringify(vdddsf).includes("lady")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
BC = vdddsf.map(a => a.idvd).indexOf("lady")
if(!Number(args[0]) || Number(args[0]) < 0 || Number(args[0]) > vdddsf[BC].verdades.length) return reply(`Use o comando ${prefix}vdsflist e escolha um dos números na lista para deletar... Ex:
${prefix+command} 2`)
vdddsf[BC].verdades.splice(Number(args[0]), 1)
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
reply(`Verdade deletada do jogo`)
break

case 'rmdsf':
if(!isOwner) return reply("Só meu dono pode usar esse comando...")
if(!JSON.stringify(vdddsf).includes("matheuzinho")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
BC = vdddsf.map(a => a.idvd).indexOf("lady")
if(!Number(args[0]) || Number(args[0]) < 0 || Number(args[0]) > vdddsf[BC].desafios.length) return reply(`Use o comando ${prefix}vdsflist e escolha um dos números na lista para deletar... Ex:
${prefix+command} 2`)
vdddsf[BC].desafios.splice(Number(args[0]), 1)
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
reply(`Desafio deletado do jogo`)
break

case 'vdddsf':
if(!isGroup) return reply(`Só em grupo`)
if(!JSON.stringify(vdddsf).includes("matheuzinho")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
if(!JSON.stringify(vdddsf).includes(from)) {
vdddsf.push({idgp: from, jogadores: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
BC = vdddsf.map(a => a.idvd).indexOf("lady")
if(vdddsf[BC].verdades.length <= 1 || vdddsf[BC].desafios.length <= 1) return reply(`É necessário ao menos duas verdades e dois desafios para iniciarmos... ${isOwner ? `Use o comando ${prefix}envvdd e ${prefix}envdsf` : ``}`)
AB = vdddsf.map(b => b.idgp).indexOf(from)
if(JSON.stringify(vdddsf[AB].jogadores).includes(sender)) {
DC = vdddsf[AB].jogadores.map(x => x.id).indexOf(sender)
if(vdddsf[AB].jogadores[DC].tipo == 0) return reply(`Olá ${pushname}, faça sua escolha...
😇⃤ Verdade
ㅤㅤㅤㅤOu
😈⃤ Desafio`)
if(vdddsf[AB].jogadores[DC].tipo == 1) return reply(`\`\`\`😇 Verdade Ou Desafio 😈\`\`\`
『 VERDADE 』
✓ -> ${vdddsf[AB].jogadores[DC].vdouds}

_(responda com verdade ou mentira)_`)
if(vdddsf[AB].jogadores[DC].tipo == 2) return reply(`\`\`\`😇 Verdade Ou Desafio 😈\`\`\`
『 DESAFIO 』
✓ -> ${vdddsf[AB].jogadores[DC].vdouds}

_(quando concluir o desafio, use ${prefix}pronto)_`)
} else {
vdddsf[AB].jogadores.push({id: sender, vdouds: "", tipo: 0})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
txt = `Olá ${pushname}, faça sua escolha...
😇⃤ Verdade
ㅤㅤㅤㅤOu
😈⃤ Desafio`
sendButton(from, {text: txt, footer: `Selecione uma das opções abaixo...`}, blackmd, sender, [{type: `cmd`, text: `😇⃤ VERDADE`, command: `verdade`}, {type: `cmd`, text: `😈⃤ DESAFIO`, command: `desafio`}], seloctt)
}
break

case 'pulardesafio': case 'pulardsf':
{
if(!JSON.stringify(vdddsf).includes("lady")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
if(!JSON.stringify(vdddsf).includes(from)) {
vdddsf.push({idgp: from, jogadores: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
AB = vdddsf.map(b => b.idgp).indexOf(from)
if(!JSON.stringify(vdddsf[AB].jogadores).includes(sender)) return reply(`Você não iniciou nenhum jogo... Use ${prefix}vdddsf`)
DC = vdddsf[AB].jogadores.map(x => x.id).indexOf(sender)
if(vdddsf[AB].jogadores[DC].tipo != 2) return reply(`Você escolheu verdade, portanto, não é possível pular o desafio assim... Diga verdade ou mentira para a seguinte afirmação/pergunta: ${vdddsf[AB].jogadores[DC].vdouds}`)
vdddsf[AB].jogadores.splice(DC, 1)
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
let { key } = await blackmd.sendMessage(from, {text: `Ih ala, desistiu kkkkk`}, {quoted: seloctt})//primeira mensagem
await sleep(1000)
await blackmd.sendMessage(from, {text: `😈 Gerando novo desafio...`, edit: key }, {quoted: seloctt})
await sleep(1000)
BA = vdddsf.map(b => b.idgp).indexOf(from)
BC = vdddsf.map(a => a.idvd).indexOf("lady")
CD = vdddsf[BA].jogadores.map(i => i.id).indexOf(sender)
aledsf = Math.floor(Math.random() * vdddsf[BC].desafios.length)
vdddsf[AB].jogadores.push({id: sender, vdouds: vdddsf[BC].desafios[aledsf].dsf, tipo: 2})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
txt = `\`\`\`😇 Verdade Ou Desafio 😈\`\`\`
『 DESAFIO 』
✓ -> ${vdddsf[BC].desafios[aledsf].dsf}

_(quando concluir o desafio, use ${prefix}pronto)_`
await blackmd.sendMessage(from, {text: txt, edit: key }, {quoted: seloctt})
}
break

case 'pronto':
if(!JSON.stringify(vdddsf).includes("lady")) {
vdddsf.push({idvd: "lady", verdades: [], desafios: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
if(!JSON.stringify(vdddsf).includes(from)) {
vdddsf.push({idgp: from, jogadores: []})
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
}
AB = vdddsf.map(b => b.idgp).indexOf(from)
if(!JSON.stringify(vdddsf[AB].jogadores).includes(sender)) return reply(`Você não iniciou nenhum jogo... Use ${prefix}vdddsf`)
DC = vdddsf[AB].jogadores.map(x => x.id).indexOf(sender)
if(vdddsf[AB].jogadores[DC].tipo != 2) return reply(`Você escolheu verdade, portanto, não é possível finalizar o desafio assim... Diga verdade ou mentira para a seguinte afirmação/pergunta: ${vdddsf[AB].jogadores[DC].vdouds}`)
vdddsf[AB].jogadores.splice(DC, 1)
fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
reply(`Btf mn, parabéns por completar o desafio 🌚🍷`)
break

case 'advn-nmr': case 'adivinharnmr':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isJsonIncludes(adivinharnmr, from)) {
  adivinharnmr.push({groupId: from, participants: []})
  saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
}
if(!isModobn) return reply(enviar.msg.modobz)
AB = adivinharnmr.map(i => i.groupId).indexOf(from)
if(isJsonIncludes(adivinharnmr[AB].participants, sender)) {
  AC = adivinharnmr[AB].participants.map(i => i.id).indexOf(sender)
  adivinharnmr.splice(AC, 1)
  saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
}
adivinharnmr[AB].participants.push({id: sender, progresso: 0, resultado: 0, fim: false})
saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
reply(`😀 ${tempo} ${pushname}, iniciarei o jogo de adivinhação do número... A cada ordem, após você resolver a questão, responda "pronto" para prosseguir.`)
await sleep(1000)
sendMess(from, `Digite "pronto" para começar (sem as aspas, é claro) 🥰`)
break

case 'savegp':
if(!isOwner) return reply(enviar.msg.dono)
reply(!isSaveGroup(from) ? `Grupo salvo na pasta 📁` : `Grupo já foi salvo ✔️`)
addGroupInRent(from, true)
break

case 'unsavegp':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isSaveGroup(from)) return reply(`Grupo não encontrado`)
rmGroupInRent(from)
reply(`Grupo deletado ✔️`)
break

case 'addrent': case 'rgrent':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
addRent(reply, prefix+command, blackmd, from, q);
break

case 'tirarrent':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupInRent(from)) return reply(`Este grupo não está registrado no sistema de aluguel...`)
tirarRent(from, reply, q)
break

case 'delrent': case 'rmrent':
if(!isOwner) return reply(enviar.msg.dono)
async function sdr() {
  dr = []
  for(a of aluguel) {
    dr.push({name: `SELECIONE AQUI`, title: a.nome, body: sendTimeHours(a.tempo), command: prefix+command+` `+a.id})
  }
  if(isGroup) reply(`Enviando PV 🔰`)
  try { ppUrl = await blackmd.profilePictureUrl(aluguel.length > 0 ? aluguel[0].id : from, 'image')
  } catch { ppUrl = semfoto }
  sendRouletteButton(sender, {image: {url: ppUrl}, caption: `🎲 Selecione abaixo o grupo que você deseja deletar do registro de aluguel...`, footer: NomeDoBot}, blackmd, sender, [{type: `list`, title: `〘 SELECIONE AQUI 〙`, rowId: [{title: `GRUPOS AQUI`, options: dr}]}], seloctt)
}
if(q) {
  if(q.length > 5) {
    if(!isGroupInRent(q)) return sdr()
    gp = q
  } else {
    if(isNaN(q) || Number(q) < 1 || Number(q) > aluguel.length) return sdr()
    gp = aluguel[Number(q) - 1].id
  }
} else { gp = from }
if(!isGroupInRent(gp)) return reply(`Este grupo não está registrado no aluguel 😪`)
delRent(reply, gp)
break

case 'cortesia':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
addCourtesy(reply, from)
break

case 'listrent': case 'lista-aluguel':
if(!isOwner) return reply(enviar.msg.dono)
if(aluguel.length <= 0) return reply(`Não há grupos salvos na lista de aluguel`)

//salvar o nome dos grupos
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
for(g of allGroups) {
  if(isGroupInRent(g.id)) {
    getGroupRent(g.id).nome = g.subject
    saveRent()
  }
}

//enviar o nome dos grupos
barra = `-`.repeat(50)
txt = `➲ ʟɪꜱᴛᴀ ᴅᴇ ɢʀᴜᴘᴏꜱ ᴀʟᴜɢᴀᴅᴏꜱ ↴
ᴛᴏᴛᴀʟ﹙ ${aluguel.length} ﹚
${barra}
${aluguel.map(i => `『 ${aluguel.map(a => a.id).indexOf(i.id) + 1} 』
〔👥〕⥲ ɢʀᴜᴘᴏ: ${i.nome}
〔⏳〕⥲ ᴛᴇᴍᴘᴏ ʀᴇꜱᴛᴀɴᴛᴇ: ${sendTimeHours(i.tempo)}
〔💳〕⥲ ᴄᴏʀᴛᴇꜱɪᴀ〘 ${i.cortesia ? `✅` : `❌`} 〙${isPrivateChat && !i.cortesia ? `
〔😃〕⥲ ᴄʟɪᴇɴᴛᴇ: @${i.cliente.split("@")[0]}` : ``}`).join(`\n${barra}\n`)}
${barra}`
mention(txt)
break

case 'lastrent':
if(!isOwner) return reply(enviar.msg.dono)
if(aluguel.length <= 0) return reply(`Não há grupos salvos na lista de aluguel`)
gp = aluguel.map(i => i)
rank = gp.sort((a, b) => (a.tempo < b.tempo) ? -1 : 0)
rent = []
top3 = aluguel.length > 3 ? 3 : aluguel.length
for(g = 0; g < top3; g++) {rent.push(rank[g])}
barra = `-`.repeat(50)
txt = `➲ ᴛᴏᴘ ${top3} ɢʀᴜᴘᴏ${top3 != 1 ? `ꜱ` : ``} ᴄᴏᴍ ᴏ ᴀʟᴜɢᴜᴇʟ ᴍᴀɪꜱ ᴘʀᴏ́xɪᴍᴏ ᴅᴇ ᴀᴄᴀʙᴀʀ ↴
${barra}
${rent.map(i => `『 ${rent.map(a => a.id).indexOf(i.id) + 1} 』
〔👥〕⥲ ɢʀᴜᴘᴏ: ${i.nome}
〔⏳〕⥲ ᴛᴇᴍᴘᴏ ʀᴇꜱᴛᴀɴᴛᴇ: ${sendTimeHours(i.tempo)}
〔💳〕⥲ ᴄᴏʀᴛᴇꜱɪᴀ〘 ${i.cortesia ? `✅` : `❌`} 〙${isPrivateChat && !i.cortesia ? `
〔😃〕⥲ ᴄʟɪᴇɴᴛᴇ: @${i.cliente.split("@")[0]}` : ``}`).join(`\n${barra}\n`)}
${barra}`
mention(txt)
break

case 'iddogrupo': case 'idgp':
if(!isOwner) return reply(enviar.msg.dono)
reply(from)
break
case 'rgb': 
case 'Rgb': 
case 'RGB':
    try {
        if (!q.trim()) {
            console.log("[ERRO] Nenhum texto fornecido.");
            return reply(`Exemplo: ${prefix + command} lady`);
        }

        console.log(`[INFO] Gerando sticker para: ${q}`);
        reply("to fazendo...");

        // URL da nova API
        const apiUrl = `https://world-ecletix.onrender.com/api/rgb?texto=${encodeURIComponent(q)}`;

        // Enviando a mensagem com o sticker gerado pela nova API
        await blackmd.sendMessage(from, { sticker: { url: apiUrl } }, { quoted: info })
            .then(() => console.log("[SUCESSO] Sticker enviado com sucesso."))
            .catch((err) => {
                console.error("[ERRO] Falha ao enviar sticker:", err);
                return reply("Erro ao gerar o sticker.");
            });

    } catch (e) {
        console.error("[ERRO] Erro inesperado:", e);
        return reply("Erro ao processar sua solicitação.");
    }
    break;
// Função genérica para enviar as figurinhas
async function enviarFigurinhas(url) {
    await blackmd.sendMessage(sender, { sticker: { url: url } });
}
// by luanzin dev 
// FIGURINHAS 
case 'figtetas':
case 'figu_tetas': {
    if (!Number(q)) return reply(`Digite a quantidade de figurinhas\nExemplo: ${prefix + command} 4`);
    if (q >= 11) return reply("Coloque abaixo de 11...");
    if (isGroup) reply(`Enviarei no seu PV.`);

    async function figusadul() {
        try {
            const rnd = Math.floor(Math.random() * 60) + 1;
            await blackmd.sendMessage(sender, {
                sticker: {
                    url: `https://raw.githubusercontent.com/TznModas/nsfw/refs/heads/main/stickers/adults/sticker_tetas/sticker_${rnd}.webp`
                }
            });
        } catch (err) {
            console.error(`Erro ao enviar figurinha: ${err.message}`);
            reply("Erro ao enviar figurinha. Tente novamente mais tarde.");
        }
    }

    (async () => {
        for (let i = 0; i < q; i++) {
            await sleep(680);
            await figusadul();
        }
    })();

    break;
}
case 'figlesbian':
case 'figu_lesbian': {
    if (!Number(q)) return reply(`Digite a quantidade de figurinhas\nExemplo: ${prefix + command} 4`);
    if (q >= 11) return reply("Coloque abaixo de 11...");
    if (isGroup) reply(`Enviarei no seu PV.`);

    async function figusadul() {
        try {
            const rnd = Math.floor(Math.random() * 120) + 1;
            await blackmd.sendMessage(sender, {
                sticker: {
                    url: `https://raw.githubusercontent.com/TznModas/nsfw/refs/heads/main/stickers/adults/sticker_lesbian/sticker_${rnd}.webp`
                }
            });
        } catch (err) {
            console.error(`Erro ao enviar figurinha: ${err.message}`);
            reply("Erro ao enviar figurinha. Tente novamente mais tarde.");
        }
    }

    (async () => {
        for (let i = 0; i < q; i++) {
            await sleep(680);
            await figusadul();
        }
    })();

    break;
}
case 'fighentai':
case 'figu_hentai': {
    if (!Number(q)) return reply(`Digite a quantidade de figurinhas\nExemplo: ${prefix + command} 4`);
    if (q >= 11) return reply("Coloque abaixo de 11...");
    if (isGroup) reply(`Enviarei no seu PV.`);

    async function figusadul() {
        try {
            const rnd = Math.floor(Math.random() * 109) + 1;
            await blackmd.sendMessage(sender, {
                sticker: {
                    url: `https://raw.githubusercontent.com/TznModas/nsfw/refs/heads/main/stickers/adults/sticker_hentai/${rnd}.webp`
                }
            });
        } catch (err) {
            console.error(`Erro ao enviar figurinha: ${err.message}`);
            reply("Erro ao enviar figurinha. Tente novamente mais tarde.");
        }
    }

    (async () => {
        for (let i = 0; i < q; i++) {
            await sleep(680);
            await figusadul();
        }
    })();

    break;
}
case 'figbundas':
case 'figu_bundas': {
    if (!Number(q)) return reply(`Digite a quantidade de figurinhas\nExemplo: ${prefix + command} 4`);
    if (q >= 11) return reply("Coloque abaixo de 11...");
    if (isGroup) reply(`Enviarei no seu PV.`);

    async function figusadul() {
        try {
            const rnd = Math.floor(Math.random() * 60) + 1;
            await blackmd.sendMessage(sender, {
                sticker: {
                    url: `https://raw.githubusercontent.com/TznModas/nsfw/refs/heads/main/stickers/adults/sticker_bundas/sticker_${rnd}.webp`
                }
            });
        } catch (err) {
            console.error(`Erro ao enviar figurinha: ${err.message}`);
            reply("Erro ao enviar figurinha. Tente novamente mais tarde.");
        }
    }

    (async () => {
        for (let i = 0; i < q; i++) {
            await sleep(680);
            await figusadul();
        }
    })();

    break;
}
case 'figu_porn':
case 'figporn': {
    if (!Number(q)) return reply(`Digite a quantidade de figurinhas\nExemplo: ${prefix + command} 4`);
    if (q >= 11) return reply("Coloque abaixo de 11...");
    if (isGroup) reply(`Enviarei no seu PV.`);

    async function figusadul() {
        try {
            const rnd = Math.floor(Math.random() * 200) + 1;
            await blackmd.sendMessage(sender, {
                sticker: {
                    url: `https://raw.githubusercontent.com/TznModas/nsfw/refs/heads/main/stickers/adults/sticker_porn/${rnd}.webp`
                }
            });
        } catch (err) {
            console.error(`Erro ao enviar figurinha: ${err.message}`);
            reply("Erro ao enviar figurinha. Tente novamente mais tarde.");
        }
    }

    (async () => {
        for (let i = 0; i < q; i++) {
            await sleep(680);
            await figusadul();
        }
    })();

    break;
}
case 'figuroblox': case 'figu_roblox':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. não pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_roblox`);
    }
    break;

case 'figu_coreana': case 'figucoreana':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. não pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_coreana`);
    }
    break;

case 'figudesenho': case 'figu_desenho':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. não pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_desenho`);
    }
    break;

case 'figurinhas1': case 'figurinhas1':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. não pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figurinhas`);
    }
    break;

case 'figurinhas2': case 'Figurinhas2':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. não pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figurinhas2`);
    }
    break;

case 'figuemoji': case 'figu_emoji':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. não pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_emoji`);
    }
    break;

case 'figualeatorio': case 'figu_alearorio':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. não pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_aleatorio`);
    }
    break;

case 'figu_anime': case 'figu_anime':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. não pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_anime`);
    }
    break;

case 'figuraiva': case 'figu_raiva':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. não pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_raiva`);
    }
    break;

case 'figuengracada': case 'figu_engracada':
    if (!q) return reply("Insira a quantidade de figurinhas que deseja que eu envie!");
    if (!Number(args[0]) || Number(q.trim()) > 50) return reply("Digite a quantidade de figurinhas que deseja que eu envie.. não pode mais de 50..");
    for (let i = 0; i < q; i++) {
        await sleep(680);
        await enviarFigurinhas(`https://world-ecletix.onrender.com/api/figu_engracada`);
    }
    break;
    
case 'tirardocntd': case 'delmsg': case 'delcntd':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
if(!marc_tds) return reply(`Marque o usuário que você quer deletar do contador, o @ ou a mensagem`)
txt = `Este usuário não está na database do contador deste grupo...`
AB = allGroupIDcountMessage.indexOf(from)
if(AB < 0) return reply(txt)
AC = getCountGroupMessage.participants.map(i => i.id).indexOf(marc_tds)
if(AC < 0) return reply(txt)
getCountGroupMessage.participants.splice(AC, 1)
saveJSON(countMessage, "./basededados/countmsg.json")
mention(`Usuário @${marc_tds.split("@")[0]} deletado do contador de mensagens com sucesso...`)
break

case 'addmsgcntd': case 'rmmsgcntd':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
if(!q.includes(`/`)) return reply(`Use assim: ${prefix+command} @/1000`)
var [usumsg, quantmsg] = q.split(`/`)
if(!Number(quantmsg)) return reply(`${quantmsg} não é número`)
usu = usumsg.toLowerCase() == `me` ? sender : identArroba(usumsg)
if(!usuInCountMessage(usu)) return mention(`O usuário @${usu1.split("@")[0]} não está na database do contador deste grupo...`)
dbuser = getUsuCountMessage(usu)
if(command.includes(`add`)) {dbuser.mensagens += Number(quantmsg)} else {dbuser.mensagens -= Number(quantmsg)}
saveJSON(countMessage, "./basededados/countmsg.json")
mention(`${quantmsg} mensage${Number(quantmsg) != 1 ? `ns` : `m`} fo${Number(quantmsg) != 1 ? `ram` : `i`} ${command.includes(`add`) ? `adicionada${Number(quantmsg) != 1 ? `s` : ``}` : `removida${Number(quantmsg) != 1 ? `s` : ``}`} do usuário @${usu.split(`@`)[0]} com sucesso ✔`)
break

case 'addcmdcntd': case 'rmcmdcntd':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
if(!q.includes(`/`)) return reply(`Use assim: ${prefix+command} @/1000`)
var [usumsg, quantmsg] = q.split(`/`)
if(!Number(quantmsg)) return reply(`${quantmsg} não é número`)
usu = usumsg.toLowerCase() == `me` ? sender : identArroba(usumsg)
if(!usuInCountMessage(usu)) return mention(`O usuário @${usu1.split("@")[0]} não está na database do contador deste grupo...`)
dbuser = getUsuCountMessage(usu)
if(command.includes(`add`)) {dbuser.comandos += Number(quantmsg)} else {dbuser.comandos -= Number(quantmsg)}
saveJSON(countMessage, "./basededados/countmsg.json")
mention(`${quantmsg} comando${Number(quantmsg) != 1 ? `s` : ``} fo${Number(quantmsg) != 1 ? `ram` : `i`} ${command.includes(`add`) ? `adicionado${Number(quantmsg) != 1 ? `s` : ``}` : `removido${Number(quantmsg) != 1 ? `s` : ``}`} do usuário @${usu.split(`@`)[0]} com sucesso ✔`)
break

case 'transferirmsg': case 'trfrmsg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(contar(q, `/`) != 1) return reply(`Este comando é para transferir as mensagens do número antigo de um usuário para o seu novo número... Retorne após o comando o número antigo do usuário, e o seu novo número, separando ambos com uma barra ( / ), ex:
${prefix+command} ${addNumberMais(botNumber)}/${addNumberMais(randomUser)}`)
usu1 = identArroba(q.split(`/`)[0])
usu2 = identArroba(q.split(`/`)[1])
if(!usuInCountMessage(usu1)) return mention(`O usuário @${usu1.split("@")[0]} não está na database do contador deste grupo...`)
if(!usuInCountMessage(usu2)) return mention(`O usuário @${usu2.split("@")[0]} não está na database do contador deste grupo...`)
dbuser1 = getUsuCountMessage(usu1)
dbuser2 = getUsuCountMessage(usu2)
msg = dbuser1.mensagens
cmd = dbuser1.comandos
dbuser2.mensagens += msg
dbuser2.comandos += cmd
saveJSON(countMessage, "./basededados/countmsg.json")
AB = getCountGroupMessage.participants.map(i => i.id).indexOf(usu1)
getCountGroupMessage.participants.splice(AB, 1)
saveJSON(countMessage, "./basededados/countmsg.json")
mention(`As ${msg} mensagens e ${cmd} comandos do usuário @${usu1.split("@")[0]} foram transferidos para o usuário @${usu2.split("@")[0]} com sucesso...`)
break

case 'anotar':
case 'tirar_nota':
case 'rmnota':
if(!isGroup) return reply(enviar.msg.grupo)  
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(command == "anotar") {
var [q5, q10] = q.trim().split("|")
if(!q5 || !q10 || !q.includes("|")) return reply(`Digite o título da anotação e o texto que deseja anotar..\nExemplo: ${prefix}anotar M4|O mais brabo das edits...`)
if(JSON.stringify(anotar).includes(from)) {  
var i2 = anotar.map(i => i.grupo).indexOf(from)  
if(JSON.stringify(anotar[i2].puxar).includes(q5)) {
var i3 = anotar[i2].puxar.map(i => i.nota).indexOf(q5)  
if(anotar[i2].puxar[i3].nota == q5) return reply(`Esta anotação já está inclusa, utilize outro título.. Ou você pode tirar com\n${prefix}tirar_nota ${q5}`)
}
}
if(!JSON.stringify(anotar).includes(from)) {
anotar.push({grupo: from, puxar: [{nota: q5, anotacao: q10}]})
fs.writeFileSync("./basedefuncionamento/tabela/anotar.json", JSON.stringify(anotar))
reply("Anotação registrada com sucesso...")
} else {
anotar[i2].puxar.push({nota: q5, anotacao: q10})
fs.writeFileSync("./basedefuncionamento/tabela/anotar.json", JSON.stringify(anotar))
reply("Anotação registrada com sucesso...")  
}
} else {
if(!q) return reply("Digite qual anotação deseja tirar pelo título..")
if(JSON.stringify(anotar).includes(from)) {  
var i2 = anotar.map(i => i.grupo).indexOf(from)  
if(JSON.stringify(anotar[i2].puxar).includes(q)) {
var i3 = anotar[i2].puxar.map(i => i.nota).indexOf(q)  
}
}
if(0 > anotar[i2].puxar.map(i => i.nota).indexOf(q)) return reply("Esta nota não está inclusa, verifique com atenção...")
anotar[i2].puxar.splice(i3, 1)
fs.writeFileSync("./basedefuncionamento/tabela/anotar.json", JSON.stringify(anotar))
reply(`Anotação ${q} tirada com sucesso...`)
}
break

case 'anotacao':
case 'anotacoes':  
case 'nota':
case 'notas':
if(!isGroup) return reply(enviar.msg.grupo)
if(command == "anotacao" || command == "nota") {
if(!q.trim()) return reply("Digite o título da anotação que deseja puxar..")
if(!JSON.stringify(anotar).includes(from)) return reply("Este grupo não tem nenhuma anotação...")
var i2 = anotar.map(i => i.grupo).indexOf(from)  
if(!JSON.stringify(anotar[i2].puxar).includes(q)) return reply("Não contém nenhuma anotação com este título.")
var i3 = anotar[i2].puxar.map(i => i.nota).indexOf(q)  
mention(`〈 ${anotar[i2].puxar[i3].anotacao} 〉`)
} else {
var i2 = anotar.map(i => i.grupo).indexOf(from)    
if(i2 < 0) return reply("Este grupo não tem nenhuma anotação...")
var i2 = anotar.map(i => i.grupo).indexOf(from) 
var antr = anotar[i2]?.puxar 
txtin = "──────────────────\n\n"
for ( i = 0; i < antr?.length; i++) {
txtin += `↝ Anotação: ⟮ ${anotar[i2]?.puxar[i]?.nota} ⟯ - 〈 ${anotar[i2]?.puxar[i]?.anotacao} 〉\n\n`
}
txtin += "──────────────────\n\n"
mention(txtin)
}
break

case 'download-link':
if(q.includes("video") || q.includes("mp4")) {
blackmd.sendMessage(from, {video: {url: q}, mimetype: 'video/mp4'}, {quoted: seloctt}).catch(e => {
reply("Erro, visualize se este link é válido...")
})
} else if(q.includes("webp") || q.includes("jpg")) {
blackmd.sendMessage(from, {image: {url: q}}, {quoted: seloctt}).catch(e => {
reply("Erro, visualize se este link é válido...")
})
}
break

case 'infoanotacao':
blackmd.sendMessage(from, {text: anotacao(prefix)})
break


case 'addnv-adc': case 'rmnv-adc':
case 'addnv-mod': case 'rmnv-mod':
case 'addnv-rm': case 'rmnv-rm':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply("KD o comando?")
com = command.split("-")[1]
if(com == "adc") nmr = 0
if(com == "mod") nmr = 1
if(com == "rm") nmr = 2
if(command.startsWith("add")) {
var [co, de] = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/").split("/")
novidades[nmr].add.push({cmd: co.toLowerCase(), desc: de ? de : ""})
saveJSON(novidades, "./database/data/novidades.json")
reply(`*_Comando adicionado a lista com sucesso ✅_*`)
} else {
AB = novidades[nmr].add.map(i => i.cmd).indexOf(q.toLowerCase())
if(AB < 0) return reply("Comando não encontrado")
novidades[nmr].add.splice(AB, 1)
saveJSON(novidades, "./database/data/novidades.json")
reply(`*_Comando removido da lista com sucesso ✔️_*`)
}
break

case 'novidades':
case 'novo':
reagir(from, "✅")
reply(`
✅ *COMANDOS ADICIONADOS:*

${novidades[0].add.length > 0 ? novidades[0].add.map(a => `• ${prefix+a.cmd} ${a.desc.length > 0 ? `_(${a.desc})_` : ``}`).join("\n") : "🚫 nenhum 🚫"}

---------------------------------------------------------
⚠️ *COMANDOS ALTERADOS:*

${novidades[1].add.length > 0 ? novidades[1].add.map(b => `• ${prefix+b.cmd} ${b.desc.length > 0 ? `_(${b.desc})_` : ``}`).join("\n") : "🚫 nenhum 🚫"}

---------------------------------------------------------
🗑️ *COMANDOS REMOVIDOS:*

${novidades[2].add.length > 0 ? novidades[2].add.map(c => `• ${prefix+c.cmd} ${c.desc.length > 0 ? `_(${c.desc})_` : ``}`).join("\n") : "🚫 nenhum 🚫"}

---------------------------------------------------------
💬 *NOSSO CHAT:* ${prefix}ladygp
❓ *Alguma sugestão ? Use o comando:* ${prefix}sugestão
💾 *Algum bug ? relate à nossa equipe no comando:* ${prefix}bug
`)
break

case 'getcase': case 'puxarcase': case 'gc': {
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`KD o nome do comando? Ex: ${prefix+command} menu`)
let { key } = await blackmd.sendMessage(from, {text: "🔎 🄱🅄🅂🄲🄰🄽🄳🄾 🄲🄰🅂🄴 🔍"}, {quoted: seloctt})
await sleep(1000)
try { var [cmdgc, idusu] = q.replace(`/ `, `/`).replace(` /`, `/`).replace(` / `, `/`).split(`/`)
gccmd = `${getCase(rmLetras(cmdgc))}`
if(!idusu) return blackmd.sendMessage(from, {text: gccmd, edit: key}, {quoted: seloctt})
envusu = identArroba(idusu)
blackmd.sendMessage(from, {text: `_Enviando a *case '${rmLetras(cmdgc)}':* no PV do @${envusu.split("@")[0]}_ 👀`, mentions: [envusu, sender], edit: key}, {quoted: seloctt})
await sleep(500)
blackmd.sendMessage(envusu, {text: `_Olá @${envusu.split(`@`)[0]}, ${tempo}... @${sender.split(`@`)[0]} te enviou a *case '${rmLetras(cmdgc)}':*_ 🥰`, mentions: [envusu, sender]})
await sleep(1000)
sendMess(envusu, gccmd) } catch(e) { console.log(e)
blackmd.sendMessage(from, {text: `*[ ❗ ] Comando Não Encontrado ❌*`, edit: key}, {quoted: seloctt}) } }
break

case 'getlinha':
if(!isOwner) return reply(enviar.msg.dono)
const arquivo = fs.readFileSync("index.js", "utf-8")
const localCase = arquivo.indexOf(`case '${q}'`)
if(localCase === -1) return reply('Comando não encontrado.')
reply(`O comando '${q}' está na linha: ` + arquivo.substr(0, localCase).split("\n").length)
break

case 'enquete':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!q.includes('/') || !q.includes('|')) return reply(`Olha só como faz ${pushname}

${prefix+command} lady a mais braba ?|sim/não/tlvz`)
luck1 = q.split('|')[0]
luck2 = q.split('|')[1]
math1 = `${luck2} `
math2 = []
for(i = 0; i < math1.length; i++) {
math2.push({sla: math1.split(math1.slice(i+1))[0].slice(i)})
}
math3 = 1
for(i = 0; i < math2.length; i++) {
if(math2[i].sla.includes('/')) {
math3 += 1
}
}
if(math3 < 2) {
reply(`Defina ao mínimo duas alternativas de respostas...`)
} else {
math4 = []
for(i = 0; i < math3; i++) {
math4.push(luck2.split('/')[i])
}
sendAsPoll(from, luck1, math4)
}
break


case 'verificado-global':
case 'globalv':
case 'selo':
if(!isOwner) return reply(enviar.msg.dono)
if(!isVerificado) {
obrigadoEXT.verificado = true
setObg(obrigadoEXT)
reply(`🔰 verificado global ativado com sucesso ✅`)
} else if(isVerificado) {
obrigadoEXT.verificado = false
setObg(obrigadoEXT)
reply(`➿ verificado global desativado com sucesso ✔️`)
}
break

case "botoes":
if(!isOwner) return reply(enviar.msg.dono);
if(botoes) {
botoes = false
obrigadoEXT.botoes = false
setObg(obrigadoEXT)
reply("✖️ Os botões foram desativados... Sábia atitude ➿");
} else if(!botoes) {
botoes = true
obrigadoEXT.botoes = true
setObg(obrigadoEXT)
reply(`✔️ Os botões foram ativados... Use com sabedoria 〰️`)
}
await sleep(700)
console.log(colors.green(`Restart necessário para save de dados..`))
process.exit()
break;

case 'audio-menu': 
if(!isOwner) return reply(enviar.msg.dono)
if(!isAudioMenu) {
obrigadoEXT.menu_audio = true
setObg(obrigadoEXT)
reply(`✔️ O áudio menu foi ativado com sucesso 〰️`)
} else if(isAudioMenu) {
obrigadoEXT.menu_audio = false
setObg(obrigadoEXT)
reply(`✖️ O áudio menu foi desativado com sucesso ➿`)
}
break

case 'console':   
if(!isOwner) return reply(enviar.msg.dono)
if(!isConsole) {
obrigadoEXT.consoleoff = true
setObg(obrigadoEXT)
reply(`✔️ O console foi ativado... Todas as ações do bot serão mostradas lá 〰️`) 
} else if(isConsole) {
obrigadoEXT.consoleoff = false
setObg(obrigadoEXT)
reply(`✖️ O console foi desativado... As ações do bot não serão mais vistas lá ➿`)
}
break

case 'menu': case 'm':
setTimeout(() => {reagir(from, react2)}, 300)
if(isIOS || isGroup) return sendMenuPrime()
botaoblk = {
  type: `list`,
  title: `〘  𝙼𝚘𝚜𝚝𝚛𝚊𝚛 𝙻𝚒𝚜𝚝𝚊 〙`,
  rowId: [
    {
      title: "『 Lady bot 』",
      options: [
        {title: "〔👑 𝙄𝙉𝙁𝙊-𝘿𝙊𝙉𝙊 👑〕", command: `${prefix}infodono`, body: `⮑ ${NomeDoBot}`}
      ]
    },
    {
      title: "『 𝙳𝙸𝚅𝙴𝚁𝚂𝙾𝚂 𝙼𝙴𝙽𝚄𝚂 』",
      options: [
        {title: "〔💎 𝙈𝙀𝙉𝙐-𝙋𝙍𝙄𝙉𝘾𝙄𝙋𝘼𝙇 💎〕", command: `${prefix}comandos`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🎗 𝙈𝙀𝙉𝙐-𝘼𝘿𝙈 🎗️〕", command: `${prefix}menuadm`, body: `⮑ ${NomeDoBot}`},
        {title: "〔💰 𝙈𝙀𝙉𝙐-𝘼𝙇𝙐𝙂𝙐𝙀𝙇 💰〕", command: `${prefix}menualuguel`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🤪 𝙈𝙀𝙉𝙐-𝙕𝙊𝙀𝙄𝙍𝘼 🤪〕", command: `${prefix}menuzoeira`, body: `⮑ ${NomeDoBot}`},
        {title: "〔❤️‍🔥 𝙈𝙀𝙉𝙐-𝙏𝙄𝙉𝘿𝙀𝙍 ❤️‍🔥〕", command: `${prefix}menutinder`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🎮 𝙈𝙀𝙉𝙐-𝙂𝘼𝙈𝙀𝙎 🎮〕", command: `${prefix}menujogos`, body: `⮑ ${NomeDoBot}`},
        //{title: "〔🏦 𝙈𝙀𝙉𝙐-𝘽𝙇𝘼𝘾𝙆-𝘾𝙄𝙏𝙔 🏦〕", command: `${prefix}menubc`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🧩 𝙈𝙀𝙉𝙐-𝙀𝙁𝙀𝙄𝙏𝙊𝙎 🧩〕", command: `${prefix}menuefeitos`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🧸 𝙈𝙀𝙉𝙐-𝙈𝙊𝘿𝙎 🧸〕", command: `${prefix}menumods`, body: `⮑ ${NomeDoBot}`},
        {title: "〔💝 𝙈𝙀𝙉𝙐-𝙁𝙄𝙂𝙐𝙍𝙄𝙉𝙃𝘼𝙎 💝〕", command: `${prefix}menufigu`, body: `⮑ ${NomeDoBot}`},
        {title: "〔😃 𝙈𝙀𝙉𝙐-𝙀𝙈𝙊𝙅𝙄 😃〕", command: `${prefix}menuemoji`, body: `⮑ ${NomeDoBot}`},
        {title: "〔💿 𝙈𝙀𝙉𝙐-𝘿𝙊𝙒𝙉𝙇𝙊𝘼𝘿𝙎 💿〕", command: `${prefix}menudownloads`, body: `⮑ ${NomeDoBot}`},
        {title: "〔📜 𝙈𝙀𝙉𝙐-𝙇𝙊𝙂𝙊𝙎 📜〕", command: `${prefix}menulogos`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🤑 𝙈𝙀𝙉𝙐-𝙑𝙄𝙋 🤑〕", command: `${prefix}menuvip`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🔞 𝙈𝙀𝙉𝙐+18 🔞〕", command: `${prefix}menu+18`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🎭 𝙀𝙉𝙏𝙍𝙀𝙏𝙀𝙉𝙄𝙈𝙀𝙉𝙏𝙊 🎭〕", command: `${prefix}entretenimento`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🔎 𝙋𝙀𝙎𝙌𝙐𝙄𝙎𝘼𝙎 🔎〕", command: `${prefix}pesquisas`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🕵️‍♂️ 𝘾𝙊𝙉𝙎𝙐𝙇𝙏𝘼𝙎 🕵️‍♂️〕", command: `${prefix}menuvip`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🗞️ 𝙈𝙀𝙉𝙐-𝙉𝙊𝙏𝙄𝘾𝙄𝘼𝙎 🗞️〕", command: `${prefix}menunot`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🤖 𝙈𝙀𝙉𝙐-𝙄𝘼 🤖〕", command: `${prefix}menuia`, body: `⮑ ${NomeDoBot}`},
        {title: "〔📷 𝙒𝘼𝙇𝙇𝙋𝘼𝙋𝙀𝙍𝙎 📷〕", command: `${prefix}menuwall`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🌞 𝙈𝙀𝙉𝙐-𝙍𝙋𝙂 🌞〕", command: `${prefix}menurpg`, body: `⮑ ${NomeDoBot}`},
        {title: "〔 ⚒️𝙁𝙀𝙍𝙍𝘼𝙈𝙀𝙉𝙏𝘼𝙎⚒️ 〕", command: `${prefix}menuf`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🔱 𝙈𝙀𝙉𝙐-𝘿𝙊𝙉𝙊 🔱〕", command: `${prefix}menudono`, body: `⮑ ${NomeDoBot}`}
      ]
    },
    {
      title: "『 𝙲𝙷𝙴𝙲𝙺𝚂 𝙴 𝙸𝙽𝙵𝙾𝚁𝙼𝙰𝙲𝙾𝙴𝚂 』",
      options: [
        {title: "〔⚡ 𝘾𝙃𝙀𝘾𝙆-𝙋𝙄𝙉𝙂 ⚡〕", command: `${prefix}ping`, body: `⮑ ${NomeDoBot}`},
        {title: "〔😼 𝙈𝙀𝙐-𝙋𝙀𝙍𝙁𝙄𝙇 😼〕", command: `${prefix}perfil`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🛒 𝘼𝙇𝙐𝙂𝘼𝙍 🛒〕", command: `${prefix}alugar`, body: `⮑ ${NomeDoBot}`},
        {title: "〔💬 𝘾𝙃𝘼𝙏-𝙊𝙁𝙄𝘾𝙄𝘼𝙇 💬〕", command: `${prefix}ladygp`, body: `⮑ ${NomeDoBot}`},
        {title: "〔✅ 𝘼𝙑𝘼𝙇𝙄𝘼𝙍 ✅〕", command: `${prefix}avalie`, body: `⮑ ${NomeDoBot}`},
        {title: "〔💡 𝙎𝙐𝙂𝙀𝙎𝙏𝘼̃𝙊 💡〕", command: `${prefix}sugestao`, body: `⮑ ${NomeDoBot}`},
        {title: "〔💾 𝙍𝙀𝙋𝙊𝙍𝙏𝘼𝙍-𝙐𝙈-𝘽𝙐𝙂 💾〕", command: `${prefix}bug`, body: `⮑ ${NomeDoBot}`},
        {title: "〔🐞 𝙄𝙉𝙁𝙊-𝙇𝘼𝘿𝙔 🐞〕", command: `${prefix}infobot`, body: `𝑨𝒖𝒅𝒊𝒐 𝑰𝒏𝒇𝒐𝒓𝒎𝒂𝒏𝒅𝒐...`}
      ]
    }
  ]
}
txt = `〔🏷〕⥲ 𝙉𝙄𝘾𝙆: ${pushname}
〔📅〕⥲ 𝘿𝘼𝙏𝘼: ${date}
〔⏱〕⥲ 𝙃𝙊𝙍𝘼: ${hora120}
〔⚜〕⥲ 𝙑𝙄𝙋: ${isVip ? 'Sim ✅' : 'Não ❌'}`, `${NomeDoBot}`
sendRouletteButton(sender, {image: {url: logoslink.logo}, caption: txt, footer: NomeDoBot, contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: blackchannel, newsletterName: `亗 Lady bot亗`}}}, blackmd, sender, [botaoblk], info)
break

case 'comandos':
setTimeout(() => {reagir(from, `😃`)}, 300)
sendMenuPrime()
break

case 'logos':
case 'menulogo':
case 'menulogos':
setTimeout(() => {reagir(from, "📜")}, 300)
const { menulogos } = require("./dono/menus/menulogos.js")
mlogos = menulogos(sender, prefix)
sendMenu(mlogos)
break

case 'menu_consultas':
case 'menucon':
case 'consultas':
case 'consulta':
setTimeout(() => {reagir(from, "🕵️‍♂️")}, 300)
const { menucon } = require("./dono/menus/consultas.js")
mcon = menucon(sender, prefix)
sendMenu(mcon)
break

case 'menunot':
case 'noticias':
case 'menu_noticias':
setTimeout(() => {reagir(from, "🗞️")}, 300)
const { menunot } = require("./dono/menus/noticias.js")
mnoti = menunot(sender, prefix)
sendMenu(mnoti)
break

case 'entreter':
case 'entretenimento':
case 'menuent':
setTimeout(() => {reagir(from, "🎭")}, 300)
const { menuent } = require("./dono/menus/entretenimento.js")
menue = menuent (sender, prefix)
sendMenu(menue)
break

case 'pesquisas':
case 'menupes':
case 'menup':
setTimeout(() => {reagir(from, "🔎")}, 300)
const { menupes } = require("./dono/menus/pesquisas.js")
pesq = menupes(sender, prefix)
sendMenu(pesq)
break

case 'menuf':
case 'ferramentas':
case 'menufer':
setTimeout(() => {reagir(from, "⚒️")}, 300)
const { menufer } = require("./dono/menus/ferramentas.js")
ferr = menufer(sender, prefix)
sendMenu(ferr)
break
case 'wallpapers':
case 'wallpaper':
case 'menuwall':
case 'menuw':
setTimeout(() => {reagir(from, "❄️")}, 300)
const { menuwall } = require("./dono/menus/wallpapers.js")
wall = menuwal(sender, prefix)
sendMenu(wall)
break

case 'ia':
case 'menuias':
case 'menuia':
setTimeout(() => {reagir(from, "🤖")}, 300)
const { menuia } = require("./dono/menus/menuia.js")
ias = menuia(sender, prefix)
sendMenu(ias)
break

case 'rpg':
case 'menurpg':
case 'Menurpg':
setTimeout(() => {reagir(from, "🌞")}, 300)
const { menurpg } = require("./dono/menus/menurpg.js")
rpg = menurpg(sender, prefix)
sendMenu(rpg)
break
case 'figurinhas':
case 'menufigurinhas':
case 'menufigu':
case 'menufig':
setTimeout(() => {reagir(from, "💝")}, 300)
const { menufig } = require("./dono/menus/menufig.js")
menuf = menufig(sender, prefix)
sendMenu(menuf)
break

case 'menuemoji':
setTimeout(() => {reagir(from, "😃")}, 300)
const { menuemoji } = require("./dono/menus/menuemoji.js")
MEJ = menuemoji(sender, prefix)
sendMenu(MEJ)
break

case 'menu+18': case '+18': case 'menunsfw':
if(isGroup && !isNsfw) return reply(`*Este comando só pode ser executado com o modo+18 ativo...*
*Para ativa-lo, digite* ${prefix}modo+18`)
if(!isGroup && !isVip) return reply("Este recurso no PV só está liberado para usuários VIP")
setTimeout(() => {reagir(from, "🔞")}, 300)
const { menunsfw } = require("./dono/menus/menunsfw.js")
m18 = menunsfw(sender, prefix)
sendMenu(m18)
break

case 'menudownloads':
case 'menudown':
case 'downloads':
case 'musica':
case 'musicas':
case 'tocarmusica':
setTimeout(() => {reagir(from, "💿")}, 300)
const { menudown } = require("./dono/menus/menudown.js")
sendMenu(menudown(sender, prefix))
break

case 'menujogos':
case 'jogos':
case 'menugames':
case 'games':
setTimeout(() => {reagir(from, "🎮")}, 300)
const { menujogos } = require("./dono/menus/menujogos.js")
menugame = menujogos(sender, prefix)
sendMenu(menugame)
break

case 'menutinder':
setTimeout(() => {reagir(from, "❤️‍🔥")}, 300)
const { menutinder } = require("./dono/menus/menutinder.js")
sendMenu(menutinder(sender, prefix))
break

case 'menualuguel':
case 'menurent':
setTimeout(() => {reagir(from, "💰")}, 300)
const { menualuguel } = require("./dono/menus/menualuguel.js")
sendMenu(menualuguel(sender, prefix))
break

case 'menuadm':
case 'menuadms':
case 'adm':
setTimeout(() => {reagir(from, "🎗️")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) { reply(enviar.msg.adm)
return blackmd.sendMessage(from, {audio: {url:'./database/audios/apenasadm.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
const { menuadm } = require("./dono/menus/menuadm.js")
sendMenu(menuadm(sender, prefix))
break

case 'menudono':
case 'donomenu':
if(!isOwner) { reply(enviar.msg.dono)
return blackmd.sendMessage(from, {audio: {url:'./database/audios/cmddono.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "🔱")}, 300)
const { menudono } = require("./dono/menus/menudono.js")
txt = menudono(sender, prefix)
sendMenu(txt)
break

case 'efeitosimg':
case 'efeitos':  
case 'efeitoimg':
case 'menuefeitos':
reagir(from, "🧩")
const { menuefeitos } = require("./dono/menus/menuefeitos.js")
txt = menuefeitos(sender, prefix)
blackmd.sendMessage(from, {image: {url: logoslink.logo}, caption: txt, mentions: [sender]})
break

case 'alteradores':
case 'mods':
case 'mod':
case 'menumods':
reagir(from, "🧸")
const { menumods } = require("./dono/menus/menumods.js")
txt = menumods(sender, prefix)
sendMenu(txt)
break

case 'menuzoeira':
case 'zoeira':
case 'brincadeiras':
setTimeout(() => {reagir(from, "🤪")}, 300)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for um, apenas digite ${prefix}modozoeira 1`)
const { menuzoeira } = require("./dono/menus/menuzoeira.js")
MZ = menuzoeira(sender, prefix)
sendMenu(MZ)
break 

case 'menuvip':
case 'menupremium':
case 'menuprem':
case 'vip':
setTimeout(() => {reagir(from, "🤑")}, 300)
const { menuvip } = require("./dono/menus/menuvip.js")
mvip = menuvip(sender, prefix)
sendMenu(mvip)
break

case 'calendario':
case 'dados':
setTimeout(() => {reagir(from, "📅")}, 300)
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
totalcmd = JSON.parse(fs.readFileSync("./database/data/totalcmd.json"))[0].totalcmd
day = `
${tempo_emoji} *${tempo.toUpperCase()}*
👤 ${pushname}

👥 *GRUPO:* ${isGroup ? groupName : "privado"}
📆 *DATA & HORA ↴*
${semana}, ${realtime()}
🎲 *TOTAL-CMD:* ${totalcmd} comandos
🤖 *BOT:* ${NomeDoBot}
👑 *DONO:* ${NickDono}

📠 _Operando em ${allGroups.length} grupos_
`
if(isGroupInRent(from)) {
hehe = getGroupRent(from)
day += `🔋 *Bateria restante para uso ↴*
-> ${barrinha(hehe.tempo, hehe.totalRent)} ${hehe.cliente == sender || isOwner ? `\n»⟩ ${sendTimeHours(hehe.tempo)} até o fim do contrato ⟨«` : ``}
`
}
reply(`${day}`)
break

case 'stickerid'://vitukjk
if(isQuotedSticker) {
const stickerId = info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage.fileSha256.toString('hex').toUpperCase();
reply(`${stickerId}`);
} else {
reply('Marque uma figurinha para mostrar o ID.');
}
break


case 'ladyg': case 'grupooficial':
reagir(from, `✅`)
try {
nome = (await blackmd.groupMetadata(obrigadoEXT.idchatofc)).subject
link = await blackmd.groupInviteCode(obrigadoEXT.idchatofc)
try { ppUrl = await blackmd.profilePictureUrl(obrigadoEXT.idchatofc, 'image')
} catch { ppUrl = semfoto }
if(isGroup) {
linkgp = `*Link do nosso grupo:* ✅

https://chat.whatsapp.com/`+link
sendUrlText(from, linkgp, nome, `Chat OFC da lady v5`, ppUrl, `https://chat.whatsapp.com/`+link, seloctt)
} else {
sendUrlDoc(from, `*Link do nosso Chat...* ✅

🔗 _Clique na imagem para entrar_`, `application/pdf`,
`${tempo_emoji}⃤ ${tempo.toUpperCase()}`,
10000, nome, '', ppUrl, `https://chat.whatsapp.com/`+link, seloctt)
}
} catch { reply("Erro") }
break

case 'site':
reagir(from, "🌐")
sendUrlText(from,
`*Site oficial do luanzn:* ✅\n\n`+site,
`🔎 ${NomeDoBot} 🔍`,
`Um site para amantes de tecnologia e inovações com conteúdos únicos`,
logoslink.menu,
site,
seloctt)
break

case 'infolady':
reagir(from, "🥰")
ib = `${tempo_emoji} _${tempo} ${pushname}, caiu de paraquedas e não sabe como funciona tudo por aqui? Chega mais..._

🤖 _a ladybug é uma bot altamente sofisticado, capaz de operar de forma remota e automática em seu grupo, com altas funções de administração e diversão. Nossa equipe se empenha diariamente para manter o bot online com os melhores sistemas que você pode encontrar._

💡 _Quanto ao uso dos comandos, o prefixo usado é ( ${prefix} ), basta digitar o mesmo na frente do comando para que esse seja executado... Claro que vc pode acabar digitando errado ou pode ser que o comando não exista. Sendo assim, olhe no ${prefix}menu e não exite em procurar o mesmo nos diversos menus que estão organizados lá._

_-> Modo de uso do prefixo:_
❌ menu${prefix}
❌ ${prefix} menu
✅ ${prefix}menu

💬 *NOSSO CHAT:* ${prefix}blackgp
🛒 *Se desejas alugar o bot para seu grupo digite:* ${prefix}alugar
🤔 *Dúvidas? Use:* ${prefix}suporte
❓ *Alguma sugestão ? Use o comando:* ${prefix}sugestão
💾 *Algum bug ? relate à nossa equipe no comando:* ${prefix}bug`
reply(ib)
break

case 'aluguel':
case 'alugueis':
case 'alugar':
case 'alugarbot': {
reagir(from, "🛒")
moneybot = `*_»⟩Tabela de preços para alugar o bot ⟨«_*

${valoresDeAluguel.map(a => `${permuteNumberEmoji(a.id)}⧽ R$ ${Number(a.valor).toFixed(2)} (${a.tempo} dias)`).join(`\n`)}
`
var download = [
`ʟᴏᴀᴅɪɴɢ〘▒▒▒▒▒▒▒▒▒▒〙0%`,
`ʟᴏᴀᴅɪɴɢ〘█▒▒▒▒▒▒▒▒▒〙10%`,
`ʟᴏᴀᴅɪɴɢ〘███▒▒▒▒▒▒▒〙35%`,
`ʟᴏᴀᴅɪɴɢ〘█████▒▒▒▒▒〙51%`,
`ʟᴏᴀᴅɪɴɢ〘███████▒▒▒〙62%`,
`ʟᴏᴀᴅɪɴɢ〘████████▒▒〙80%`,
`ʟᴏᴀᴅɪɴɢ〘██████████〙100%`,
`𝙻𝙾𝙰𝙳𝙸𝙽𝙶 𝙲𝙾𝙼𝙿𝙻𝙴𝚃𝙴𝙳...`
]
let { key } = await blackmd.sendMessage(from, {text: tempo+" "+pushname}, {quoted: info})
await sleep(2000)
for(let i = 0; i < download.length; i++) {
await blackmd.sendMessage(from, {text: download[i], edit: key }, {quoted: info})
}
reply(moneybot + `

❪🍧ฺ࣭࣪͘ꕸ▸ _use *${prefix}buykeygp* para escolher o tempo de aluguel e *${prefix}buygp* com o link do grupo para o bot entrar..._`)}
break

case 'loja': case 'store':
reagir(from, "🛍️")
try { ppimg = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image'))}`)).data
} catch(e) { ppimg = semfoto }
txt = `ㅤㅤㅤㅤㅤㅤ *🛒〘 LOJA 〙🛒* 
❪🛍️ฺ࣭࣪͘ꕸ▸ *ALUGUÉIS*
${valoresDeAluguel.map(a => `${permuteNumberEmoji(a.id)}⧽ R$ ${Number(a.valor).toFixed(2)} (${a.tempo} dias)`).join(`\n`)}
_Use *${prefix}buykeygp*_

❪💰ฺ࣭࣪͘ꕸ▸ *VIP*
1️⃣ R$ ${Number(valoresVIP.vip).toFixed(2)} (30 dias - VIP global sem puxadas)
2️⃣ R$ ${Number(valoresVIP.vipcp).toFixed(2)} (30 dias - VIP global com puxadas)
3️⃣ R$ ${Number(valoresVIP.vipgp).toFixed(2)} (30 dias - VIP de grupo sem puxadas)
4️⃣ R$ ${Number(valoresVIP.vipgpcp).toFixed(2)} (30 dias - VIP de grupo com puxadas)
_Use *${prefix}buyvip* ou *${prefix}buyvipgp*_

❪🔖ฺ࣭࣪͘ꕸ▸ *Card XP*
_Cada dia é multiplicado 1 a mais (Se for 1 dia, multiplica por 2... Se for 3 dias, multiplica por 4, etc)_
${valoresXP.map(x => `*» ${x.velocidade} «*
` + x.dados.map(p => `${permuteNumberEmoji(p.id)}⧽ R$ ${Number(p.valor).toFixed(2)} (${x.velocidade} por ${sendLetterTime(p.tempo)})`).join(`\n`)).join(`\n`)}
_Use *${prefix}buycard*_`
ft = `Caso queira visualizar a loja em lista, clique no botão abaixo...`
butao = isGroup ? sendButton : sendRouletteButton
rent = isGroup ? {text: txt, footer: ft} : {image: {url: `https://telegra.ph/file/698a9e0883be7a1091ae7.jpg`}, caption: txt, footer: ft}
butao(from, rent, blackmd, sender, [{type: `cmd`, text: `𝙎𝙏𝙊𝙍𝙀 𝙇𝙄𝙎𝙏 🕹`, command: prefix+`storelist`}], seloctt)
break

case 'storelist': case 'liststore': case 'lojalista': case 'listaloja':
txt =
`\t\t\t⮑ 𝙎𝙏𝙊𝙍𝙀 𝙇𝙄𝙎𝙏 ⮐
〔👤〕↝ ᴜꜱᴜᴀ́ʀɪᴏ: @${sender.split("@")[0]}
〔📆〕↝ ᴅᴀᴛᴀ: ${sendHours("dddd, LL")}
〔💰〕↝ ꜱᴀʟᴅᴏ: R$ ${getSepCoins(sender)[2]}`
listaluguel = []
for(a of valoresDeAluguel) {
  listaluguel.push({name: `ALUGUE AGORA`, title: `${permuteNumberEmoji(a.id)}⧽ ${a.tempo} dias`, body: `R$ ${Number(a.valor).toFixed(2)}`, command: prefix+`buykeygp `+a.tempo})
}
listvip = []
for(b = 0; b < 3; b++) {listvip.push({name: `VIP GLOBAL "SEM" PUXADAS`, title: `${permuteNumberEmoji(listvip.length + 1)}⧽ ${(b + 1) * 10} dias`, body: `R$ ${Number((b + 1) * (valoresVIP.vip / 3)).toFixed(2)}`, command: prefix+`buyvip `+String((b + 1) * 10)},
{name: `VIP GLOBAL "COM" PUXADAS`, title: `${permuteNumberEmoji(listvip.length + 2)}⧽ ${(b + 1) * 10} dias`, body: `R$ ${Number((b + 1) * (valoresVIP.vipcp / 3)).toFixed(2)}`, command: prefix+`buyvip `+String((b + 1) * 10)+`/puxadas`})}
for(c = 0; c < 3; c++) {listvip.push({name: `GRUPO VIP "SEM" PUXADAS`, title: `${permuteNumberEmoji(listvip.length + 1)}⧽ ${(c + 1) * 10} dias`, body: `R$ ${Number((c + 1) * (valoresVIP.vipgp / 3)).toFixed(2)}`, command: prefix+`buyvipgp `+String((c + 1) * 10)},
{name: `GRUPO VIP "COM" PUXADAS`, title: `${permuteNumberEmoji(listvip.length + 2)}⧽ ${(c + 1) * 10} dias`, body: `R$ ${Number((c + 1) * (valoresVIP.vipgpcp / 3)).toFixed(2)}`, command: prefix+`buyvipgp `+String((c + 1) * 10)+`/puxadas`})}
listcardxp = []
for(d of valoresXP) {
  for(e of d.dados) {listcardxp.push({name: d.velocidade, title: `${permuteNumberEmoji(listcardxp.length + 1)}⧽ ${sendLetterTime(e.tempo)}`, body: `R$ ${Number(e.valor).toFixed(2)}`, command: prefix+`buycard ${d.velocidade}/${sendLetterTime(e.tempo)}`})}
}
but =
[{title: `ALUGUEL DE GRUPO`, options: listaluguel},
{title: `VIP GLOBAL E GRUPO VIP`, options: listvip},
{title: `CARD MULTI XP`, options: listcardxp}]
if(isGroup) reply(`Enviando PV`)
sendRouletteButton(sender, {image: {url: `https://telegra.ph/file/698a9e0883be7a1091ae7.jpg`}, caption: txt, mentions: [sender], footer: `_Escolha na lista abaixo o que desejas comprar ⤵_`, contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: blackchannel, newsletterName: `亗 ʙʟᴀᴄᴋ ꜱʏꜱᴛᴇᴍ ᴏꜰᴄ 亗`}}}, blackmd, sender, [{type: `list`, title: `〘 💢 CLIQUE AQUI 💢 〙`, rowId: but}], seloctt)
break

case 'infoaluguel':
setTimeout(() => {reagir(from, "🤑")}, 300)
reply(`*Olá caro viajante, está perdido de como alugar o Black ?? Ett vou lhe dar uma rápida dica.* 🧐
  
*Como visto na tabela acima, tem os preços de aluguel mensal... O preço varia dependendo da quantidade de meses; porém o preço é unitário por grupo.* 😃

*Por exemplo, se alugar dois grupos por 1 mês, vai ser ${valoresDeAluguel[1].valor}+${valoresDeAluguel[1].valor} = ${valoresDeAluguel[1].valor + valoresDeAluguel[1].valor}$. Ou se alugar dois grupos por dois meses, será ${valoresDeAluguel[2].valor}+${valoresDeAluguel[2].valor} = ${valoresDeAluguel[2].valor + valoresDeAluguel[2].valor}$.* 💵

*Caso você queira alugar o bot ou queira mais informações, chame meu dono no PV* 👑`)
break

case 'recarga': case 'recarregar': {
valores = [1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100]
caixa = [{tap: []}]
total = 0
for(a = 0; a < valores.length; a++) {
  if(caixa[total].tap.length < 3) {
    caixa[total].tap.push(valores[a])
  } else {
    caixa.push({tap: [valores[a]]})
    total += 1
  }
}
if(!valores.includes(Number(q))) {
  if(isIOS || isGroup) return reply(`*_Retorne o valor da recarga diretamente após o comando, ex:_*
_${prefix+command} ${valores[alerandom(valores.length)]}_

*_Valores disponíveis:_*
${caixa.map(a => `_` + a.tap.map(b => `R$ ${Number(b).toFixed(2)}`).join(`\t\t\t\t\t\t\t`) + `_`).join(`\n`)}`)
  matheuzinho = []
  for(v of valores) {
    matheuzinho.push({title: `𝗥𝗘𝗖𝗔𝗥𝗚𝗔 𝗡𝗢 𝗩𝗔𝗟𝗢𝗥 𝗗𝗘 ${v}$`, body: `referente a ${v} moeda${v != 1 ? "s" : ""}`, command: prefix+command+" "+String(v)})
  }
  return sendRouletteButton(sender, {image: {url: `https://blackstorage.store/midia/1735506461779.jpg`}, caption: tempo + " " + pushname + ", vejo que você não escolheu o valor da recarga corretamente... Irei te mandar a tabela abaixo ↴", footer: `𖥨ํ∘̥⃟⸽⃟💌৴▸ _Lembrando que essa recarga não está vinculada a compra de nenhum produto no bot, com exceção das moedas... Tais moedas após compradas poderão ser usadas para afins como aluguéis de grupos, VIP e outros. Para mais info, ver *${prefix}inforent*_`}, blackmd, sender, [{type: "list", title: `〘 𝗥𝗘𝗖𝗔𝗥𝗚𝗔𝗦 〙`, rowId: [{title: NomeDoBot, options: matheuzinho}]}], seloctt)
}
nmr = Number(q)
var pagament = new payment(MercadoPagoKey)
try {
let inf = await pagament.create_payment(nmr)
console.log(colors.yellow(`\n\n[⚠️] código de pagamento gerado no valor de ${nmr}$ ⚜️\n\n`))
if(isGroup) reply('Por questões de segurança, irei te enviar os dados no PV...')
await sleep(1000)
if(!isIOS) {
sendRouletteButton(sender, {image: Buffer.from(inf.qr_code, "base64"), caption: `QR code de pagamento acima... Caso queira apenas o código, segue o pix copia e cola abaixo ↴`, footer: NomeDoBot, contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: blackchannel, newsletterName: `亗 ʙʟᴀᴄᴋ ꜱʏꜱᴛᴇᴍ ᴏꜰᴄ 亗`}}}, blackmd, sender, [{type: `copy_text`, text: `CLIQUE AQUI PARA COPIAR 📑`, url: inf.copy_paste}], seloctt)
} else {
blackmd.sendMessage(sender, {image: Buffer.from(inf.qr_code, "base64"), caption: `QR code de pagamento acima... Caso queira apenas o código, segue o pix copia e cola abaixo ↴`, footer: NomeDoBot, contextInfo: {forwardingScore: 999, isForwarded: true, forwardedNewsletterMessageInfo: {newsletterJid: blackchannel, newsletterName: `亗 ʙʟᴀᴄᴋ ꜱʏꜱᴛᴇᴍ ᴏꜰᴄ 亗`}}}, {quoted: seloctt})
await sleep(3000)
sendMess(sender, inf.copy_paste)
}
await sleep(5000)
sendMess(sender, `Lembrando que você tem 10 minutos para efetuar o pagamento... Caso exceda o tempo, há possibilidade do sistema não contabilizar as moedas.

Qualquer dúvida, use o comando ${prefix}suporte...`)

let check = await pagament.check_payment();

while(check.status == 'pending') { check = await pagament.check_payment() }
if(check.status == "approved") {
addCoinsInVirtualBalance(sender, nmr)
console.log(colors.green(`\n\n[❕] pagamento efetuado com sucesso ✔️\n\n`))
const sendComp = (taxa, valor) => {
sub = 100 / taxa
return `
┏◤ ━━━━━━━━━━───━━━━━━━━━━━ ◢┓
[⚙️] *COMPROVANTE DE PAGAMENTO* [⚙️]
╟┓
║┢ ❪📖ฺ࣭࣪͘ꕸ▸ *Nome:* ${pushname}
║┢ ❪📱ฺ࣭࣪͘ꕸ▸ *Número:* @${sender.split('@')[0]}
║╽
║┢ ❪💸ฺ࣭࣪͘ꕸ▸ *Valor:* R$ ${Number(valor).toFixed(2)}
║┢ ❪💰ฺ࣭࣪͘ꕸ▸ *Taxa:* ${taxa}% ( R$ ${Number(valor/sub).toFixed(2)} )
║┢ ❪🪙ฺ࣭࣪͘ꕸ▸ *Total:* R$ ${Number(valor - (valor / sub)).toFixed(2)}
║╽
║┢ 📅⃤ *Data:* ${sendHours('DD/MM/YYYY')}
║┢ ⏰⃤ *Hora:* ${sendHours('HH:mm:ss')}
║╽
║╽ㅤㅤㅤㅤ💠 Black System 💠
╙┷━━━━━━━━━━━───━━━━━━━━━━━┛
` }
blackmd.sendMessage(obrigadoEXT.idprivategp, {text: sendComp(1, nmr), mentions: [sender, nmrdn]})
await sleep(1000)
mention(`💠 Parabéns @${sender.split('@')[0]}, seu débito foi aprovado no valor de *R$ ${Number(nmr).toFixed(2)}* debitado em sua conta virtual da Black System proveniente da recarga... Para mais info sobre o que fazer com suas moedas, acesse *${prefix}loja*`)
await sleep(1000)
return sendMess(sender, sendComp(0, nmr))
}
reply("Pagamento expirado ヅ")
} catch(e) {
console.log(e)
reply("Sistema parece instável... Pfvr, volte mais tarde ✋🏽😳🤚🏽")
}
}
break

case 'me': case 'you':
if(command == `you`) {
if(!isOwner) return reply(enviar.msg.dono)
if(!marc_tds) return reply("Marque o usuário que vc quer puxar o saldo")
usu = marc_tds
} else { usu = sender }
registrarUsuInVirtualBalance(usu)
try { ppimg = await blackmd.profilePictureUrl(`${usu.split('@')[0]}@c.us`, 'image')
} catch { ppimg = semfoto }
i = getCoinsUsu(usu)
txt = `📖 *NOME:* ${getSepCoins(usu)[0]}
💸 *SALDO:* R$ ${getSepCoins(usu)[2]}
📱 *WHATSAPP:* wa.me/${i.id.split('@')[0]}
🆔 *ID:* ${i.UID}
💳 *CORTESIAS:* ${i.cortesia} ${i.keys.length > 0 ? `

🔑 *KEYS:*
${i.keys.map(k => `• *chave:* ${isGroup ? k.key.slice(0, 10) + `#`.repeat(k.key.length - 10) : k.key}
• *tipo:* "${k.tipo == 1 ? `aluguel` : k.tipo == 2 ? `cortesia` : k.tipo == 3 ? `vip` : k.tipo == 4 ? `grupo vip` : `card xp`}"
• *tempo:* ${k.tempo <= 0 ? `∞ INFINITO` : k.tipo == 1 || k.tipo == 2 || k.tipo == 5 ? String((k.tempo - (k.tempo % 24)) / 24) + `d` + ((k.tempo % 24) > 0 ? ` e ` + String(k.tempo % 24) + `h` : ``) : String(k.tempo) + `d`}`).join(`\n\n`)}` : ``}

_Registrado em ${i.rg}_`
sendUrlText(from, txt, NomeDoBot, ``, ppimg, `https://wa.me/`+usu.split("@")[0], seloctt)
break

case 'keys':
if(!isOwner) return reply(enviar.msg.dono)
if(allKeysRentSystem.length <= 0) return reply(`Não há keys salvas na database do bot...`)
txt =
`🎲 _*Total de keys:* ${allKeysRentSystem.length}_
${allKeysRentSystem.map(k => `👤 *ID:* @${k.cliente.split("@")[0]}
🔑 *CHAVE:* ${isGroup ? k.key.slice(0, 6) + `#`.repeat(k.key.length - 6) : k.key}
🧵 *TIPO:* "${k.tipo == 1 ? `aluguel` : k.tipo == 2 ? `cortesia` : k.tipo == 3 ? `vip` : k.tipo == 4 ? `grupo vip` : `card xp`}"
⏱ *TEMPO:* ${k.tempo <= 0 ? `∞ INFINITO` : k.tipo == 1 || k.tipo == 2 || k.tipo == 5 ? String((k.tempo - (k.tempo % 24)) / 24) + `d` + ((k.tempo % 24) > 0 ? ` e ` + String(k.tempo % 24) + `h` : ``) : String(k.tempo) + `d`}`).join(`\n\n`)}`
mention(txt)
break

case 'addsaldo':
if(!isOwner) return reply(enviar.msg.dono)
var [nmr, quant] = q.split('/')
if(!nmr || !quant) return reply(`Você vai colocar o número da pessoa e após isso uma barra ( / ). Após a barra, coloque o saldo que será adc. Ex:
${prefix+command} ${nmrdn.split('@')[0]}/30`)
if(!Number(quant)) return reply(quant+" não é número...")
usu = nmr.toLowerCase() == "me" ? sender : identArroba(nmr)
addCoinsInVirtualBalance(usu, quant)
mention(`💠 R$ ${Number(quant).toFixed(2)} adc ao saldo do usuário @${usu.split('@')[0]}`)
break

case 'rmsaldo':
if(!isOwner) return reply(enviar.msg.dono)
var [nmr, quant] = q.split('/')
if(!nmr || !quant) return reply(`Você vai colocar o número da pessoa e após isso uma barra ( / ). Após a barra, coloque o saldo que será removido. Ex:
${prefix+command} ${nmrdn.split('@')[0]}/30`)
if(!Number(quant)) return reply(quant+" não é número...")
usu = nmr.toLowerCase() == "me" ? sender : identArroba(nmr)
rmCoinsInVirtualBalance(usu, quant)
mention(`💠 R$ ${Number(quant).toFixed(2)} rmvd do saldo do usuário @${usu.split('@')[0]}`)
break

case 'transferirsaldo': case 'transferir-saldo':
var [nmr, quant] = q.split('/')
if(!nmr || !quant) return reply(`Você vai colocar o número da pessoa e após isso uma barra ( / ). Após a barra, coloque o saldo que será transferido. Ex:
${prefix+command} ${nmrdn.split('@')[0]}/30`)
if(!Number(quant)) return reply(quant+" não é número...")
if(Number(quant) < 0) return reply("O valor precisa ser maior que 0")
usu = identArroba(nmr)
if(usu.includes(sender)) return reply(`Não podes transferir para você msm né`)
if(usu.includes(botNumber)) return reply(`Não podes transferir para o bot né`)
registrarUsuInVirtualBalance(sender)
registrarUsuInVirtualBalance(usu)
if(Number(quant) > getCoinsUsu(sender).saldo) return reply("Você não possui saldo para efetuar essa transferência")
addCoinsInVirtualBalance(usu, quant)
rmCoinsInVirtualBalance(sender, quant)
mention(`💠 R$ ${Number(quant).toFixed(2)} transferido${Number(quant) === 1 ? "" : "s"} para o usuário @${usu.split('@')[0]}`)
break

case 'buygp':
if(!q) return reply('Insira um link de convite do grupo ao lado do comando.')
if(!q.includes('chat.whatsapp.com/') || q.includes('|')) return reply(`Ops, verifique o link que você inseriu...\nUse: ${prefix} link do grupo`)
registrarUsuInVirtualBalance(sender)
if(Number(getCoinsUsu(sender).saldo) < 5 && getCoinsUsu(sender).keys.length <= 0) return reply(`Seu saldo está abaixo do mínimo permitido para usar este comando... Recomendo efetuar uma recarga de moedas através do comando ${prefix}recarga`)
link = q.split('app.com/')[1]
try {
blackmd.groupAcceptInvite(`${link}`)
await sleep(2000)
reply(`🤖 Entrando no grupo... Devo ressaltar que os comandos não funcionarão ao menos que vc compre uma chave de acesso através do comando *${prefix}buykeygp*`)
} catch(erro) {
if(JSON.stringify(erro).includes('resource-limit')) return reply(`O grupo já está com o número máximo de membros... Não consigo entrar 🫠`)
if(JSON.stringify(erro).includes('not-authorized')) return reply(`Não foi possível entrar no grupo pq algum admin me baniu... Pfvr, peça para o meu dono me adicionar (chame ${prefix}dono)`)
reply(`Não foi possível entrar no grupo... Pfvr, chame meu dono para ele registrar os dados 🎲`)
}
break

case 'buycort':
if(!q) return reply(`KD o link do grupo pá eu liberar a cortesia?`)
if(!q.includes('chat.whatsapp.com/') || q.includes('|')) return reply(`Ops, verifique o link que você inseriu...\nUse: ${prefix} link do grupo`)
registrarUsuInVirtualBalance(sender)
if(Number(getCoinsUsu(sender).saldo) < 5) return reply(`Seu saldo está abaixo do mínimo permitido para usar este comando... Recomendo efetuar uma recarga de moedas através do comando ${prefix}recarga`)
if(getCoinsUsu(sender).cortesia <= 0) return reply(`Você não possui mais *CARD CORTESIA* neste mês para prosseguir com este comando...`)
link = q.split('app.com/')[1]
try {
blackmd.groupAcceptInvite(`${link}`)
await sleep(2000)
gerarTypeKey(sender, {type: 2, grupo: from})
if(isGroup) reply(`Irei te enviar no PV 🧵`)
await sleep(1000)
dados = getCoinsUsu(sender)
dados.cortesia -= 1
saveCoins()
chave = dados.keys[dados.keys.length - 1].key
sendButton(sender, {text: `💡 A chave "${chave}" foi gerada com sucesso... Copie e cole a mesma no seu grupo para validar a cortesia e liberar os comandos do bot 😊`, footer: chave}, blackmd, sender, [{type: `copy_text`, text: `CLIQUE AQUI`, url: chave}], seloctt)
} catch(erro) {
if(JSON.stringify(erro).includes('resource-limit')) return reply(`O grupo já está com o número máximo de membros... Não consigo entrar 🫠`)
if(JSON.stringify(erro).includes('not-authorized')) return reply(`Não foi possível entrar no grupo pq algum admin me baniu... Pfvr, peça para o meu dono me adicionar (chame ${prefix}dono)`)
reply(`Não foi possível entrar no grupo... Pfvr, chame meu dono para ele registrar os dados 🎲`)
}
break

case 'gerarkeycort': {
if(!isOwner) return reply(enviar.msg.dono)
reagir(from, "😀")
let { key } = await blackmd.sendMessage(from, {text: `🎲 *_KEY GERADA COM SUCESSO_* 🎲`}, {quoted: info})
await sleep(1500)
gerarTypeKey(sender, {type: 2, grupo: from})
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
await sleep(500)
blackmd.sendMessage(from, {text: `${chave}`, edit: key}, {quoted: info})
await sleep(500)
sendMess(from, `🎳 *_Descrição ⤵_*
〔🎯〕⥲ *Tipo:* "cortesia"
〔⏱〕⥲ *Tempo:* 24h`)
await sleep(500)
blackmd.sendMessage(from, {text: `Copie essa chave ou encaminhe ao privado do cliente ✔`}, {quoted: {
  key: {
    fromMe: false,
    participant: botNumber
  },
  message: {
    conversation: chave
  }
}})
}
break

case 'transferirgp':
if(!q || !q.includes(`chat.whatsapp.com`)) return reply(`Coloque ao lado do comando o link do novo grupo em que você deseja colocar o bot... Assim:
${prefix+command} link do grupo`)
gps = []
for(i of aluguel) {if(i.cliente == sender) gps.push({title: i.nome, body: sendTimeHours(i.tempo) + " até o fim do aluguel...", command: prefix+command+" "+q+"|"+i.id})}
if(gps.length <= 0) return reply(`☝🏻😔 Smt, você não está na lista de clientes do bot... Mas não se preocupe, você pode mudar isso alugando o bot para o seu grupo usando o comando ${prefix}buykeygp 💭`)
barra = q.replace(" |", "|").replace("| ", "|").replace(" | ", "|")
var [link, idgp] = barra.split("|")
if(!idgp) {
if(isGroup) reply(`Chega PV 🔰`)
try { ppUrl = await blackmd.profilePictureUrl(from, 'image')
} catch { ppUrl = semfoto }
return sendRouletteButton(sender, {image: {url: ppUrl}, caption: `_Selecione na lista abaixo o grupo na qual você deseja transferir para o novo... Este antigo será deletado do aluguel, e uma nova key será enviada no seu privado_ 💭`, footer: `_Listando abaixo os grupos na qual o seu número consta como cliente..._`}, blackmd, sender, [{type: `list`, title: `🔻 CLIQUE AQUI 🔺`, rowId: [{title: tempo+" "+pushname, options: gps}]}], seloctt)
}
if(!isGroupInRent(idgp)) return reply(`Este grupo não está registrado no sistema de aluguel... Para que haja possibilidade de transferir o registro, você precisa usar este comando com um grupo na qual você seja cliente 😃`)
if(getGroupRent(idgp).cliente != sender) return reply(`Ops espertinho kkkk querendo pegar um grupo que não é seu?`)
try {
blackmd.groupAcceptInvite(link.split('app.com/')[1])
await sleep(1000)
temporent = getGroupRent(idgp).tempo
delRent(reply, idgp)
await sleep(1000)
if(isGroup) sendMess(from, `Irei te enviar a nova chave no PV 🧵`)
await sleep(1000)
blackmd.groupLeave(idgp)
gerarTypeKey(sender, {type: 1, grupo: from, tempo: String(temporent) + `h`})
await sleep(1000)
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
sendButton(sender, {text: `💡 A chave "${chave}" foi gerada com sucesso... Copie e cole a mesma no seu grupo para validar a transferência de aluguel e liberar os comandos do bot no novo chat 😊`, footer: chave}, blackmd, sender, [{type: `copy_text`, text: `CLIQUE AQUI`, url: chave}], seloctt)
await sleep(1000)
sendMess(sender, `🤖 Entrando no grupo... Devo ressaltar que os comandos não funcionarão ao menos que vc copie e cole essa chave de acesso dentro do novo grupo.`)
} catch(erro) {
console.log(erro)
if(JSON.stringify(erro).includes('resource-limit')) return reply(`O grupo já está com o número máximo de membros... Não consigo entrar 🫠`)
if(JSON.stringify(erro).includes('not-authorized')) return reply(`Não foi possível entrar no grupo pq algum admin me baniu... Pfvr, peça para o meu dono me adicionar (chame ${prefix}dono)`)
reply(`Não foi possível entrar no grupo... Pfvr, chame meu dono para ele registrar os dados 🎲`)
}
break

case 'buykeygp':
valores = []
for(i of valoresDeAluguel) {valores.push({name: NomeDoBot, title: `${i.tempo} dias`, body: `R$ ${Number(i.valor).toFixed(2)}`, command: `${prefix+command} ${i.tempo}`})}
sla = false
for(s of valoresDeAluguel) {if(q && Number(q) === s.tempo) sla = true}
if(!sla) {
if(isIOS) return reply(`📊 *_Escolha a quantidade de dias para alugar:_*
${valores.map(v => `- ${v.command}`).join(`\n`)}`)
if(isGroup) reply(`Enviando PV 🔰`)
try { img = await blackmd.profilePictureUrl(from, 'image')
} catch { img = semfoto }
return sendRouletteButton(sender, {image: {url: img}, caption: `Escolha na lista abaixo a quantidade de dias que você quer alugar para o seu grupo...`, footer: NomeDoBot}, blackmd, sender, [{type: `list`, title: `〘 ESCOLHA AQUI 〙`, rowId: [{title: `escolha abaixo`, options: valores}]}], seloctt)
}
gvr = getValuesRent(q)
if(getCoinsUsu(sender).saldo < gvr.valor) return reply(`[❗] Você não possui saldo suficiente para efetuar essa compra... Para alugar ${gvr.tempo} dias, serão necessários R$ ${(gvr.valor).toFixed(2)}, e você possui apenas R$ ${getSepCoins(sender)[2]} em sua conta... Use o comando ${prefix}recarga para adicionar moedas a sua conta e comprar as keys 😕`)
rmCoinsInVirtualBalance(sender, gvr.valor)
gerarTypeKey(sender, {type: 1, grupo: from, tempo: String(gvr.tempo) + `d`, valor: gvr.valor})
if(isGroup) reply(`Irei te enviar no PV 🧵`)
await sleep(1000)
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
sendButton(sender, {text: `💡 A chave "${chave}" foi gerada com sucesso... Copie e cole a mesma no seu grupo para validar o aluguel e liberar os comandos do bot 😊`, footer: chave}, blackmd, sender, [{type: `copy_text`, text: `CLIQUE AQUI`, url: chave}], seloctt)
//await sleep(500)
//sendImage(sender, `https://pomf2.lain.la/f/28mcqie5.jpg`, `Desse jeito caso não saiba ✔`)
await sleep(500)
sendMess(sender, `A propósito, caso você não tenha solicitado a entrada do bot no seu grupo, use *${prefix}buygp* com o link ao lado para o bot entrar 🥰`)
break

case 'gerarkeygp': {
if(!isOwner) return reply(enviar.msg.dono)
barra = q.replace(' /', '/').replace('/ ', '/').replace(' / ', '/')
var [v1, v2] = barra.split('/')
if(!q.includes('/')) return reply(`Você vai colocar o número da pessoa que alugou e após isso uma barra ( / ). Após a barra, coloque a quantidade de dias que este alugou para seu grupo. Ex:
${prefix+command} ${nmrdn.split('@')[0]}/30d`)
usu = v1.toLowerCase() == "me" ? sender : identArroba(v1)
const [checkkeygp] = await blackmd.onWhatsApp(usu.split('@')[0])
if(checkkeygp == undefined) return reply(`O número ${usu.split('@')[0]} não é válido no whatsapp`)
lt = v2.slice(v2.length - 1, v2.length).toLowerCase()
if(v2.length > 1 && lt != `d` && lt != `h`) return reply(`Você precisa setar o tempo de aluguel em h ou d... Ex:
${prefix+command} @/30d`)
clientrentcmd = usu
let { key } = await blackmd.sendMessage(from, {text: `🎲 *_KEY GERADA COM SUCESSO_* 🎲`}, {quoted: info})
await sleep(1500)
gerarTypeKey(clientrentcmd, {type: 1, grupo: from, tempo: v2})
dados = getCoinsUsu(clientrentcmd)
chave = dados.keys[dados.keys.length - 1].key
await sleep(500)
blackmd.sendMessage(from, {text: `${chave}`, edit: key}, {quoted: info})
await sleep(500)
sendMess(from, `🎳 *_Descrição ⤵_*
〔🎯〕⥲ *Tipo:* "aluguel"
〔⏱〕⥲ *Tempo:* ${Number(v2.slice(0, v2.length - 1)) > 0 ? v2 : `∞ INFINITO`}
〔🤓〕⥲ *Cliente:* @${clientrentcmd.split("@")[0]}`)
await sleep(500)
blackmd.sendMessage(from, {text: `Copie essa chave ou encaminhe ao privado do cliente ✔`}, {quoted: {
  key: {
    fromMe: false,
    participant: botNumber
  },
  message: {
    conversation: chave
  }
}})
}
break

case 'buyvip':
reagir(from, "🤑")
if(!q) return reply(`Coloque a quantidade de dias VIP...
Ex: ${prefix+command} 30
Ou
Ex: ${prefix+command} 30/puxadas`)
var [a, b] = q.split("/")
if(!Number(a) > 0) return reply("Apenas números positivos para setar o tempo pfvr")
if(a.includes('.')) return reply("Não serão aceitos números decimais...")
isPux = b && (b.toLowerCase() === `puxadas` || b.toLowerCase() === `consultas` || b.toLowerCase() === `vip`) ? true : false
nmr = ((isPux ? valoresVIP.vipcp : valoresVIP.vip) / 30).toFixed(2)
usu = getCoinsUsu(sender)
valor = nmr * Number(a)
if(usu.saldo < valor) return reply(`[❗] Não foi possível completar a compra da Key... ${a} dia${Number(a) !== 1 ? 's' : ''} VIP "${isPux ? `com` : `sem`}" puxadas custar${Number(a) !== 1 ? 'ão' : 'á'} R$ ${(valor).toFixed(2)}, e você possui apenas R$ ${getSepCoins(sender)[2]} em sua conta... Use o comando ${prefix}recarga para adicionar moedas a sua conta e comprar as keys ⚠️`)
rmCoinsInVirtualBalance(sender, valor)
gerarTypeKey(sender, {type: 3, grupo: from, tempo: a, mod: isPux, valor: valor})
if(isGroup) reply(`Irei te enviar no PV 🧵`)
await sleep(1000)
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
sendButton(sender, {text: `💡 A chave "${chave}" foi gerada com sucesso... Copie e cole a mesma em um grupo ou no privado do bot mesmo para validar o VIP e liberar seu acesso aos comandos especiais do sistema 😊`, footer: chave}, blackmd, sender, [{type: `copy_text`, text: `CLIQUE AQUI`, url: chave}], seloctt)
await sleep(1000)
sendMess(sender, `Lembrando que você pode doar essa key VIP para outra pessoa caso queira, basta enviar no PV dela... Pois se enviar no grupo o bot validará o VIP para você 🤩`)
break

case 'gerarkeyvip': {
if(!isOwner) return reply(enviar.msg.dono)
reagir(from, "🤑")
if(!q) return reply(`Coloque a quantidade de dias VIP...
Ex: ${prefix+command} 30
Ou
Ex: ${prefix+command} 30/puxadas`)
if(q.includes('.')) return reply("Não serão aceitos números decimais...")
var [a, b] = q.split("/")
isPux = b && (b.toLowerCase() === `puxadas` || b.toLowerCase() === `consultas` || b.toLowerCase() === `vip`) ? true : false
let { key } = await blackmd.sendMessage(from, {text: `🎲 *_KEY GERADA COM SUCESSO_* 🎲`}, {quoted: info})
await sleep(1500)
gerarTypeKey(sender, {type: 3, grupo: from, mod: isPux, tempo: a})
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
await sleep(500)
blackmd.sendMessage(from, {text: `${chave}`, edit: key}, {quoted: info})
await sleep(500)
sendMess(from, `🎳 *_Descrição ⤵_*
〔🎯〕⥲ *Tipo:* "VIP"
〔⏱〕⥲ *Tempo:* ${Number(a) > 0 ? String(a) + ` dias` : `∞ INFINITO`}
〔🔎〕⥲ *Consultas:* ${isPux ? `sim ✔` : `não ✖`}`)
await sleep(500)
blackmd.sendMessage(from, {text: `Copie essa chave ou encaminhe ao privado do cliente ✔`}, {quoted: {
  key: {
    fromMe: false,
    participant: botNumber
  },
  message: {
    conversation: chave
  }
}})
}
break

case 'buyvipgp':
reagir(from, "🤑")
if(!q) return reply(`Coloque a quantidade de dias VIP...
Ex: ${prefix+command} 30
Ou
Ex: ${prefix+command} 30/puxadas`)
var [a, b] = q.split("/")
if(!Number(a) > 0) return reply("Apenas números positivos para setar o tempo pfvr")
if(a.includes('.')) return reply("Não serão aceitos números decimais...")
isPux = b && (b.toLowerCase() === `puxadas` || b.toLowerCase() === `consultas` || b.toLowerCase() === `vip`) ? true : false
nmr = ((isPux ? valoresVIP.vipgpcp : valoresVIP.vipgp) / 30).toFixed(2)
usu = getCoinsUsu(sender)
valor = nmr * Number(a)
if(usu.saldo < valor) return reply(`[❗] Não foi possível completar a compra da Key... ${a} dia${Number(a) !== 1 ? 's' : ''} de GROUP VIP "${isPux ? `com` : `sem`}" puxadas custar${Number(a) !== 1 ? 'ão' : 'á'} R$ ${(valor).toFixed(2)}, e você possui apenas R$ ${getSepCoins(sender)[2]} em sua conta... Use o comando ${prefix}recarga para adicionar moedas a sua conta e comprar as keys ⚠️`)
rmCoinsInVirtualBalance(sender, valor)
gerarTypeKey(sender, {type: 4, grupo: from, tempo: a, mod: isPux, valor: valor})
if(isGroup) reply(`Irei te enviar no PV 🧵`)
await sleep(1000)
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
sendButton(sender, {text: `💡 A chave "${chave}" foi gerada com sucesso... Copie e cole a mesma em seu grupo para validar o VIP neste chat e liberar o acesso aos comandos especiais do sistema para todos os membros presentes 😊`, footer: chave}, blackmd, sender, [{type: `copy_text`, text: `CLIQUE AQUI`, url: chave}], seloctt)
await sleep(1000)
sendMess(sender, `Lembrando que você pode doar essa key VIP para outra pessoa caso queira, basta enviar no PV dela... Pois se enviar no grupo o bot validará o VIP para o seu chat 🤩`)
break

case 'gerarkeyvipgp': {
if(!isOwner) return reply(enviar.msg.dono)
reagir(from, "🤑")
if(!q) return reply(`Coloque a quantidade de dias VIP...
Ex: ${prefix+command} 30
Ou
Ex: ${prefix+command} 30/puxadas`)
if(q.includes('.')) return reply("Não serão aceitos números decimais...")
var [a, b] = q.split("/")
isPux = b && (b.toLowerCase() === `puxadas` || b.toLowerCase() === `consultas` || b.toLowerCase() === `vip`) ? true : false
let { key } = await blackmd.sendMessage(from, {text: `🎲 *_KEY GERADA COM SUCESSO_* 🎲`}, {quoted: info})
await sleep(1500)
gerarTypeKey(sender, {type: 4, grupo: from, mod: isPux, tempo: a})
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
await sleep(500)
blackmd.sendMessage(from, {text: `${chave}`, edit: key}, {quoted: info})
await sleep(500)
sendMess(from, `🎳 *_Descrição ⤵_*
〔🎯〕⥲ *Tipo:* "GROUP VIP"
〔⏱〕⥲ *Tempo:* ${Number(a) > 0 ? a : `∞ INFINITO`}
〔🔎〕⥲ *Consultas:* ${isPux ? `sim ✔` : `não ✖`}`)
await sleep(500)
blackmd.sendMessage(from, {text: `Copie essa chave ou encaminhe ao privado do cliente ✔`}, {quoted: {
  key: {
    fromMe: false,
    participant: botNumber
  },
  message: {
    conversation: chave
  }
}})
}
break

case 'reembolsar':
if(!q) return reply(`KD a key que vc deseja reembolsar?`)
if(!existKeyRentSystem(q)) return reply("[❗] chave não encontrada ou inexistente ❌")
usu = getClientKey(q)
if(usu.cliente != sender) return reply("Espertinho ksksks mas essa key não é tua pra tu pegar reembolso nela")
nmr = usu.valor
tipo = usu.tipo
rmTypeKey(q)
if(tipo != 2) { addCoinsInVirtualBalance(sender, nmr)
reply(`💠 Saldo reembolsado em sua conta da Black System no valor de R$ ${Number(nmr).toFixed(2)} (Key deletada) 🤭`)
} else { getCoinsUsu(sender).cortesia += 1
saveCoins()
reply(`💠 *CARD CORTESIA* restaurado (Key deletada) 🤭`) }
break

case 'rmkey':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`KD a key que vc deseja apagar?`)
if(!existKeyRentSystem(q)) return reply("[❗] chave não encontrada ou inexistente ❌")
rmTypeKey(q)
reply(`✋🏽😳🤚🏽 A Key ${q} foi deletada do sistema com sucesso ✅`)
break

case 'resetkey':
if(!isOwner) return reply(enviar.msg.dono)
if(Number(q) !== 1) return reply(`Tem certeza disso? Esse comando irá deletar todas as keys presentes no sistema, independente de quais sejam... Se estiver certo disso, use ${prefix+command} 1`)
if(allKeysRentSystem.length <= 0) return reply(`Não há keys salvas no sistema`)
for(i of moedas) {
  if(i.keys.length > 0) {
    i.keys = []
    saveCoins()
  }
}
reply(`Todas as keys do sistema foram deletadas com sucesso ✔`)
await sleep(300)
console.log(colors.green(`Restart necessário para save de dados..`))
process.exit()
break

case 'donate':
case 'doar':
case 'apoiar':
if(!q || isNaN(q) || Number(q) <= 0) return reply(`Quer doar e ajudar meu dono? 😍
Retorne após o comando o valor que você deseja doar para o meu dono, ex: ${prefix+command} ${(alerandom(9) + 1) * 5}`)
nmr = Number(q)
if(isGroup) reply(`Vem PV 🥰`)
await sleep(1000)
GenerateQRpix(sender, {text: `Equipe Black System agradece 💞`, footer: `BLACK SYSTEM OFC`, pix: nmr, chave: `mathgames72331621@gmail.com`, type: `email`}, blackmd)
break

case 'pix':
setTimeout(() => {reagir(from, "🥹")}, 300)
sendRouletteButton(from, {image: {url: `https://blackstorage.store/midia/1735506461779.jpg`}, caption: `*Caso queira ajudar meu mestre com qualquer quantia... Aqui está o pix dele:* 🙇🏻‍♂️

*Chave ↴*`}, blackmd, sender, [{type: `copy_text`, text: `CHAVE EMAIL`, url: `blacksystemofc2025@gmail.com`}], seloctt)
break

case 'cobrar':
if(!isOwner) return reply(enviar.msg.dono)
if(!q.includes(`/`)) return reply(`Separe o número do usuário e o valor da cobrança...
Ex: ${prefix+command} ${addNumberMais(sender)}/5`)
var [cusu, cvalor] = q.split(`/`)
usu = identArroba(cusu)
if(isNaN(cvalor)) return reply(`Retorne um número válido... "${cvalor}" não é número.`)
nmr = Number(cvalor)
if(nmr <= 0) return reply(`A cobrança precisa ser maior ser maior que zero.`)
mention(`*_Enviando cobrança no PV do @${usu.split("@")[0]}..._* 💠`)
await sleep(700)
blackmd.sendMessage(usu, {text: `${Number(sendHours(`HH`)) >= 6 && Number(sendHours(`HH`)) < 12 ? `Buenos dias` : Number(sendHours(`HH`)) >= 12 && Number(sendHours(`HH`)) < 18 ? `Buenas tardes` : `Buenas noches`} @${usu.split("@")[0]}, te foi solicitado um pagamento vindo do @${sender.split("@")[0]} 💠`, mentions: [sender, usu]})
await sleep(1100)
GenerateQRpix(usu, {text: `PAGUE CALOTEIRO!!`, footer: `BLACK SYSTEM OFC`, pix: nmr, chave: `mathgames72331621@gmail.com`, type: `email`}, blackmd)
break

case 'criador':
ttgp = isGroup ? groupMembers.length * groupAdmins.length + somembros.length : 6
horar = moment.tz('America/Sao_Paulo').format('HH:mm')
datar = moment.tz('America/Sao_Paulo').format('DD/MM')
criador = `🤧 *Ah o meu criador é o luan, Ele foi quem desenvolveu esse sistema todo que você está usando* 🥰`
sendUrlDoc(from, criador, 'application/pdf', `${horar}H ┋ ${datar} 📆`, ttgp, NomeDoBot, ``, `https://telegra.ph/file/adad9b9a3606857e380be.jpg`, `https://wa.me/5585998603654`, seloctt)
break

case 'owner':
case 'odono':
case 'dono': 
case 'infodono':
reagir(from, "👑")
const { infodono } = require("./dono/info/infodono.js")
sendContact(from, NickDono, NomeDoBot, numerodono_ofc)
sendButton(from, {image: {url: logoslink.logo}, caption: infodono(tempo, tempo_emoji, sender, NickDono, nmrdn, NomeDoBot, prefix), mentions: [sender], footer: NomeDoBot}, blackmd, sender, [{type: `copy_url`, text: `CLIQUE AQUI`, url: `https://wa.me/`+nmrdn.split("@")[0]}], seloctt)
break

case 'configurar-bot':
if(!isOwner) return reply(`INDISPONÍVEL`)
blackmd.sendMessage(from, {text: configbot(prefix)}, {quoted: selo})
break

case 'comandos-termux':
blackmd.sendMessage(from, {text: cmd_termux(prefix)}, {quoted: selo})
break

case 'destrava':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isVip) return reply(`[ ❗ ] Precisa ser VIP e admin ❌`)
if(!isGroupAdmins) return reply(`Você ainda não é admin 🤪`)
blackmd.sendMessage(from, {text: destrava(prefix)}, {quoted: seloctt})
break

case 'getpp':
if(!isVip) return reply(enviar.msg.vip)
if(!menc_os2) return reply(`Marque o usuário que você quer puxar a foto de perfil, a mensagem ou o @`)
try { ppimg = await blackmd.profilePictureUrl(`${menc_os2.split('@')[0]}@c.us`, 'image')
} catch { return mention(`[❗] não foi possível pegar a foto de perfil do usuário @${menc_os2.split("@")[0]} ❌`) }
sendImage(from, ppimg, ``, seloblk)
break

case 'lerarquivo': case 'lerfile': {
  if(!isVip) return reply(enviar.msg.vip)
    if(!isQuotedDocument) return reply(`Marque um documento para que eu possa fazer a transcrição...`)
      let { key } = await blackmd.sendMessage(from, {text: `🔎 _Transcrevendo áudio... Aguarde_ 🔍`}, {quoted: info})
    await sleep(2000)
    try {
      media = isQuotedDocument ? info.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : info.message.documentMessage
      doc = await getFileBuffer(media, `document`)
      caminho = `./database/data/black.txt`
      fs.writeFileSync(caminho, doc)
      await sleep(700)
      txt = fs.readFileSync(caminho)
      await blackmd.sendMessage(from, {text: txt, edit: key}, {quoted: info})
      await sleep(600)
      return fs.unlinkSync(caminho)
    } catch(e) {
      console.log(e)
      await blackmd.sendMessage(from, {text: `[❗] Erro, não foi possível ler este arquivo enviado... ❌`, edit: key}, {quoted: info})
    }
  }
break
case 'perfil':
reagir(from, "😸")
usu = sender_ou_n
try {
  ppimg = await blackmd.profilePictureUrl(`${usu.split('@')[0]}@c.us`, 'image')
} catch {
  ppimg = semfoto
}
try {
  bio = (await blackmd.fetchStatus(usu)).status
} catch {
  bio = "🔒 Privada 🔒"
}
txt = `╓─━⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓━─┒
┢╕ㅤㅤㅤㅤㅤ📦 𝙂𝙀𝙍𝘼𝙇 📦
╽╟ • ɴᴏᴍᴇ: ${getname(usu)}
╽╟ • ɴúᴍᴇʀᴏ: wa.me/${usu.split("@")[0]}
╽╟ • ʙɪᴏ: ${bio}
╽╟ • ꜱᴀʟᴅᴏ: R$ `
if(isJsonIncludes(moedas, usu)) {
  A1 = moedas.map(a => a.id).indexOf(usu)
  txt += `${Number(moedas[A1].saldo).toFixed(2)}`
} else { txt += `00.00` }
txt += `
╽╟ ~>『 ${isAllOwner(usu) ? "✅" : "❌"} 』ᴅᴏɴᴏ
╽╟ ~>『 ${isAdmin(usu) ? "✅" : "❌"} 』ᴀᴅᴍ
╽╟ ~>『 ${isOnlyVip(usu) ? "✅" : "❌"} 』ᴠɪᴩ
╽╟ ~>『 ${isJsonIncludes(vipgp, from) ? "✅" : "❌"} 』ɢʀᴜᴩᴏ ᴠɪᴩ
┕╨⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋┚`

if(isGroup || isJsonIncludes(level, usu)) {
  txt += `\n\n╓─━═╾╼═╾╼═╾╼═╾╼═╾╼═╾╼═━─┒
┢╕ㅤㅤㅤ📊 𝘾𝙊𝙉𝙏𝘼𝘿𝙊𝙍𝙀𝙎 📊`
  if(isGroup) {
    B1 = countMessage.map(b => b.groupId).indexOf(from)
    B2 = countMessage[B1].participants.map(b => b.id).indexOf(usu)
    B3 = B2 >= 0 ? countMessage[B1].participants[B2] : ""
    txt += `
╽╟ • ❪🗒️ฺ࣭࣪͘ꕸ▸ ᴍᴇɴꜱᴀɢᴇɴꜱ: ${B2 >= 0 ? largeNumber(B3.mensagens) : "0"}
┢┸ • ❪🗄️ฺ࣭࣪͘ꕸ▸ ᴄᴏᴍᴀɴᴅᴏꜱ: ${B2 >= 0 ? largeNumber(B3.comandos) : "0"}
┢╕`
    }
    if(isJsonIncludes(level, usu)) {
    C1 = level.map(c => c.id).indexOf(usu)
    C2 = level[C1]
    C3 = level.map(i => i)
    C4 = C3.sort((a, b) => (a.contador < b.contador) ? 0 : -1)
    C5 = level.length > 10 ? 10 : level.length
    C6 = []
    for(i = 0; i < C5; i++) {
      if(i != null) {
        C6.push({id: C4[i].id})
      }
    }
    C7 = C6.map(c => c.id).indexOf(usu)
    txt += `
╽╟ • ❪📬ฺ࣭࣪͘ꕸ▸ ʟᴇᴠᴇʟ: ${C2.level}
╽╟ • ❪🗳️ฺ࣭࣪͘ꕸ▸ xᴩ: ${largeNumber(C2.contador)}
╽╟ • ❪💎ฺ࣭࣪͘ꕸ▸ ʀᴀɴᴋ: ${C7 >= 0 ? "Top " + (C7 + 1) : "\"não está no rank\""}
╽╟ • ❪📥ฺ࣭࣪͘ꕸ▸ ᴩᴀᴛᴇɴᴛᴇ: ${patente(C2.contador)}
┢┸ • ❪🚫ฺ࣭࣪͘ꕸ▸ ʙʟᴏqᴜᴇᴀᴅᴏ『 ${C2.block ? "✅" : "❌"} 』`
  }
  txt += `\n┕⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋┚`
}
if(isJsonIncludes(vip, usu)) {
  D1 = vip.map(d => d.id).indexOf(usu)
  D2 = vip[D1]
  txt += `\n\n╓─━═╾╼═╾╼═╾╼═╾╼═╾╼═╾╼═━─┒
┢╕ㅤㅤㅤㅤㅤㅤ💸 𝙑𝙄𝙋 💸`
  txt += !D2.infinito ? `
╽║ ${barrinha(((D2.dias - 1) * 24) + Number(sendHours("HH")), D2.total * 24)}
╽╟ • ❪🤑ฺ࣭࣪͘ꕸ▸ _${sendTimeDay(D2.dias)} restante${Number(sendTimeDay(D2.dias).slice(0, 2)) !== 1 ? "s" : ""}_` : `
╽║ 〘██████████〙100%
╽╟ • ❪🤑ฺ࣭࣪͘ꕸ▸ _∞ INFINITY_`
  txt += `\n┕╨⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋┚`
}
if(isJsonIncludes(cardxp, usu)) {
  E1 = cardxp.map(e => e.id).indexOf(usu)
  E2 = cardxp[E1]
  txt += `\n\n╓─━═╾╼═╾╼═╾╼═╾╼═╾╼═╾╼═━─┒
┢╕ㅤㅤㅤㅤㅤ🔖 𝘾𝘼𝙍𝘿 𝙓𝙋 🔖
╽╟ • 💾⃤ ᴛᴏᴛᴀʟ: ${E2.cards.length}
╽║ `
  txt += E2.active ? `
╽╟ • ❪📼ฺ࣭࣪͘ꕸ▸ ᴍᴜʟᴛɪᴩʟɪᴄᴀᴅᴏʀ: ${E2.cards[E2.mapa].multi}x
╽╟ • ❪📆ฺ࣭࣪͘ꕸ▸ ᴛᴇᴍᴩᴏ: _${sendTimeHours(E2.tempo)} restante${Number(E2.tempo) !== 1 ? "s" : ""}_
╽║ ${barrinha(E2.tempo, E2.cards[E2.mapa].horas)}` : `❌ ᴄᴀʀᴅ ɴãᴏ ᴀᴛɪᴠᴀᴅᴏ ❌`
  txt += `\n┕╨⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋┚`
}
sendUrlText(from, txt, `😜 𝙋𝙀𝙍𝙁𝙄𝙇 🤪`, ``, ppimg, `https://wa.me/`+usu.split("@")[0], seloctt)
break

case 'perfil2':
reagir(from, "🤭")
//foto de perfil
try {
ppimg = await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image')
} catch {
ppimg = semfoto
}
try {
var conselho = palavrasc[Math.floor(Math.random() * palavrasc.length)]
//bio do usuário
try {
bioperfil = (await blackmd.fetchStatus(sender)).status
} catch {
bioperfil = "🔒 Privada 🔒"
}
const dptr = `ㅤㅤ〘 ՏᎬႮ ᏢᎬᎡҒᏆᏞ 〙
⏤͟͟͞͞ ꦿ𝙽𝚘𝚖𝚎 *↴*
⇒ ${pushname}

⏤͟͟͞͞ ꦿ𝚆𝚑𝚊𝚝𝚜𝚊𝚙𝚙 *↴*
⇒ wa.me/${sender.split("@")[0]}

⏤͟͟͞͞ ꦿ𝙱𝚒𝚘 *↴*
⇒ ${bioperfil}

🐂⃤ 𝙽í𝚟𝚎𝚕 𝙶𝚊𝚍𝚘『 ${Math.floor(Math.random()*100)}% 』
📱⃤ 𝚂𝚎𝚞 𝙲𝚎𝚕𝚞𝚕𝚊𝚛『 ${info.key.id.length > 21 ? 'Android  🤣' : info.key.id.substring(0, 2) == '3A' ? 'IOS 😂😂😅' : 'Zap zap web  😂😂☝🏼😅'} 』
😈⃤ 𝙽í𝚟𝚎𝚕 𝙿𝚞𝚝𝚊『 ${Math.floor(Math.random()*100)}% 』
🥵⃤ 𝙽í𝚟𝚎𝚕 𝙳𝚎 𝙶𝚘𝚜𝚝𝚘𝚜𝚞𝚛𝚊『 ${Math.floor(Math.random()*100)}% 』
🍼⃤ 𝙿𝚛𝚘𝚐𝚛𝚊𝚖𝚊『 R$ ${Math.floor(Math.random()*9999)} 』


ㅤㅤ〘 ᏟϴΝՏᎬᏞᎻϴ 〙
${conselho}

_${tempo}_ ${tempo_emoji}
`
blackmd.sendMessage(from, {audio: {url:'./database/audios/criatura.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: seloctt})
await sleep(1000)
blackmd.sendMessage(from, {image: {url: ppimg}, caption: dptr}, {quoted: seloctt})
} catch (e) {
console.log(e)
}
break

case 'conselhobiblico':
case 'conselhosbiblico':  
case 'conselhosb':   
case 'conselhob':
case 'conselhos':
case 'conselho':
setTimeout(() => {reagir(from, "🥰")}, 300)
var conselhosb = conselhob[Math.floor(Math.random() * conselhob.length)]   
jr = `Oiê, ${tempo} ${pushname} ! ^-^

🍁𝑪𝒐𝒏𝒔𝒆𝒍𝒉𝒐𝒔 𝑩𝒊́𝒃𝒍𝒊𝒄𝒐𝒔 𝒑𝒓𝒂 𝒗𝒐𝒄𝒆̂ 🍁

- ${conselhosb} 

⏤͟͟͞͞ ꦿBot⧽ ${NomeDoBot}
⏤͟͟͞͞ ꦿGrupo⧽ ${groupName}`
blackmd.sendMessage(from, {text: jr}, {quoted:info, contextInfo: {"mentionedJid": jr}})
break

case 'frases':
case 'frase':
setTimeout(() => {reagir(from, tempo_emoji)}, 300)
frases_ = palavrasc[Math.floor(Math.random() * palavrasc.length)]
reply(`${frases_}

⏤͟͟͞͞ ꦿ${NomeDoBot}
_${tempo}_ ${tempo_emoji}`)
break

case 'tabela':
blackmd.sendMessage(from, {text: tabela(prefix, NomeDoBot)}, {quoted: selo})
break 


case 'destrava2':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isVip) return reply(`[ ❗ ] Precisa ser VIP e admin ❌`)
if(!isGroupAdmins) return reply(`Você ainda não é admin 🤪`)
blackmd.sendMessage(from, {text: destrava2 (prefix)}, {quoted: seloctt})
break 

case 'infobemvindo':
case 'infobv':  
blackmd.sendMessage(from, {text: infobemvindo(prefix, pushname)}, {quoted: selo})
break

case 'idiomas':
case 'idioma':
case 'infogtts':
txt = `  
IDIOMAS DO GTTS OU DO TRADUTOR

EXEMPLO :

>> ${prefix}gtts pt (texto)

o PT que coloquei, é a linguagem, então pode por no lugar as 2 letras que define a linguagem, iguais os exemplos e os idiomas abaixo.

'af': 'Afrikaans',
'sq': 'Albanian',
'ar': 'Arabic',
'hy': 'Armenian',
'ca': 'Catalan',
'hr': 'Croatian',
'cs': 'Czech',
'da': 'Danish',
'nl': 'Dutch',
'en': 'English',
'eo': 'Esperanto',
'fi': 'Finnish',
'fr': 'French',
'de': 'German',
'el': 'Greek',
'ht': 'Haitian Creole',
'hi': 'Hindi',
'hu': 'Hungarian',
'is': 'Icelandic',
'id': 'Indonesian',
'it': 'Italian',
'ja': 'Japanese',
'ko': 'Korean',
'la': 'Latin',
'lv': 'Latvian',
'mk': 'Macedonian',
'no': 'Norwegian',
'pl': 'Polish',
'pt': 'Portugues',
'ro': 'Romanian',
'ru': 'Russian',
'sr': 'Serbian',
'sk': 'Slovak',
'es': 'Spanish',
'sw': 'Swahili',
'sv': 'Swedish',
'ta': 'Tamil',
'th': 'Thai',
'tr': 'Turkish',
'vi': 'Vietnamese',
'cy': 'Welsh'
 
🔥${NomeDoBot}🔥`

blackmd.sendMessage(from, {text: txt}, {quoted: selo})
break

case 'infocontador':
case 'infobanghost':  
blackmd.sendMessage(from, {text: infocontador(prefix, pushname)}, {quoted: selo})
break

case 'infolistanegra':
blackmd.sendMessage(from, {text: infolistanegra(prefix, pushname)}, {quoted: selo})
break

case 'inforgaluguel':
blackmd.sendMessage(from, {text: infoaluguel(prefix, pushname)}, {quoted: selo})
break

case 'infotransmitir':
blackmd.sendMessage(from, {text: infotransmitir(prefix, pushname)}, {quoted: selo})
break

case 'infopalavrão':
case 'infopalavrao':
blackmd.sendMessage(from, {text: infopalavrao(prefix, pushname)}, {quoted: selo})
break

case 'infobancarac':
blackmd.sendMessage(from, {text: infobancarac(prefix, pushname)}, {quoted: selo})
break

case 'git':
case 'git-bot':  
case 'gitdobot':
case 'gitbot':
reply(`🌐 *Git disponível no site:*
https://github.com/m4thxyz/blackofc`)
break

//========(FUNÇÕES-PREMIUM-AQUI)=======\\

case 'ler':
case 'ocr':
case 'lerfoto':
if(!isVip) return reply(enviar.msg.vip)
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) {
encmedia = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'image')
fs.writeFileSync(rane, buffimg)
media = rane 
reply(enviar.espere)
await recognize(media, {lang: 'eng+ind', oem: 1, psm: 3})
.then(teks => {
reply(teks.trim())
DLT_FL(media)
})
.catch(err => {
reply(err.message)
DLT_FL(media)
})
} else {
reply('Somente fotos!')
}
break
case 'revelar':
case 'rvisu':
case 'revelarvisu':
if(!isVip) return reply(enviar.msg.vip)
if(!isQuotedVisuU || !isQuotedVisuU2) return reply(`marque uma foto/video em visualização unica`)
try{
reagir(from, "👁️")
if(JSON.stringify(info).includes("videoMessage")) {
var vio = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var viewImage = vio?.imageMessage || info.message?.imageMessage || vio?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || vio?.viewOnceMessage?.message?.imageMessage
var viewVideo = vio?.videoMessage || info.message?.videoMessage || vio?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || vio?.viewOnceMessage?.message?.videoMessage
viewVideo.viewOnce = false
viewVideo.video = {url: viewVideo.url}
viewVideo.caption += "\n\n👁️ *REVELANDO ONE VISION* 👁️"
blackmd.sendMessage(from, viewVideo, {quoted: info})
} else if(JSON.stringify(info).includes("imageMessage")) {
var vio = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var viewImage = vio?.imageMessage || info.message?.imageMessage || vio?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || vio?.viewOnceMessage?.message?.imageMessage
var viewVideo = vio?.videoMessage || info.message?.videoMessage || vio?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || vio?.viewOnceMessage?.message?.videoMessage
viewImage.viewOnce = false
viewImage.image = {url: viewImage.url}
viewImage.caption += "\n\n👁️ *REVELANDO ONE VISION* 👁️"
blackmd.sendMessage(from, viewImage, {quoted: info})
} else if(info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.viewOnceMessageV2Extension?.message?.audioMessage) {
var viewAudio = info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.viewOnceMessageV2Extension?.message?.audioMessage
viewAudio.viewOnce = false
viewAudio.ptt = true
media = await getFileBuffer(viewAudio, `audio`)
blackmd.sendMessage(from, {audio: media}, {quoted: info})
}
} catch(e){
console.log(e)
reply(`Erro`)
}
break

case 'listavip':
reagir(from, "💎")
if(!isVip) { reply(enviar.msg.vip)
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
caixa = []
for(v of vip) {
  caixa.push({mapa: vip.map(i => i.id).indexOf(v.id) + 1, id: v.id, dias: v.dias, infinito: v.infinito, advenced: v.advenced})
}
total = caixa.length
if(isGroup && isJsonIncludes(vipgp, from)) {
  AB = vipgp.map(i => i.id).indexOf(from)
  vg = vipgp[AB]
  for(g of groupMembers) {
    if(!isJsonIncludes(vip, g.id)) caixa.push({mapa: groupMembers.map(i => i.id).indexOf(g.id) + 1 + total, id: g.id, dias: vg.dias, infinito: vg.infinito, advenced: vg.advenced})
  }
}
if(caixa.length <= 0) return reply(`Não há usuários VIP salvos na pasta do bot...`)
txt = `『 🤑 *ALTA REALEZA* 🤑 』
${caixa.map(c =>
`»${c.mapa}«
👤 *Usuário:* @${c.id.split("@")[0]}
⏳ *Tempo:* ${c.infinito ? `∞ *INFINITY [ VIP ]*` : sendTimeDay(c.dias)}
👨🏻‍💻 *Consultas (${c.advenced ? `✅` : `❌`})*`).join(`\n\n`)}`
txt += `\n\nㅤ *TOTAL〘* ${caixa.length} *〙*\n\n⏤͟͟͞͞ ꦿ${tempo} ${tempo_emoji}`
mencionarIMG(txt, `https://files.catbox.moe/pcg8iv.jpg`)
break

case 'listavipgp': case 'listagpvip':
reagir(from, "💎")
if(!isVip) return reply(enviar.msg.vip)
if(vipgp.length <= 0) return reply(`Não há grupos vips salvos na pasta 💁🏻‍♂️`)
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
onlygpsvip = []
for(i of allGroups) {
  if(isJsonIncludes(vipgp, i.id)) {
    AB = vipgp.map(b => b.id).indexOf(i.id)
    onlygpsvip.push({id: i.id, nome: i.subject, dias: vipgp[AB].dias, infinito: vipgp[AB].infinito, advenced: vipgp[AB].advenced})
  }
}
txt = `『 🤑 *ALL GROUPS VIP* 🤑 』
${onlygpsvip.map(c =>
`»${onlygpsvip.map(d => d.id).indexOf(c.id) + 1}«
👥 *Grupo:* ${c.nome}
⏳ *Tempo:* ${c.infinito ? `∞ *INFINITY [ VIP ]*` : sendTimeDay(c.dias)}
👨🏻‍💻 *Consultas (${c.advenced ? `✅` : `❌`})*`).join(`\n\n`)}`
txt += `\n\nㅤ *TOTAL〘* ${onlygpsvip.length} *〙*\n\n⏤͟͟͞͞ ꦿ${tempo} ${tempo_emoji}`
mencionarIMG(txt, `https://i.imgur.com/Mk2k4uD.jpeg`)
break

case 'metodos':
if(!isVip) return reply(enviar.msg.vip)
const { metodos } = require('./armor/js/metodos.js');
tipo = q
if(tipo.toLowerCase().startsWith("desban")) {
  dbn = q.split('desban')[1]
  if(Number(dbn) > 0 && Number(dbn) <= metodos.desban.length && !dbn.includes('.')) {
    txt = metodos.desban[Number(dbn)-1]
  } else return reply(`Escolha um número de 1-${metodos.desban.length}, ex:\n${prefix+command} desban 2`)
} else if(tipo.toLowerCase().startsWith("sair do -1")) {
  sd1 = q.split('sair do -1')[1]
  if(Number(sd1) > 0 && Number(sd1) <= metodos.sairdomenos1.length && !sd1.includes('.')) {
    txt = metodos.sairdomenos1[Number(sd1)-1]
  } else return reply(`Escolha um número de 1-${metodos.sairdomenos1.length}, ex:\n${prefix+command} sair do -1 2`)
} else if(tipo.toLowerCase().replace("ú", "u").startsWith("desativar numero")) {
  dn = q.replace("ú", "u").split('desativar numero')[1]
  if(Number(dn) > 0 && Number(dn) <= metodos.desativarnumero.length && !dn.includes('.')) {
    txt = metodos.desativarnumero[Number(dn)-1]
  } else return reply(`Escolha um número de 1-${metodos.desativarnumero.length}, ex:\n${prefix+command} desativar número 2`)
} else return reply(`Vc precisa escolher o método:
> ${prefix+command} desban
> ${prefix+command} sair do -1
> ${prefix+command} desativar número`)
reply(txt+`\n\n〘 Lady 👑 bot 〙`)
break

case 'getquoted':
case 'getinfo':  
case 'get':  
reply(JSON.stringify(info.message.extendedTextMessage.contextInfo, null, 3))
break

case 'get-txt':  
reply(JSON.stringify(info.message.extendedTextMessage.contextInfo.quotedMessage.conversation, null, 2))
break

case 'netflix': case 'globoplay': case 'amazonprime': case 'telecine': case 'canvas': case 'hbo': case 'starsplus': case 'sportify':
if(!isJsonIncludes(moedas, sender)) return reply(`Você não possui saldo... Veja ${prefix}me`)
account = `./database/contas/${command}.json`
if(!fs.existsSync(account)) return reply("Banco de dados dessa conta não foi encontrado... Pfvr, chame meu dono para resolver.")
acc = JSON.parse(fs.readFileSync(account))
if(acc.length <= 0) return reply("Nenhuma conta em estoque no momento... Pfvr, volte mais tarde")
if(command == 'netflix') valor = 10
if(command == 'globoplay') valor = 15
if(command == 'amazonprime') valor = 10
if(command == 'telecine') valor = 20
if(command == 'canvas') valor = 5
if(command == 'hbo') valor = 10
if(command == 'starsplus') valor = 5
if(command == 'sportify') valor = 5
AB = moedas.map(i => i.id).indexOf(sender)
if(moedas[AB].saldo < valor) return reply(`Esta ação lhe custaria R$ ${valor.toFixed(2)}, mas o seu saldo se encontra abaixo disso... Faça uma recarga no comando ${prefix}recarga`)
moedas[AB].saldo -= valor
saveJSON(moedas, `./basedefuncionamento/aluguel/moedas.json`)
BC = alerandom(acc.length)
txt = `ㅤㅤㅤㅤㅤㅤ🌟 ${command.toUpperCase()} 🌟

✉️ *Login:* ${acc[BC].login}
🔑 *Senha:* ${acc[BC].senha}

_Conta debitada no valor de R$ ${valor.toFixed(2)}... Nossa equipe agradece a confiança em nossos serviços_ 🥰`
if(isGroup) { reply(`*Enviando* 🥰`) }
await sleep(1000)
sendMess(sender, txt)
acc.splice(BC, 1)
saveJSON(acc, account)
break

case 'add-netflix': case 'add-globoplay': case 'add-amazonprime': case 'add-telecine': case 'add-canvas': case 'add-hbo': case 'add-starsplus': case 'add-sportify':
if(!isOwner) return reply(`Só meu dono`)
conta = command.split("add-")[1]
account = `./database/contas/${conta}.json`
if(!fs.existsSync(account)) return reply("JSON não encontrado para armazenar os dados... Verifica isso aí")
barra = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/")
var [continha, password] = barra.split("/")
if(!continha || !password) return reply(`Separe após o comando, o login e senha com uma barra ( / ), ex:
${prefix+command} teupaidecalinha@gmail.com/12345`)
acc = JSON.parse(fs.readFileSync(account))
if(isJsonIncludes(acc, continha)) return reply("Conta já existente no banco de dados 📂")
acc.push({login: continha, senha: password})
saveJSON(acc, account)
reply(`Conta ${conta.toUpperCase()} adicionada com sucesso ✅`)
break

case 'rm-netflix': case 'rm-globoplay': case 'rm-amazonprime': case 'rm-telecine': case 'rm-canvas': case 'rm-hbo': case 'rm-starsplus': case 'rm-sportify':
if(!isOwner) return reply(`Só meu dono`)
conta = command.split("rm-")[1]
account = `./database/contas/${conta}.json`
if(!fs.existsSync(account)) return reply("JSON não encontrado para armazenar os dados... Verifica isso aí")
if(!q) return reply(`Retorne o email da conta ou o número dela presente no comando ${prefix+"lista-"+conta} para deletar 🗑️`)
acc = JSON.parse(fs.readFileSync(account))
try {
loc = Number(q) ? Number(q) - 1 : acc.map(i => i.login).indexOf(q)
reply(`Conta ${acc[loc].login} deletada com sucesso ✅`)
acc.splice(loc, 1)
return saveJSON(acc, account)
} catch { return reply("Conta não existente no banco de dados 📂") }
break

case 'lista-netflix': case 'lista-globoplay': case 'lista-amazonprime': case 'lista-telecine': case 'lista-canvas': case 'lista-hbo': case 'lista-starsplus': case 'lista-sportify':
if(!isOwner) return reply(`Só meu dono`)
conta = command.split("lista-")[1]
account = `./database/contas/${conta}.json`
acc = JSON.parse(fs.readFileSync(account))
if(!fs.existsSync(account)) return reply("JSON não encontrado para armazenar os dados... Verifica isso aí")
txt = `🌟 *Lista de contas ${conta.toUpperCase()}:*`
for(i = 0; i < acc.length; i++) {
  txt += `\n\n[ ${i+1} ]\n*Login:* ${acc[i].login}\n*Senha:* ${acc[i].senha}`
}
txt += `\n\n📜 *Total:* ${acc.length}`
reply(txt)
break

case 'disney':
if(!isVip) return reply(enviar.msg.vip)
disney = JSON.parse(fs.readFileSync("./database/disney.json"))
moon = disney[Math.floor(Math.random() * disney.length)]
blackmd.sendMessage(from, {image: {url: 'https://telegra.ph/file/9cb91bf0953c17ca4268a.jpg'}, caption: `
> Lembre-se: teste a conta para ver se tem acesso ou não, algumas contas não tem mais acesso válido, boa sorte.

> Login: ${moon.login}

> Senha: ${moon.senha}`}, {quoted: info})
break

case 'gerarcpf':
if(!isVip) return reply(enviar.msg.vip)
cp1 = `${Math.floor(Math.random() * 300) + 600}`
cp2 = `${Math.floor(Math.random() * 300) + 600}`
cp3 = `${Math.floor(Math.random() * 300) + 600}`
cp4 = `${Math.floor(Math.random() * 30) + 60}`
cpf = `${cp1}.${cp2}.${cp3}-${cp4}`
blackmd.sendMessage(from, {text: `𝐂𝐏𝐅 𝐆𝐄𝐑𝐀𝐃𝐎 𝐂𝐎𝐌『 𝐒𝐔𝐂𝐄𝐒𝐒𝐎 』💻\n\n${cpf}`}, {quoted: seloctt})
break

case 'gerarcartao':
    if (!q) {
        return blackmd.sendMessage(from, { text: '[⚙️] Por favor, envie o tipo de cartão que deseja gerar. Exemplo: .gerarcartao Visa' }, { quoted: info });
    }

    const tipoCartao = encodeURIComponent(q);
    const apiCartao = `https://api.ownblox.biz.id/api/vcc?type=${tipoCartao}&count=5`;

    try {
        const responseCartao = await axios.get(apiCartao);

        if (Array.isArray(responseCartao.data)) {
            let listaCartoes = '💳 Cartões gerados:\n\n';
            responseCartao.data.forEach((cartao, index) => {
                listaCartoes += `🆔 Cartão ${index + 1}:\n`;
                listaCartoes += `• Nome: ${cartao.name}\n`;
                listaCartoes += `• Número: ${cartao.number}\n`;
                listaCartoes += `• CVV: ${cartao.cvv}\n`;
                listaCartoes += `• Validade: ${cartao.expiry}\n\n`;
            });

            blackmd.sendMessage(from, { text: listaCartoes.trim() }, { quoted: info });
        } else if (responseCartao.data.error) {
            blackmd.sendMessage(from, { text: `🚨 Erro: ${responseCartao.data.error}` }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não consegui gerar os cartões.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao gerar cartões:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao tentar gerar cartões.' }, { quoted: info });
    }
    break;


case 'listafake': case 'listafakes':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
reagir(from, "🇺🇸")
txt = `🇺🇸 *Lista de números fake presentes neste grupo:*\n`
let totalfake = 0
for(i = 0; i < groupMembers.length; i++) {
  if(groupMembers[i].id.split(groupMembers[i].id.slice(2))[0] === ("55")) {} else {
    txt += `⇒ ${isGroupAdmins ? '@' : 'wa.me/'}${groupMembers[i].id.split("@")[0]}\n`
    totalfake += 1
  }
}
txt += `\n🇺🇸 Total: ${totalfake}`
if(totalfake > 0) {
  var resp = isGroupAdmins ? mention : reply
  resp(txt)
} else {
  reply("Não há números fake neste grupo...")
}
break

case 'brlist': case 'listabr':
if(!isGroup) return reply(enviar.msg.grupo)
reagir(from, "🇧🇷")
txt = `🇧🇷 *Lista de números brasileiros presentes neste grupo:*\n`
let totalbr = 0
for(i = 0; i < groupMembers.length; i++) {
  if(groupMembers[i].id.split(groupMembers[i].id.slice(2))[0] === ("55")) {
    if(groupMembers[i].id.includes(botNumber)) {} else {
      txt += `⇒ ${isGroupAdmins ? '@' : 'wa.me/'}${groupMembers[i].id.split("@")[0]}\n`
      totalbr += 1
    }
  }
}
txt += `\n🇧🇷 Total: ${totalbr}`
if(totalbr > 0) {
  var resp = isGroupAdmins ? mention : reply
  resp(txt)
} else {
  reply("Não há números brasileiros neste grupo...")
}
break

case 'dddlist': case 'listaddd':
if(!isGroup) return reply(enviar.msg.grupo)
if(!q) return reply(`Use ${prefix+command} DDD`)
if(!Number(args[0])) return reply(`${args[0]} não é número...`)
if(Number(args[0]) < 10 || Number(args[0]) > 99) return reply("Retorne um DDD válido")
reagir(from, "🇧🇷")
txt = `🇧🇷 *Lista de números brasileiros com DDD +${args[0]} presentes neste grupo:*\n`
let totalddd = 0
for(i = 0; i < groupMembers.length; i++) {
  if(groupMembers[i].id.split(groupMembers[i].id.slice(4))[0] === (`55${args[0]}`)) {
    if(groupMembers[i].id.includes(botNumber)) {} else {
      txt += `⇒ ${isGroupAdmins ? '@' : 'wa.me/'}${groupMembers[i].id.split("@")[0]}\n`
      totalddd += 1
    }
  }
}
txt += `\n🇧🇷 Total: ${totalddd}`
if(totalddd > 0) {
  var resp = isGroupAdmins ? mention : reply
  resp(txt)
} else {
  reply(`Não há números com o DDD +${args[0]} neste grupo...`)
}
break

case 'gerarnmr':
if(!isVip) return reply(enviar.msg.vip)
if(args.length < 1) return reply(`*Digite o DDD para gerar...*\n*Exemplo:* ${prefix + command} 91`)
nmrale1 = `${Math.floor(Math.random() * 3) + 6}`
nmrale2 = `${Math.floor(Math.random() * 3) + 6}`
nmrale3 = `${Math.floor(Math.random() * 3) + 6}`
nmrale4 = `${Math.floor(Math.random() * 3) + 6}`
nmrale5 = `${Math.floor(Math.random() * 3) + 6}`
nmrale6 = `${Math.floor(Math.random() * 3) + 6}`
nmrale7 = `${Math.floor(Math.random() * 3) + 6}`
nmrale8 = `${Math.floor(Math.random() * 3) + 6}`
nmrale = `${nmrale1+nmrale2+nmrale3+nmrale4+nmrale5+nmrale6+nmrale7+nmrale8}`
blackmd.sendMessage(from, {text: `*Gerando número de tell com o DDD* ${q}⧽

⇒ ${q}9${nmrale}
wa.me/55${q+nmrale}`}, {quoted: seloctt})
break

case 'encurtalink':
if(!isVip) return reply(enviar.msg.vip)
if(!q) return reply(`Ex: ${prefix+command} ${site}`)
try {
link = q
anu = await axios.get(`https://tinyurl.com/api-create.php?url=${link}`)
reply(`${anu.data}`)
} catch (e) {
emror = String(e)
reply(`${e}`)
}
break
case 'tinyurl':
case 'linkcurto': {
  if (!text) return reply(`*❗ Informe uma URL para encurtar!*`);

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tinyurl?url=${encodeURIComponent(text)}`);
    
    if (data.status !== 200 || !data.result) {
      return reply(`*❗ Erro ao encurtar o link.*`);
    }

    await sock.sendMessage(from, {
      text: `*🔗 Link encurtado com sucesso!*\n\n*Original:* ${text}\n*Encurtado:* ${data.result}`,
      mentions: [sender]
    }, { quoted: msg });

    reaction(msg, '✅');
  } catch (e) {
    console.error(e);
    reply(`*❗ Erro ao encurtar o link.*`);
    reaction(msg, '❌');
  }
  break;
}
case 'adfoc':
  if (!q) return reply('Me envie o link que deseja encurtar.')

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/shortlink/adfoc?url=${encodeURIComponent(q)}`)

    if (data?.status === 200 && data?.result) {
      reply(`Link encurtado com sucesso:\n${data.result}`)
    } else {
      reply('Não foi possível encurtar o link.')
    }
  } catch (err) {
    console.log(err)
    reply('Erro ao encurtar o link.')
  }
  break
  case 'bitly':
  if (!q) return reply('Me envie o link que deseja encurtar.')

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/shortlink/bitly?url=${encodeURIComponent(q)}`)

    if (data?.status === 200 && data?.result) {
      reply(`Link encurtado com sucesso:\n${data.result}`)
    } else {
      reply('Não foi possível encurtar o link.')
    }
  } catch (err) {
    console.log(err)
    reply('Erro ao encurtar o link.')
  }
  break
  case 'ouo':
  if (!q) return reply('Me envie o link que deseja encurtar.')

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/shortlink/ouo?url=${encodeURIComponent(q)}`)

    if (data?.status === 200 && data?.result) {
      reply(`Link encurtado com sucesso:\n${data.result}`)
    } else {
      reply('Não foi possível encurtar o link.')
    }
  } catch (err) {
    console.log(err)
    reply('Erro ao encurtar o link.')
  }
  break
  case 'cleanuri':
  if (!q) return reply('Me envie o link que deseja encurtar.')

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/shortlink/cleanuri?url=${encodeURIComponent(q)}`)

    if (data?.status === 200 && data?.result) {
      reply(`Link encurtado com sucesso:\n${data.result}`)
    } else {
      reply('Não foi possível encurtar o link.')
    }
  } catch (err) {
    console.log(err)
    reply('Erro ao encurtar o link.')
  }
  break
case 'ssurl':
  if (!q) return reply('Me envie o link que deseja encurtar.')

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/shortlink/ssur?url=${encodeURIComponent(q)}`)

    if (data?.status === 200 && data?.result) {
      reply(`Link encurtado com sucesso:\n${data.result}`)
    } else {
      reply('Não foi possível encurtar o link.')
    }
  } catch (err) {
    console.log(err)
    reply('Erro ao encurtar o link.')
  }
  break
case 'shortlink':
  if (!q) return reply('Me envie o link que deseja encurtar.')

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/shortlink/vurl?url=${encodeURIComponent(q)}`)

    if (data?.status !== 200 || !data?.result) {
      return reply('Não foi possível encurtar o link.')
    }

    reply(`Link encurtado com sucesso:\n${data.result}`)
  } catch (err) {
    console.log(err)
    reply('Erro ao encurtar o link.')
  }
  break
  
// CONSULTAS
//consultas by world ecletix & lady-botv4 
case 'telefone':
case "numero": {
    if (!q) {
        return reply("Você precisa fornecer um número para consultar.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/numero?q=${encodeURIComponent(q)}`);

        // Caso retorne que não foi encontrado
        if (Array.isArray(data) && data[0]?.includes("NÃO ENCONTRADO")) {
            return reply("⚠️ Telefone não encontrado.");
        }

        // Função para extrair valores do array
        const extrair = (chave) => {
            const item = data.find(x => x.startsWith(chave));
            return item ? item.replace(chave, "").trim() : "Não informado";
        };

        const telefone = extrair("• TELEFONE:");
        const nome = extrair("• NOME:");
        const cpf = extrair("• CPF/CNPJ:");
        const logradouro = extrair("• LOGRADOURO:");
        const numero = extrair("• NÚMERO:");
        const complemento = extrair("• COMPLEMENTO:");
        const bairro = extrair("• BAIRRO:");
        const cidade = extrair("• CIDADE:");
        const estado = extrair("• ESTADO:");
        const cep = extrair("• CEP:");

        let resposta =
            `🔍 *CONSULTA DE TELEFONE* 🔍\n` +
            `• Telefone: ${telefone}\n` +
            `• Nome: ${nome}\n` +
            `• CPF/CNPJ: ${cpf}\n` +
            `• Endereço: ${logradouro}, ${numero}\n` +
            `• Complemento: ${complemento}\n` +
            `• Bairro: ${bairro}\n` +
            `• Cidade/Estado: ${cidade} - ${estado}\n` +
            `• CEP: ${cep}\n\n` +
            `• Usuário: ${pushname}\n` +
            `• Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro ao consultar telefone:", err);
        reply("Erro ao consultar o telefone. Tente novamente mais tarde.");
    }
}
break;
case "nome2": {
    if (!q) {
        return reply("Você precisa fornecer um nome completo para consulta.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/nome-completo?q=${encodeURIComponent(q)}`);

        // Verifica se a resposta contém mensagem de erro
        if (Array.isArray(data) && data[0]?.includes("NOME NÃO ENCONTRADO")) {
            return reply(data[0]); // Retorna a mensagem de erro da API
        }

        // Verifica se a resposta é válida e completa
        if (!Array.isArray(data) || data.length < 6) {
            return reply("Não consegui obter os resultados, tente novamente mais tarde.");
        }

        const resultado = {
            resultado: data[1]?.replace("• RESULTADO: ", "") || "Desconhecido",
            nome: data[2]?.replace("• NOME: ", "") || "Desconhecido",
            cpf: data[3]?.replace("• CPF: ", "") || "Desconhecido",
            sexo: data[4]?.replace("• SEXO: ", "") || "Desconhecido",
            nascimento: data[5]?.replace("• NASCIMENTO: ", "") || "Desconhecido"
        };

        const message =
            `🔍 *CONSULTA DE NOME* 🔍\n` +
            `• Resultado: ${resultado.resultado}\n` +
            `• Nome: ${resultado.nome}\n` +
            `• CPF: ${resultado.cpf}\n` +
            `• Sexo: ${resultado.sexo}\n` +
            `• Nascimento: ${resultado.nascimento}\n` +
            `• Usuário: ${pushname}\n` +
            `• Bot: ${NomeDoBot}`;

        reply(message);

    } catch (error) {
        console.error("Erro ao processar a consulta de nome:", error);
        return reply("Ocorreu um erro ao consultar o nome. Por favor, tente novamente mais tarde.");
    }
} break;
case "nome3": {
    if (!q) {
        return reply("Você precisa fornecer um nome para consulta.");
    }

    try {
        const { data } = await axios.get(`https://api-bruxel4s.shop/api/consulta/nome?query=${encodeURIComponent(q)}`);

        const resultados = data.resultados;
        if (!Array.isArray(resultados) || resultados.length === 0) {
            return reply("Nenhum resultado encontrado para esse nome.");
        }

        const r = resultados[0];

        let resposta =
            `🧾 *CONSULTA POR NOME* 🧾\n\n` +
            `• Nome: ${r.nome || "Não informado"}\n` +
            `• CPF: ${r.cpf || "Não informado"}\n` +
            `• Nascimento: ${r.nascimento || "Não informado"}\n` +
            `• Sexo: ${r.sexo || "Não informado"}\n` +
            `• Pai: ${r.pai || "Não encontrado"}\n` +
            `• Mãe: ${r.mae || "Não encontrado"}\n\n` +
            `• Usuário: ${pushname}\n` +
            `• Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro na consulta nome6:", err);
        reply("Erro ao consultar o nome. Tente novamente mais tarde.");
    }
}
break;
case "email": {
    if (!q) {
        return reply("Você precisa fornecer um e-mail para consulta.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/email?q=${encodeURIComponent(q)}`);

        // Verifica se a resposta contém mensagem de erro
        if (Array.isArray(data) && (data[0]?.includes("NÃO ENCONTRADO"))) {
            return reply(data[0]); // Retorna diretamente a mensagem de erro da API
        }

        // Verifica se a resposta é válida e contém todos os dados esperados
        if (!Array.isArray(data) || data.length < 6) {
            return reply("Não consegui obter os resultados, tente novamente mais tarde.");
        }

        const resultado = {
            resultado: data[1]?.replace("• RESULTADO: ", "") || "Desconhecido",
            nome: data[2]?.replace("• NOME: ", "") || "Desconhecido",
            documento: data[3]?.replace("• CPF/CNPJ: ", "") || "Desconhecido",
            sexo: data[4]?.replace("• SEXO: ", "") || "Desconhecido",
            nascimento: data[5]?.replace("• NASCIMENTO: ", "") || "Desconhecido"
        };

        const message =
            `🔍 *CONSULTA DE E-MAIL* 🔍\n` +
            `• Resultado: ${resultado.resultado}\n` +
            `• Nome: ${resultado.nome}\n` +
            `• CPF/CNPJ: ${resultado.documento}\n` +
            `• Sexo: ${resultado.sexo}\n` +
            `• Nascimento: ${resultado.nascimento}\n` +
            `• Usuário: ${pushname}\n` +
            `• Bot: ${NomeDoBot}`;

        reply(message);

    } catch (error) {
        console.error("Erro ao processar a consulta de e-mail:", error);
        return reply("Ocorreu um erro ao consultar o e-mail. Por favor, tente novamente mais tarde.");
    }
} break;
case "cpf": {
    if (!q) {
        return reply("Você precisa fornecer um CPF para consulta.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/consultarcpf?cpf=${encodeURIComponent(q)}`);

        if (Array.isArray(data) && data[0]?.includes("CPF INVÁLIDO")) {
            return reply(data[0]);
        }

        const extrair = (chave) => {
            const item = data.find(x => x.startsWith(chave));
            return item ? item.replace(chave, "").trim() : "Não informado";
        };

        const nome = extrair("• NOME:");
        const cpf = extrair("• CPF:");
        const nascimento = extrair("• NASCIMENTO:");
        const idade = extrair("• IDADE:");
        const signo = extrair("• SIGNO:");
        const sexo = extrair("• SEXO:");
        const mae = extrair("• MÃE:");
        const pai = extrair("• PAI:");
        const logradouro = extrair("• LOGRADOURO:");
        const numero = extrair("• NÚMERO:");
        const complemento = extrair("• COMPLEMENTO:");
        const bairro = extrair("• BAIRRO:");
        const cidade = extrair("• CIDADE:");
        const estado = extrair("• ESTADO:");
        const pais = extrair("• PAÍS:");
        const cep = extrair("• CEP:");
        const telefone = extrair("• TELEFONE:");

        let resposta =
            `🔍 *CONSULTA DE CPF* 🔍\n` +
            `• Nome: ${nome}\n` +
            `• CPF: ${cpf}\n` +
            `• Nascimento: ${nascimento} (Idade: ${idade})\n` +
            `• Signo: ${signo}\n` +
            `• Sexo: ${sexo}\n` +
            `• Mãe: ${mae}\n` +
            `• Pai: ${pai}\n\n` +
            `*Endereço:*\n` +
            `${logradouro}, ${numero} ${complemento}\n` +
            `${bairro} - ${cidade}/${estado} - ${cep}\n` +
            `País: ${pais}\n\n` +
            `• Telefone: ${telefone}\n\n` +
            `• Usuário: ${pushname}\n` +
            `• Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro na consulta consultarcpf:", err);
        reply("Erro ao consultar o CPF. Tente novamente mais tarde.");
    }
}
break;
case "cpf2": {
    if (!q) {
        return reply("Você precisa fornecer um número de CPF para consulta.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/cpf2?q=${encodeURIComponent(q)}`);

        // Verifica se a resposta é uma mensagem de erro
        if (Array.isArray(data) && data[0]?.includes("CPF INVÁLIDO")) {
            return reply(data[0]); // Retorna a mensagem de erro diretamente
        }

        if (!Array.isArray(data) || data.length < 5) {
            return reply("Não consegui obter os resultados. Tente novamente mais tarde.");
        }

        // Extrair partes principais da resposta
        const extrairValor = (prefixo) => {
            const item = data.find(linha => linha.startsWith(prefixo));
            return item ? item.replace(prefixo, '').trim() : "Desconhecido";
        };

        const nome = extrairValor("• NOME:");
        const nascimento = extrairValor("• NASCIMENTO:");
        const idade = extrairValor("• IDADE:");
        const cpf = extrairValor("• CPF:");
        const score = extrairValor("• SCORE:");
        const status = extrairValor("• STATUS RECEITA FEDERAL:");
        const emails = data.slice(data.indexOf("• E-MAILS:") + 1, data.indexOf("• ENDEREÇOS:")) || [];

        const enderecosIndex = data.indexOf("• ENDEREÇOS:");
        const telefonesIndex = data.indexOf("• TELEFONES PROPRIETÁRIO:");
        const enderecos = data.slice(enderecosIndex + 1, telefonesIndex) || [];

        const telefones = data.slice(telefonesIndex + 1, data.indexOf("• TELEFONES COMERCIAIS:")) || [];

        // Monta mensagem
        let message =
            `🔍 *CONSULTA DE CPF* 🔍\n` +
            `• Nome: ${nome}\n` +
            `• Nascimento: ${nascimento} (Idade: ${idade})\n` +
            `• CPF: ${cpf}\n` +
            `• Score: ${score}\n` +
            `• Status RF: ${status}\n` +
            `\n*E-mails encontrados:*\n${emails.join('\n') || 'Nenhum'}\n` +
            `\n*Endereços:*\n${enderecos.join('\n') || 'Nenhum'}\n` +
            `\n*Telefones:*\n${telefones.join('\n') || 'Nenhum'}\n` +
            `\n• Usuário: ${pushname}\n` +
            `• Bot: ${NomeDoBot}`;

        reply(message);

    } catch (error) {
        console.error("Erro ao consultar CPF:", error);
        return reply("Erro ao consultar CPF. Tente novamente mais tarde.");
    }
} break;
case "cpf3": {
    if (!q) {
        return reply("Você precisa fornecer um número de CPF para consulta.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/cpf3?q=${encodeURIComponent(q)}`);

        if (Array.isArray(data) && data[0]?.includes("CPF INVÁLIDO")) {
            return reply(data[0]);
        }

        const extrair = (chave) => {
            const item = data.find(x => x.startsWith(chave));
            return item ? item.replace(chave, "").trim() : "Não informado";
        };

        const nome = extrair("• NOME:");
        const nascimento = extrair("• NASCIMENTO:");
        const idade = extrair("• IDADE:");
        const cpf = extrair("• CPF:");
        const score = extrair("• SCORE:");
        const status = extrair("• STATUS RECEITA FEDERAL:");
        const mae = extrair("• MÃE:");
        const pai = extrair("• PAI:");
        const profissao = extrair("• PROFISSÃO:");
        const renda = extrair("• RENDA PRESUMIDA:");

        const emails = data.slice(data.indexOf("• E-MAILS:") + 1, data.indexOf("• ENDEREÇOS:")) || [];
        const enderecos = data.slice(data.indexOf("• ENDEREÇOS:") + 1, data.indexOf("• TELEFONES PROPRIETÁRIO:")) || [];
        const telefones = data.slice(data.indexOf("• TELEFONES PROPRIETÁRIO:") + 1, data.indexOf("• TELEFONES COMERCIAIS:")) || [];
        const parentesIndex = data.indexOf("• POSSÍVEIS PARENTES:");
        const vizinhosIndex = data.indexOf("• POSSÍVEIS VIZINHOS:");
        const parentes = parentesIndex !== -1 && vizinhosIndex !== -1 ? data.slice(parentesIndex + 1, vizinhosIndex) : [];

        let resposta =
            `🔍 *CONSULTA DE CPF* 🔍\n` +
            `• Nome: ${nome}\n` +
            `• CPF: ${cpf}\n` +
            `• Nascimento: ${nascimento} (Idade: ${idade})\n` +
            `• Mãe: ${mae}\n` +
            `• Pai: ${pai}\n` +
            `• Profissão: ${profissao}\n` +
            `• Renda Presumida: R$ ${renda}\n` +
            `• Score: ${score}\n` +
            `• Status Receita Federal: ${status}\n\n` +
            `*E-mails encontrados:*\n${emails.join('\n') || 'Nenhum'}\n\n` +
            `*Endereços:*\n${enderecos.join('\n') || 'Nenhum'}\n\n` +
            `*Telefones:*\n${telefones.join('\n') || 'Nenhum'}\n\n` +
            `*Parentes:*\n${parentes.join('\n') || 'Nenhum'}\n\n` +
            `• Usuário: ${pushname}\n` +
            `• Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro na consulta cpf3:", err);
        reply("Erro ao consultar o CPF. Tente novamente mais tarde.");
    }
}
break;
        
case "cpf6":
{
  if (!q) {
    return blackmd.sendMessage(
      from,
      { text: `Por favor, forneça um CPF válido. Exemplo: ${prefix}cpfcompleto 16982570746` },
      { quoted: info }
    );
  }

  try {
    const response = await axios.get(`https://scraper.mdzapis.com/consultar/mdz?type=cpf&data=${encodeURIComponent(q)}&base=COMPLETA&apikey=freemdz15days`);

    if (!response.data || !response.data.resultado) {
      return blackmd.sendMessage(from, { text: "Erro: Não foi possível obter os dados para este CPF." }, { quoted: info });
    }

    const dados = response.data.resultado;

    let msg = `🔍 *Consulta de CPF Completo*\n\n`;
    msg += `👤 *Nome:* ${dados.match(/NOME:\s(.*?)\n/)?.[1] || "Não encontrado"}\n`;
    msg += `🆔 *CPF:* ${dados.match(/CPF:\s(.*?)\n/)?.[1] || "Não encontrado"}\n`;
    msg += `📊 *Situação Cadastral:* ${dados.match(/SITUAÇÃO CADASTRAL:\s(.*?)\n/)?.[1] || "Não encontrado"}\n`;
    msg += `🎂 *Nascimento:* ${dados.match(/NASCIMENTO:\s(.*?)\n/)?.[1] || "Não encontrado"}\n`;
    msg += `🧑‍🎓 *Escolaridade:* ${dados.match(/ESCOLARIDADE:\s(.*?)\n/)?.[1] || "Não encontrado"}\n`;
    msg += `👩‍👦 *Nome da Mãe:* ${dados.match(/MÃE:\s(.*?)\n/)?.[1] || "Não encontrado"}\n`;
    msg += `👨 *Nome do Pai:* ${dados.match(/PAI:\s(.*?)\n/)?.[1] || "Não encontrado"}\n`;
    msg += `💰 *Renda:* R$ ${dados.match(/RENDA:\s(.*?)\n/)?.[1] || "Não encontrado"}\n`;
    msg += `📉 *Poder Aquisitivo:* ${dados.match(/PODER AQUISITIVO:\s(.*?)\n/)?.[1] || "Não encontrado"}\n`;

    const telefones = dados.match(/(\d{11})\nTIPO:\s(.*?)\nOPERADORA:\s(.*?)\n/g);
    if (telefones) {
      msg += `📞 *Telefones:* \n`;
      telefones.forEach((tel, i) => {
        const match = tel.match(/(\d{11})\nTIPO:\s(.*?)\nOPERADORA:\s(.*?)\n/);
        msg += `   📌 ${i + 1}: ${match[1]} (${match[2]}) - ${match[3]}\n`;
      });
    }

    const emailMatch = dados.match(/EMAIL:\s(.*?)\n/);
    if (emailMatch) {
      msg += `📧 *Email:* ${emailMatch[1]}\n`;
    }

    const enderecos = dados.match(/CEP:\s(.*?)\s-\sESTADO:\s(.*?)\s-\sMUNICÍPIO:\s(.*?)\s-\sLOGRADOURO:\s(.*?)\s-\sBAIRRO:\s(.*?)\s-\sCOMPLEMENTO:\s(.*?)\s-\sNÚMERO:\s(.*?)\n/g);
    if (enderecos) {
      msg += `📍 *Endereços:* \n`;
      enderecos.forEach((end, i) => {
        const match = end.match(/CEP:\s(.*?)\s-\sESTADO:\s(.*?)\s-\sMUNICÍPIO:\s(.*?)\s-\sLOGRADOURO:\s(.*?)\s-\sBAIRRO:\s(.*?)\s-\sCOMPLEMENTO:\s(.*?)\s-\sNÚMERO:\s(.*?)\n/);
        msg += `   📌 ${i + 1}: ${match[4]}, ${match[7]}, ${match[5]}, ${match[3]}/${match[2]} - CEP: ${match[1]}\n`;
      });
    }

    blackmd.sendMessage(from, { text: msg }, { quoted: info });

  } catch (error) {
    console.error('Erro ao buscar CPF:', error);
    blackmd.sendMessage(from, { text: "Ocorreu um erro ao processar a solicitação." }, { quoted: info });
  }
}
break;

case "cpf7":
{
  if (!q) {
    return blackmd.sendMessage(
      from,
      { text: `Por favor, forneça um CPF válido. Exemplo: ${prefix}cpffull 56256337972` },
      { quoted: info }
    );
  }

  try {
    const response = await axios.get(`https://ghostapis.com.br/api.php?token=758a8326817da871e9a2713e2c684c5d&cpf_completo=${encodeURIComponent(q)}`);

    if (!response.data || response.data.CPF !== q) {
      return blackmd.sendMessage(from, { text: "Erro: Não foi possível obter os dados para este CPF." }, { quoted: info });
    }

    const dados = response.data;

    let msg = `🔍 *Consulta de CPF*\n\n`;
    msg += `👤 *Nome:* ${dados.NOME || "Não encontrado"}\n`;
    msg += `🆔 *CPF:* ${dados.CPF || "Não encontrado"}\n`;
    msg += `🎂 *Nascimento:* ${dados.NASCIMENTO || "Não encontrado"}\n`;
    msg += `👨‍👩‍👧‍👦 *Nome da Mãe:* ${dados.NOME_MAE || "Não encontrado"}\n`;
    msg += `👨 *Nome do Pai:* ${dados.NOME_PAI || "Não encontrado"}\n`;
    msg += `💳 *RG:* ${dados.RG || "Não encontrado"}\n`;
    msg += `📊 *Estado Civil:* ${dados.ESTADO_CIVIL || "Não encontrado"}\n`;

    if (dados.LISTA_TELEFONE && dados.LISTA_TELEFONE.length > 0) {
      msg += `📞 *Telefones:* ${dados.LISTA_TELEFONE.map(t => t.NUMBER).join(", ")}\n`;
    }

    if (dados.LISTA_EMAIL && dados.LISTA_EMAIL.length > 0) {
      msg += `📧 *Emails:* ${dados.LISTA_EMAIL.map(e => e.EMAIL).join(", ")}\n`;
    }

    if (dados.ENDERECO && dados.ENDERECO.length > 0) {
      msg += `📍 *Endereços:* \n`;
      dados.ENDERECO.forEach((end, i) => {
        msg += `   📌 ${i + 1}: ${end.LOGRADOURO}, ${end.LOGRADOURO_NUMERO}, ${end.BAIRRO}, ${end.CIDADE}/${end.UF} - CEP: ${end.CEP}\n`;
      });
    }

    if (dados.VAZAMENTOS_SENHA_CPF && dados.VAZAMENTOS_SENHA_CPF.length > 0) {
      msg += `🔓 *Senha vazada:* ${dados.VAZAMENTOS_SENHA_CPF.map(v => v.SENHA).join(", ")}\n`;
    }

    blackmd.sendMessage(from, { text: msg }, { quoted: info });

  } catch (error) {
    console.error('Erro ao buscar CPF:', error);
    blackmd.sendMessage(from, { text: "Ocorreu um erro ao processar a solicitação." }, { quoted: info });
  }
}
break;
case "cpf8": {
    if (!q) {
        return reply("Você precisa fornecer um CPF para consulta.");
    }

    try {
        const { data } = await axios.get(`https://api-bruxel4s.shop/api/consulta/cpf?query=${encodeURIComponent(q)}`);

        const r = data.resultado;
        if (!r || r.nome === "undefined") {
            return reply("CPF não encontrado ou inválido.");
        }

        let resposta =
            `🔍 *CONSULTA CPF 8* 🔍\n\n` +
            `• Nome: ${r.nome || "Não informado"}\n` +
            `• CPF: ${r.cpf || "Não informado"}\n` +
            `• Nascimento: ${r.nascimento || "Não informado"}\n` +
            `• Sexo: ${r.sexo || "Não informado"}\n` +
            `• Mãe: ${r.mae || "Não informado"}\n` +
            `• Pai: ${r.pai || "Não informado"}\n\n` +
            `*Endereço:*\n` +
            `${r.endereco?.logradouro || "Desconhecido"}, ${r.endereco?.numero || "S/N"}\n` +
            `${r.endereco?.bairro || "Bairro não informado"}\n` +
            `${r.endereco?.municipio || "Município não informado"} - CEP: ${r.endereco?.cep || "Desconhecido"}\n\n` +
            `*Documentos:*\n` +
            `• RG: ${r.documentos?.rgNumero || "Não encontrado"}\n` +
            `• Órgão Emissor: ${r.documentos?.rgOrgaoEmisor || "Não encontrado"}\n` +
            `• UF: ${r.documentos?.rgUf || "Não encontrado"}\n` +
            `• Emissão: ${r.documentos?.rgDataEmissao || "Não encontrado"}\n` +
            `• CNS: ${r.documentos?.cns || "Não encontrado"}\n\n` +
            `*Contatos:*\n` +
            `• Telefone: ${r.contatos?.telefone || "Não encontrado"}\n` +
            `• Telefone 2: ${r.contatos?.telefoneSecundario || "Não encontrado"}\n\n` +
            `• Usuário: ${pushname}\n` +
            `• Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro na consulta cpf6:", err);
        reply("Erro ao consultar o CPF na base cpf6. Tente novamente mais tarde.");
    }
}
break;
case "placa": {
    if (!q) {
        return reply("Você precisa fornecer uma placa para consulta.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/placa2?q=${encodeURIComponent(q)}`);

        if (Array.isArray(data) && data[0]?.includes("PLACA INVÁLIDA")) {
            return reply(data[0]);
        }

        const extrair = (chave) => {
            const item = data.find(x => x.startsWith(chave));
            return item ? item.replace(chave, "").trim() : "Não informado";
        };

        const placa = extrair("• PLACA:");
        const situacao = extrair("• SITUAÇÃO:");
        const marca = extrair("• MARCA:");
        const modelo = extrair("• MODELO:");
        const cor = extrair("• COR:");
        const anoFab = extrair("• ANO - FABRICAÇÃO:");
        const anoMod = extrair("• ANO - MODELO:");
        const municipio = extrair("• MUNICIPIO:");
        const estado = extrair("• ESTADO:");
        const chassi = extrair("• CHASSI:");
        const renavam = extrair("• RENAVAM:");
        const segmento = extrair("• SEGMENTO:");
        const subSegmento = extrair("• SUB SEGMENTO:");
        const grupo = extrair("• GRUPO:");
        const combustivel = extrair("• COMBUSTIVEL:");
        const tipoVeiculo = extrair("• TIPO DE VEICULO:");
        const especie = extrair("• ESPECIE:");
        const passageiros = extrair("• QUANTIDADE DE PASSAGEIROS:");
        const crv = extrair("• EMISSÃO ULTIMO CRV:");
        const atualizado = extrair("• ULTIMA ATUALIZAÇÃO:");

        let resposta =
            `🔍 *CONSULTA DE PLACA* 🔍\n` +
            `• Placa: ${placa}\n` +
            `• Situação: ${situacao}\n` +
            `• Marca/Modelo: ${marca} / ${modelo}\n` +
            `• Cor: ${cor}\n` +
            `• Ano: ${anoFab} / ${anoMod}\n` +
            `• Município/UF: ${municipio} - ${estado}\n` +
            `• Chassi: ${chassi}\n` +
            `• Renavam: ${renavam}\n\n` +
            `• Segmento: ${segmento}\n` +
            `• Sub Segmento: ${subSegmento}\n` +
            `• Grupo: ${grupo}\n` +
            `• Combustível: ${combustivel}\n` +
            `• Tipo: ${tipoVeiculo}\n` +
            `• Espécie: ${especie}\n` +
            `• Passageiros: ${passageiros}\n` +
            `• Últ. CRV: ${crv}\n` +
            `• Atualização: ${atualizado}\n\n` +
            `• Usuário: ${pushname}\n` +
            `• Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro na consulta placa2:", err);
        reply("Erro ao consultar a placa. Tente novamente mais tarde.");
    }
}
break;
case "placa3": {
    if (!q) {
        return reply("Você precisa fornecer uma placa para consulta.");
    }

    try {
        const placa = q.toUpperCase().replace(/\s/g, '');
        if (placa.length !== 7) {
            return reply("Por favor, forneça uma placa válida com 7 caracteres.");
        }

        const { data } = await axios.get(`https://mdzapis.com/api/placanew?placa=${placa}`);
        
        if (!data || !data.status || !data.resultado) {
            return reply("Não consegui obter os resultados, tente novamente mais tarde.");
        }

        const resultado = data.resultado;
        const situacao = resultado.situacao || "Desconhecida";
        const placaVeiculo = resultado.placa || "Desconhecida";
        const chassi = resultado.chassi || "Desconhecido";
        const renavam = resultado.renavam || "Desconhecido";
        const numMotor = resultado.numMotor || "Desconhecido";
        const combustivel = resultado.combustivel || "Desconhecido";
        const marcaModelo = resultado.marcaModelo || "Desconhecido";
        const cor = resultado.cor || "Desconhecida";
        const anoFabricacao = resultado.anoFabricacao || "Desconhecido";
        const anoModelo = resultado.anoModelo || "Desconhecido";
        const restricoes = resultado.restricoes?.join(", ") || "Sem restrições";
        const multas = resultado.multas?.comentario || "Sem informações sobre multas";
        const proprietario = resultado.proprietario?.nome || "Desconhecido";
        const endereco = resultado.enderecos?.logradouro || "Desconhecido";
        const cidade = resultado.enderecos?.municipio || "Desconhecida";
        const uf = resultado.enderecos?.uf || "Desconhecido";

        const usuario = pushname || "Desconhecido";
        const bot = NomeDoBot || "Desconhecido";

        const message = `*Informações do veículo com placa ${placa}:*\n` +
                        `- Situação: ${situacao}\n` +
                        `- Placa: ${placaVeiculo}\n` +
                        `- Chassi: ${chassi}\n` +
                        `- Renavam: ${renavam}\n` +
                        `- Número do Motor: ${numMotor}\n` +
                        `- Combustível: ${combustivel}\n` +
                        `- Marca/Modelo: ${marcaModelo}\n` +
                        `- Cor: ${cor}\n` +
                        `- Ano de Fabricação: ${anoFabricacao}\n` +
                        `- Ano do Modelo: ${anoModelo}\n` +
                        `- Restrições: ${restricoes}\n` +
                        `- Multas: ${multas}\n` +
                        `- Proprietário: ${proprietario}\n` +
                        `- Endereço: ${endereco}, ${cidade} - ${uf}\n` +
                        `- Usuário: ${pushname}\n` +
                        `- Bot: ${NomeDoBot}`;

        reply(message);
    } catch (error) {
        console.error("Erro ao processar a solicitação:", error);
        return reply("Ocorreu um erro ao processar a solicitação. Por favor, tente novamente mais tarde.");
    }
}
break;
case "placa4": {
    if (!q) {
        return reply("Você precisa fornecer uma placa para consulta.");
    }

    try {
        const { data } = await axios.get(`https://api-bruxel4s.shop/api/consulta/placa?query=${encodeURIComponent(q)}`);

        const r = data.resultado;
        if (!r || !r.placa) {
            return reply("Placa não encontrada ou inválida.");
        }

        const d = r.detalhes || {};

        let resposta =
            `🚘 *CONSULTA DE PLACA* 🚘\n\n` +
            `• Placa: ${r.placa || "Não informado"}\n` +
            `• Chassi: ${r.chassi || "Não informado"}\n\n` +
            `*Detalhes do Veículo:*\n` +
            `• Marca/Modelo: ${d.marcaModelo || "Desconhecido"}\n` +
            `• Ano de Fabricação: ${d.anoFabricacao || "Desconhecido"}\n` +
            `• Ano do Modelo: ${d.anoModelo || "Desconhecido"}\n` +
            `• Tipo do Veículo: ${d.tipoVeiculo || "Desconhecido"}\n` +
            `• Espécie: ${d.especieVeiculo || "Desconhecido"}\n` +
            `• Cor: ${d.corVeiculo || "Desconhecida"}\n` +
            `• Combustível: ${d.combustivel || "Desconhecido"}\n` +
            `• Capacidade de Carga: ${d.capacidadeCarga || "0"}\n` +
            `• Passageiros: ${d.quantidadePassageiro || "0"}\n` +
            `• Peso Bruto Total: ${d.pesoBrutoTotal || "0"}\n` +
            `• Município: ${d.municipio || "Desconhecido"}\n` +
            `• Estado (UF): ${d.ufPlaca || "Desconhecido"}\n\n` +
            `• Usuário: ${pushname}\n` +
            `• Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro na consulta placa6:", err);
        reply("Erro ao consultar a placa. Tente novamente mais tarde.");
    }
}
break;
case "score":
{
    if (!q) {
        return reply("Você precisa fornecer um número de CPF para consulta.");
    }

    try {
        const cpf = q.replace(/\D/g, '');
        if (cpf.length !== 11) {
            return reply("Por favor, forneça um CPF válido com 11 dígitos.");
        }

        const { data } = await axios.get(`https://mdzapis.com/api/score?cpf=${cpf}`);  

        if (!data || !data.status || !data.resultado) {  
            return reply("Não consegui obter os resultados, tente novamente mais tarde.");  
        }  

        const resultado = data.resultado;  
        const nome = resultado.nome || "Desconhecido";  
        const nascimento = resultado.nascimento || "Desconhecido";  
        const sexo = resultado.sexo || "Desconhecido";  
        const mae = resultado.mae || "Desconhecida";  
        const pai = resultado.pai || "Desconhecido";  
        const estadoCivil = resultado.estadoCivil || "Desconhecido";  
        const profissao = resultado.profissao || "Desconhecido";  
        const renda = resultado.renda || "Desconhecido";  
        const poderAquisitivo = resultado.poderAquisitivo || "Desconhecido";  
        const scoreCsb = resultado.scoreCsb || "Desconhecido";  
        const scoreCsba = resultado.scoreCsba || "Desconhecido";  
        const telefone = resultado.telefones?.[0]?.telefone || "Desconhecido";  
        const email = resultado.emails?.[0]?.email || "Desconhecido";  

        const message = `*Informações do CPF ${cpf}:*\n` +  
                        `- Nome: ${nome}\n` +  
                        `- Nascimento: ${nascimento}\n` +  
                        `- Sexo: ${sexo}\n` +  
                        `- Mãe: ${mae}\n` +  
                        `- Pai: ${pai}\n` +  
                        `- Estado Civil: ${estadoCivil}\n` +  
                        `- Profissão: ${profissao}\n` +  
                        `- Renda: ${renda}\n` +  
                        `- Poder Aquisitivo: ${poderAquisitivo}\n` +  
                        `- Score CSB: ${scoreCsb}\n` +  
                        `- Score CSBA: ${scoreCsba}\n` +  
                        `- Telefone: ${telefone}\n` +  
                        `- Email: ${email}\n` +  
                        `- Usuário: ${pushname}\n` +  
                        `- Bot: ${NomeDoBot}`;  

        reply(message);

    } catch (error) {
        console.error("Erro ao processar a solicitação:", error);
        return reply("Ocorreu um erro ao processar a solicitação. Por favor, tente novamente mais tarde.");
    }

} break;

case "cpf4": {
    if (!q) {
        return reply("Você precisa fornecer um número de CPF para consulta.");
    }

    try {  
        const cpf = q.replace(/\D/g, '');  
        if (cpf.length !== 11) {  
            return reply("Por favor, forneça um CPF válido com 11 dígitos.");  
        }  

        const { data } = await axios.get(`https://mdzapis.com/api/cpffree?cpf=${cpf}`);  

        if (!data || !data.status || !data.resultado) {  
            return reply("Não consegui obter os resultados, tente novamente mais tarde.");  
        }  

        const resultado = data.resultado;  
        const nome = resultado.nome || "Desconhecido";  
        const nascimento = resultado.nascimento || "Desconhecido";  
        const sexo = resultado.sexo || "Desconhecido";  
        const mae = resultado.mae || "Desconhecida";  
        const pai = resultado.pai || "Desconhecido";  
        const estadoCivil = resultado.estadoCivil || "Desconhecido";  
        const profissao = resultado.profissao || "Desconhecido";  
        const renda = resultado.renda || "Desconhecido";  
        const poderAquisitivo = resultado.poderAquisitivo || "Desconhecido";  
        const scoreCsb = resultado.scoreCsb || "Desconhecido";  
        const scoreCsba = resultado.scoreCsba || "Desconhecido";  
        const descricaoMosaic = resultado.descricaoMosaic || "Desconhecido";  
        const classeMosaic = resultado.classeMosaic || "Desconhecida";  
        const telefone = resultado.telefones?.[0]?.telefone || "Desconhecido";  
        const email = resultado.emails?.[0]?.email || "Desconhecido";  
        const beneficios = resultado.beneficios?.map(b => `- ${b.beneficio}: ${b.totalRecebido}`).join("\n") || "Sem informações";  

        const usuario = pushname || "Desconhecido";  
        const bot = NomeDoBot || "Desconhecido";  

        const message = `*Informações do CPF ${cpf}:*\n` +  
                        `- Nome: ${nome}\n` +  
                        `- Nascimento: ${nascimento}\n` +  
                        `- Sexo: ${sexo}\n` +  
                        `- Mãe: ${mae}\n` +  
                        `- Pai: ${pai}\n` +  
                        `- Estado Civil: ${estadoCivil}\n` +  
                        `- Profissão: ${profissao}\n` +  
                        `- Renda: ${renda}\n` +  
                        `- Poder Aquisitivo: ${poderAquisitivo}\n` +  
                        `- Score CSB: ${scoreCsb}\n` +  
                        `- Score CSBA: ${scoreCsba}\n` +  
                        `- Descrição Mosaic: ${descricaoMosaic}\n` +  
                        `- Classe Mosaic: ${classeMosaic}\n` +  
                        `- Telefone: ${telefone}\n` +  
                        `- Email: ${email}\n` +  
                        `- Benefícios:\n${beneficios}\n` +  
                        `- Usuário: ${pushname}\n` +  
                        `- Bot: ${NomeDoBot}`;  

        reply(message);  
    } catch (error) {  
        console.error("Erro ao processar a solicitação:", error);  
        return reply("Ocorreu um erro ao processar a solicitação. Por favor, tente novamente mais tarde.");  
    }

} break;
case "telefone3": {
    if (!q) {
        return reply("Você precisa fornecer um número de telefone para consulta.");
    }

    try {
        const telefone = q.replace(/\D/g, '');
        if (telefone.length !== 11) {
            return reply("Por favor, forneça um número de telefone válido.");
        }

        const { data } = await axios.get(`https://mdzapis.com/api/telsis?telefone=${telefone}`);
        
        if (!data || !data.status || !data.resultado || data.resultado.length === 0) {
            return reply("Não consegui obter os resultados, tente novamente mais tarde.");
        }

        const resultado = data.resultado[0];
        const nome = resultado.nome || "Desconhecido";
        const cpfCnpj = resultado.cpfCnpj || "Desconhecido";
        const endereco = resultado.endereco || {};
        const rua = endereco.logradouro || "Desconhecido";
        const numero = endereco.numero || "Desconhecido";
        const bairro = endereco.bairro || "Desconhecido";
        const cidade = endereco.cidade || "Desconhecida";
        const cep = endereco.cep || "Desconhecido";

        const dadosCompletos = resultado.dadosCompletos?.resultado || {};
        const nomePessoa = dadosCompletos.nome || "Desconhecido";
        const nascimento = dadosCompletos.data_nascimento?.data || "Desconhecida";
        const idade = dadosCompletos.data_nascimento?.idade || "Desconhecida";
        const nacionalidade = dadosCompletos.nacionalidade || "Desconhecida";
        const nomeMae = dadosCompletos.nome_mae || "Desconhecida";
        const nomePai = dadosCompletos.nome_pai || "Desconhecido";

        const message = `*Informações sobre o telefone ${telefone}:*\n` +
                        `- Nome: ${nome}\n` +
                        `- CPF/CNPJ: ${cpfCnpj}\n` +
                        `- Endereço: ${rua}, ${numero}, ${bairro}, ${cidade} - CEP: ${cep}\n` +
                        `- Nome Completo: ${nomePessoa}\n` +
                        `- Data de Nascimento: ${nascimento} (Idade: ${idade})\n` +
                        `- Nacionalidade: ${nacionalidade}\n` +
                        `- Nome da Mãe: ${nomeMae}\n` +
                        `- Nome do Pai: ${nomePai}`;

        reply(message);
    } catch (error) {
        console.error("Erro ao processar a solicitação:", error);
        return reply("Ocorreu um erro ao processar a solicitação. Por favor, tente novamente mais tarde.");
    }
}
break;

case "parentes": {
    if (!q) return reply("Você precisa fornecer um CPF para consulta.");

    const cpf = q.replace(/\D/g, '');
    if (cpf.length !== 11) return reply("Por favor, forneça um CPF válido.");

    try {
        const { data } = await axios.get(`https://mdzapis.com/api/parentes?cpf=${cpf}`);
        const lista = data?.resultado?.parentes;

        if (!lista || lista.total === 0) return reply("Não consegui obter os resultados, tente novamente mais tarde.");

        let message = `*Parentes do CPF ${cpf}:*\n\n`;
        lista.itens.forEach((p, i) => {
            message += `*${i + 1}.*\n- Nome: ${p.nome}\n- CPF: ${p.cpf}\n- Vínculo: ${p.vinculo}\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar parentes:", error);
        reply("Ocorreu um erro ao processar a solicitação. Por favor, tente novamente mais tarde.");
    }
} break;

//case de ip

case "telefone2": {
    if (!q) return reply("Você precisa fornecer um número de telefone para consulta.");

    try {
        const telefone = q.replace(/\D/g, '');
        if (telefone.length < 10 || telefone.length > 11)
            return reply("Por favor, forneça um número de telefone válido com 10 ou 11 dígitos.");

        const res = await fetchJson(`https://world-ecletix.onrender.com/api/consultas?type=telefone&query=${telefone}`);
        
        if (!res || !res.status || !res.resultado)
            return reply("Nenhum dado encontrado para o telefone fornecido.");

        const { telefone: telefoneInfo, nome, operadora, "cpf/cnpj": cpfInfo } = res.resultado;

        const message = `*Informações do Telefone ${telefoneInfo}:*\n` +
                        `- Nome: ${nome}\n` +
                        `- CPF/CNPJ: ${cpfInfo}\n` +
                        `- Operadora: ${operadora || "Desconhecida"}\n` +
                        `- Usuário: ${pushname || "Desconhecido"}\n` +
                        `- Bot: ${NomeDoBot || "Desconhecido"}`;

        reply(message);
    } catch (error) {
        console.error("Erro ao processar a solicitação:", error);
        return reply("Ocorreu um erro ao processar a solicitação. Por favor, tente novamente mais tarde.");
    }
}
break;
case "nome": {
    if (!q) return reply("Você precisa fornecer um nome para consulta.");

    try {
        const nome = q.trim();
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/consultas?type=nome&query=${encodeURIComponent(nome)}`);
        
        if (!res || !res.status || !res.resultado)
            return reply("Nenhum dado encontrado para o nome fornecido.");

        const { cpf, nome: nomeCompleto, sexo, nascimento } = res.resultado;

        const message = `*Informações sobre o nome ${nomeCompleto}:*\n` +
                        `- CPF: ${cpf || "Não disponível"}\n` +
                        `- Data de Nascimento: ${nascimento || "Não disponível"}\n` +
                        `- Sexo: ${sexo || "Não especificado"}\n` +
                        `- Usuário: ${pushname || "Desconhecido"}\n` +
                        `- Bot: ${NomeDoBot || "Desconhecido"}`;

        reply(message);
    } catch (error) {
        console.error("Erro ao processar a solicitação:", error);
        return reply("Ocorreu um erro ao processar a solicitação. Por favor, tente novamente mais tarde.");
    }
}
break;
case 'infosite':
case "whois": {
    if (!q) {
        return reply("Você precisa fornecer um domínio para consultar.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/whois/${q}`);

        if (!data || !data.WhoisRecord) {
            return reply("⚠️ Domínio não encontrado ou inválido.");
        }

        const registro = data.WhoisRecord;

        let resposta =
            `🔍 *CONSULTA WHOIS* 🔍\n` +
            `• Domínio: ${registro.domainName || "Não informado"}\n` +
            `• Status: ${registro.status || "Não informado"}\n` +
            `• Servidores DNS: ${registro.nameServers?.hostNames?.join(", ") || "Não informado"}\n` +
            `• Criado em: ${registro.createdDate || "Não informado"}\n` +
            `• Atualizado em: ${registro.updatedDate || "Não informado"}\n` +
            `• Expira em: ${registro.expiresDate || "Não informado"}\n` +
            `• Registrante: ${registro.registrant?.name || "Não informado"}\n` +
            `• Email: ${registro.contactEmail || "Não informado"}\n\n` +
            `• Usuário: ${pushname}\n` +
            `• Bot: ${NomeDoBot}`;

        reply(resposta);

    } catch (err) {
        console.error("Erro ao consultar domínio:", err);
        reply("Erro ao consultar o domínio. Tente novamente mais tarde.");
    }
}
break;
case "ip": {
    if (!q) return reply("Você precisa fornecer um IP para consulta.");

    try {
        const ip = q.trim();
        const res = await fetchJson(`https://ipwhois.app/json/${ip}`);

        if (!res || !res.success)
            return reply("Nenhum dado encontrado para o IP fornecido.");

        const {
            ip: ipInfo, continent, country, country_code, region, city, latitude, longitude,
            asn, org, isp, timezone, currency, currency_code, currency_symbol
        } = res;

        const message = `*Informações do IP ${ipInfo}:*\n` +
                        `- Continente: ${continent}\n` +
                        `- País: ${country} (${country_code})\n` +
                        `- Região: ${region}\n` +
                        `- Cidade: ${city}\n` +
                        `- Latitude: ${latitude}\n` +
                        `- Longitude: ${longitude}\n` +
                        `- ASN: ${asn}\n` +
                        `- Organização: ${org}\n` +
                        `- ISP: ${isp}\n` +
                        `- Fuso Horário: ${timezone}\n` +
                        `- Moeda: ${currency} (${currency_code})\n` +
                        `- Símbolo da Moeda: ${currency_symbol}\n` +
                        `- Usuário: ${pushname}\n` +
                        `- Bot: ${NomeDoBot}`;

        reply(message);
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;

case "cnpj":
{
    if (!q) {
        return reply("Você precisa fornecer um CNPJ para consulta.");
    }

    try {
        const cnpj = q.replace(/\D/g, '');
        if (cnpj.length !== 14) {
            return reply("Por favor, forneça um CNPJ válido com 14 dígitos.");
        }

        const res = await fetchJson(`https://brasilapi.com.br/api/cnpj/v1/${cnpj}`);
        //by luan

        if (!res || !res.cnpj) {
            return reply("Nenhum dado encontrado para o CNPJ fornecido.");
        }

        const {
            razao_social, nome_fantasia, cnpj: cnpjResult, logradouro, numero, bairro,
            municipio, uf, cep, ddd_telefone_1, email, capital_social,
            natureza_juridica, descricao_situacao_cadastral, qsa
        } = res;

        let sociosInfo = qsa.map(socio =>
            `- Nome do sócio: ${socio.nome_socio}\n  Qualificação: ${socio.qualificacao_socio}`
        ).join('\n');

        const message = `*Informações do CNPJ ${cnpjResult}:*\n` +
                        `- Razão Social: ${razao_social}\n` +
                        `- Nome Fantasia: ${nome_fantasia || "Não informado"}\n` +
                        `- Logradouro: ${logradouro}, ${numero}\n` +
                        `- Bairro: ${bairro}\n` +
                        `- Cidade: ${municipio} - ${uf}\n` +
                        `- CEP: ${cep}\n` +
                        `- Telefone: ${ddd_telefone_1}\n` +
                        `- Email: ${email || "Não informado"}\n` +
                        `- Capital Social: R$ ${capital_social.toFixed(2)}\n` +
                        `- Natureza Jurídica: ${natureza_juridica}\n` +
                        `- Situação Cadastral: ${descricao_situacao_cadastral}\n\n` +
                        `*Quadro Societário:*\n${sociosInfo}\n` +
                        `- Usuário: ${pushname}\n` +
                        `- Bot: ${NomeDoBot}`;

        reply(message);
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;

case "cpf5":
{
    if (!q) {
        return reply("Você precisa fornecer um CPF para consulta.");
    }

    try {
        // Remove caracteres não numéricos do CPF fornecido
        const cpf = q.replace(/\D/g, '');
        if (cpf.length !== 11) {
            return reply("Por favor, forneça um CPF válido com 11 dígitos.");
        }

        // Faz a requisição para a API de consulta por CPF
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/consultas?type=cpf&query=${cpf}`);
        //by luan

        // Verifica se a resposta contém dados esperados
        if (!res || !res.status) {
            return reply("Nenhum dado encontrado para o CPF fornecido.");
        }

        // Extrai as informações da resposta
        const { "🧑‍💼 nome": nome, "🚻 sexo": sexo, "🎂 nascimento": nascimento, "👩‍👧 mãe": mae, "🆔 cpf": cpfFormatado } = res.resultado;

        // Prepara a mensagem com as informações do CPF
        const message = `*Informações do CPF ${cpfFormatado}:*\n` +
                        `- Nome: ${nome}\n` +
                        `- Sexo: ${sexo}\n` +
                        `- Nascimento: ${nascimento}\n` +
                        `- Mãe: ${mae}\n` +
                        `- CPF: ${cpfFormatado}`;

        reply(message);
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "ddd":
{
    if (!q) {
        return reply("Você precisa fornecer um DDD para consulta.");
    }

    try {
        const ddd = q.replace(/\D/g, '');
        if (ddd.length !== 2) {
            return reply("Por favor, forneça um DDD válido com 2 dígitos.");
        }

        const res = await fetchJson(`https://brasilapi.com.br/api/ddd/v1/${ddd}`);
        //by luan

        if (!res || !res.state) {
            return reply("Nenhum dado encontrado para o DDD fornecido.");
        }

        const { state, cities } = res;

        const message = `*Informações do DDD ${ddd}:*\n` +
                        `- Estado: ${state}\n` +
                        `- Cidades:\n${cities.join(', ')}`;

        reply(message);
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;

case "cep":
{
    if (!q) {
        return reply("Você precisa fornecer um CEP para consulta.");
    }

    try {
        // Remove caracteres não numéricos do CEP fornecido
        const cepInput = q.replace(/\D/g, '');
        if (cepInput.length !== 8) {
            return reply("Por favor, forneça um CEP válido com 8 dígitos.");
        }

        const res = await fetchJson(`https://brasilapi.com.br/api/cep/v2/${cepInput}`);
        //by luan

        // Verifica se a resposta contém dados esperados
        if (!res || !res.cep) {
            return reply("Nenhum dado encontrado para o CEP fornecido.");
        }

        // Extrai as informações da resposta
        const { cep: cepResult, street, neighborhood, city, state } = res;

        // Prepara a mensagem com as informações do CEP
        const message = `*Informações do CEP ${cepResult}:*\n` +
                        `- Rua: ${street}\n` +
                        `- Bairro: ${neighborhood}\n` +
                        `- Cidade: ${city}\n` +
                        `- Estado: ${state}`;

        reply(message);
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
		
case 'cep2': {
    if (!q) return reply('Por favor, forneça um CEP para consulta. Exemplo: !cep 01001000');

    const cep = q.trim();

    try {
        const apiUrl = `https://viacep.com.br/ws/${cep}/json/`;
        const response = await fetch(apiUrl);
        const data = await response.json();

        if (data.erro) {
            return reply('CEP não encontrado. Verifique o número e tente novamente.');
        }

        const result = `
            *🔍Consulta de CEP🔎*
            
            CEP: ${data.cep}
            Logradouro: ${data.logradouro}
            Complemento: ${data.complemento}
            Bairro: ${data.bairro}
            Cidade: ${data.localidade}
            Estado: ${data.uf}
        `;
        
        return reply(result);
    } catch (error) {
        console.log(error);
        return reply('Ocorreu um erro ao consultar o CEP. Tente novamente mais tarde.');
    }
}
break; 
case "placa2":
{
    if (!q) {
        return reply("Você precisa fornecer uma placa para consulta.");
    }

    try {
        const placa = q.toUpperCase().replace(/\s+/g, ''); // Normaliza o formato da placa
        if (placa.length !== 7) {
            return reply("Por favor, forneça uma placa válida com 7 caracteres.");
        }

        const res = await fetchJson(`https://world-ecletix.onrender.com/api/consultas?type=placa&query=${placa}`);
        //by luan

        if (!res || !res.status) {
            return reply("Nenhum dado encontrado para a placa fornecida.");
        }

        const {
            "- placa": placaInfo,
            "- marca": marcaInfo,
            "- modelo": modeloInfo,
            "- ano": anoInfo,
            "- cor": corInfo,
            "- chassi": chassiInfo,
            "- município": municipioInfo,
            "- uf": ufInfo,
            "- combustível": combustivelInfo,
            "- cilindradas": cilindradasInfo,
            "- segmento": segmentoInfo
        } = res.resultado;

        // Monta a mensagem excluindo dados irrelevantes
        const message = `*Informações do Veículo - Placa ${placaInfo}:*\n` +
                        `- Marca: ${marcaInfo}\n` +
                        `- Modelo: ${modeloInfo}\n` +
                        `- Ano: ${anoInfo}\n` +
                        `- Cor: ${corInfo}\n` +
                        `- Chassi: ${chassiInfo}\n` +
                        `- Município: ${municipioInfo}\n` +
                        `- UF: ${ufInfo}\n` +
                        `- Combustível: ${combustivelInfo}\n` +
                        `- Cilindradas: ${cilindradasInfo}\n` +
                        `- Segmento: ${segmentoInfo}\n\n` +
                        `- Usuário: ${pushname}\n` +
                        `- Bot: ${NomeDoBot}`;

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a placa:", error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "operadora3": {
    if (!q) {
        return reply("Você precisa fornecer um número para consultar.");
    }

    try {
        const { data } = await axios.get(`https://blacksystemofc.com.br/api/operadora?numero=${encodeURIComponent(q)}&apikey=black`);
        
        if (!data?.resultado) {
            return reply("Não foi possível encontrar informações sobre o número.");
        }

        const { telefone, operadora, dispositivo, estado } = data.resultado;

        let resposta =
            `📱 *CONSULTA DE OPERADORA* 📱\n` +
            `• Telefone: ${telefone}\n` +
            `• Operadora: ${operadora}\n` +
            `• Tipo: ${dispositivo}\n` +
            `• Estado: ${estado}\n\n` +
            `• Usuário: ${pushname}\n` +
            `• Bot: ${NomeDoBot}`;

        reply(resposta);
    } catch (err) {
        console.error("Erro ao consultar operadora3:", err);
        reply("Erro ao consultar a operadora. Tente novamente mais tarde.");
    }
}
break;

case "operadora": {
    if (!q) {
        return reply("Você precisa fornecer um número para consultar.");
    }

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/operadora?numero=${encodeURIComponent(q)}`);
        
        if (!data?.mensagem) {
            return reply("Não foi possível identificar a operadora.");
        }

        let resposta =
            `📲 *CONSULTA DE OPERADORA* 📲\n` +
            `• Resultado: ${data.mensagem}\n\n` +
            `• Usuário: ${pushname}\n` +
            `• Bot: ${NomeDoBot}`;

        reply(resposta);
    } catch (err) {
        console.error("Erro ao consultar operadora:", err);
        reply("Erro ao consultar a operadora. Tente novamente mais tarde.");
    }
}
break;
case "operadora2":
{
    if (!q) {
        return reply("Você precisa fornecer um número de telefone para consulta.");
    }

    try {
        const telefone = q.replace(/\D/g, ''); // Remove caracteres não numéricos
        if (telefone.length < 10 || telefone.length > 11) {
            return reply("Por favor, forneça um número de telefone válido com 10 ou 11 dígitos.");
        }

        const res = await fetchJson(`https://api.zero-two.online/api/operadora?numero=55${telefone}&apikey=alucard`);
        //by luan

        if (!res || res.status !== 200) {
            return reply("Nenhum dado encontrado para o telefone fornecido.");
        }

        const { telefone: telefoneInfo, operadora: operadoraInfo, dispositivo: dispositivoInfo, estado: estadoInfo } = res.resultado;

        const message = `*Informações do Telefone ${telefoneInfo}:*\n` +
                        `- Operadora: ${operadoraInfo}\n` +
                        `- Dispositivo: ${dispositivoInfo}\n` +
                        `- Estado: ${estadoInfo}\n\n` +
                        `- Usuário: ${pushname}\n` +
                        `- Bot: ${NomeDoBot}`;

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a operadora:", error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
// fim das consultas 
//===========(ADMS-FUNÇÕES-AKI)=========\\

case 'raizq': case 'raizquadrada':
if(!Number(q.replace("√", ""))) return reply("Retorne após o comando o número que você quer encontrar a raiz quadrada")
radical = Number(q.replace("√", ""))
if(!raiz(radical)) {
  divi = divisores(radical)
  if(divi.length <= 0) return reply("Nenhum divisor encontrado...")
  primeiro = []
  for(a of divi) {
    if(raiz(a)) primeiro.push({search: a, resultado: findRaiz(a)})
  }
  if(primeiro.length <= 0) return reply("Nenhuma raiz encontrada...")
  result_x = primeiro[primeiro.length - 1].resultado
  resto = radical / primeiro[primeiro.length - 1].search
  dividir = divisores(resto)
  if(divisores.length > 0) {
    segundo = []
    for(b of dividir) {
      if(raiz(b)) segundo.push({search: b, resultado: findRaiz(b)})
    }
    if(segundo.length > 0) {
      result_x *= segundo[segundo.length - 1].resultado
      result_x += `√` + (resto / segundo[segundo.length - 1].search)
    } else result_x += `√` + resto
  } else result_x += `√` + resto
} else result_x = findRaiz(radical)
reply(`🧮 _Segundo meus cálculos, a √${q.replace("√", "")} é -> *"${result_x}"*_ ヅ`)
break

case 'bhaskara':
if(!q) return reply(`Retorne a equação quadrática após o comando (use a variável "x", exemplo: ${prefix+command} 2x²+4x+2 = 0)`)
a = Number(q.replace("x²", "x2").split("x2")[0])
b = Number(q.replace("x²", "x2").split("x2")[1].split("x")[0])
c = Number(q.split("x")[2].split("=")[0])
txt = `∆ = b² - 4 • a • c
∆ = ${b}² - 4 • ${a} • ${c}
∆ = ${b*b} ${Number(-4*a*c) >= 0 ? `+${-4*a*c}` : -4*a*c}
∆ = ${Number(b*b) + Number(-4*a*c)}
`
delta = Number(b*b) + Number(-4*a*c)
if(delta < 0) return reply("A equação não possui raiz")
raiz = []
for(i = 0; i < Number(delta/2); i++) {
if(Number(i*i) === delta) {
raiz.push(i)
}
}
if(delta != 0 && raiz.length <= 0) return reply(`√${delta} não encontrada`)
txt += `
x = -b ±√∆
         2 • a
x = -(${b}) ±√${delta}
         2 • ${a}
`
if(delta > 0) {
txt += `
x = ${b*Number(-1)} ±${raiz[0]}
         ${a*2}
x' = ${b*Number(-1)} + ${raiz[0]}
         ${a*2}
x' = ${Number(b*Number(-1)) + Number(raiz[0])}
         ${a*2}
x' = ${Number(Number(b*Number(-1)) + Number(raiz[0])) / Number(a*2)}

x'' = ${b*Number(-1)} - ${raiz[0]}
         ${a*2}
x'' = ${Number(b*Number(-1)) - Number(raiz[0])}
         ${a*2}
x'' = ${Number(Number(b*Number(-1)) - Number(raiz[0])) / Number(a*2)}

$ = {${Number(Number(b*Number(-1)) + Number(raiz[0])) / Number(a*2)}, ${Number(Number(b*Number(-1)) - Number(raiz[0])) / Number(a*2)}}`
} else {
txt += `x = ${b*Number(-1)}
       ${a*2}
x = ${Number(b*Number(-1)) / Number(a*2)}
`
}
reply(txt)
break

case 'calculadora':
case 'calcular':  
case 'calc':
case 'math':
if(!q) return reply(`KD a conta matemática pá eu fazer ?`)
rsp = q.replace("x", "*").replace('"', ":").replace(new RegExp("[()abcdefghijklmnopqrstwuvxyz]", "gi"), "").replace("÷", "/")
return reply(JSON.stringify(eval(rsp, null,'\t')))
break 

case 'nomegp':
setTimeout(() => {reagir(from, react2)}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!q) return reply(`Escreva o novo nome do grupo`)
blat = args.join(" ")
blackmd.groupUpdateSubject(from, `${blat}`)
blackmd.sendMessage(from, {text: `🙇🏻‍♂️ *Ok alteza, o nome do grupo foi alterado para:* ${q}`}, {quoted: seloctt})
break

case 'chatblack':
reagir(from, react2)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
blackmd.groupUpdateSubject(from, `༒ ɓℓα૮ҡ ɓσƭ ૮ɦαƭ ༒`)
blackmd.sendMessage(from, {text: `*_Nome do chat atualizado ✅_*`}, {quoted: seloctt})
break

case 'descgp':
case 'descriçãogp':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.adm)
if(!q) return reply(`Escreva a nova bio do grupo`)
blabla = args.join(" ")
blackmd.groupUpdateDescription(from, `${blabla}`)
blackmd.sendMessage(from, {text: 'Sucesso, alterou a descrição do grupo'}, {quoted: seloctt})
break

case 'setfotogp':
case 'fotogp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isQuotedImage) return reply(`Use: ${prefix + command} <Marque uma foto>`)
ftgp = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(ftgp.mimetype))
buffimg = await getFileBuffer(ftgp, 'image')
fs.writeFileSync(rane, buffimg)
medipp = rane 
blackmd.updateProfilePicture(from, {url: medipp})
reply(`Foto do grupo alterada com sucesso`) 
break

case 'linkgp':
case 'linkgrupo':
reagir(from, "✅")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
try {
var matheuzinho = await blackmd.profilePictureUrl(from, 'image')
} catch {
var matheuzinho = `https://telegra.ph/file/6ca032835ed7a16748b6f.jpg`
}
linkgc = await blackmd.groupInviteCode(from)
blackmd.sendMessage(from, {text: '*_Aqui está o link do grupo⧽_*\n\nhttps://chat.whatsapp.com/'+linkgc, contextInfo: {
  externalAdReply: {
    title: groupName,
    body: ``,
    thumbnail: await getBuffer(matheuzinho),
    mediaType: 1,
    showAdAttribution: true,
    sourceUrl: 'https://chat.whatsapp.com/'+linkgc
  }
}}, {quoted: seloctt})
break

case 'novolink':
case 'nlink':
case 'redefinir':
setTimeout(() => {reagir(from, "🧵")}, 300)
if (!isGroupAdmins) return reply(enviar.msg.adm)
if (!isGroup) return reply(enviar.msg.grupo)
if (!isBotGroupAdmins) return reply(enviar.msg.Badmin)
try {
await blackmd.groupRevokeInvite(from)
await sleep(1000)
link = await blackmd.groupInviteCode(from)
sendButton(from, {text: `[❗] link redefinido com sucesso 💢`, footer: NomeDoBot}, blackmd, sender, [{type: `copy_text`, text: `🥏 𝙇𝙄𝙉𝙆 𝘼𝙌𝙐𝙄 🎳`, url: `https://chat.whatsapp.com/`+link}], seloctt)
} catch(e) { console.log(e)
reply("Erro ao tentar redefinir o link") }
break

case 'recrutar': case 'convidar':
setTimeout(() => {reagir(from, "🫡")}, 300)
if(!isGroupAdmins || !isVip) return reply("[ ❗ ] *precisa ser ADM e VIP* ❌")
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!marc_tds) return reply(`Marque um usuário com o comando ${prefix+command}, a mensagem, o @ ou o número.`)
try {
getlink = `https://chat.whatsapp.com/` + (await blackmd.groupInviteCode(from))
} catch(e) {console.log(e)
return reply(`Não foi possível pegar o link do grupo...`)}
try { ftgpcmd = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(from, 'image'))}`)).data
} catch { ftgpcmd = semfoto }
if(command == `convidar` && botoes) {
try { ftusu = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(marc_tds.split('@')[0]+`@c.us`, 'image'))}`)).data
} catch(e) { ftusu = semfoto }
img = `https://blacksystemofc.com.br/api/canvas/jxr/welcome?nome=${getname(marc_tds)}&guilda=${groupName}&perfil=${ftgpcmd}&membro=${groupMembers.length + 1}&avatar=${ftusu}&fundo=`+dataGp[0].wellcome[0].fundobemvindo
} else { img = ftgpcmd }
txt = `${tempo} @${marc_tds.split(`@`)[0]}, o ${isGroupAdmins ? `ADM` : `membro VIP`} @${sender.split(`@`)[0]} te convidou para entrar no grupo ${groupName}... Clique no link acima/abaixo caso queira participar 🥰`
enviado = `${command == `recrutar` ? `Recrutamento` : `Convite`} para se juntar ao grupo ${groupName} enviado no PV do @${marc_tds.split("@")[0]} com sucesso ✔`
if(!botoes) { sendUrlText(marc_tds, txt, groupName, ``, img, getlink)
await sleep(1000)
return mention(enviado) }
try { linkgp = (await axios.get(`https://tinyurl.com/api-create.php?url=${getlink}`)).data
} catch(e) {console.log(e)
return reply(`Não foi possível converter o link do grupo...`)}
sendButton(marc_tds, {image: {url: img}, caption: txt, footer: NomeDoBot, mentions: [marc_tds, sender]}, blackmd, sender, [{type: `copy_url`, text: `CLIQUE AQUI 🥏`, url: linkgp}])
await sleep(1000)
mention(enviado)
break

case 'listatm':
if(!isOwner) return reply(enviar.msg.dono)
rgp = JSON.parse(fs.readFileSync("./basedefuncionamento/TMGP.json"))
if(rgp.length == 0) return reply(`Não contém nenhum registro de transmissão, utilize ${prefix}rgtm no grupo que deseja que ele receba as transmissões do bot..`)
bl = `✧͜͡҉𝙂𝙍𝙐𝙋𝙊𝙎-𝙍𝙀𝙂𝙄𝙎𝙏𝙍𝘼𝘿𝙊𝙎
________________________________________\n\n`;
for ( i = 0; i < rgp.length; i++) {
bl += `»${i+1}«
ೈ፝͜͡𝙄𝘿: ${rgp[i].id}
ೈ፝͜͡𝙉𝙊𝙈𝙀: ${rgp[i].infonome}
________________________________________\n\n`
}
bl += `*By:* ${NomeDoBot}`
reply(bl)
break

case 'rgtm':
if(!isOwner) return reply(enviar.msg.dono)
rgp = JSON.parse(fs.readFileSync("./basedefuncionamento/TMGP.json"))
if(JSON.stringify(rgp).includes(from)) return reply("Mas eu já registrei esse grupo ;-;") 
rgp.push({id: from, infonome: `${isGroup ? groupName: pushname}`})
fs.writeFileSync("./basedefuncionamento/TMGP.json", JSON.stringify(rgp))
reply("*Grupo registrado com sucesso meu mestre* 🙇🏻‍♂️")
break

case 'tirardatm':
case 'deltm':
if(!isOwner) return reply(enviar.msg.dono)
rgp = JSON.parse(fs.readFileSync("./basedefuncionamento/TMGP.json"))
if(q.trim().length > 4) {
var ustm = rgp.map(i => i.id).indexOf(q.trim())
} else {
var ustm = rgp.map(i => i.id).indexOf(from)
}
if(!JSON.stringify(rgp).includes(ustm)) return reply("Não tem como eu tirar da lista um grupo que não está na lista ;-;")
rgp.splice(ustm, 1)
fs.writeFileSync("./basedefuncionamento/TMGP.json", JSON.stringify(rgp))
reply("*Ok mestre... Este grupo não será mais notificado em transmissões futuras* 🫡")
break

case 'fazertm':
case 'tm':
if(!isOwner) return reply(enviar.msg.dono)
var rgp = JSON.parse(fs.readFileSync("./basedefuncionamento/TMGP.json"))
if(rgp.length == 0) return reply("Não contém nenhum grupo registrado para realizar transmissão") 
await sleep(1000);
var DFC = "";
var rsm = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var pink = isQuotedImage ? rsm?.imageMessage: info.message?.imageMessage
var blue = isQuotedVideo ? rsm?.videoMessage: info.message?.videoMessage
var red = isQuotedMsg ? rsm?.textMessage: info.message?.textMessage
var purple = isQuotedDocument ? rsm?.documentMessage: info.message?.documentMessage
var yellow = isQuotedDocW ? rsm?.documentWithCaptionMessage?.message?.documentMessage: info.message?.documentWithCaptionMessage?.message?.documentMessage
var aud_d = isQuotedAudio ? rsm.audioMessage : ""
var figu_d = isQuotedSticker ? rsm.stickerMessage : ""
var red = isQuotedMsg && !aud_d &&!figu_d && !pink && !blue&& !purple && !yellow? "⚠️ *TRANSMISSÃO DO BLACK* ⚠️\n\n"+rsm.conversation: info.message?.conversation
var green = isQuotedMsg2 && !aud_d &&!figu_d && !red && !pink && !blue && !purple && !yellow ? "⚠️ *TRANSMISSÃO DO BLACK* ⚠️\n\n"+rsm.extendedTextMessage?.text : info?.message?.extendedTextMessage?.text
/*var MRC_TD = groupMembers.map(i => i.id)*/
if(pink) {
var DFC = pink
pink.caption = q.length > 1 ? "⚠️ *TRANSMISSÃO DO BLACK* ⚠️\n\n"+q : pink.caption.replace(new RegExp(prefix+command, "gi"), `⚠️ *TRANSMISSÃO DO BLACK* ⚠️\n\n`)
pink.image = {url: pink.url}
} else if(blue) {
var DFC = blue  
blue.caption = q.length > 1 ? "⚠️ *TRANSMISSÃO DO BLACK* ⚠️\n\n"+q : blue.caption.replace(new RegExp(prefix+command, "gi"), `⚠️ *TRANSMISSÃO DO BLACK* ⚠️\n\n`)
blue.video = {url: blue.url}
} else if(red) {
black = {}
black.text = red.replace(new RegExp(prefix+command, "gi"), `⚠️ *TRANSMISSÃO DO BLACK* ⚠️\n\n`)
/*black.mentions = MRC_TD*/
var DFC = black
} else if(!aud_d && !figu_d && green) {
brown = {}
brown.text = green.replace(new RegExp(prefix+command, "gi"), `⚠️ *TRANSMISSÃO DO BLACK* ⚠️\n\n`)
var DFC = brown
} else if(purple) {
var DFC = purple
purple.document = {url: purple.url} 
} else if(yellow) {
var DFC = yellow 
yellow.caption = q.length > 1 ? "⚠️ *TRANSMISSÃO DO BLACK* ⚠️\n\n"+q : yellow.caption.replace(new RegExp(prefix+command, "gi"), `⚠️ *TRANSMISSÃO DO BLACK* ⚠️\n\n`)
yellow.document = {url: yellow.url}  
} else if(figu_d) {
var DFC = figu_d
figu_d.sticker = {url: figu_d.url}
} else if(aud_d) {
var DFC = aud_d
aud_d.audio = {url: aud_d.url}
}
for (i = 0; i < rgp.length; i++) {
blackmd.sendMessage(rgp[i].id, DFC)}
reply(`*Mensagem enviada para todos os ${rgp.length} grupos presentes na lista* 🫡`)
break

case 'abrirgp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return (enviar.msg.Badmin)
if(!q) return reply(`Retorne após o comando o tempo em que o grupo abrirá, seguindo os exemplos:
${prefix+command} 12:00 _(horário exato)_
ou
${prefix+command} 4h _(daqui a 4 horas a frente)_`)
letra = q.slice(q.length - 1, q.length).toLowerCase()
if(letra == `s`) {
  nmr = Number(q.slice(0, q.length - 1))
  mention(`*Sucesso @${sender.split("@")[0]}, o grupo ${groupName} será aberto em ${q}* ✔`)
  setTimeout(async() => {
    blackmd.groupSettingUpdate(from, 'not_announcement')
    await sleep(2500)
    blackmd.sendMessage(from, {text: `[❕] *O grupo foi aberto com sucesso após ${q}* ✔`})
  }, nmr * 1000);
} else {
  addOpenCloseGP(from, q, sender, `open`)
  last = getLastOpenCloseGP(from)
  day = last.dias
  mention(`*Sucesso @${sender.split("@")[0]}, o grupo ${groupName} será aberto ${last.dias > 0 ? sendFutureTime([{valor: last.dias, type: `days`}]).toLowerCase().split(` `)[0] + ` ` : ``}às ${last.hora}* ✔`)
}
break

case 'fechargp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return (enviar.msg.Badmin)
if(!q) return reply(`Retorne após o comando o tempo em que o grupo fechará, seguindo os exemplos:
${prefix+command} 12:00 _(horário exato)_
ou
${prefix+command} 4h _(daqui a 4 horas a frente)_`)
letra = q.slice(q.length - 1, q.length).toLowerCase()
if(letra == `s`) {
  nmr = Number(q.slice(0, q.length - 1))
  mention(`*Sucesso @${sender.split("@")[0]}, o grupo ${groupName} será fechado em ${q}* ✔`)
  setTimeout(async() => {
    blackmd.groupSettingUpdate(from, 'announcement')
    await sleep(2500)
    blackmd.sendMessage(from, {text: `[❗] *O grupo foi fechado com sucesso após ${q}* ❌`})
  }, nmr * 1000);
} else {
  addOpenCloseGP(from, q, sender, `close`)
  last = getLastOpenCloseGP(from)
  day = last.dias
  mention(`*Sucesso @${sender.split("@")[0]}, o grupo ${groupName} será fechado ${last.dias > 0 ? sendFutureTime([{valor: last.dias, type: `days`}]).toLowerCase().split(` `)[0] + ` ` : ``}às ${last.hora}* ⏱`)
}
break
case 'clima2':
case 'Cuaca':
case 'cuaca':
    if (!q) {
        return blackmd.sendMessage(from, { text: '[⚙️] Por favor, envie o nome da cidade. Exemplo: !clima Fortaleza' }, { quoted: info });
    }

    const cidadeClima = encodeURIComponent(q);
    const apiClima = `https://api.ownblox.biz.id/api/cuaca?kota=${cidadeClima}`;

    try {
        const responseClima = await axios.get(apiClima);

        if (responseClima.data.status === 200 && responseClima.data.result) {
            const clima = responseClima.data.result;
            let mensagemClima = `🌎 Clima para: ${clima.kota}\n\n`;
            mensagemClima += `🕐 Zona Horária: ${clima.zona_waktu}\n`;
            mensagemClima += `🌡️ Temperatura: ${clima.suhu}\n`;
            mensagemClima += `🌧️ Condição: ${clima.kondisi}\n`;
            mensagemClima += `💧 Umidade: ${clima.kelembaban}\n`;
            mensagemClima += `💨 Vento: ${clima.angin}\n`;
            mensagemClima += `⚙️ Pressão: ${clima.tekanan !== "undefined mb" ? clima.tekanan : "Indefinido"}\n`;

            blackmd.sendMessage(from, { text: mensagemClima.trim() }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não consegui obter informações do clima.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao consultar clima:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao tentar consultar o clima.' }, { quoted: info });
    }
    break;
case 'clima':
clime = [ "☁️", "⛅", "⛈️", "🌤️", "🌥️", "🌦️", "🌧️", "🌨️", "🌩️"]
setTimeout(() => {reagir(from, clime[Math.floor(Math.random() * clime.length)])}, 300)
if (!q) return reply(`Use ${prefix + command} cidade`)
reply(`Pesquisando clima de ${q} ${clime[Math.floor(Math.random() * clime.length)]}`)
qq = q.normalize('NFD').replace(/[\u0300-\u036f]/g, "").toLowerCase().trim()
clima = await axios.get(`https://api.openweathermap.org/data/2.5/weather?q=${qq}&appid=1d0bdf08a222f8f2da252ef8921ff4ab&units=metric&lang=pt_br`)
if (clima.error) return reply(clima.error)
hora1 = moment.tz('America/Sao_Paulo').format('HH:mm');
date10 = moment.tz('America/Sao_Paulo').format('DD/MM');
if(isGroup) {
climanmr = groupMembers.length * groupAdmins.length + somembros.length
} else {
climanmr = 0.4
}
matheuzinho = `
🌪️ _CLIMA_ 🌪️
*▧⃯⃟📅⃤ Data:* ${date10}
*▧⃯⃟🌎⃤ Cidade:* ${clima.data.name}
*┌───────────────────┐*
*│▧⃯⃟🌡️⃤ Temperatura:* ${clima.data.main.temp.toFixed()}ºC
*│▧⃯⃟🔺⃤ Temp. Max:* ${clima.data.main.temp_max.toFixed()}ºC
*│▧⃯⃟🔻⃤ Temp. Min:* ${clima.data.main.temp_min.toFixed()}ºC
*│▧⃯⃟🌦️⃤ Clima:* ${clima.data.weather[0].description}
*│▧⃯⃟💧⃤ Umidade: ${clima.data.main.humidity}%*
*└───────────────────⃤*
ㅤㅤㅤㅤ〘 ${hora1}h 〙
`
await blackmd.sendMessage(from, {
   document: Buffer.from('oi curioso'),
   caption: matheuzinho,
   mimetype: 'application/pdf', // Formato
   fileName: `PREV. DO TEMPO ${clime[Math.floor(Math.random() * clime.length)]}`,
   fileLength: 100000000 * climanmr, // Tamanho (250mb)
   contextInfo: {
    externalAdReply: {
      title: NomeDoBot,
      body: '',
      mediaType: 1,
      thumbnail: await getBuffer(logoslink.menu), // só pega imagens até 300x300 
      showAdAttribution: true, // Coloca true para enviada como anúncio 
      renderLargerThumbnail: true, // Deixa a imagem grande
      sourceUrl: '${site}' // Link que aparece quando aperta
    }
  }
})
break

case 'grupo': case 'gp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!q) return sendListB(from, {text: `*Selecione abaixo a opção para abrir/fechar o grupo* ${groupName} 🙏🏼😔`, footer: `_Clique na lista abaixo para selecionar..._`}, blackmd, sender, `♨️ CLIQUE AQUI ♨️`, [{title: `O grupo ${groupName} está ${groupMetadata.announce ? "fechado" : "aberto"}...`, options: [
{title: "ABRIR GRUPO 🔓", body: NomeDoBot, command: prefix+command+" a"},
{title: "FECHAR GRUPO 🔒", body: NomeDoBot, command: prefix+command+" f"}
]}], seloctt)
if(args[0] === 'a') {
if(!groupMetadata.announce) return reply(`O grupo já está aberto...`)
setTimeout(() => {reagir(from, "✅")}, 300)
reply(`*GRUPO ABERTO COM SUCESSO* ✅`)
abrirgp(from) } else if(args[0] === 'f') {
if(groupMetadata.announce) return reply(`O grupo já está fechado...`)
setTimeout(() => {reagir(from, "❌")}, 300)
reply(`*GRUPO FECHADO COM SUCESSO* ❌`)
fechargp(from) }
break

case 'revelafoto':
case 'rft':
setTimeout(() => {reagir(from, "🕵🏻‍♂️")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
try {
var rft = await blackmd.profilePictureUrl(from, 'image')
} catch {
var rft = `https://telegra.ph/file/6ca032835ed7a16748b6f.jpg`
}
blackmd.sendMessage(from, {image: {url: rft}, caption: groupName}, {quoted: seloctt})
break

case 'grupoinfo':
case 'infogrupo':
case 'infogp':  
case 'gpinfo':  
case 'regras':
setTimeout(() => {reagir(from, "💬")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
try {ppUrl = await blackmd.profilePictureUrl(from, 'image')
} catch {ppUrl = semfoto}
grupodb = await blackmd.groupMetadata(from)
txt = `💬 *NOME ↴*
『 ${groupName} 』
🧸 *MEMBROS:* »${groupMembers.length}«
⚜️ *ADMs:* »${groupAdmins.length}«

_DADOS EM GERAL_
🔒 » GRUPO ESTÁ *${grupodb.announce ? `FECHADO` : `ABERTO`}* «
🖍 » MEMBROS *${grupodb.restrict ? `NÃO ` : ``}PODEM* EDITAR OS DADOS DO GRUPO «
👥 » GRUPO *${grupodb.isCommunity ? `` : `NÃO `}ESTÁ* EM COMUNIDADE «
✅ » APROVAÇÃO DE ADMINS PARA ENTRAR NO GRUPO *${grupodb.joinApprovalMode ? `` : `DES`}ATIVADA* «
📤 » MEMBROS *${grupodb.memberAddMode ? `` : `NÃO `}PODEM* ADICIONAR NOVOS USUÁRIOS «

✒️ *DESCRIÇÃO ↴*
${groupDesc || `\"não listada\"`}`
blackmd.sendMessage(from, {image: {url: ppUrl}, caption: txt, contextInfo: {forwardingScore: Number(sendHours(`HHmm`)), isForwarded: true}}, {quoted: seloblk})
break

case 'totag':
case 'cita':
case 'hidetag':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!menc_prt && !q) return reply("Marque uma imagem, vídeo, áudio ou escreva algo para p bot retornar a mesma mensagem marcando todos os membros do grupo")
var DFC = "";
var rsm = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var pink = isQuotedImage ? rsm?.imageMessage: info.message?.imageMessage
var blue = isQuotedVideo ? rsm?.videoMessage: info.message?.videoMessage
var purple = isQuotedDocument ? rsm?.documentMessage: info.message?.documentMessage
var yellow = isQuotedDocW ? rsm?.documentWithCaptionMessage?.message?.documentMessage: info.message?.documentWithCaptionMessage?.message?.documentMessage
var aud_d = isQuotedAudio ? rsm.audioMessage : ""
var figu_d = isQuotedSticker ? rsm.stickerMessage : ""
var red = isQuotedMsg && !aud_d && !figu_d && !pink && !blue&& !purple && !yellow? rsm.conversation: info.message?.conversation
var green = rsm?.extendedTextMessage?.text || info?.message?.extendedTextMessage?.text
var MRC_TD = groupMembers.map(i => i.id)
if(pink && !aud_d && !purple) {
var DFC = pink
pink.caption = q.length > 1 ? q :pink.caption.replace(new RegExp(prefix+command, "gi"), ``)
pink.image = {url: pink.url}
pink.mentions = MRC_TD
} else if(blue && !aud_d && !purple) {
var DFC = blue  
blue.caption = q.length > 1 ? q.trim() :blue.caption.replace(new RegExp(prefix+command, "gi"), ``).trim()
blue.video = {url: blue.url}
blue.mentions = MRC_TD
} else if(red && !aud_d && !purple) {
black = {}
black.text = red.replace(new RegExp(prefix+command, "gi"), ``).trim()
black.mentions = MRC_TD
var DFC = black
} else if(!aud_d && !figu_d && green && !purple && !purple) {
brown = {}
brown.text = green.replace(new RegExp(prefix+command, "gi"), ``).trim()
brown.mentions = MRC_TD
var DFC = brown
} else if(purple) {
var DFC = purple
purple.document = {url: purple.url}
purple.mentions = MRC_TD
} else if(yellow && !aud_d) {
var DFC = yellow 
yellow.caption = q.length > 1 ? q.trim() :yellow.caption.replace(new RegExp(prefix+command, "gi"), ``).trim()
yellow.document = {url: yellow.url}
yellow.mentions = MRC_TD
} else if(figu_d && !aud_d) {
var DFC = figu_d
figu_d.sticker = {url: figu_d.url}
figu_d.mentions = MRC_TD
} else if(aud_d) {
var DFC = aud_d
aud_d.audio = {url: aud_d.url}
aud_d.mentions = MRC_TD
aud_d.ptt = true
}
blackmd.sendMessage(from, DFC).catch(e => {
console.log(e)
})
break

case 'marcar': case 'marcar2': case 'marcarwa':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
come = command == "marcarwa" ? "wa.me/" : "</> @"
if(somembros.length <= 0) return reply(`${tempo} ${pushname}

_Não foram encontrados membros no grupo_『 ${groupName} 』... _Apenas_ [ *ADMINISTRADORES* ]
_Caso queira marcar os adms, use_ ${prefix}adms`)
txt = q ? q+`\n\n` : ``
txt += somembros.map(i => come+i.split("@")[0]).join("\n")
if(command == "marcar2") sendAudio(from, `./database/audios/marcar/${alerandom(3)+1}.m4a`, `audio/mp4`, seloctt)
await sleep(700)
mention(txt)
break

case 'reviverqr':
case 'limparqr':
if(!isOwner) return reply(enviar.msg.dono)
qrpath = "./basededados/BLACKMD-QR"
fs.readdir(qrpath, (err, files) => {
  if(err) {
    console.error("Erro ao listar arquivos:", err);
    reply("Erro ao listar arquivos.");
  } else {
    let count = 0;
    files.forEach((file) => {
      if(file.startsWith("pre-key") || file.startsWith("sender-key") || file.startsWith("session-")) {
        fs.unlink(path.join(qrpath, file), (err) => {
          if(err) {
            console.error(`Erro ao excluir ${file}:`, err);
          } else {
            console.log(`${file} excluído com sucesso.`);
            count++;
          }
        });
      }
    });
    reply("*PODE DEIXAR MESTRE*🎖️\n\n⇒ Reiniciando..")
    setTimeout(async () => {
      process.exit()
    }, 1000)
  }
});
break

case 'reviver':
setTimeout(() => {reagir(from, "✅")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(`Tá afim de banir o número do bot é ?`)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('Marque uma mensagem do alvo!')
sleep(5000)
response2 = await blackmd.groupParticipantsUpdate(from, [menc_prt], "add" )
reply(`Usuário revivido com sucesso... 😰`)
break

case 'add':
setTimeout(() => {reagir(from, "✅")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(`Tá afim de banir o número do bot é ?`)
if(!q) return reply("KD o número do indivíduo ?")
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
try {
usu = q + "@s.whatsapp.net"
blackmd.groupParticipantsUpdate(from, [usu], "add" )
reply("✅ Usuário adicionado ao grupo com sucesso...")
} catch {
reply("Erro 404")
}
break

case 'addgp':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`Hmmm`)
if(!Number(q)) return reply("Apenas números")
reagir(from, "🙂")
var getGroups = await blackmd.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
var ingfoo = groups.map(v => v)
try {
blackmd.groupParticipantsUpdate(ingfoo[q].id, [nmrdn], "add" )
setTimeout(() => {
blackmd.groupParticipantsUpdate(ingfoo[q].id, [nmrdn], "promote")
blackmd.sendMessage(ingfoo[q].id, {text: "*Bem vindo meu senhor* 🙇🏻‍♂️"})
}, 5000)
} catch(erro) {
reply(String(erro))
}
break

case 'sairgp':
case 'sair':
if(isGroup && !isOwner && !info.key.fromMe) return reply("Este comando só o bot ou o dono pode executar..")
try {
blackmd.groupLeave(from)
} catch(erro) {
reply(String(erro))
}
break

case 'seradm':
setTimeout(() => {reagir(from, "🫡")}, 300)
if(!isOwner && !isnit) return reply(enviar.msg.dono)
mentions(`Ok meu senhor @${sender.split("@")[0]}, agora você é um ADM do grupo 🙇🏻‍♂️`, [sender], true)
blackmd.groupParticipantsUpdate(from, [sender], "promote")
break

case 'sermembro':
setTimeout(() => {reagir(from, "🥲")}, 300)
if(!isOwner && !isnit) return reply(enviar.msg.dono)
mentions(`Pronto mestre @${sender.split("@")[0]}, rebaixei o senhor para membro comum no grupo ${groupName} 🥹`, [sender], true)
blackmd.groupParticipantsUpdate(from, [sender], "demote")
break

case 'advertir':
case 'adverter': 
case 'adv':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!menc_os2) return reply("Marque o alvo que você deseja advertir")
if(menc_os2 == botNumber) return reply("Não pode advertir o próprio bot...");
if(menc_os2 == nmrdn) return reply("Não pode advertir o próprio dono do bot");
if(groupAdmins.includes(menc_os2)) return reply("Não pode advertir ADMS..");
AB = ADVT.map(i => i.id).indexOf(menc_os2)
if(AB >= 0) {
  if(ADVT[AB].adv < 2) {
    ADVT[AB].adv += 1
    setGp(dataGp)
    return mention(`[❗] Atenção @${menc_os2.split("@")[0]}, você já foi advertido ${ADVT[AB].adv} vezes... Na próxima é ban ❌`)
  } else {
    mention(`Este foi seu aviso final @${menc_os2.split(`@`)[0]}... Por não atentar as suas advertências, te darei um ban de presente 🥰`)
    ADVT.splice(AB, 1)
    setGp(dataGp)
    await sleep(3000)
    return remover(from, menc_os2)
  }
} else {
  ADVT.push({id: menc_os2, adv: 1})
  setGp(dataGp)
  return mention(`[❗] Atenção @${menc_os2.split("@")[0]}, você foi advertido... Tome cuidado, pois 3 adv resultarão em banimento ❌`)
}
break

case 'rmadv':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!marc_tds) return reply("KD o alvo que você deseja retirar a advertência")
AB = ADVT.map(i => i.id).indexOf(marc_tds)
if(AB < 0) return reply("Não há advertências neste usuário")
ADVT.splice(AB, 1)
setGp(dataGp)
reply("Advertência retirada com sucesso...")
break

case 'advlist':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(ADVT.length <= 0) return reply(`Não há membros com advertência neste grupo...`)
mention(`🗂 Lista de usuários com advt neste grupo:
${ADVT.map(i => `»${ADVT.map(a => a.id).indexOf(i.id) + 1}«
👤 *Usuário:* @${i.id.split("@")[0]}
⚠ *Advertência:* ${i.adv}`).join(`\n-\n`)}`)
break

//======≠(INFOS/EXECUÇÃO/DONO)≠=========\\

case 'apresentar':
case 'apr':  
if(!isGroupAdmins) return reply(enviar.msg.adm)
inff = `Bem vindo(a) ao grupo : ${groupName}


👾 •𝑬𝑵𝑻𝑹𝑶𝑼 𝑺𝑬 𝑨𝑷𝑹𝑬𝑺𝑬𝑵𝑻𝑨•
📸 •F𝜣T𝜣
👻 •N𝜣ME
📌 •CID∆DE
🗓️ •ID∆DE
⚠️ •LEI∆ ∆S REGR∆S D𝜣 GRUP𝜣

*APROVEITE O GRUPO!*`
blackmd.sendMessage(from, {text: inff}, {quoted: selo})
break

case 'papof':
case 'regraspp':  
if(!isGroupAdmins) return reply(enviar.msg.adm)
txtz = `【᯽𒋨📷:𝑆𝑒 𝑎𝑝𝑟𝑒𝑠𝑒𝑛𝑡𝑒𝑚 𝑙𝑖𝑥𝑜𝑠🌚»°】
𒋨·࣭࣪̇🔥ɴᴏᴍᴇ:
𒋨·࣭࣪̇🔥ɪᴅᴀᴅᴇ:
𒋨·࣭࣪̇🔥ʀᴀʙᴀ:
*Aᴘʀᴇsᴇɴᴛᴇ-sᴇ sᴇ ǫᴜɪsᴇʀ.*
𝙏𝘼𝙂𝙎➭᜔ׂ࠭ ⁸₈⁸|𝟖𝟖𝟖|𝟠𝟠𝟠| ེི⁸⁸⁸
 ──╌╌╌┈⊰★⊱┈╌╌╌┈─
❌ ENTROU NO 
GRUPO INTERAJA, NÃO PRECISAMOS DE ENFEITES,INATIVOS SERAO REMOVIDOS ❌* 

/﹋<,︻╦╤─ ҉ - -----💥 
/﹋ 🅴 🅱🅴🅼 🆅🅸🅽🅳🅾 🆂🅴🆄🆂 🅵🅸🅻🅷🅾🆂 🅳🅰 🅿🆄🆃🅰`
blackmd.sendMessage(from, {text: txtz}, {quoted: selo})
break

case 'digt':
if(!isGroupAdmins) return reply(enviar.msg.adm)
bla = `🔥↯𝐉𝐀 𝐄𝐍𝐓𝐑𝐀 𝐃𝐈𝐆𝐈𝐓𝐀𝐍𝐃𝐎 𝚽𝐈 ↯°🌚💕
           ི⋮ ྀ🌴⏝ ི⋮ ྀ🚸 ི⋮ ྀ⏝🌴 ི⋮ ྀ 

🐼🍧↯𝖠𝖰𝖴𝖨 𝖵𝖮𝖢𝖤̂ 𝖯𝖮𝖣𝖤 𝖲𝖤𝖱↯🍧🐻
ㅤㅤㅤㅤ  ◍۫❀⃘࣭࣭࣭࣭ٜꔷ⃔໑࣭࣭ٜ⟅◌ٜ🛸◌⟆࣭࣭ٜ໑⃕ꔷ⃘࣭࣭࣭࣭ٜ❀۫◍ི࣭࣭࣭࣭ ུ
    【✔】ᴘʀᴇᴛᴀ👩🏾‍🦱 【✔】ʙʀᴀɴᴄᴀ👩🏼
    【✔】ᴍᴀɢʀᴀ🍧【✔】ɢᴏʀᴅᴀ🍿
    【✔】ᴘᴏʙʀᴇ🪙 【✔】ʀɪᴄᴀ💳
    【✔】ʙᴀɪᴀɴᴀ💌【✔】ᴍᴀᴄᴏɴʜᴇɪʀᴀ🍁
    【✔】ᴏᴛᴀᴋᴜ🧧【✔】ᴇ-ɢɪʀʟ🦄
    【✔】ʟᴏʟɪ🍭    【✔】ɢᴀᴅᴏ🐃
    【✔】ɢᴀʏ🏳️‍🌈     【✔】ʟᴇsʙɪᴄᴀ✂️
    【✔】ᴠᴀᴅɪᴀ💄  【✔】ᴛʀᴀᴠᴇᴄᴏ🍌
                【✔】ɴɪɴɢᴜᴇᴍ ʟɪɢᴀ📵
. ☪︎ • ☁︎. . •.
【 𝐕𝐄𝐌 𝐆𝐀𝐋𝐄𝐑𝐀, 𝐒𝐄 𝐃𝐈𝐕𝐄𝐑𝐓𝐈𝐑 𝐄 𝐅𝐀𝐙𝐄𝐑 𝐏𝐀𝐑𝐓𝐄 𝐃𝐀 𝐅𝐀𝐌𝐈𝐋𝐈𝐀.】🥂`
blackmd.sendMessage(from, {text: bla}, {quoted: selo})
break

case 'wlcm':
if(!isGroupAdmins) return reply(enviar.msg.adm)
reply(`▁▂▃▄▅▆▇█ W̷E̷L̷C̷O̷M̷E̷ █▇▆▅▄▃▂▁
👻 ⏤͟͟͞͞ ꦿ𝙴𝚗𝚝𝚛𝚘𝚞 𝙹á 𝙲𝚑𝚎𝚐𝚊 𝚂𝚎 𝙰𝚙𝚛𝚎𝚜𝚎𝚗𝚝𝚊𝚗𝚍𝚘 𝙰í #numerodele#
📸⃤ 𝙁𝙊𝙏𝙊
✍🏼⃤ 𝙉𝙊𝙈𝙀
🧸⃤ 𝙄𝘿𝘼𝘿𝙀
🏘️⃤ 𝘾𝙄𝘿𝘼𝘿𝙀
💞⃤ 𝙍𝙀𝙇𝘼𝘾𝙄𝙊𝙉𝘼𝙈𝙀𝙉𝙏𝙊

▧⃯⃟⚠️ ݈݇─ 𝙰𝚝𝚎𝚗çã𝚘 𝙰𝚜 𝚁𝚎𝚐𝚛𝚊𝚜 𝙽𝚊 𝙱𝚒𝚘 𝙳𝚘 𝙶𝚛𝚞𝚙𝚘 𝙾𝚞 𝚅𝚊𝚒 𝙲𝚘𝚗𝚑𝚎𝚌𝚎𝚛 𝙾 𝙵𝚊𝚖𝚘𝚜𝚘 🤭`)
break

case 'joingp':
if(!isOwner) return reply('```SOMENTE MEU DONO LINDÃO```')
if(!JSON.stringify(bcgp).includes("mensagem")) {
  bcgp.push({tipo: "mensagem", msg: []})
  fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
}
if(!JSON.stringify(bcgp).includes("grupos")) {
  bcgp.push({tipo: "grupos", gps: []})
  fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
}
var [linkM4, msgM4] = q.split('|')
if(!linkM4) return reply('Insira um link de convite ao lado do comando.')
if(!msgM4) return reply(`Vejo que você não inseriu a mensagem que será enviada... Faça assim:\n${prefix+command} link do grupo/mensagem para enviar`)
var getGroups = await blackmd.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
var ingfoo = groups.map(v => v)
ingfoo.sort((a, b) => (a[0] < b.length))
if(!linkM4.includes('chat.whatsapp.com/')) return reply('Ops, verifique o link que você inseriu.')
link = linkM4.split('app.com/')[1]
AB = bcgp.map(i => i.tipo).indexOf("mensagem")
AC = bcgp.map(i => i.tipo).indexOf("grupos")
try {
for(i = 0; i < ingfoo.length; i++) {
  bcgp[AC].gps.push({groupId: ingfoo[i].id})
  fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
}
bcgp[AB].msg.push({txt: msgM4, cobrado: false})
fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
blackmd.groupAcceptInvite(`${link}`)
return reply(`Todos os grupos da lista foram salvos na pasta... Qualquer grupo que esteja fora da lista será tratado como indigno e réu de receber uma mensagem no PV de cada um dos seus membros`)
} catch(erro) {
if(String(erro).includes('not-authorized') ) {
reply('Não foi possível entrar no grupo.\nMotivo: Banimento.')
}
}
break

case 'delgp':
if(!isOwner) return reply("Só meu dono")
if(bcgp.length <= 0) return reply(`Não há mensagens salvas...`)
AB = bcgp.map(i => i.tipo).indexOf("mensagem")
matheuzinho = bcgp[AB].msg
if(matheuzinho.length <= 0) return reply(`Não há mensagens salvas...`)
if(!Number(args[0]) || Number(args[0]) < 1 || Number(args[0]) > matheuzinho.length) return reply("Olhe no comando "+prefix+"gplist e escolha o número correspondente a mensagem para deletar")
BC = Number(args[0]) - 1
matheuzinho.splice(BC, 1)
fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
reply("Mensagem da lista deletada com sucesso ✅")
break

case 'gplist':
if(!isOwner) return reply("Só meu dono")
if(bcgp.length <= 0) return reply(`Não há mensagens salvas...`)
AB = bcgp.map(i => i.tipo).indexOf("mensagem")
if(bcgp[AB].msg.length <= 0) return reply(`Não há mensagens salvas...`)
resp = `*Mensagens salvas para envio:*`
matheuzinho = bcgp[AB].msg
for(i = 0; i < matheuzinho.length; i++) {
  resp += `\n• ${i+1} -> ${matheuzinho[i].txt}`
}
reply(resp)
break

case 'listagp':
setTimeout(() => {reagir(from, "🎲")}, 300)
if(!isOwner) return reply(enviar.msg.dono)
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
gptt = []
for(i of allGroups) {
  try { getlink = `https://chat.whatsapp.com/${(await blackmd.groupInviteCode(i.id))}`
  } catch { getlink = `"link indisponível"` }
  nmr = 0
  for(p of i.participants) {
    if(p.admin != null) nmr += 1
  }
  gptt.push({
    id: i.id,
    contador: allGroups.map(a => a.id).indexOf(i.id) + 1,
    nome: i.subject,
    criador: i?.subjectOwner || i?.owner ? getname(i?.owner || i?.subjectOwner).replace(`usuário`, `wa.me/${(i?.subjectOwner || i?.owner).split(`@`)[0]}`) : `"não listado"`,
    admins: nmr,
    membros: i.participants.length - nmr,
    link: getlink
  })
}
if(gptt.length < 0) return reply(`Não há grupos salvos...`)
reply(`🎭 *Exibindo ${gptt.length > 1 ? `todos os ${gptt.length} grupos` : `o único grupo`} da lista ↴*
${gptt.map(i => `»${i.contador}«
♟ *Nome:* ${i.nome}
🎮 *Criador/a do grupo:* ${i.criador}
🕹 *Total de admins:* ${i.admins}
🎱 *Total de membros:* ${i.membros} ${isPrivateChat ? `
🕶 *ID do grupo:* ${i.id}
⚙ *Link do grupo:* ${i.link}` : ``}`).join(`\n\n`)}`)
break

case 'iddogp':
setTimeout(() => {reagir(from, "🧵")}, 300)
if(!isOwner)return reply(enviar.msg.dono)
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
but = []
for(i of allGroups) {
  but.push({title: i.subject || `"Não listado"`, body: `${i.participants.length} membro${i.participants.length != 1 ? `s` : ``} ao todo`, command: prefix+command+` `+i.id})
}
if(!q || allGroups.map(a => a.id).indexOf(q) < 0) {
  if(isGroup) reply(`Chega PV 🔰`)
  try { ppUrl = await blackmd.profilePictureUrl(from, 'image')
  } catch { ppUrl = semfoto }
  return sendRouletteButton(sender, {image: {url: ppUrl}, caption: `Olhe na lista abaixo e selecione o grupo que você deseja puxar o ID:`, footer: NickDono}, blackmd, sender, [{type: `list`, title: `〘 𝗚𝗥𝗨𝗣𝗢𝗦 𝗔𝗤𝗨𝗜 〙`, rowId: [{title: `Listando ${allGroups.length > 1 ? `todos os ${allGroups.length} grupos` : `o único grupo`} da lista...`, options: but}]}], seloctt)
}
AB = allGroups.map(a => a.id).indexOf(q)
grupo = allGroups[AB]
reply(`_ID do grupo ${grupo.subject} ↴_`)
await sleep(700)
sendMess(from, grupo.id)
break

case 'linkdogp': {
setTimeout(() => {reagir(from, "🧶")}, 300)
if(!isOwner)return reply(enviar.msg.dono)
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
but = []
for(i of allGroups) {
  but.push({title: i.subject || `"Não listado"`, body: `${i.participants.length} membro${i.participants.length != 1 ? `s` : ``} ao todo`, command: prefix+command+` `+i.id})
}
if(!q || allGroups.map(a => a.id).indexOf(q) < 0) {
  if(isGroup) reply(`Chega PV 🔰`)
  try { ppUrl = await blackmd.profilePictureUrl(from, 'image')
  } catch { ppUrl = semfoto }
  return sendRouletteButton(sender, {image: {url: ppUrl}, caption: `Olhe na lista abaixo e selecione o grupo que você deseja puxar o link:`, footer: NickDono}, blackmd, sender, [{type: `list`, title: `〘 𝗚𝗥𝗨𝗣𝗢𝗦 𝗔𝗤𝗨𝗜 〙`, rowId: [{title: `Listando ${allGroups.length > 1 ? `todos os ${allGroups.length} grupos` : `o único grupo`} da lista...`, options: but}]}], seloctt)
}
let { key } = await blackmd.sendMessage(from, {text: `_Buscando grupo_ 🔎`}, {quoted: info})
await sleep(1000)
AB = allGroups.map(a => a.id).indexOf(q)
grupo = allGroups[AB]
try { getlink = `https://chat.whatsapp.com/${(await blackmd.groupInviteCode(grupo.id))}`
} catch { return await blackmd.sendMessage(from, {text: `Não foi possível puxar o link... É possível que o bot não seja adm neste grupo 😥`, edit: key }, {quoted: info}) }
await blackmd.sendMessage(from, {text: `_Link do grupo ${grupo.subject} ↴_
${getlink}`, edit: key }, {quoted: info}) }
break

case 'sairdogp': {
setTimeout(() => {reagir(from, "🧦")}, 300)
if(!isOwner)return reply(enviar.msg.dono)
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
but = []
for(i of allGroups) {
  but.push({title: i.subject || `"Não listado"`, body: `${i.participants.length} membro${i.participants.length != 1 ? `s` : ``} ao todo`, command: prefix+command+` `+i.id})
}
if(!q || allGroups.map(a => a.id).indexOf(q) < 0) {
  if(isGroup) reply(`Chega PV 🔰`)
  try { ppUrl = await blackmd.profilePictureUrl(from, 'image')
  } catch { ppUrl = semfoto }
  return sendRouletteButton(sender, {image: {url: ppUrl}, caption: `Olhe na lista abaixo e selecione o grupo que você quer que o bot saia:`, footer: NickDono}, blackmd, sender, [{type: `list`, title: `〘 𝗚𝗥𝗨𝗣𝗢𝗦 𝗔𝗤𝗨𝗜 〙`, rowId: [{title: `Listando ${allGroups.length > 1 ? `todos os ${allGroups.length} grupos` : `o único grupo`} da lista...`, options: but}]}], seloctt)
}
AB = allGroups.map(a => a.id).indexOf(q)
let { key } = await blackmd.sendMessage(from, {text: `💆🏻‍♂️ Saindo do grupo ${allGroups[AB].subject} 🚶🏻‍♂️`}, {quoted: info})
await sleep(2000)
blackmd.groupLeave(q)
await sleep(1000)
await blackmd.sendMessage(from, {text: `🙇🏻‍♂️ Pronto chefe, missão dada é missão cumprida 💁🏻‍♂️`, edit: key}, {quoted: info})
}
break

case 'delfilegp': {
setTimeout(() => {reagir(from, "📂")}, 300)
if(!isOwner) return reply(enviar.msg.dono)
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
but = []
for(i of allGroups) {
  but.push({title: i.subject || `"Não listado"`, body: `${i.participants.length} membro${i.participants.length != 1 ? `s` : ``} ao todo`, command: prefix+command+` `+i.id})
}
if(!q || allGroups.map(a => a.id).indexOf(q) < 0) {
  if(isGroup) reply(`Chega PV 🔰`)
  try { ppUrl = await blackmd.profilePictureUrl(from, 'image')
  } catch { ppUrl = semfoto }
  return sendRouletteButton(sender, {image: {url: ppUrl}, caption: `Olhe na lista abaixo e selecione o grupo que você deseja deletar a dB de arquivos:`, footer: NickDono}, blackmd, sender, [{type: `list`, title: `〘 𝗚𝗥𝗨𝗣𝗢𝗦 𝗔𝗤𝗨𝗜 〙`, rowId: [{title: `Listando ${allGroups.length > 1 ? `todos os ${allGroups.length} grupos` : `o único grupo`} da lista...`, options: but}]}], seloctt)
}
caminho = `./basededados/grupos/${q}.json`
if(!fs.existsSync(caminho)) {
  console.log(`ID: ${q}\n\n"${caminho}" não existe`)
  return reply(`Grupo não existente ❌`)
}
AB = allGroups.map(a => a.id).indexOf(q)
grupo = {id: q, name: allGroups[AB].subject}
DLT_FL(caminho)
reply(`_Grupo ${grupo.name} por ID *${grupo.id}* deletado da dB com sucesso_ ✔`)
await sleep(700)
console.log(colors.green(`Restart necessário para save de dados..`))
process.exit()
}
break

case 'limpardb':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = countMessage.map(i => i.groupId).indexOf(from)
total = countMessage[AB].participants.length
caixa = []
for(i = 0; i < countMessage[AB].participants.length; i++) {
  if(isJsonIncludes(groupMembers, countMessage[AB].participants[i].id)) {
    caixa.push(countMessage[AB].participants[i])
  }
}
pack = total - caixa.length
if(pack <= 0) return reply("*Todos os ghosts da data base já foram deletados...*")
countMessage[AB].participants = caixa
saveJSON(countMessage, "./basededados/countmsg.json")
reply(`${pack} números foram deletados da pasta com sucesso ✅`)
break

case 'addglobalmessage': case 'addgbmsg':
if(!isOwner) return reply(enviar.msg.dono)
var [h, m1] = q.replace("/ ", "/").replace(" /", "/").replace(" / ", "/").split("/")
if(!h || !m1) return reply(`Retone após o comando o horário e a mensagem que você quer enviar quando o sistema estiver ativado, ex:
${prefix+command} 18:00/se a vida te der um limão, desconfie, pq nada é de graça`)
t = h.split(":")[0]
if(Number(t) < 0 || Number(t) > 24 || t.includes('.')) return reply("Formato de hora inválido... Só existem horas entre 00 e 24 🤡")
c = h.includes(":") ? `` : `:00`
p = h + c
x = p.split(":")[1]
if(Number(x) < 0 || Number(x) > 60 || x.includes('.')) return reply("Formato de hora inválido... Só minutos entre 00 e 60 🤡")
horacerta = `${Number(p.split(":")[0]) >= 10 ? Number(p.split(":")[0]) : `0${Number(p.split(":")[0])}`}:${Number(p.split(":")[1]) >= 10 ? Number(p.split(":")[1]) : `0${Number(p.split(":")[1])}`}`
if(isJsonIncludes(gbmsg[1].msg, horacerta)) {
AB = gbmsg[1].msg.map(i => i.time).indexOf(horacerta)
gbmsg[1].msg.splice(AB, 1)
saveJSON(gbmsg, "./basededados/gbmsg.json")
}
faq = m1
gbmsg[1].msg.push({time: horacerta, frase: faq, save: "00"})
saveJSON(gbmsg, "./basededados/gbmsg.json")
reply(`A mensagem "${faq}" foi definida com sucesso às ${horacerta}h... Para ativar no grupo, use ${prefix}gbmsg`)
break

case 'removeglobalmessage': case 'rmgbmsg':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`Para melhor precisão, retorne após o comando, o horário que você deseja deletar... Caso esteja em dúvida, olhe no comando ${prefix}lista-gbmsg todos os horários registrados.`)
t = q.split(":")[0]
if(Number(t) < 0 || Number(t) > 24 || t.includes('.')) return reply("Formato de hora inválido... Só existem horas entre 00 e 24 🤡")
c = q.includes(":") ? `` : `:00`
p = q + c
x = p.split(":")[1]
if(Number(x) < 0 || Number(x) > 60 || x.includes('.')) return reply("Formato de hora inválido... Só minutos entre 00 e 60 🤡")
horacerta = `${Number(p.split(":")[0]) >= 10 ? Number(p.split(":")[0]) : `0${Number(p.split(":")[0])}`}:${Number(p.split(":")[1]) >= 10 ? Number(p.split(":")[1]) : `0${Number(p.split(":")[1])}`}`
AB = gbmsg[1].msg.map(i => i.time).indexOf(horacerta)
if(AB < 0) return reply("Horário não registrado")
gbmsg[1].msg.splice(AB, 1)
saveJSON(gbmsg, "./basededados/gbmsg.json")
reply("Horário deletado com sucesso ✅")
break

case 'lista-globalmessage': case 'lista-gbmsg':
if(!isOwner) return reply(enviar.msg.dono)
if(gbmsg[1].msg.length <= 0) return reply("Não há horários definidos...")
reply(`📨 *Lista de mensagens e horários..*
📖 *Total:* ${gbmsg[1].msg.length}

${gbmsg[1].msg.map(i => `• *Horário:* ${i.time}h
• *Mensagem:* ${i.frase}`).join("\n-\n")}`)
break

case 'globalmessage': case 'gbmsg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isJsonIncludes(gbmsg[0].gp, from)) {
  gbmsg[0].gp.push({id: from})
  saveJSON(gbmsg, "./basededados/gbmsg.json")
  return reply(`*Ativada função de mensagens programadas neste grupo com sucesso* ✅`)
} else {
  AB = gbmsg[0].gp.map(i => i.id).indexOf(from)
  gbmsg[0].gp.splice(AB, 1)
  saveJSON(gbmsg, "./basededados/gbmsg.json")
  return reply(`Sucesso, você desativou as mensagens programadas deste grupo...`)
}
break

case 'atividade':
case 'atividades':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = countMessage.map(a => a.groupId).indexOf(from)
if(AB < 0) return reply(`Não há dados de mensagens deste grupo salvos na database do bot...`)
grupo = countMessage[AB].participants
if(grupo.length <= 0) return reply(`Não há membros suficientes no grupo...`)
txt = `🥏 *_Atividade dos membros deste grupo:_*
${grupo.map(g => `*Usuário:* @${g.id.split("@")[0]}
*Menssagens:* ${g.mensagens}
*Comandos:* ${g.comandos}`).join(`\n\n`)}`
mention(txt)
break

case 'inativos':
case 'inativo':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(isNaN(q)) return reply(`Retorne após o comando a quantidade de mensagens que você quer puxar...`)
AB = countMessage.map(a => a.groupId).indexOf(from)
if(AB < 0) return reply(`Não há dados de mensagens deste grupo salvos na database do bot...`)
grupo = countMessage[AB].participants
caixa = []
for(i of grupo) {
  if(i.mensagens <= Number(q)) caixa.push(i.id)
}
if(caixa.length == 0) return reply(`Não há pessoas com ${q} msg..`)
txt = `_Usuários com ${q.trim()} msg ou menos..._
╔══════════════════╣
${caixa.map(c => `╟ »${caixa.indexOf(c) + 1}« @${c.split("@")[0]}`).join(`
║
`)}
╚═════╣ ${NomeDoBot}`
mention(txt)
break

case 'banghost': case 'banghosts':
if(!isGroup) return reply(enviar.msg.grupo)  
if(!isOwner) return reply(enviar.msg.dono)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!q || !Number(q) < 0) return reply(`Retorne após o comando a quantidade mínima de mensagens que os usuários devem ter para não serem banidos... Qualquer usuário com mensagens abaixo disso irâo de submarino.
Ex: ${prefix+command} 5`)
hehe = []
AB = countMessage.map(i => i.groupId).indexOf(from)
nmr = 0
for(a of countMessage[AB].participants) {
  if(a.mensagens <= Number(q)) {
    if(!nmrdn.includes(a.id) && !botNumber.includes(a.id)) {
      if(isJsonIncludes(groupMembers, a.id)) hehe.push(a.id)
      if(!isJsonIncludes(groupAdmins, a.id)) nmr += 1
    }
  }
}
if(nmr <= 0) return reply(`Todos os usuários com essa quantidade de mensagens já foram removidos..`)
ativado = isWelkom3
fechargp(from)
await sleep(1000)
reply(`Grupo fechado para limpeza 🗑`)
if(ativado) {
dataGp[0].wellcome[2].bemvindo3 = false
setGp(dataGp)
}
limpeza = 0
total = hehe.length
for(h of hehe) {
  await sleep(1400)
  if(isJsonIncludes(groupAdmins, h)) {
    blackmd.sendMessage(from, {text: `Usuário @${h.split("@")[0]} foi poupado do banimento por ser admin 👑`, mentions: [h]})
  } else if(isOnlyVip(h)) {
    blackmd.sendMessage(from, {text: `Usuário @${h.split("@")[0]} foi poupado do banimento por ser VIP ⚜`, mentions: [h]})
  } else {
    remover(from, h)
  }
  limpeza += 1
}
if(limpeza >= total) {
  await sleep(1000)
  abrirgp(from)
  await sleep(1000)
  sendMess(from, `Todos os usuários com ${q} msg ou menos foram removidos com sucesso 🗑`)
  if(ativado) {
    dataGp[0].wellcome[2].bemvindo3 = true
    setGp(dataGp)
  }
}
break

case 'verificarnmr':
if(!isOwner) return reply(enviar.msg.dono)
const [result] = await blackmd.onWhatsApp(q)
if(result == undefined) {
reply("Este usuário não é existente no WhatsApp")
} else {
reply(`-> ${sla} Número inserido é existente no WhatsApp.\n\ncom o id:`)
setTimeout(() => {
blackmd.sendMessage(from, {text: result.jid})
}, 1100)
}
break

case 'wame':
barra = q.replace(" |", "|").replace("| ", "|").replace(" | ", "|")
var [nmr, msg] = barra.split('|')
if(!nmr) return reply("KD o número de wpp?")
me = nmr.includes('@') ? nmr.split('@')[1] : nmr.toLowerCase() == "me" ? sender.split('@')[0] : nmr.toLowerCase() == "bot" ? botNumber.split('@')[0] : nmr.toLowerCase() == "dono" ? nmrdn.split('@')[0] : nmr
txt = `wa.me/`+me.replace(new RegExp("[()+-/ +/]", "gi"), "")
if(msg) txt += `?text=`+encodeURI(msg)
reply(txt)
break



case 'correio':
setTimeout(() => {reagir(from, "✉️")}, 300)
var [txt1, txt2] = q.split('/')
if(!txt1) return reply(`KD o número da pessoa ?`)
if(!txt2) return reply(`Separe o número da pessoa e a mensagem com uma /

Ex: ${sender.split('@')[0]}/oi vida`)
if(txt1.includes("@")) return reply(`Não inclua @ no número...`)
msg_ = `*Correio enviado...* ✉️

*Para mais dúvidas, digite:* ${prefix}infocorreio`
reply(msg_)
bla = 
`╔══════════════════╣
╟ 𝙲𝚘𝚛𝚛𝚎𝚒𝚘 𝙰𝚗ô𝚗𝚒𝚖𝚘 🤫
║
╩ㅤ⇒𝙼𝚎𝚗𝚜𝚊𝚐𝚎𝚖: ${txt2}
________________________________________

${NomeDoBot} ✉️`
blackmd.sendMessage(txt1.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net`, {text: bla})
break

case 'correio2':
setTimeout(() => {reagir(from, "✉️")}, 300)
var [txt1, txt2] = q.split('/')
if(!txt1) return reply(`KD o número da pessoa ?`)
if(!txt2) return reply(`Separe o número da pessoa e a mensagem com uma /

Ex: ${sender.split('@')[0]}/oi vida`)
if(!txt1.startsWith("55") && !txt1.startsWith("+55")) return reply(`Não se esqueça do 55 na frente`)
if(txt1.includes("@")) return reply(`Não inclua @ no número...`)
msg_ = `*Correio enviado...* ✉️

*Para mais dúvidas, digite:* ${prefix}infocorreio`
reply(msg_)
bla = 
`╔══════════════════╣
╟ ${pushname} Te Enviou Uma Msg
║
╩ㅤ⇒𝙼𝚎𝚗𝚜𝚊𝚐𝚎𝚖: ${txt2}
________________________________________

ೈ፝͜͡✉️ wa.me/${sender.split('@')[0]}`
blackmd.sendMessage(txt1.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net`, {text: bla})
break

case 'infocorreio':
setTimeout(() => {reagir(from, "📩")}, 300)
infocarta = `*${tempo} ${pushname}, há duas formas de correio:*

[ ${prefix}correio ]
A primeira forma de correio irá enviar uma mensagem para o remetente de forma totalmente anônima...

[ ${prefix}correio2 ]
Já a segunda forma de correio, irá pôr o seu número na carta... Isto é, caso você queira se identificar, ou mesmo, para o remetente entrar em contato com você.

-----------------------------------------------------------

*Em ambas as formas, é necessário pôr o número de forma correta, na seguinte ordem:*
-> Comando+55+DDD+número do indivíduo+/+sua mensagem para ele

_*Nota:* Não pode conter o 9 na frente do número_
❌ 9xxxx-xxxx
✅ xxxx-xxxx
_(Não é necessário pôr o "+", nem o "-")_

*Exemplo:*
-> ${prefix}correio 556481310187/oi gstz
-> ${prefix}correio2 556481310187/salve meu pit

*Bjs de luz, Estevão Ferreira* ✨`
blackmd.sendMessage(from, {image: {url: `https://telegra.ph/file/87aeadc7997d9eb91bfcb.jpg`}, caption: infocarta}, {quoted: seloctt})
break

case 'msgpv':
reagir(from, "✅")
if(!isOwner) return reply("A vontade de banir pessoas assim não é pouca... 😒")
if(!isMsgPV) {
obrigadoEXT.msgpv = true
setObg(obrigadoEXT)
reply(`✔️ A mensagem no PV foi ativada para todos os comandos que necessitem dela 〰️`)
} else {
obrigadoEXT.msgpv = false
setObg(obrigadoEXT)
reply(`✖️ A mensagem no PV foi desativada... Alguns comandos não enviarão avisos no PV, mas continuarão funcionando ➿`)
}
break

case 'nome-bot':
if(!isOwner  && !ischyt && !info.key.fromMe) return reply(enviar.msg.dono)  
NomeDoBot = q.trim()
setting.NomeDoBot = q.trim()
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, 2))
reply(`Ok ${NickDono}, agora eu me chamo ${q}`)
break

case 'nick-dono':
if(!isOwner  && !ischyt && !info.key.fromMe) return reply(enviar.msg.dono) 
setting.NickDono = q.trim()
NickDono = setting.NickDono
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, 2))
reply(`O Nick Do Dono foi alterado para:
> ${q}`)
break

case 'numero-dono':
if(!isOwner && !ischyt && !info.key.fromMe) return reply(enviar.msg.dono)
if(!q) return reply("KD o número de WhatsApp")
if(q.match(/[a-z]/i)) return reply("É apenas números..")
reply(`Ok ${pushname}, transferência de dono feita para wa.me/${q} com sucesso...`)
setting.numerodono = q.trim().replace(new RegExp("[()+-/ +/]", "gi"), "");
numerodono[0] = setting.numerodono
numerodn = setting.numerodono
numerodono_ofc = setting.numerodono
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, 2))
break

case 'fotomenu':
case 'fundomenu':
if(!isOwner) return reply(enviar.msg.dono)
if(!isQuotedImage) return reply("Marque uma imagem")
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) { 
reply(`Calma ae, tem muitos comandos usando essa foto... Tô trocando aqui`)
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
logoslink.logo = res
fs.writeFileSync('./basededados/logos.json', JSON.stringify(logoslink, null, 2))
reply(`A foto do menu foi alterada com sucesso para: ${logoslink.logo}`)
} else {
reply(`Mande uma imagem com o comando ${prefix + command} para trocar a foto de todos menu...`)
}
break

case 'logomenu':
if(!isOwner) return reply(enviar.msg.dono)
if(!isQuotedImage) return reply("Marque uma imagem")
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) { 
reply(`Calma ae, tem muitos comandos usando essa foto... Tô trocando aqui`)
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
logoslink.menu = res
fs.writeFileSync('./basededados/logos.json', JSON.stringify(logoslink, null, 2))
reply(`A foto do menu principal foi alterada com sucesso para: ${logoslink.menu}`)
} else {
reply(`Mande uma imagem com o comando ${prefix + command} para trocar a foto do menu principal...`)
}
break

case 'logoping': case 'fundoping':
if(!isOwner) return reply(enviar.msg.dono)
if(!isQuotedImage) return reply("Marque uma imagem")
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) { 
reply(`Calma ae, já tô trocando...`)
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
logoslink.ping = res
fs.writeFileSync('./basededados/logos.json', JSON.stringify(logoslink, null, 2))
reply(`A foto do ping foi alterada com sucesso para: ${logoslink.ping}`)
} else {
reply(`Mande uma imagem com o comando ${prefix + command} para trocar a foto do ping...`)
}
break

case 'prefixo-bot':
case 'setprefixs':
case 'setprefixo':
case 'setprefix':
case 'novoprefixo':
if(args.length < 1) return
if(!isOwner  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.dono)
setting.prefix = args[0]
fs.writeFileSync('./dono/settings.json', JSON.stringify(setting, null, 2))
reply(`Novo prefixo definido ( ${args[0]} )`)
break

case 'nomegp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
blackmd.groupUpdateSubject(from, `${body.slice(9)}`)
blackmd.sendMessage(from, {text: 'Sucesso, alterou o nome do grupo'}, {quoted: seloctt})
break

case 'fotobot':
if(!isOwner  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.dono)
if(!isQuotedImage) return reply(`Envie fotos com legendas ${prefix}fotobot ou tags de imagem que já foram enviadas`)
buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage, 'image')
blackmd.updateProfilePicture(botNumber, buff)
reply('Obrigado pelo novo perfil😗')
break

case 'clonar':
if(!isOwner  && !isnit && !issupre && !ischyt) return reply('Você quem é o proprietário?')
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('Marque a pessoa que você quer clonar\n\n*EXEMPLO:* clone @')
if(!menc_jid2[0] || menc_jid2[1]) return reply("Marque o @ do usuário para roubar a foto do perfil dele, para a do bot..")
let { jid, id, notify } = groupMembers.find(x => x.id === menc_jid2[0])
try {
pp = await blackmd.profilePictureUrl(id)
buffer = await getBuffer(pp)
blackmd.updateProfilePicture(botNumber, buffer)
mentions(`Foto do perfil atualizada com sucesso, usando a foto do perfil @${id.split('@')[0]}`, [id], true)
} catch (e) {
reply('Putz, deu erro, a pessoa deve estar sem foto 😔')
}
break

case 'envmsg':
if(!isOwner && !isnit) return
var [tx1, tx2] = q.split("/")
blackmd.sendMessage(tx1, {text: tx2})
break

case 'bcgp':
case 'bcgc':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply('Cade o texto?')
for(i of groupMembers) {
await sleep(1000)
var txt = `*${tempo.toUpperCase()}* ${getname(i.id)}

-> ${q}`
sendMess(i.id, txt)
}
break

case 'setpgp': case 'setcofc':
if(!isOwner) return reply(enviar.msg.dono)
if(command == "setpgp") {
obrigadoEXT.idprivategp = from
setObg(obrigadoEXT)
reply("Grupo privado atualizado ✅")
} else {
obrigadoEXT.idchatofc = from
setObg(obrigadoEXT)
reply("Chat oficial atualizado ✅")
}
break

case 'dono1':
case 'defcon5':
if(args.length < 1) return
if(!sender.includes(nmrdn) && !sender.includes(botNumber) && !ischyt) return reply(enviar.msg.dono)
if(q.length > 8) {
resp = "*『 DEFCON 5 ATIVADO 』* \n\n⚠️ *Nível de segurança:* 1\n🤍 *Status de segurança:* ```Seguro```"
} else {
resp = "*『 DEFCON 5 DESATIVADO 』*"
}
obrigadoEXT.dono1 = q.trim()
dono1 = obrigadoEXT.dono1
setObg(obrigadoEXT)
reply(resp)
break

case 'dono2':
case 'defcon4':
if(args.length < 1) return
if(!sender.includes(nmrdn) && !sender.includes(botNumber) && !ischyt) return reply(enviar.msg.dono)
if(q.length > 8) {
resp = "*『 DEFCON 4 ATIVADO 』* \n\n⚠️ *Nível de segurança:* 2\n💚 *Status de segurança:* ```Estável```"
} else {
resp = "*『 DEFCON 4 DESATIVADO 』*"
}
obrigadoEXT.dono2 = q.trim()
dono2 = obrigadoEXT.dono2
setObg(obrigadoEXT)
reply(resp)
break

case 'dono3':
case 'defcon3':
if(args.length < 1) return
if(!sender.includes(nmrdn) && !sender.includes(botNumber) && !ischyt) return reply(enviar.msg.dono)
if(q.length > 8) {
resp = "*『 DEFCON 3 ATIVADO 』* \n\n⚠️ *Nível de segurança:* 3\n💛 *Status de segurança:* ```Alarmante```"
} else {
resp = "*『 DEFCON 3 DESATIVADO 』*"
}
obrigadoEXT.dono3 = q.trim()
dono3 = obrigadoEXT.dono3
setObg(obrigadoEXT)
reply(resp)
break

case 'dono4':
case 'defcon2':
if(args.length < 1) return
if(!sender.includes(nmrdn) && !sender.includes(botNumber) && !ischyt) return reply(enviar.msg.dono)
if(q.length > 8) {
resp = "*『 DEFCON 2 ATIVADO 』* \n\n⚠️ *Nível de segurança:* 4\n❤️ *Status de segurança:* ```Um passo da guerra```"
} else {
resp = "*『 DEFCON 2 DESATIVADO 』*"
}
obrigadoEXT.dono4 = q.trim()
dono4 = obrigadoEXT.dono4
setObg(obrigadoEXT)
reply(resp)
break

case 'dono5':
case 'defcon1':
if(args.length < 1) return
if(!sender.includes(nmrdn) && !sender.includes(botNumber) && !ischyt) return reply(enviar.msg.dono)
if(q.length > 8) {
resp = "*『 DEFCON 1 ATIVADO 』* \n\n⚠️ *Nível de segurança:* 5\n🖤 *Status de segurança:* ```Guerra nuclear```"
} else {
resp = "*『 DEFCON 1 DESATIVADO 』*"
}
obrigadoEXT.dono5 = q.trim()
dono5 = obrigadoEXT.dono5
setObg(obrigadoEXT)
reply(resp)
break

case 'dono6':
case 'defcon':
if(args.length < 1) return
if(!sender.includes(nmrdn) && !sender.includes(botNumber) && !ischyt) return reply(enviar.msg.dono)
if(q.length > 8) {
resp = `⚠️ *Ativação de DEFCONs confirmada...*
🫡 *Bem vindo (a)* wa.me/${q}`
} else {
resp = `⚠️ *Desativação de DEFCONs confirmada...*`
}
obrigadoEXT.dono6 = q.trim()
dono6 = obrigadoEXT.dono6
setObg(obrigadoEXT)
reply(resp)
break

case 'getquoted':
reply(JSON.stringify(info.message.extendedTextMessage.contextInfo, null, 3))
break

case 'donos':
setTimeout(() => {reagir(from, "✅")}, 300)
donos = `👑 𝙼𝙴𝚂𝚃𝚁𝙴 𝚂𝚄𝙿𝚁𝙴𝙼𝙾 ↴
wa.me/${numerodono_ofc}

× DΞFᏟϴΝ 5⇒ ${dono1}
× DΞFᏟϴΝ 4⇒ ${dono2}
× DΞFᏟϴΝ 3⇒ ${dono3}
× DΞFᏟϴΝ 2⇒ ${dono4}
× DΞFᏟϴΝ 1⇒ ${dono5}
× LÍDΞR SUPΞRIϴR ↴
wa.me/${dono6}`
ttgp = isGroup ? groupMembers.length * groupAdmins.length + somembros.length : 6
horar = moment.tz('America/Sao_Paulo').format('HH:mm');
datar = moment.tz('America/Sao_Paulo').format('DD/MM');
sendUrlDoc(from, donos, 'application/pdf', `${horar}H ┋ ${datar} 📆`, ttgp, NomeDoBot, '', 'https://telegra.ph/file/adad9b9a3606857e380be.jpg', `https://instagram.com/m4thxyz_`, seloctt)
break

case 'adms':
case 'admins':
case 'chamaradms':
setTimeout(() => {reagir(from, react2)}, 300)
blackmd.sendMessage(from, {text: `⚠️ *CHAMANDO TODOS OS ADMINS...*
${pushname} *solicita a vossa presença* 👀${q ? `\n\n*-> Recado:* _"${q}"_` : ``}`, mentions: groupAdmins}, {quoted: info})
break

case 'cases':
if(!isOwner) return reply("Você não é dono para utilizar este comando...")
try {
const listCases = () => {
const fileContent = fs.readFileSync("index.js").toString();
const caseNames = fileContent.match(/case\s+'(.+?)'/g);
if(caseNames) {
return caseNames.map((caseName, index) => `• ${index + 1} -> ${caseName.match(/'(.+?)'/)[1]}`).join('\n');
} else {
reply("Nenhuma case encontrada.") } }
blackmd.sendMessage(from, { text: listCases() }, { quoted: seloctt });
} catch (e) {
console.log(e)
reply('Ocorreu um erro ao obter as cases.') }
break

case 'totalcmd':
try {
tc = "./database/data/totalcmd.json"
totalcmd = JSON.parse(fs.readFileSync(tc))
const fileContent = fs.readFileSync("index.js").toString();
const caseNames = fileContent.match(/case\s+'(.+?)'/g);
cont = caseNames.length
totalcmd[0].totalcmd = cont
saveJSON(totalcmd, tc)
reply(`🎲 O bot possui atualmente ${cont} comandos ヅ`)
} catch { reply("[ ❗ ] Erro ao obter o total de comandos ❌") }
break

case 'criartabela': case 'criartbl': case 'criartab':
if(!isGroupAdmins && !isOwner) return reply("Só adm ou dono pode utilizar este comando.")
if(!q.trim()) return reply("Digite o que deseja colocar na tabela do grupo..")
msgz = args.join(" ")
msgtmpol = moment.tz('America/Sao_Paulo').format('HH:mm:ss');
datinhaofc = moment.tz('America/Sao_Paulo').format('DD/MM/YY');
fs.writeFileSync(`./basedefuncionamento/tabela/tabela-${from}.json`,
JSON.stringify({Horario: msgtmpol, Data: datinhaofc, Tabela: msgz}, null, 2));
reply(`Tabela do grupo foi criada com sucesso..`)
break

case 'tabelagp': case 'tabeladogp': case 'tabelinha': 
if(!fs.existsSync(`./basedefuncionamento/tabela/tabela-${from}.json`)) {
reply(`Cade a tabela, cria ela com o comando\nExemplo : ${prefix}criartabela lindas do grupo : e etc ..`)
}
const tabelagpofc = JSON.parse(fs.readFileSync(`./basedefuncionamento/tabela/tabela-${from}.json`)); 
blity = `- ⏰ Horário que criou a Tabela : ${tabelagpofc.Horario}\n\n- 🗓️ Data que criou a Tabela : ${tabelagpofc.Data}\n\n - Tabela : ${tabelagpofc.Tabela}`
mention(blity)
break

case 'infovip':
reply(`Olá ${pushname}, ${tempo.toLowerCase()}... Já se perguntou como se tornar vip e ter acesso aí comandos do menu vip exclusivamente pra vc ??

Bom, para tal façanha, é necessário pagar um valor de R$ ${Number(valoresVIP.vip).toFixed(2)} que será referente a 30 dias de VIP. Você terá os seguintes direitos:
• uso dos comandos do ${prefix}menuvip
• uso do PV do bot quando o mesmo estiver bloqueado
• alguns poderes de ADM
• uso do gpt no PV
• ${prefix}docfake em qualquer canto
• fazer figurinha sem legenda
• uso do menu +18 e seus comandos no PV
• ganho de moedas no RPG

Caso se interessar, favor chamar meu dono no comando ${prefix}dono`)
break

case 'startpaid': case 'stoppaid':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.advip)
horarios2 = getGroupInPaid(from)
if(horarios2.start) {
horarios2.start = false
savePaid()
return reply(`O sistema de horários foi desativado com sucesso neste grupo 🐅`)
} else {
horarios2.start = true
savePaid()
return reply(`O sistema de horários foi ativado com sucesso neste grupo 🐯`)
}
break

case 'addhorarios': case 'addhorario': case 'addpaid':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.advip)
if(!getGroupInPaid(from).start) return reply(`O sistema de horários está desativado... Caso queira usar, primeiro ligue eles usando ${prefix}startpaid 🐯`)
if(!q) return reply(`Retorne após o comando o intervalo de tempo entre cada envio de slot, ex:
${prefix+command} 30m
ou
${prefix+command} 1h`)
nmr = q.slice(0, q.length - 1)
letra = q.slice(q.length - 1, q.length).toLowerCase()
if(letra != `h` && letra != `m`) return reply(`Use apenas horas ou minutos, ex: 30m ou 1h`)
if(!Number(nmr)) return reply(`"${nmr}" precisa ser um número maior que zero`)
addPaid(from, q)
reply(`Horário pagante definido com sucesso 🐯`)
break

case 'fundohorario': case 'fundohorarios': case 'fundopaid':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.advip)
if(!getGroupInPaid(from).start) return reply(`O sistema de horários está desativado... Caso queira usar, primeiro ligue eles usando ${prefix}startpaid 🐯`)
ggip = getGroupInPaid(from)
if(!q || Number(q) !== 0) {
  if(!isImage && !isQuotedImage) return reply(`Marque uma image com o comando ${prefix+command}`)
  try {
    getinfoimg = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
    getfl = await getFileBuffer(getinfoimg, 'image')
    //fs.writeFileSync(`./basedefuncionamento/horarios/${from}.jpg`, getfl)
    uptele = await upload(getfl)
    ggip.fundoperso = true
    ggip.url = uptele//`./basedefuncionamento/horarios/${from}.jpg`
    savePaid()
    return reply(`O fundo dos horários foi atualizado para ${uptele} com sucesso ✔`)
    //return reply(`O fundo dos horários foi atualizado com sucesso ✔`)
  } catch(e) {
    console.log(e)
    reply(`Não foi possível salvar a imagem... Tente novamente 🐯`)
  }
} else {
  if(Number(q) === 0) {
    ggip.fundoperso = false
    savePaid()
    rmGroupLinkInPaid(from)
    return reply(`O fundo personalizado dos horários foi deletado com sucesso ✔`)
  } else return reply(`Use ${prefix+command} [marque uma imagem] para personalizar o fundo dos horários pagantes e ${prefix+command} 0 para deletar a imagem salva.`)
}
break

case 'rmhorarios': case 'rmhorario': case 'rmpaid':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.advip)
if(!getGroupInPaid(from).start) return reply(`O sistema de horários está desativado... Caso queira usar, primeiro ligue eles usando ${prefix}startpaid 🐯`)
if(!q) return reply(`Retorne após o comando o ID do horário pagante que você quer deletar`)
if(!isIDinPaid(from, q)) return reply(enviar.msg.notusu.replace(`usuário`, `horário`))
rmPaid(from, q)
reply(`Horário pagante deletado com sucesso 🐅`)
break

case 'listahorarios': case 'listahorario': case 'listpaid': case 'paidlist':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.advip)
if(!getGroupInPaid(from).start) return reply(`O sistema de horários está desativado... Caso queira usar, primeiro ligue eles usando ${prefix}startpaid 🐯`)
horarios2 = getGroupInPaid(from).horarios
if(horarios2.length <= 0) return reply(`Não há horários pagantes definidos neste grupo 🐯`)
reply(`🐯 *_Horários pagantes do grupo ${groupName}:_*
${horarios2.map(i => `🆔 *ID:* ${i.id}
⏳ *Intervalo de tempo:* ${String(i.nmr) + i.letra}
🍀 *Próximo horário:* ${i.tempo}`).join(`\n\n`)}`)
break

case 'attgrouplink': case 'atualizarfotoshorarios':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.advip)
if(!getGroupInPaid(from).start) return reply(`O sistema de horários está desativado... Caso queira usar, primeiro ligue eles usando ${prefix}startpaid 🐯`)
horarios3 = []
for(glp of groupLinkPaid) {
  if(!isJsonIncludes(horarios3, glp.id)) horarios3.push(glp)
}
saveJSON(horarios3, `./basedefuncionamento/horarios/grouplink.json`)
reply(`Database de fotos dos grupos/slots atualizada com sucesso 🐯`)
await sleep(700)
console.log(colors.green(`Restart necessário para save de dados..`))
process.exit()
break

case 'attpaid': case 'atualizarhorarios':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isAdvencedVip(sender) && !isAdvencedGroupVip(from)) return reply(enviar.msg.advip)
if(!getGroupInPaid(from).start) return reply(`O sistema de horários está desativado... Caso queira usar, primeiro ligue eles usando ${prefix}startpaid 🐯`)
horarios4 = []
for(p of paidHours) {
  if(p.horarios.length > 0) horarios4.push(p)
}
saveJSON(horarios4, `./basedefuncionamento/horarios/horarios.json`)
saveJSON([], `./basedefuncionamento/horarios/grouplink.json`)
reply(`Pasta de slots limpa e atualizada com sucesso 🐯`)
await sleep(700)
console.log(colors.green(`Restart necessário para save de dados..`))
process.exit()
break

case 'ausente': case 'afk':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOnlyVip(sender)) return reply(enviar.msg.vip)
if(!q) return reply("Digite após o comando o seu motivo de ausência")
if(JSON.stringify(ausentes).includes(sender)) {
AB = ausentes.map(i => i.id).indexOf(sender)
ausentes.splice(AB, 1)
saveJSON(ausentes, './basededados/ausentes.json')
}
await sleep(500)
ausentes.push({
id: sender,
nome: pushname,
dono: isOwner ? true : false,
motivo: q,
data: sendHours('DD/MM'),
hora: sendHours('HH:mm')
})
saveJSON(ausentes, './basededados/ausentes.json')
reply(`Ok ${isOwner ? 'mestre' : 'oh grande ser'}, a partir de agora ${isOwner ? 'o senhor' : 'você'} está "${q}" 🙇🏻‍♂️`)
break

case 'voltei': case 'on': case 'ativo': case 'acordei':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOnlyVip(sender)) return reply(enviar.msg.vip)
if(!JSON.stringify(ausentes).includes(sender)) return reply("Não há registros de ausência de sua parte")
AB = ausentes.map(i => i.id).indexOf(sender)
ausentes.splice(AB, 1)
saveJSON(ausentes, './basededados/ausentes.json')
reply("Bem vindo de volta 🙇🏻‍♂️")
break

case 'servip':
if(!isOwner && !isSesc) return reply(enviar.msg.dono)
if(isJsonIncludes(vip, sender)) return reply(`Mas vc já é VIP meu mestre 🙇🏻‍♂️`)
addVip(sender, 0, true)
mention(`*Prontinho @${sender.split('@')[0]}... Agora você se tornou [ VIP ] meu mestre* 😍`)
break

case 'reagir':
const reactionMessage = {
react: {
text: "💖",
key: info.key
}
}
sendMsg = await blackmd.sendMessage(from, reactionMessage)
break

case 'addvip':
reagir(from, "🤑")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
barra = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/")
var [nmr, tempo50, mod] = barra.split('/')
if(!nmr || !tempo50) return reply(`Coloque o número do indivíduo e uma barra logo depois (/), após isso, coloque a quantidade de dias que este será VIP...
Ex: ${prefix+command} ${nmrdn.split('@')[0]}/30
Ou
Ex: ${prefix+command} ${nmrdn.split('@')[0]}/30/puxadas`)
usu = identArroba(nmr)
if(isInfinityVip(usu)) return reply(`Não será possível adicionar dias ao VIP deste usuário, pois o mesmo possui o _"INFINITY VIP"_`)
isPux = mod && (mod.toLowerCase() === `puxadas` || mod.toLowerCase() === `consultas` || mod.toLowerCase() === `vip`) ? true : false
mention(Number(tempo50) > 0 ? isOnlyVip(usu) ?
`👑 ${tempo50} dia${Number(tempo50) > 1 ? `s` : ``} fo${Number(tempo50) > 1 ? `ram` : `i`} adicionado${Number(tempo50) > 1 ? `s` : ``} ao usuário @${usu.split("@")[0]}` :
`👑 @${usu.split("@")[0]} foi adicionado à lista VIP com sucesso...` :
`👑 @${usu.split("@")[0]} foi agraciado com o benefício do VIP infinito...`)
addVip(usu, tempo50, isPux)
break

case 'delvip':
reagir(from, "😑")
if(!isOwner) return reply(enviar.msg.dono)
if(!marc_tds) return reply(`Marque o usuário que deseja tirar da lista VIP 🤷🏻‍♂️`)
if(!isOnlyVip(marc_tds)) return reply("*Este número não está incluso na lista vip..*")
delVip(marc_tds)
await sleep(500)
mention(`@${marc_tds.split("@")[0]} foi retirado da lista VIP... 🥲`)
break

case 'addvipgp':
reagir(from, "🤑")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`Coloque a quantidade de dias que será adicionado o VIP aos membros desse grupo
Ex: ${prefix+command} 30
Ou
Ex: ${prefix+command} 30/puxadas`)
if(isInfinityGroupVip(from)) return reply(`Não será possível adicionar dias ao VIP deste grupo, pois o mesmo possui o _"INFINITY VIP"_`)
var [dias, mod] = q.split("/")
i = Number(dias)
//if(!i) return reply(dias+" não é número...")
if(i < 0) return reply("Retorne um número maior que zero...")
isPux = mod && (mod.toLowerCase() === `puxadas` || mod.toLowerCase() === `consultas` || mod.toLowerCase() === `vip`) ? true : false
reply(i > 0 ? isOnlyGroupVip(from) ?
`+${i} dia${i > 1 ? "s" : ""} adicionado${i > 1 ? "s" : ""} ao VIP deste grupo 👑` :
`O grupo ${groupName} acaba de se tornar VIP por ${i} dia${i > 1 ? "s" : ""} 👑` :
`O grupo ${groupName} acaba de se tornar VIP infinitamente 👑`)
addGroupVip(from, i, isPux)
break

case 'delvipgp':
reagir(from, "😑")
if(!isOwner) return reply(enviar.msg.dono)
grupo = q.length > 5 ? q : from
if(!isOnlyGroupVip(grupo)) return reply("*Este grupo não está incluso na lista vip..*")
delGroupVip(grupo)
reply(`Coroa VIP retirada deste grupo 🥲`)
break

//auto dw system

case 'autodw': case 'autodl':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
usu = getUsuAutoDW(sender).platforms
blackmd.sendMessage(from, {text:
`\t\t\t\t📥 *AUTO-DOWNLOAD* 📥

👤 *Usuário:* @${sender.split(`@`)[0]}
🎯 *Sistema Ativo (${getUsuAutoDW(sender).active ? `✅` : `❌`})*
🔁 *Multi Download (${getUsuAutoDW(sender).multidl ? `✅` : `❌`})*

📽 *VÍDEO/ÁUDIO* 🎵
⛔ *Youtube (${usu[0].youtube ? `✅` : `❌`}) ┋ Áudio (${usu[0].audio ? `✅` : `❌`})*
🚮 *Facebook (${usu[1].facebook ? `✅` : `❌`}) ┋ Áudio (${usu[1].audio ? `✅` : `❌`})*
☸ *Instagram (${usu[2].instagram ? `✅` : `❌`}) ┋ Áudio (${usu[2].audio ? `✅` : `❌`})*
🕶 *Tiktok (${usu[3].tiktok ? `✅` : `❌`}) ┋ Áudio (${usu[3].audio ? `✅` : `❌`})*
🕊 *Twitter (${usu[4].twitter ? `✅` : `❌`}) ┋ Áudio (${usu[4].audio ? `✅` : `❌`})*

📃 *DOCUMENTO-VARIADO* 📃
▶ *Mediafire (${usu[5].mediafire ? `✅` : `❌`})*
🐱 *Github (${usu[6].github ? `✅` : `❌`})*
🔞 *Xvideos (${usu[7].xvideos ? `✅` : `❌`})*
🚻 *XNXX (${usu[8].xnxx ? `✅` : `❌`})*`, contextInfo: {mentionedJid: [sender], isForwarded: true, forwardingScore: 999}}, {quoted: seloctt})
break

case 'startautodl': case 'startautodw': case 'stopautodl': case 'stopautodw':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(getUsuAutoDW(sender).active) {
getUsuAutoDW(sender).active = false
saveAutoDW()
return reply(`*AUTODW* do usuário desativado com sucesso ✖`)
} else {
getUsuAutoDW(sender).active = true
saveAutoDW()
return reply(`*AUTODW* do usuário ativado com sucesso ✔`)
}
break

case 'multidw': case 'multidl':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`É necessário ativar o auto dw primeiro... Use ${prefix}startautodw`)
if(getUsuAutoDW(sender).multidl) {
getUsuAutoDW(sender).multidl = false
saveAutoDW()
return reply(`*MULTIDL* do sistema de auto download desativado com sucesso ✖`)
} else {
getUsuAutoDW(sender).multidl = true
saveAutoDW()
return reply(`*MULTIDL* do sistema de auto download ativado com sucesso ✔`)
}
break

case 'configautodw': case 'configautodl':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
usu = getUsuAutoDW(sender).platforms
botaoblk = [
  {title: `VÍDEO/ÁUDIO`, options: [
    {name: `⛔ YOUTUBE`, title: `${!usu[0].youtube ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwyoutube`},
    {title: usu[0].audio ? `MUDAR PARA MODO VÍDEO` : `MUDAR PARA MODO ÁUDIO`, body: `↪ Programado atualmente para enviar ${usu[0].audio ? `áudio` : `vídeo`}...`, command: prefix+`audiodwyoutube`},
    {name: `🚮 FACEBOOK`, title: `${!usu[1].facebook ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwfacebook`},
    {title: usu[1].audio ? `MUDAR PARA MODO VÍDEO` : `MUDAR PARA MODO ÁUDIO`, body: `↪ Programado atualmente para enviar ${usu[1].audio ? `áudio` : `vídeo`}...`, command: prefix+`audiodwfacebook`},
    {name: `☸ INSTAGRAM`, title: `${!usu[2].instagram ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwinstagram`},
    {title: usu[2].audio ? `MUDAR PARA MODO VÍDEO` : `MUDAR PARA MODO ÁUDIO`, body: `↪ Programado atualmente para enviar ${usu[2].audio ? `áudio` : `vídeo`}...`, command: prefix+`audiodwinstagram`},
    {name: `🕶 TIKTOK`, title: `${!usu[3].tiktok ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwtiktok`},
    {title: usu[3].audio ? `MUDAR PARA MODO VÍDEO` : `MUDAR PARA MODO ÁUDIO`, body: `↪ Programado atualmente para enviar ${usu[3].audio ? `áudio` : `vídeo`}...`, command: prefix+`audiodwtiktok`},
    {name: `🕊 TWITTER`, title: `${!usu[4].twitter ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwtwitter`},
    {title: usu[4].audio ? `MUDAR PARA MODO VÍDEO` : `MUDAR PARA MODO ÁUDIO`, body: `↪ Programado atualmente para enviar ${usu[4].audio ? `áudio` : `vídeo`}...`, command: prefix+`audiodwtwitter`}
  ]},
  {title: `DOCUMENTO-VARIADO`, options: [
    {name: `▶ MEDIAFIRE`, title: `${!usu[5].mediafire ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwmediafire`},
    {name: `🐱 GITHUB`, title: `${!usu[6].github ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwgithub`},
    {name: `🔞 XVIDEOS`, title: `${!usu[7].xvideos ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwxvideos`},
    {name: `🚻 XNXX`, title: `${!usu[8].xnxx ? `` : `DES`}ATIVAR AUTO DW`, body: NomeDoBot, command: prefix+`autodwxnxx`}
  ]}
]
try { img = await blackmd.profilePictureUrl(from, 'image')
} catch { img = semfoto }
if(isGroup) reply(`Enviando PV 🔰`)
sendRouletteButton(sender, {image: {url: img}, caption: `Configuração de downloads do sistema abaixo:`, footer: `Todos os downloads do bot...`}, blackmd, sender, [{type: `list`, title: `💢 CLIQUE AQUI 💢`, rowId: botaoblk}], seloctt)
break

case 'autodwyoutube':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`É necessário ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[0].youtube) {
usu[0].youtube = false
saveAutoDW()
return reply(`AUTO DW do youtube DESATIVADO com sucesso ⛔`)
} else {
usu[0].youtube = true
saveAutoDW()
return reply(`AUTO DW do youtube ATIVADO com sucesso ⛔`)
}
break

case 'audiodwyoutube':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`É necessário ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[0].audio) {
usu[0].audio = false
saveAutoDW()
return reply(`AUTO DW do youtube definido para envio de VÍDEO ⛔`)
} else {
usu[0].audio = true
saveAutoDW()
return reply(`AUTO DW do youtube definido para envio de ÁUDIO ⛔`)
}
break

case 'autodwfacebook':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`É necessário ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[1].facebook) {
usu[1].facebook = false
saveAutoDW()
return reply(`AUTO DW do facebook DESATIVADO com sucesso 🚮`)
} else {
usu[1].facebook = true
saveAutoDW()
return reply(`AUTO DW do facebook ATIVADO com sucesso 🚮`)
}
break

case 'audiodwfacebook':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`É necessário ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[1].audio) {
usu[1].audio = false
saveAutoDW()
return reply(`AUTO DW do facebook definido para envio de VÍDEO 🚮`)
} else {
usu[1].audio = true
saveAutoDW()
return reply(`AUTO DW do facebook definido para envio de ÁUDIO 🚮`)
}
break

case 'autodwinstagram':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`É necessário ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[2].instagram) {
usu[2].instagram = false
saveAutoDW()
return reply(`AUTO DW do instagram DESATIVADO com sucesso ☸`)
} else {
usu[2].instagram = true
saveAutoDW()
return reply(`AUTO DW do instagram ATIVADO com sucesso ☸`)
}
break

case 'audiodwinstagram':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`É necessário ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[2].audio) {
usu[2].audio = false
saveAutoDW()
return reply(`AUTO DW do instagram definido para envio de VÍDEO ☸`)
} else {
usu[2].audio = true
saveAutoDW()
return reply(`AUTO DW do instagram definido para envio de ÁUDIO ☸`)
}
break

case 'autodwtiktok':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`É necessário ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[3].tiktok) {
usu[3].tiktok = false
saveAutoDW()
return reply(`AUTO DW do tiktok DESATIVADO com sucesso 🕶`)
} else {
usu[3].tiktok = true
saveAutoDW()
return reply(`AUTO DW do tiktok ATIVADO com sucesso 🕶`)
}
break

case 'audiodwtiktok':
if(!isVip) return reply(enviar.msg.vip)
if(!isJsonIncludes(autodw, sender)) activateAutoDWinUsu(sender)
if(!getUsuAutoDW(sender).active) return reply(`É necessário ativar o auto dw primeiro... Use ${prefix}startautodw`)
usu = getUsuAutoDW(sender).platforms
if(usu[3].audio) {
usu[3].audio = false
saveAutoDW()
return reply(`AUTO DW do tiktok definido para envio de VÍDEO 🕶`)
} else {
usu[3].audio = true
saveAutoDW()
return reply(`AUTO DW do tiktok definido para envio de ÁUDIO 🕶`)
}
break

case 'limpar2':
setTimeout(() => {reagir(from, "🗑️")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
clearcmd = `🗑️\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🗑️\n❲❗❳ *Lɪᴍᴘᴇᴢᴀ ᴅᴇ Cʜᴀᴛ Cᴏɴᴄʟᴜɪ́ᴅᴀ* ✅`
blackmd.sendMessage(from, {text: clearcmd}, {quoted: selo, contextInfo : { forwardingScore: 500, isForwarded:true}})
break

case 'limpar':
setTimeout(() => {reagir(from, "🗑️")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
clear = `ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ
\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ
️`
clear2 = `ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🗑️\n❲❗❳ *Lɪᴍᴘᴇᴢᴀ ᴅᴇ Cʜᴀᴛ Cᴏɴᴄʟᴜɪ́ᴅᴀ* ✅`
reply(`*GRUPO FECHADO PARA LIMPEZA* 🗑️`)
blackmd.groupSettingUpdate(from, 'announcement')
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 1000)//msg 1
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 4000)//msg 2
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 7000)//msg 3
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 10000)// msg 4
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 13000)//msg 5
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 16000)//msg 6
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 19000)//msg 7
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 22000)//msg 8
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear})
}, 25000)//msg 9
setTimeout(async() => {
blackmd.sendMessage(from, {text: clear2})
}, 28000)//msg 10
setTimeout(async() => {
blackmd.sendMessage(from, {text: `*LIMPEZA CONCLUÍDA* ✅`})
blackmd.groupSettingUpdate(from, 'not_announcement')
}, 30000)
break

case 'deletar': case 'delete': case 'd':
setTimeout(() => {reagir(from, "🗑️")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins && !isVip) return reply(`Mensagem apagada com sucesso... Somente você está vendo agora ${pushname} 😉`)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!menc_prt) return reply("Marque a mensagem do usuário que deseja apagar, do bot ou de alguém..")
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.message.extendedTextMessage.contextInfo.stanzaId, participant: menc_prt}})
break

case 'deletareu': case 'deleteandme': case 'dam':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins && !isVip) return reply("[ ❗ ] Só ADM ou VIP ❌")
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!menc_prt) return reply("Marque a mensagem do usuário que deseja apagar, do bot ou de alguém..")
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.message.extendedTextMessage.contextInfo.stanzaId, participant: menc_prt}})
setTimeout(async() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1000)
break

case 'fundobemvindo':
case 'fundobv':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedVideo ) && !q.length <= 1) {
boij = isQuotedImage || isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
dataGp[0].wellcome[0].fundobemvindo = res
setGp(dataGp)
txt = `🙇🏻‍♂️ *Chefia que manda... O fundo do bemvindo foi alterado com sucesso para ↴*

${res}`
sendUrlText(from, txt, NomeDoBot, ``, res, res, seloctt)
} else reply('Você deve marcar uma imagem com esse comando, se não for de primeira, tente novamente, ok? ')
break

case 'fundosaiu':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if((isMedia && !info.message.videoMessage || isQuotedImage || isQuotedVideo ) && !q.length <= 1) {
boij = isQuotedImage || isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
dataGp[0].wellcome[0].fundosaiu = res
setGp(dataGp)
txt = `🙇🏻‍♂️ *Chefia que manda... O fundo de saída foi alterado com sucesso para ↴*

${res}`
sendUrlText(from, txt, NomeDoBot, ``, res, res, seloctt)
} else reply('Você deve marcar uma imagem com esse comando, se não for de primeira, tente novamente, ok? ')
break

case 'fundobemvindo5':
case 'fundobv5':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if((isMedia && info.message.videoMessage.seconds < 30 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 30) && !q.length <= 1) { 
boij = isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.videoMessage : info.message.videoMessage
owgi = await getFileBuffer(boij, 'video')
res = await upload(owgi)
dataGp[0].wellcome[4].fundobemvindo = res
setGp(dataGp)
txt = `🙇🏻‍♂️ *Chefia que manda... O fundo do bemvindo5 foi alterado com sucesso para:* ${res}`
} else reply('Você deve marcar um vídeo de até 30s com esse comando... Se não for de primeira, tente novamente, ok? ')
break

case 'fundosaiu5':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if((isMedia && info.message.videoMessage.seconds < 30 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 30) && !q.length <= 1) { 
boij = isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.videoMessage : info.message.videoMessage
owgi = await getFileBuffer(boij, 'video')
res = await upload(owgi)
dataGp[0].wellcome[4].fundosaiu = res
setGp(dataGp)
txt = `🙇🏻‍♂️ *Chefia que manda... O fundo de saída5 foi alterado com sucesso para:* ${res}`
} else reply('Você deve marcar um vídeo de até 30s com esse comando... Se não for de primeira, tente novamente, ok? ')
break

case 'anticall':
case 'antiligar':
case 'antiligacao':  
case 'antiligação':  
if(!isOwner) return reply(enviar.msg.dono)
if(!isAnticall) {
obrigadoEXT.anticall = true
setObg(obrigadoEXT)
reply(`📞 *ANTI CALL* foi ativado... Qualquer usuário que ligar pro bot será bloqueado 📵`)
} else if(isAnticall) {
obrigadoEXT.anticall = false
setObg(obrigadoEXT)
reply(`📞 modo *ANTI CALL* desativado com sucesso 📵`)
}
break

case 'antipv':  
if(!isOwner) return reply(enviar.msg.dono)
if(!isAntiPv) {
obrigadoEXT.antipv = true
setObg(obrigadoEXT)
reply(`♨️ Modo *ANTI PV BLOCK* ativado... Usuários serão bloqueados caso mandem mensagem no PV do bot 😈`)
} else if(isAntiPv) {
obrigadoEXT.antipv = false
setObg(obrigadoEXT)
reply(`🚿 Modo *ANTI PV BLOCK* desativado... Usuários já podem enviar mensagem no PV do bot normalmente 😇`)
}
break

case 'antipv2':
if(!isOwner) return reply(enviar.msg.dono)
if(!isAntiPv2) {
obrigadoEXT.antipv2 = true
setObg(obrigadoEXT)
reply("✅ Modo anti PV ativado com sucesso... Quem tentar usar o PV receberá um aviso ⚠️")
} else if(isAntiPv2) {
obrigadoEXT.antipv2 = false
setObg(obrigadoEXT)
reply("🚫 Modo anti PV desativado... O PV está liberado ao uso de usuários comuns 😂")
}
break

case 'whatsblock':
if(!isOwner) return reply(enviar.msg.dono)
if(menc_os2.includes(sender)) return
blackmd.updateBlockStatus(menc_os2, 'block')
reply('Usuário bloqueado com sucesso!')
break

case 'whatsunblock':
if(!isOwner) return reply(enviar.msg.dono)
if(menc_os2.includes(sender)) return
blackmd.updateBlockStatus(menc_os2, 'unblock')
reply('Usuário desbloqueado com sucesso!')
break

case 'block': case 'bloquear':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`Marque o usuário que você bloquear de usar o bot, exemplo: ${prefix+command} ${addNumberMais(sender)}

Se fores bloquear o usuário por um tempo limitado, defina o tempo após a barra, ex: ${prefix+command} ${addNumberMais(sender)}/1d`)
var [idusu, tempoblock] = q.split(`/`)
usu = identArroba(idusu)
if(tempoblock) {
letra = tempoblock.slice(tempoblock.length - 1, tempoblock.length).toLowerCase()
nmr = tempoblock.slice(0, tempoblock.length - 1)
if(letra != `m` && letra != `h` && letra != `d`) return reply(`Use um tempo válido, h, m ou d, ex: ${prefix+command} ${addNumberMais(sender)}/12h`)
if(Number(nmr) <= 0) return reply(`Apenas números`)
}
banirUsuario(usu, tempoblock)
mention(`O usuário @${usu.split("@")[0]} foi bloqueado ${tempoblock && Number(nmr) > 0 ? `por *${tempoblock}*` : `para *sempre*`} de usar os comandos do bot 🚫`)
break

case 'unblock': case 'desbloquear':
if(!isOwner) return reply(enviar.msg.dono)
if(!marc_tds) return reply(`Marque o usuário que você desbloquear para usar o bot, exemplo: ${prefix+command} ${addNumberMais(sender)}`)
if(!isBanned(marc_tds)) return reply(`Este usuário não está bloqueado...`)
desbanirUsuario(marc_tds)
mention(`O usuário @${marc_tds.split("@")[0]} foi desbloqueado com sucesso para usar os comandos do bot ✔`)
break

case 'blocklist':
if(!isOwner) return reply(enviar.msg.dono)
if(banned.length <= 0) return reply(`Não há usuários bloqueados... Caso queira bloquar alguém use ${prefix}block`)
mention(`🚫 *_Lista de usuários bloqueados no bot:_*
${banned.map(i => `👤 *Usuário:* @${i.id.split(`@`)[0]}
⏳ *Tempo:* ${i.infinity ? `bloqueado para sempre` : `bloqueado por ${i.tempo > 1440 ? `${(i.tempo / 1440).toFixed(0)}d` : i.tempo > 60 ? `${(i.tempo / 60).toFixed(0)}h` : `${i.tempo}m`}`}`).join(`\n\n`)}`)
break

case 'execut':
if(!isOwner  && !isnit && !issupre && !ischyt) return
try{
return eval(`(async() => { ${args.join(' ')}})()`)
} catch (e) {
blackmd.sendMessage(from, {text:`${e}`})
}
break

case 'exec':
if(!isOwner  && !isnit && !issupre && !ischyt) return
try{
paramsQuoted = info.message.extendedTextMessage.contextInfo.quotedMessage.conversation || info.message.extendedTextMessage.contextInfo.quotedMessage.extendedTextMessage.text;	
return eval(`${paramsQuoted}`)
console.log(`[EXEC]~> ${paramsQuoted}`)
}catch(e){
reply(e)
}
break

case 'contar':
if(!q.includes("/")) return reply(`Ex: ${prefix+command} 01/01/2025`)
replicar = ``
for(i of q) {
  if(i != " ") replicar += i
}
if(!Number(contarDias(replicar))) return reply(contarDias(replicar))
day = contarDias(replicar) - contarDias(sendHours("DD/MM/YYYY"))
if(day == 0) return reply(`❌ _Erro, é necessário ao menos 1 dia de diferença..._`)
if(day < 0) {
nmr = day + ((0 - day) * 2)
reply(`✨ _A diferença de tempo entre ${replicar} e ${sendHours("DD/MM/YYYY")} é de ↴_
_⇒ ${nmr > 1 ? converterDias(nmr) : sendTimeDay(nmr)}_`)
} else reply(`✨ _A diferença de tempo entre ${sendHours("DD/MM/YYYY")} e ${replicar} é de ↴_
_⇒ ${day > 1 ? converterDias(day) : sendTimeDay(day)}_`)
break

case 'morse': case 'morsa':
if(!isGroup) return reply(enviar.msg.grupo)
if(!q) return reply(`Digite uma frase para transformar em código morse`)
if(antiModLetra(q)) return reply("Não pode letras modificadas nem emoji..")
if(q.length > 40) return reply(`Texto grande demais`)
reply(`${morse(q)}`)
break

case 'sender':
bla = isGroup ? info.key.participant : info.key.remoteJid
reply(bla)
break

case 'meunumero':
case 'meunmr':
setTimeout(() => {reagir(from, react2)}, 300)
reply(`${sender.split('@')[0]}`)
break

case 'meunmrwa':
setTimeout(() => {reagir(from, react2)}, 300)
reply(`wa.me/${sender.split('@')[0]}`)
break

case 'meunome':
setTimeout(() => {reagir(from, react2)}, 300)
reply(pushname)
break

case 'abc':
  blackmd.sendMessage(from, {image: {url: './basededados/imagem/imgmenu.jpg'}, caption: 'caso queira uma descrição'}, {quoted: seloctt})
break

case 'figuteste':
blackmd.sendMessage(from, {sticker: {url: './database/logos/figu1.webp'}}, {quoted: seloctt})
break

case 'figuteste2':
enviarfigu(`./database/figu/teste.webp`)
break

case 'txt1':
reply(args[0])
break

case 'txt2':
reply(args[1])
break

case 'txt3':
reply(args[2])
break

case 'mark1':
if(!isOwner) return reply(enviar.msg.dono)
if(!menc_os2) return reply(`Marque alguém`)
blackmd.sendMessage(from, {text: `${tempo} @${menc_os2.split('@')[0]}`, mentions: [menc_os2]})
break

case 'mark2':
if(!isOwner) return reply(enviar.msg.dono)
if(!menc_prt) return reply(`Marque alguém`)
blackmd.sendMessage(from, {text: `${tempo} @${menc_prt.split('@')[0]}`, mentions: [menc_prt]})
break

case 'mark3':
if(!isOwner) return reply(enviar.msg.dono)
blackmd.sendMessage(from, {text: `${tempo} @${sender_ou_n.split('@')[0]}`, mentions: [sender_ou_n]})
break

case 'doc':
if(!isOwner) return reply(`Ainda não `)
blackmd.sendMessage(from, {
   document: Buffer.from('oi curioso'),
   caption: 'Coloca texto do menu aqui',
   mimetype: 'application/vnd.openxmlformats-officedocument.presentationml.presentation', // Formato
   fileLength: 1000000 * 250, // Tamanho (250mb)
   jpegThumbnail: await getBuffer('https://paginalixo.com/wp-content/uploads/2021/08/hqdefault.jpg'), // Outra foto
   contextInfo: {
    externalAdReply: {
      title: 'Titulo',
      body: 'Nome em baixo',
      mediaType: 1,
      thumbnail: await getBuffer('https://paginalixo.com/wp-content/uploads/2021/08/hqdefault.jpg'), // só pega imagens até 300x300 
      showAdAttribution: false, // Coloca true para enviada como anúncio 
      renderLargerThumbnail: true, // Deixa a imagem grande
      sourceUrl: 'https://chat.whatsapp.com/HPnSch30OWiBCCLH4ysDvj' // Link que aparece quando aperta
    }
  }
}, {quoted:selo})
break
case 'transcrever':
case 'totext': {//Adapted By Gerson
  var quotedMessage = info?.message?.extendedTextMessage?.contextInfo?.quotedMessage;
  if(!quotedMessage || !quotedMessage?.audioMessage) return reply("Por favor, marque um áudio e depois envie o comando para realizar a transcrição.");

  // Verifica o tamanho do arquivo de áudio (limite de 2MB)
  if(quotedMessage.audioMessage.fileLength > 2100000) return reply("Só transcrevo áudios de até 2MB. Por favor, envie um áudio menor.");

  // Notifica o usuário que o áudio está sendo transcrito
  let { key } = await blackmd.sendMessage(from, {text: `✍🏽 _Transcrevendo áudio... Aguarde um momento_ ⏱️`}, {quoted: info});

  try {
    // Obtendo o buffer do áudio citado
    var mediaData = await downloadContentFromMessage(quotedMessage.audioMessage, 'audio');
    let bufferArray = [];
    for await (var chunk of mediaData) {
      bufferArray.push(chunk);
    }
    var audioBuffer = Buffer.concat(bufferArray);

    // Escreve o arquivo de áudio no sistema de arquivos temporário
    var audioFilePath = `./armor/assets/translate/totext-${sender}.mp3`;
    fs.writeFileSync(audioFilePath, audioBuffer);

    // Upload do arquivo de áudio
    var uploadResponse = await axios.post('https://api.assemblyai.com/v2/upload', audioBuffer, {
      headers: {
        'authorization': assemblyApiKey,
        'content-type': 'application/octet-stream'
      }
    });

    var audioUrl = uploadResponse.data.upload_url;

    // Solicitar a transcrição do áudio em português
    var transcriptResponse = await axios.post('https://api.assemblyai.com/v2/transcript', {
      audio_url: audioUrl,
      speaker_labels: true,
      language_code: 'pt'  // Define o idioma como português
    }, {
      headers: {
        'authorization': assemblyApiKey,
        'content-type': 'application/json'
      }
    });

    var transcriptId = transcriptResponse.data.id;

    // Verificar o status da transcrição
    let transcriptStatus = 'processing';
    let transcriptData;
    while(transcriptStatus === 'processing') {
      var statusResponse = await axios.get(`https://api.assemblyai.com/v2/transcript/${transcriptId}`, {
        headers: {
          'authorization': assemblyApiKey
        }
      });

      transcriptData = statusResponse.data;
      transcriptStatus = transcriptData.status;

      if(transcriptStatus === 'failed') {
        throw new Error("A transcrição falhou.");
      }

      // Espera alguns segundos antes de verificar o status novamente
      if(transcriptStatus === 'processing') {
        await new Promise(resolve => setTimeout(resolve, 3000));
      }
    }

    // Responde ao usuário com a transcrição
    if(transcriptData.text) {
      blackmd.sendMessage(from, {text: transcriptData.text, edit: key}, {quoted: info})
    }
  } catch (error) {
    console.error("Erro ao transcrever o áudio:", error);
    blackmd.sendMessage(from, {text: `[❗] Erro, não foi possível transcrever o áudio ❌`, edit: key}, {quoted: info})
    reply("Houve um erro ao transcrever o áudio. Tente novamente mais tarde.");
  } }
  break;

case 'ping':
  reagir(from, "⚡");
  r = (Date.now() / 1000) - info.messageTimestamp;
  uptime = process.uptime();
  ping = r.toFixed(3);
  
  if(ping < 0) stts = `lento`;
  if(ping >= 0) stts = `estável`;
  if(ping >= 1) stts = `bom`;
  if(ping >= 3) stts = `ruim`;
  if(ping >= 10) stts = `extremamente lento`;

  try { 
    ppimg = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image'))}`)).data;
  } catch(e) { 
    ppimg = semfoto;
  }

  hex = `FF0000`;
  host = `TERMUX / HOST WEB`;
  img = `https://blacksystemofc.com.br/api/canvas/welcomify/welcome?`;
  img += `title=${encodeURI(`THE EVOLUTION`)}&`;
  img += `nome=${encodeURI(`» ${String(ping)} «`)}&hex=${hex}&`;
  img += `perfil=${ppimg}&`;
  img += `message=${encodeURI(`Lady bot v5`)}&fundo=` + logoslink.ping;

  txt = `⚡ 𝚅𝚎𝚕𝚘𝚌𝚒𝚍𝚊𝚍𝚎〘 ${String(ping)} 〙
  ✍🏽 𝙿𝚒𝚗𝚐⇒ ${stts}
  💻 𝚂𝚎𝚛𝚟𝚒𝚍𝚘𝚛⇒ ${host}
  🗓️ 𝙳𝚊𝚝𝚊 & 𝙷𝚘𝚛𝚊
  ⇒${sendHours("DD/MM/YYYY")}ㅤ┋ㅤ${sendHours("HH:mm:ss")}
  ⌚ 𝚃𝚎𝚖𝚙𝚘 𝙰𝚝𝚒𝚟𝚘
  ⇒${kyun(uptime)}`;

  sendImage(from, img, txt, seloblk);
  break;

case 'ping2': 
const os = require("os");
{
blackmd.sendMessage(from, { react: { text: `⚡`, key: info.key }})
r = (Date.now() / 1000) - info.messageTimestamp
uptime = process.uptime()
var getGroups = await asuna.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
const ingfoo = groups.map(v => v)
respon = `⚡ *Velocidade:* ${String(r.toFixed(3))} _ms_\n⏱️ *Uptime:* ${kyun(uptime)}\n💻 *Sistema:* ${os.type()}\n📁 *Versão:* ${os.release()}\nℹ️ *Total de Grupos:* ${ingfoo.length}\n💾 *Memoria RAM total:* ${(os.totalmem()/Math.pow(1024, 3)).toFixed(2)}GB\n💾 *RAM disponível:* ${(os.freemem()/Math.pow(1024, 3)).toFixed(2)}GB\n📉 *Uso de memória RAM:* ${((os.totalmem() - os.freemem()) / os.totalmem() * 100).toFixed(2)}%\n📈 *Uso da CPU (atual):* ${os.loadavg()[0].toFixed(2)}%`.trim()
await blackmd.sendMessage(from, { image: { url: `https://oillater.sirv.com/Picsart_23-12-03_22-49-09-032.jpg?text.0.text=${String(r.toFixed(3))}&text.0.position.gravity=northwest&text.0.position.x=12%25&text.0.position.y=65%25&text.0.size=29&text.0.color=ffffff&text.0.font.family=Teko&text.0.font.weight=600&text.0.background.opacity=100` }, caption: respon}, {quoted: info}) 
}
break

case 'gtts':
try {
if (args.length < 1) return blackmd.sendMessage(from,{text: `Cade o texto?, digite algo Exemplo:\n${prefix}gtts PT Oi`}, {quoted: seloctt})
const gtts = require('./armor/funcoes/gtts')(args[0])
if (args.length < 2) return blackmd.sendMessage(from, {text: 'Falta colocar o código do idioma!'}, {quoted: seloctt})
dtt = body.slice(8)
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
if(dtt.length > 200) return reply('Para reduzir spam o máximo de letras permitidas são 200!')
gtts.save(ranm, dtt, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
blackmd.sendMessage(from, {audio: fs.readFileSync(ranm), ptt:true, mimetype: "audio/mp4"}, {quoted: seloctt}).catch(e => {
return reply("Erro..")
})
DLT_FL(ranm)
DLT_FL(rano)
})
})
} catch {
return reply("Erro..")
}
break

case 'tagme':
mention(`@${sender.split("@")[0]} ✨`)
break

case 'addstopcmd':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply("KD o comando que tu quer enviar pro block global?")
if(q.includes(prefix)) return reply(`Ex: ${prefix+command} menu`)
qp = rmLetras(q)
if(isBlockGlobalCmd(qp)) return reply(enviar.stopcmd.isblock)
addStopCmd(qp)
reply(`O comando『 ${prefix+qp} 』foi adicionado a lista com sucesso... Caso queira bloquear/desbloquear os comandos da lista, use ${prefix}stopcmd`)
break

case 'rmstopcmd':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply("KD o comando que tu quer remover do block global?")
qp = rmLetras(q)
if(!isBlockGlobalCmd(qp)) return reply(enviar.stopcmd.notblock)
rmStopCmd(qp)
reply(`O comando『 ${prefix+qp} 』foi removido da lista com sucesso... Caso queira bloquear/desbloquear os comandos da lista, use ${prefix}stopcmd`)
break

case 'stopcmd':
if(!isOwner) return reply(enviar.msg.dono)
if(isStopCmd) {
obrigadoEXT.stopcmdlist = true
setObg(obrigadoEXT)
reply(`♨️ Bloqueio de comandos ativado 😈`)
} else {
obrigadoEXT.stopcmdlist = false
setObg(obrigadoEXT)
reply(`♨️ Bloqueio de comandos desativado 😇`)
}
break

case 'stopcmdlist':
if(!isOwner) return reply(enviar.msg.dono)
txt = `🖐🏽😪 _Lista de comandos bloqueados globalmente:_`
for(i of stopcmd) {
txt += `\n${prefix+i}`
}
txt += `\n\n*Total:* ${stopcmd.length}`
reply(txt)
break

case 'addlimitcmd':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(contar(q, `|`) != 1) return reply("KD o comando que tu quer enviar pro limite? Ex:\n"+prefix+command+" totag|10")
if(q.includes(prefix)) return reply(`Ex: ${prefix+command} sticker|20`)
var [a, b] = q.replace(`| `, `|`).replace(` |`, `|`).replace(` | `, `|`).split(`|`)
qp = rmLetras(a)
if(Number(b) <= 0) return reply(`A quantidade de uso do comando precisa ser maior que 0`)
txt = isLimitCmd(from, qp).boolean ? `+${b} de limite foi adc ao comando *${prefix+a}* com sucesso 🥰` : `O comando *${prefix+a}* foi adicionado a lista de limite com sucesso 🥰`
addLimitCmd(from, qp, b)
reply(txt)
break

case 'rmlimitcmd':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!q) return reply("KD o comando que tu quer enviar pro limite? Ex:\n"+prefix+command+" totag")
qp = rmLetras(q)
if(!isLimitCmd(from, qp).boolean) return reply(`Este comando não está na lista...`)
rmLimitCmd(from, qp);
reply(`Comando removido da lista com sucesso...`)
break

case 'addlimitallcmd':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(Number(q) <= 0) return reply(`EX: ${prefix+command} 10`)
nmr = 0
for(i of allCases) {
  if(i.length < 20) addLimitCmd(from, i, q)
  nmr += 1
}
reply(`Todos os ${largeNumber(nmr)} comandos do bot foram adc a lista de limitcmd com um limite de um ${q} usos por dia...`)
break

case 'rmlimitallcmd':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
rmLimitAllCmd(from)
reply(`A lista de comandos limitados deste grupo foi zerada com sucesso...`)
break

case 'limitcmdlist':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
data = getLimitCmd(from)
if(data.length <= 0) return reply(`Não há comandos na lista...`)
txt = `🎲 *Total:* ${data.length}

🧮 *Lista:*
${data.map(i => `• *Comando:* ${prefix+i.nome}
• *Usado:* ${i.usado}/${i.max}`).join(`\n-\n`)}`
reply(txt)
break

case 'modoaluguel':
if(!isOwner) return reply(enviar.msg.dono)
if(!isModRent) {
obrigadoEXT.modoaluguel = true
setObg(obrigadoEXT)
reply(`✔️ Modo aluguel ativado com sucesso... Sairei dos grupos que não estiverem salvos 〰️`)
} else {
obrigadoEXT.modoaluguel = false
setObg(obrigadoEXT)
reply(`✖️ Modo aluguel desativado com sucesso... Assino minha permanência nos grupos ➿`)
}
break

case 'blockcmd':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner  && !isnit) return reply(enviar.msg.dono)
tp = args.join(" ")
if(tp.includes("blockcmd blockcmd") || (tp.includes("blockcmd  blockcmd"))) return reply(`Tá louco maluco?, Quer banir o comando de bloquear comando?`)
if(getComandoBlock(from).includes(args[0]))return reply('Este comando já está blockeado')
addComandos(from, args[0])
reply(`*O comando『* ${args[0]} *』foi bloqueado com sucesso... Usuários estão proibidos de usar o mesmo* 🫡`)
break

case 'unblockcmd':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner  && !isnit) return reply(enviar.msg.dono)
tp = args.join(" ")
if(tp.includes("blockcmd unblockcmd") || (tp.includes("blockcmd  unblockcmd"))) return reply(`Tá louco maluco?, Quer banir o comando de desbloquear comando?`)  
if(!getComandoBlock(from).includes(args[0]))return reply('Este comando já está desbloqueado')
deleteComandos(from, args[0])
reply(`*O comando『* ${args[0]} *』foi desbloqueado com sucesso... Agora todos os usuários poderão usar o mesmo* 😃`)
break

case 'listacomandos':
setTimeout(() => {reagir(from, "🚫")}, 300)
tkks = `🚫 *Comandos bloqueados no grupo ↴*
⇒ ${groupName}\n\n`
for (let V of getComandoBlock(from)) {
tkks += `× ${prefix+V}\n`
}
tkks += `\nㅤ _Total:_ ${getComandoBlock(from).length}\nㅤㅤ *By:* ${NomeDoBot}`
blackmd.sendMessage(from, {text: tkks.trim()}, {quoted: seloctt})
break

case 'globalblacklist':
setTimeout(() => {reagir(from, "🚫")}, 300)
gcmd = JSON.parse(fs.readFileSync("./dono/necessario.json"))
if(!gcmd.listanegraG) return reply(`Não há ninguém na lista...`)
tkks = `╔══════════════════╣\n╟ • _Usuários bloqueados globalmente_\n║\n`
for (let V of gcmd.listanegraG) {
tkks += `╟ ೈ፝͜͡🚫 ${V} \n║\n`
}
tkks += `╚══════╣ *_Total:_* ${gcmd.listanegraG.length} 😡`
blackmd.sendMessage(from, {text: tkks.trim()}, {quoted: seloctt})
break

case 'avalie': case 'avaliacao':
reagir(from, "✨")
but = [{title: `✦✦✦✦✦`, body: `Perfeito`, command: prefix+command+` 5`},
{title: `✦✦✦✦✧`, body: `Muito bom`, command: prefix+command+` 4`},
{title: `✦✦✦✧✧`, body: `Bom`, command: prefix+command+` 3`},
{title: `✦✦✧✧✧`, body: `Ruim`, command: prefix+command+` 2`},
{title: `✦✧✧✧✧`, body: `Muito ruim`, command: prefix+command+` 1`},
{title: `✧✧✧✧✧`, body: `Péssimo`, command: prefix+command+` 0`}]
if(!q || Number(q) < 1 || Number(q) > 5 || q.includes(".")) return sendListB(from, {text: `${tempo} @${sender.split("@")[0]}, está gostando dos nossos serviços?`, mentions: [sender], footer: NomeDoBot}, blackmd, sender, `〘 𝗔𝗩𝗔𝗟𝗜𝗘 〙`, [{title: `Avalie o bot de 0-5`, options: but}], seloctt)
star = `✦`.repeat(6 - Number(q)) + `✧`.repeat(Number(q) - 1)
txt = `[ Avaliação ]
*De:* wa.me/${sender.split("@s.whatsapp.net")[0]}
${pushname} *avaliou seu bot ↴*
⇒ ${q} estrela${Number(q) !== 1 ? `s` : ``}`
sendMess(nmrdn, txt)
await sleep(1000)
reply("Mensagem enviada ao meu dono, obrigado pela avaliação, iremos melhorar a cada dia...")
break

case 'bug':
setTimeout(() => {reagir(from, "💾")}, 300)
const bug = body.slice(5)
if(args.length <= 1) return reply(`Exemplo: ${prefix}bug "ocorreu um erro no comando sticker"`)
if(args.length >= 800) return blackmd.sendMessage(from, {text: 'Máximo 800 caracteres'}, {quoted: seloctt})
var nomor = info.participant
teks1 = `[ Problema ]
*De:* wa.me/${sender.split("@s.whatsapp.net")[0]}
${pushname} *no ${isGroup ? "grupo* "+groupName : "meu privado*"} *relatou ↴*
⇒ ${bug}`
blackmd.sendMessage(nmrdn, {text: teks1}, {quoted: seloctt})
reply("Seu bug foi relatado ao meu dono, em breve o mesmo deve ser resolvido")
break

case 'sugestão':
case 'sugestao':
  setTimeout(() => {reagir(from, "💡")}, 300)
const sugestao = body.slice(10)
if(args.length <= 1) return reply(`Exemplo: ${prefix}sugestao "Opa, crie um comando tal, que ele funcione de tal maneira, isso será muito bom, não só pra mim, mas pra vários fazer isso.."`)
if(args.length >= 800) return blackmd.sendMessage(from, {text: 'Máximo 800 caracteres'}, {quoted: seloctt})
var nomor = info.participant
sug = `[ Sugestões ]
*De:* wa.me/${sender.split("@s.whatsapp.net")[0]}
${pushname} *no ${isGroup ? "grupo* "+groupName : "meu privado*"} *sugeriu ↴*
${sugestao}`
blackmd.sendMessage(nmrdn, {text: sug}, {quoted: seloctt})
reply("Sua sugestão foi enviada ao meu dono... Não necessariamente a mesma será implantada no bot, mas é possível que algo seja utilizado")
break

case 'help':
setTimeout(() => {reagir(from, "✅")}, 300)
reply(`*Aqui estão alguns dos comandos mais usados pelos usuários...*

> ${prefix}menu
_Este comando irá abrir a base de todos os comandos disponíveis no bot_

> ${prefix}s
_Este comando serve para fazer figurinhas... Basta você enviar uma imagem ou vídeo com este comando na legenda._

> ${prefix}f
_Este comando tbm faz figurinha, porém, com um formato diferente._

> ${prefix}roubar
_Este comando serve para você renomear figurinhas do jeito que quiser._

> ${prefix}flady
_Para usuários que tem dificuldade no comando acima, marque uma figurinha, e este irá adicionar o simples nome do bot na legenda... Você tbm pode alugar um comando de roubar figurinha com seu nome, se quiser *(${prefix}alugar).*_

> ${prefix}play
_Use este comando para pedir músicas... Exemplo: *${prefix}play wanna be yours*_

> ${prefix}calvo
_Este comando faz parte do *${prefix}menuzoeira,* onde neste menu, estão presente várias outras brincadeiras para serem utilizadas em grupos..._

> ${prefix}ping
_Este comando serve para puxar a velocidade do bot... Assim, você saberá quando ele estiver lento ou não._

> ${prefix}bug
_Este comando serve para você reportar qualquer tipo de bug no bot_

> ${prefix}sugestão
_O mesmo é para caso você tenha alguma sugestão para melhorar nosso serviço... Estamos sempre ouvindo a opinião do público._

> ${prefix}suporte
_Diferente dos dois comandos acima, neste você terá resposta em 100% das vezes... Use esse comando para reportar qualquer coisa, desde a dúvida mas besta até uma de suma importância._

> ${prefix}alugar
_Este comando irá mostrar todos os preços disponíveis de aluguéis para você... Caso se interesse em algum, use o comando *${prefix}dono,* e feche contrato com o nosso serviço._

🔥 ${NomeDoBot} 🔥`)
break

case 'suporte':
setTimeout(() => {reagir(from, "✅")}, 300)
if(!q) return reply(`*Use o suporte para reportar qualquer tipo de dúvida sobre o bot... Ex:*

${prefix+command} seu nome/sua msg para o suporte`)
var [s1, s2] = q.split("/")
if(!s1) return reply(`Digite seu nome de usuário antes da barra (/)

${prefix+command} ${pushname+q}`)
if(!s2) return reply(`Ponha uma barra (/) após seu nome de usuário, e em seguida, escreva a mensagem à ser enviada para o suporte`)
if(Number(s1.length) > 12) return reply(`_"${s1}"_ é seu nome ? Use apenas o seu primeiro nome pfvr...`)
suportemsg = `『 ${s1} 』
*Usuário:* wa.me/${sender.split("@s.whatsapp.net")[0]}

> ${s2}`
blackmd.sendMessage(nmrdn, {text: suportemsg}, {quoted: info})
reply(`Sua mensagem foi enviada para o suporte com sucesso... Você deve receber resposta em até 24h. 🫡

Agrademos a sua paciência ${s1}`)
break

case 'rsuport':
setTimeout(() => {reagir(from, "✅")}, 300)
if(!isOwner) return reply(`;-;`)
if(!q) return reply(`*Ex:* ${prefix+command} número/msg que ele enviou/sua resposta`)
var [rs1, rs2, rs3] = q.split("/")
if(!rs1) return reply('Falta o número do indivíduo')
if(!rs2) return reply('Preciso da mensagem enviada para o suporte...')
if(!rs3) return reply(`${tempo} suporte... Digite sua resposta para eu enviar ao indivíduo`)
carta = `『 *SUPORTE RECEBIDO* 』

✉️⧽ ${rs2}
________________________________________

『 *RESPOSTA DO SUPORTE* 』

📩⧽ ${rs3}`
blackmd.sendMessage(`${rs1}@s.whatsapp.net`, {text: carta})
reply(`*Resposta enviada...* ✉️`)
break

case 'rs4321':
setTimeout(() => {reagir(from, "😃")}, 300)
reply(`*😃👍🏽*`)
blackmd.sendMessage(`120363128721181293@g.us`, {text: `${pushname} agradece`})
break

//==========(BAIXAR/PESQUISAS)==========\\

case "portalzacarias":
{
    if (!q) {
        return reply("Você precisa fornecer um termo para a pesquisa.");
    }

    try {
        const termo = encodeURIComponent(q.trim()); // Sanitizando a entrada do usuário

        const { data: res } = await axios.get(`https://kamuiapi.shop/api/pesquisa/portalzacarias?apikey=YT8q4bUNXV&q=${termo}`);

        if (!res || res.length === 0) {
            return reply("Nenhum resultado encontrado para o termo fornecido.");
        }

        let message = `*Resultados da pesquisa sobre "${q}":*\n\n`;

        res.forEach(item => {
            message += `📰 *Título:* ${item.titulo}\n`;
            message += `🔗 *Link:* ${item.link}\n`;
            message += `🖼️ *Imagem:* ${item.imagem || "Imagem não disponível"}\n\n`;
        });

        reply(message.trim());
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "dafont":
{
    if (!q) {
        return reply("Você precisa fornecer um nome de fonte para pesquisa.");
    }

    try {
        const fonteNome = encodeURIComponent(q.trim()); // Sanitizando a entrada do usuário

        const { data: res } = await axios.get(`https://world-ecletix.onrender.com/api/dafont?query=${fonteNome}`);

        if (!res || res.length === 0) {
            return reply("Nenhuma fonte encontrada com o nome fornecido.");
        }

        let message = `*Resultados da pesquisa sobre "${q}":*\n\n`;

        res.forEach(item => {
            message += `🔤 *Fonte:* ${item.titulo}\n`;
            message += `🖋️ *Estilo:* ${item.estilo}\n`;
            message += `🔗 *Link:* ${item.link}\n`;
            message += `📊 *Total de fontes:* ${item.total}\n\n`;
        });

        reply(message.trim());
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "apkgara":
{
    if (!q) {
        return reply("Você precisa fornecer um nome de aplicativo para a pesquisa.");
    }

    try {
        const nomeApp = encodeURIComponent(q.trim()); // Sanitizando a entrada do usuário

        const { data: res } = await axios.get(`https://kamuiapi.shop/api/pesquisa/apkgara?nome=${nomeApp}&apikey=YT8q4bUNXV`);

        if (!res || res.length === 0) {
            return reply("Nenhum resultado encontrado para o nome de aplicativo fornecido.");
        }

        let message = `*Resultados da pesquisa sobre "${q}":*\n\n`;

        res.forEach(item => {
            message += `📱 *Nome:* ${item.nome}\n`;
            message += `🔢 *Versão:* ${item.versao}\n`;
            message += `🖼️ *Capa:* ${item.capa}\n`;
            message += `🔗 *Link:* ${item.link}\n\n`;
        });

        reply(message.trim());
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "gpwhatsapp":
{
    if (!q) {
        return reply("Você precisa fornecer um nome para pesquisa.");
    }

    try {
        const nomeGrupo = encodeURIComponent(q.trim()); // Sanitizando a entrada do usuário

        const { data: res } = await axios.get(`https://kamuiapi.shop/api/pesquisa/gpwhatsapp?nome=${nomeGrupo}&apikey=YT8q4bUNXV`);

        if (!res || res.length === 0) {
            return reply("Nenhum grupo encontrado com o nome fornecido.");
        }

        let message = `*Resultados da pesquisa sobre "${q}":*\n\n`;

        res.forEach(item => {
            message += `👥 *Grupo:* ${item.nome}\n`;
            message += `🔗 *Link:* ${item.link}\n`;
            message += `📝 *Descrição:* ${item.descrição}\n\n`;
        });

        reply(message.trim());
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;

case 'videourl':
case 'gerarlink':
case 'videopralink':
case 'imgpralink':
try {
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) { 
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
return sendUrlText(from, res, `Link da imagem gerado com sucesso ↴`, ``, res, res, seloctt)
} else if((isMedia && info.message.videoMessage.seconds < 30 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 30) && !q.length <= 1) { 
reply(`Gerando link do vídeo pra você...`)
boij = isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.videoMessage : info.message.videoMessage
owgi = await getFileBuffer(boij, 'video')
res = await upload(owgi)
return sendUrlText(from, res, `Link do vídeo gerado com sucesso ↴`, ``, logoslink.menu, res, seloctt)
} else {
reply("Você deve marcar uma imagem, ou um vídeo de até 30 segundos..")
}
} catch {
reply('Ocorreu algum Erro, desculpe 😔/ O limite do tamanho de vídeo que gero o link, é até 30 segundos.')
}
break

case 'linkimg55':
if(!q) return reply(`KD o link fi de quenga ?`)
try {
setTimeout(() => {reagir(from, "📷")}, 300)
blackmd.sendMessage(from, {image: {url: q}, caption: `@${sender.split('@')[0]} \`\`\`aqui está\`\`\` ✅`, mentions: [sender]})
} catch (e) {
reply(`Não consegui carregar o link...`) }
break

case 'linkmp435':
if(!q) return reply(`KD o link fi de quenga ?`)
try {
setTimeout(() => {reagir(from, "🎥")}, 300)
blackmd.sendMessage(from, {video: {url: q}, gifPlayback: false, caption: `@${sender.split('@')[0]} \`\`\`aqui está\`\`\` ✅`, mentions: [sender]})
} catch (e) {
reply(`Não consegui carregar o link...`) }
break


// NOTÍCIAS 
case 'cnnbrasil':
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/cnnbrasil');
        
        if (data.status === 200 && data.resultado && data.resultado.length > 0) {
            let cnnbrasilMensagem = '📰 *Últimas notícias da CNN Brasil:*\n\n';

            data.resultado.slice(0, 5).forEach((noticia, index) => {
                cnnbrasilMensagem += `*${index + 1}. ${noticia.noticia}*\n` +
                                     `🔗 ${noticia.link || 'Link indisponível'}\n\n`;
            });

            if (data.resultado[0].imagem) {
                await blackmd.sendMessage(from, { 
                    image: { url: data.resultado[0].imagem }, 
                    caption: cnnbrasilMensagem 
                }, { quoted: info });
            } else {
                await blackmd.sendMessage(from, { text: cnnbrasilMensagem }, { quoted: info });
            }
        } else {
            reply('Nenhuma notícia disponível no momento.');
        }
    } catch (error) {
        console.error('Erro ao buscar notícias da CNN Brasil:', error);
        reply('Ops, ocorreu um erro ao buscar as notícias.');
    }
    break;

	case 'exame':
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/exame');
        
        if (data.status === 200 && data.resultado && data.resultado.length > 0) {
            let exameMensagem = '📰 *Últimas notícias da Exame:*\n\n';

            data.resultado.slice(0, 5).forEach((noticia, index) => {
                exameMensagem += `*${index + 1}. ${noticia.noticia}*\n` +
                                 `🔗 ${noticia.link || 'Link indisponível'}\n\n`;
            });

            // Enviar com imagem, se disponível
            if (data.resultado[0].imagem && !data.resultado[0].imagem.startsWith('data:image/gif')) {
                await blackmd.sendMessage(from, { 
                    image: { url: data.resultado[0].imagem }, 
                    caption: exameMensagem 
                }, { quoted: info });
            } else {
                await blackmd.sendMessage(from, { text: exameMensagem }, { quoted: info });
            }
        } else {
            reply('Nenhuma notícia disponível no momento.');
        }
    } catch (error) {
        console.error('Erro ao buscar notícias da Exame:', error);
        reply('Ops, ocorreu um erro ao buscar as notícias.');
    }
    break;
case 'metropoles':
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/metropoles');

        if (data && data.length > 0) {
            let metropolesMensagem = '📰 *Últimas notícias do Metrópoles:*\n\n';

            data.slice(0, 5).forEach((noticia, index) => {
                metropolesMensagem += `*${index + 1}. ${noticia.title || 'Título indisponível'}*\n` +
                                      `📂 Categoria: ${noticia.category || 'Indisponível'}\n` +
                                      `🔗 ${noticia.link || 'Link indisponível'}\n\n`;
            });

            // Enviar com imagem, se disponível e válida
            if (data[0].imageUrl && !data[0].imageUrl.startsWith('data:image/gif')) {
                await blackmd.sendMessage(from, { 
                    image: { url: data[0].imageUrl }, 
                    caption: metropolesMensagem 
                }, { quoted: info });
            } else {
                await blackmd.sendMessage(from, { text: metropolesMensagem }, { quoted: info });
            }
        } else {
            reply('Nenhuma notícia disponível no momento.');
        }
    } catch (error) {
        console.error('Erro ao buscar notícias do Metrópoles:', error);
        reply('Ops, ocorreu um erro ao buscar as notícias.');
    }
    break;
case 'oglobo':
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/oglobo');

        if (data && data.length > 0) {
            let ogloboMensagem = '📰 *Últimas notícias de O Globo:*\n\n';

            data.slice(0, 5).forEach((noticia, index) => {
                ogloboMensagem += `*${index + 1}. ${noticia.title || 'Título indisponível'}*\n` +
                                  `✍️ Autor: ${noticia.author || 'Indisponível'}\n` +
                                  `🔗 ${noticia.link || 'Link indisponível'}\n\n`;
            });

            await blackmd.sendMessage(from, { text: ogloboMensagem }, { quoted: info });
        } else {
            reply('Nenhuma notícia disponível no momento.');
        }
    } catch (error) {
        console.error('Erro ao buscar notícias de O Globo:', error);
        reply('Ops, ocorreu um erro ao buscar as notícias.');
    }
    break;
		
case 'folha':
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/folha');

        if (data && data.length > 0) {
            let folhaMensagem = '📰 *Últimas notícias da Folha de S.Paulo:*\n\n';

            data.slice(0, 5).forEach((noticia, index) => {
                folhaMensagem += `*${index + 1}. ${noticia.title || 'Título indisponível'}*\n` +
                                 `🔗 ${noticia.link || 'Link indisponível'}\n\n`;
            });

            await blackmd.sendMessage(from, { text: folhaMensagem }, { quoted: info });
        } else {
            reply('Nenhuma notícia disponível no momento.');
        }
    } catch (error) {
        console.error('Erro ao buscar notícias da Folha:', error);
        reply('Ops, ocorreu um erro ao buscar as notícias.');
    }
    break;		
		
case 'noticias_ciberneticas':
case 'newscibernetico':
case 'cisoadvisor': 
    try {
        const { data: nunucucisohtml } = await axios.get('https://www.cisoadvisor.com.br/arquivo-categorias/')
        const nunucucisoparser = cheerio.load(nunucucisohtml)
        let nunucucisonoticias = []
        
        nunucucisoparser('.elementor-post').each((index, nunucucisopost) => {
            const nunucucisotitle = nunucucisoparser(nunucucisopost).find('.elementor-post__title a').text().trim()
            const nunucucisosummary = nunucucisoparser(nunucucisopost).find('.elementor-post__excerpt p').text().trim()
            const nunucucisolink = nunucucisoparser(nunucucisopost).find('.elementor-post__title a').attr('href')
            const nunucucisoimage = nunucucisoparser(nunucucisopost).find('.elementor-post__thumbnail img').attr('src')
            
            if (nunucucisotitle && nunucucisolink) {
                nunucucisonoticias.push({
                    nunucucisotitle,
                    nunucucisosummary,
                    nunucucisolink,
                    nunucucisoimage
                })
            }
        })

        nunucucisonoticias = nunucucisonoticias.slice(0, 5)
        
        let nunucucisomensagem = '🛡️ *Últimas Notícias de Segurança Cibernética:*\n\n'
        nunucucisonoticias.forEach((nunucucisoitem, index) => {
            nunucucisomensagem += `*${index + 1}. ${nunucucisoitem.nunucucisotitle}*\n` +
                                  `📋 ${nunucucisoitem.nunucucisosummary}\n` +
                                  `🔗 ${nunucucisoitem.nunucucisolink}\n\n`
        })

        if (nunucucisonoticias.length > 0 && nunucucisonoticias[0].nunucucisoimage) {
            await blackmd.sendMessage(from, { 
                image: { url: nunucucisonoticias[0].nunucucisoimage }, 
                caption: nunucucisomensagem 
            }, { quoted: info })
        } else {
            await blackmd.sendMessage(from, { text: nunucucisomensagem }, { quoted: info })
        }
    } catch (nunucucisoerro) {
        console.error('Erro ao buscar notícias do CISO Advisor:', nunucucisoerro)
        reply('⚠️ Não foi possível buscar as notícias do CISO Advisor no momento.')
    }
    break//nunu dia das criança
case 'news':
    const apiUrl = 'https://world-ecletix.onrender.com/api/ultimasnoticias';

    try {
        // Requisição para a API de últimas notícias
        const response = await axios.get(apiUrl);
        const noticias = response.data;

        // Verificar se a resposta contém notícias
        if (noticias && noticias.length > 0) {
            // Limitar o número de notícias exibidas
            const limit = 5; // Número de notícias para exibir
            let message = '📰 Últimas Notícias:\n\n';

            noticias.slice(0, limit).forEach((noticia, index) => {
                const { titulo, link } = noticia;

                // Adicionar a notícia à mensagem
                message += `${index + 1}. *${titulo}*\nLeia mais: ${link}\n\n`;
            });

            // Enviar a mensagem com as notícias
            await blackmd.sendMessage(from, { text: message }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível encontrar as últimas notícias.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao fazer a requisição à API de notícias:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao buscar as últimas notícias.' }, { quoted: info });
    }
    break;
case 'noticia': 
    try {
        if (!q) return reply(`Informe um tema para realizar a pesquisa de suas notícias!`);
        
        const theNews = await axios.get(`https://newsapi.org/v2/everything?q=${encodeURIComponent(q)}&sortBy=publishedAt&language=pt&apiKey=9dc1dde158804756ae9b33dd8d71f7a1`);
        
        const newsSends = theNews.data.articles.map(d => 
            `${d.publishedAt.split('T').join(' - ').split('Z')[0]}\n\n` +
            `${d.title} - ${d.author} [${d.source.name}]\n\n` +
            `${d.description}\n\n` +
            `${d.url}\n\n` +
            `${d.content}\n\n` +
            `--------------------------- * ---------------------------\n\n`
        ).join('');
        
        reply(newsSends);
    } catch (e) {
        console.log(e);
        reply('Erro ao buscar as notícias. Tente novamente mais tarde.');
    }
    break;
  case 'jovempan': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/jovempan');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma notícia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.noticia) {
                mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                                   `🔗 [Leia mais](${noticia.link})\n` +
                                   `${noticia.imagem ? `![Imagem](${noticia.imagem})\n` : ''}\n`; // Incluindo a imagem aqui
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma notícia disponível no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar notícias do Jovem Pan:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as notícias do Jovem Pan.' }, { quoted: info });
    }
    break;
}

case 'uol': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/uol');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma notícia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.noticia) {
                mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                                   `🔗 [Leia mais](${noticia.link})\n` +
                                   `${noticia.imagem ? `![Imagem](${noticia.imagem})\n` : ''}\n`; // Incluindo a imagem aqui
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma notícia disponível no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar notícias da UOL:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as notícias da UOL.' }, { quoted: info });
    }
    break;
}

case 'estadao': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/estadao');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma notícia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.noticia) {
                mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                                   `🔗 [Leia mais](${noticia.link})\n` +
                                   `${noticia.imagem ? `![Imagem](${noticia.imagem})\n` : ''}\n`; // Incluindo a imagem aqui
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma notícia disponível no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar notícias do Estadão:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as notícias do Estadão.' }, { quoted: info });
    }
    break;
}

case 'terra': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/terra');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma notícia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.noticia) {
                mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                                   `🔗 [Leia mais](${noticia.link})\n` +
                                   `${noticia.imagem ? `![Imagem](${noticia.imagem})\n` : ''}\n`;
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma notícia disponível no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar notícias do Terra:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as notícias do Terra.' }, { quoted: info });
    }
    break;
}
case 'aominuto': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/aominuto');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma notícia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.noticia) {
                mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                                   `📅 Postado: ${noticia.postado}\n` +
                                   `🗂 Categoria: ${noticia.categoria}\n` +
                                   `🔗 [Leia mais](${noticia.link})\n\n`;
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma notícia disponível no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar notícias do A O Minuto:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as notícias do A O Minuto.' }, { quoted: info });
    }
    break;
}
case 'vejaabril': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/vejaabril');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma notícia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.noticia) {
                mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                                   `🖼️ [Imagem](${noticia.imagem})\n` +
                                   `🗂 Categoria: ${noticia.categoria}\n` +
                                   `🔗 [Leia mais](${noticia.link})\n\n`;
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma notícia disponível no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar notícias da Veja:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as notícias da Veja.' }, { quoted: info });
    }
    break;
}
case 'agazeta': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/agazeta');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma notícia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.link) { // Verifica se há um link disponível
                mensagemNoticias += `*Notícia ${index + 1}*\n` +
                                   `🖼️ [Imagem](${noticia.imagem})\n` +
                                   `🗂 Categoria: ${noticia.categoria}\n` +
                                   `🔗 [Leia mais](${noticia.link})\n\n`;
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma notícia disponível no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar notícias da A Gazeta:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as notícias da A Gazeta.' }, { quoted: info });
    }
    break;
}
case 'fut': {
    try {
        const { data: futebolnunuakake } = await axios.get('https://ge.globo.com/')
        const fut$ = cheerio.load(futebolnunuakake)
        let noticiadofut = []

        fut$('.feed-post-body').each((index, futelement) => {
            if (index < 7) {
                const titulodofutebol = fut$(futelement).find('.feed-post-link').text().trim()
                const linkfutebol = fut$(futelement).find('.feed-post-link').attr('href')
                const futimagem = fut$(futelement).find('.bstn-fd-picture-image').attr('src')

                if (titulodofutebol && linkfutebol) {
                    noticiadofut.push({
                        titulodofutebol,
                        linkfutebol,
                        futimagem
                    })
                }
            }
        })

        let futmensagem = ' '
        noticiadofut.forEach((futnoticia, index) => {
            futmensagem += `*${index + 1}. ${futnoticia.titulodofutebol}*\n` +
                           `🔗 ${futnoticia.linkfutebol}\n\n`
        })

        if (noticiadofut.length > 0 && noticiadofut[0].futimagem) {
            await blackmd.sendMessage(from, {
                image: { url: noticiadofut[0].futimagem },
                caption: futmensagem
            }, { quoted: info })
        } else {
            await blackmd.sendMessage(from, { text: futmensagem }, { quoted: info })
        }
    } catch (futerro) {
        console.error('erro:', futerro)
        reply('ops foi de f.')
    }
    break
			}
			case 'fisiculturista': 
    try {
        const { data: nunufisudata } = await axios.get('https://www.cnnbrasil.com.br/tudo-sobre/fisiculturismo/')
        const nunufisu$ = cheerio.load(nunufisudata)
        let nunufisunoticias = []
        nunufisu$('.home__list__item').each((index, nunufisuelement) => {
            const nunufisuezbt = nunufisu$(nunufisuelement).find('.news-item-header__title').text().trim()
            const nunufisulink = nunufisu$(nunufisuelement).find('a').attr('href')
            const nunufisuimg = nunufisu$(nunufisuelement).find('img').attr('src')
            const nunufisudate = nunufisu$(nunufisuelement).find('.home__title__date').text().trim()

            if (nunufisuezbt && nunufisulink) {
                nunufisunoticias.push({
                    nunufisuezbt,
                    nunufisulink,
                    nunufisuimg,
                    nunufisudate
                })
            }
        })

        nunufisunoticias = nunufisunoticias.slice(0, 5)
        
        let nunufisumensagem = '🏆 *Últimas:*\n\n'
        nunufisunoticias.forEach((nunufisunoticia, index) => {
            nunufisumensagem += `*${index + 1}. ${nunufisunoticia.nunufisuezbt}*\n` +
                                `🗓️ ${nunufisunoticia.nunufisudate}\n` +
                                `🔗 ${nunufisunoticia.nunufisulink}\n\n`
        })
        
        if (nunufisunoticias.length > 0 && nunufisunoticias[0].nunufisuimg) {
            await blackmd.sendMessage(from, { 
                image: { url: nunufisunoticias[0].nunufisuimg }, 
                caption: nunufisumensagem 
            }, { quoted: info })
        } else {
            await blackmd.sendMessage(from, { text: nunufisumensagem }, { quoted: info })
        }
    } catch (nunufisuerro) {
        console.error('Erro ao buscar notícias de fisiculturismo:', nunufisuerro)
        reply('ops foi de f.')
    }
    break;
    
    case 'time': {
    if (!text) {
        return reply(`Por favor, forneça o nome do time. Exemplo: ${prefix}time fortaleza`);
    }

    const clube = text.trim(); // O nome do time é obtido a partir da entrada do usuário

    try {
        const { data: timeData } = await axios.get(`https://world-ecletix.onrender.com/api/times?clube=${encodeURIComponent(clube)}`);
        let noticiastime = [];

        // Filtra as notícias que têm título e link
        timeData.forEach((noticia) => {
            if (noticia.title && noticia.link) {
                noticiastime.push({
                    title: noticia.title,
                    link: noticia.link,
                    imgSrc: noticia.imgSrc,
                    date: noticia.date
                });
            }
        });

        let timeMensagem = '';
        noticiastime.forEach((timeNoticia, index) => {
            timeMensagem += `*${index + 1}. ${timeNoticia.title}*\n` +
                            `🔗 ${timeNoticia.link}\n` +
                            `🗓️ ${timeNoticia.date}\n\n`;
        });

        // Envia a mensagem, se houver notícias
        if (noticiastime.length > 0) {
            const primeiraImagem = noticiastime[0].imgSrc ? { image: { url: noticiastime[0].imgSrc } } : {};
            await blackmd.sendMessage(from, {
                ...primeiraImagem,
                caption: timeMensagem
            }, { quoted: info });
        } else {
            reply('Nenhuma notícia encontrada.');
        }
    } catch (timeErro) {
        console.error('erro:', timeErro);
        reply('Ops, houve um erro ao buscar as notícias do time.');
    }
    break;
}
case 'genoticias': {
    if (!text) {
        return blackmd.sendMessage(
            from,
            { text: `Por favor, forneça um termo para busca. Exemplo: ${prefix}genoticias fifa` },
            { quoted: info }
        );
    }

    const termoBusca = text.trim();

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/genoticias?termo=${encodeURIComponent(termoBusca)}`);
        
        if (!data.sucesso || !data.dados || data.dados.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma notícia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.dados.forEach((noticia, index) => {
            mensagemNoticias += `*${index + 1}. ${noticia.titulo}*\n` +
                               `📰 ${noticia.trechoManchete}\n` +
                               `🕒 ${noticia.horarioPostagem}\n` +
                               `🔗 [Leia mais](${noticia.linkNoticia})\n` +
                               `${noticia.linkImagem ? `![Imagem](${noticia.linkImagem})\n` : ''}\n`; // Incluindo a imagem aqui
        });

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar notícias:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as notícias.' }, { quoted: info });
    }
    break;
}
case 'g1': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/g1');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma notícia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                               `📝 ${noticia.desc ? noticia.desc : 'Sem descrição'}\n` +
                               `🕒 ${noticia.postado}\n` +
                               `🔗 [Leia mais](${noticia.link})\n` +
                               `${noticia.imagem ? `![Imagem](${noticia.imagem})\n` : ''}\n`; // Incluindo a imagem aqui
        });

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar notícias do G1:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as notícias do G1.' }, { quoted: info });
    }
    break;
}

case 'poder360': {
    try {
        const { data } = await axios.get('https://world-ecletix.onrender.com/api/poder360');

        if (!data.resultado || data.resultado.length === 0) {
            return blackmd.sendMessage(from, { text: 'Nenhuma notícia encontrada.' }, { quoted: info });
        }

        let mensagemNoticias = '';
        data.resultado.forEach((noticia, index) => {
            if (noticia.noticia) {
                mensagemNoticias += `*${index + 1}. ${noticia.noticia}*\n` +
                                   `🔗 [Leia mais](${noticia.link})\n` +
                                   `${noticia.imagem ? `![Imagem](${noticia.imagem})\n` : ''}\n`; // Incluindo a imagem aqui
            }
        });

        if (!mensagemNoticias) {
            mensagemNoticias = 'Nenhuma notícia disponível no momento.';
        }

        await blackmd.sendMessage(from, { text: mensagemNoticias }, { quoted: info });
    } catch (error) {
        console.error('Erro ao buscar notícias do Poder360:', error);
        await blackmd.sendMessage(from, { text: 'Ocorreu um erro ao buscar as notícias do Poder360.' }, { quoted: info });
    }
    break;
}
case 'noticia2': 
try {
if (!q) return reply(`Informe um tema para realizar a pesquisa de suas notícias!`)
theNews = await axios.get(`https://newsapi.org/v2/everything?q=${encodeURIComponent(q)}&sortBy=publishedAt&language=pt&apiKey=9dc1dde158804756ae9b33dd8d71f7a1`);
newsSends = theNews.data.articles.map(d => `${d.publishedAt.split('T').join(' - ').split('Z')[0]}\n\n${d.title} - ${d.author} [${d.source.name}]\n\n${d.description}\n\n${d.url}\n\n${d.content}\n\n--------------------------- * ---------------------------\n\n`).join('');
reply(newsSends).catch(() => {
return console.log(e)
})
} catch (e) {
return console.log(e)
}
break
case 'vasconews': 
    try {
        var nunudatav = await axios.get('https://vasco.com.br/noticias-home/')
        var nunu$v = cheerio.load(nunudatav.data)
        var nununoticiasv = []
        nunu$v('.box-noticias').each((index, nunulementv) => {
            var nunuezbtv = nunu$v(nunulementv).find('h3').text().trim()
            var nunugdv = nunu$v(nunulementv).find('.btn').text().trim()
            var nunulinkv = nunu$v(nunulementv).find('a').attr('href')
            var nunuimagev = nunu$v(nunulementv).find('img').attr('src')

            if (nunuezbtv && nunulinkv) {
                nununoticiasv.push({
                    nunuezbtv,
                    nunugdv: nunugdv.replace('Leia mais', ''),
                    nunulinkv: `${nunulinkv}`,
                    nunuimagev
                })
            }
        })

        nununoticiasv = nununoticiasv.slice(0, 5)

        var nunumensagemv = '⚽ *Últimas Notícias do Vasco:*\n\n'
        nununoticiasv.forEach((nununoticia, index) => {
            nunumensagemv += `*${index + 1}. ${nununoticia.nunuezbtv}*\n` +
                            `📝 ${nununoticia.nunugdv}\n` +
                            `🛕 ${nununoticia.nunulinkv}\n`
            nunumensagemv += '\n'
        })
        if (nununoticiasv.length > 0 && nununoticiasv[0].nunuimagev) {
            await blackmd.sendMessage(from, { 
                image: { url: nununoticiasv[0].nunuimagev }, 
                caption: nunumensagemv 
            }, { quoted: info })
        } else {
            await blackmd.sendMessage(from, { text: nunumensagemv }, { quoted: info })
        }
    } catch (nunuerrov) {
        console.error('Erro ao buscar notícias do Vasco', nunuerrov)
        reply('⚠️ Não foi possível buscar as notícias do Vasco no momento')
    }
    break
case 'volei': 
    try {
        const { data: nunuvoleicudataxw } = await axios.get('https://webvolei.com.br/')
        const nunuvoleicuhtmlkl = cheerio.load(nunuvoleicudataxw)
        let nunuvoleiculistgp = []
        nunuvoleicuhtmlkl('li.articles-box-item').each((index, nunuvoleicuelementovb) => {
            const nunuvoleicutitulorb = nunuvoleicuhtmlkl(nunuvoleicuelementovb).find('h3.article-title a').text().trim()
            const nunuvoleicudescxv = nunuvoleicuhtmlkl(nunuvoleicuelementovb).find('.article-meta-info .date').text().trim()
            const nunuvoleiculinkbw = nunuvoleicuhtmlkl(nunuvoleicuelementovb).find('h3.article-title a').attr('href')
            const nunuvoleicuimgmr = nunuvoleicuhtmlkl(nunuvoleicuelementovb).find('.article-thumb img').attr('src')

            if (nunuvoleicutitulorb && nunuvoleiculinkbw) {
                nunuvoleiculistgp.push({
                    nunuvoleicutitulorb,
                    nunuvoleicudescxv,
                    nunuvoleiculinkbw: `${nunuvoleiculinkbw}`,
                    nunuvoleicuimgmr
                })
            }
        })

        nunuvoleiculistgp = nunuvoleiculistgp.slice(0, 5)
        
        let nunuvoleicumsgqk = '🏐 *Últimas Notícias do Vôlei:*\n\n'
        nunuvoleiculistgp.forEach((nunuvoleicunoticiasbx, index) => {
            nunuvoleicumsgqk += `*${index + 1}. ${nunuvoleicunoticiasbx.nunuvoleicutitulorb}*\n` +
                            `📅 ${nunuvoleicunoticiasbx.nunuvoleicudescxv}\n` +
                            `🔗 ${nunuvoleicunoticiasbx.nunuvoleiculinkbw}\n`
            nunuvoleicumsgqk += '\n'
        })
        if (nunuvoleiculistgp.length > 0 && nunuvoleiculistgp[0].nunuvoleicuimgmr) {
            await blackmd.sendMessage(from, { 
                image: { url: nunuvoleiculistgp[0].nunuvoleicuimgmr }, 
                caption: nunuvoleicumsgqk 
            }, { quoted: info })
        } else {
            await blackmd.sendMessage(from, { text: nunuvoleicumsgqk }, { quoted: info })
        }
    } catch (nunuvoleicuerrordk) {
        console.error('Erro ao buscar notícias de Vôlei:', nunuvoleicuerrordk)
        reply('⚠️ Não foi possível buscar as notícias de Vôlei no momento')
    }
    break
 case 'basquetenews': 
    try {
        const { data: nunucubasquetehtmlakjs } = await axios.get('https://noticiasdebasquete.com.br/noticias-basquete/')
        const nunucubasqueteparserzzx = cheerio.load(nunucubasquetehtmlakjs)
        let nunucubasquetenoticiasqfj = []
        
        nunucubasqueteparserzzx('.listing-item').each((index, nunucubasquetenoticiaxfz) => {
            const nunucubasquetetitlezby = nunucubasqueteparserzzx(nunucubasquetenoticiaxfz).find('.post-title').text().trim()
            const nunucubasquetesummaryczx = nunucubasqueteparserzzx(nunucubasquetenoticiaxfz).find('.post-summary').text().trim()
            const nunucubasquetelinkqvf = nunucubasqueteparserzzx(nunucubasquetenoticiaxfz).find('a').attr('href')
            const nunucubasqueteimagecss = nunucubasqueteparserzzx(nunucubasquetenoticiaxfz).find('.img-holder').css('background-image')

            let nunucubasqueteimagecbv = ''
            if (nunucubasqueteimagecss && nunucubasqueteimagecss.match(/url(.*?)/)) {
                nunucubasqueteimagecbv = nunucubasqueteimagecss.match(/url(.*?)/)[1]
            }

            if (nunucubasquetetitlezby && nunucubasquetelinkqvf) {
                nunucubasquetenoticiasqfj.push({
                    nunucubasquetetitlezby,
                    nunucubasquetesummaryczx,
                    nunucubasquetelinkqvf: `${nunucubasquetelinkqvf}`,
                    nunucubasqueteimagecbv
                })
            }
        })

        nunucubasquetenoticiasqfj = nunucubasquetenoticiasqfj.slice(0, 5)
        
        let nunucubasquetemensagemazw = '🏀 *Últimas Notícias do Basquete:*\n\n'
        nunucubasquetenoticiasqfj.forEach((nunucubasqueteitemwby, index) => {
            nunucubasquetemensagemazw += `*${index + 1}. ${nunucubasqueteitemwby.nunucubasquetetitlezby}*\n` +
                            `🔗 ${nunucubasqueteitemwby.nunucubasquetelinkqvf}\n\n`
        })

        if (nunucubasquetenoticiasqfj.length > 0 && nunucubasquetenoticiasqfj[0].nunucubasqueteimagecbv) {
            await blackmd.sendMessage(from, { 
                image: { url: nunucubasquetenoticiasqfj[0].nunucubasqueteimagecbv }, 
                caption: nunucubasquetemensagemazw 
            }, { quoted: info })
        } else {
            await blackmd.sendMessage(from, { text: nunucubasquetemensagemazw }, { quoted: info })
        }
    } catch (nunucubasqueteerroqwe) {
        console.error('Erro ao buscar notícias do Basquete:', nunucubasqueteerroqwe)
        reply('⚠️ Não foi possível buscar as notícias de basquete no momento.')
    }
    break;
    case 'sbt':
    case 'sbtnews':
    case "SBT": {
    try {
        // by: luanzn_fe

        const obterNoticiasSBT = async () => {
            try {
                const res = await axios.get('https://www.sbt.com.br/');
                const $ = cheerio.load(res.data);
                const noticias = [];
                
                $('.news-card').each((i, e) => {
                    const titulo = $(e).find('.news-card-title').text().trim();
                    const link = $(e).find('a').attr('href');
                    const resumo = $(e).find('.news-card-summary').text().trim();
                    const imagem = $(e).find('img').attr('src');

                    if (titulo && link) {
                        noticias.push({
                            titulo,
                            link,
                            resumo: resumo || 'Sem resumo disponível.',
                            imagem: imagem || 'Sem imagem disponível.'
                        });
                    }
                });
                return noticias;
            } catch (error) {
                throw new Error(`Erro ao buscar notícias do SBT: ${error.message}`);
            }
        };

        const enviarNoticias = async (noticias) => {
            if (noticias.length === 0) {
                return reply('Desculpe, não encontrei notícias para enviar.');
            }

            for (const noticia of noticias.slice(0, 5)) {
                const mensagem = `
📰 *Notícias do SBT* 📰
🔹 *Título:* ${noticia.titulo}
🔹 *Resumo:* ${noticia.resumo}
🔹 *Link:* ${noticia.link}
🔹 *Imagem:* ${noticia.imagem}
`;

                try {
                    await blackmd.sendMessage(from, { text: mensagem }, { quoted: info });
                } catch (error) {
                    console.log(`Erro ao enviar a mensagem: ${error.message}`);
                }
            }
        };

        // Obtendo notícias
        const noticias = await obterNoticiasSBT();

        if (noticias.length === 0) {
            return reply('Desculpe, não encontrei notícias recentes.');
        }

        // Enviando notícias para o usuário
        await enviarNoticias(noticias);

        // Reação de sucesso
        await blackmd.sendMessage(from, { react: { text: '✅️', key: info.key } });

    } catch (error) {
        console.error('Erro inesperado:', error);
        reply(`Ocorreu um erro inesperado: ${error.message}`);
    }
    break;
}
case 'globo':{
    try {
        reply('Aguarde, estou obtendo as últimas notícias do g1...');               
        const { data } = await axios.get('https://g1.globo.com/');
        const $ = cheerio.load(data);
        let noticias = [];
        $('.feed-post-link').each((index, element) => {
            const titulo = $(element).text().trim();
            const url = $(element).attr('href');
            noticias.push({ titulo, url });
        });
        let mensagem = '📰 Últimas notícias do g1:\n\n';
        noticias.slice(0, 10).forEach((noticia, index) => {
            mensagem += `${index + 1}. ${noticia.titulo}\n🔗 ${noticia.url}\n\n`;
        });
        reply(mensagem);
    } catch (error) {
        console.error(error);
        reply('Desculpe, houve um erro ao obter as notícias.');
    }
break;
}
// FERRAMENTAS

case 'proximojogo':
case 'jogosfuturos': {
    if (!q) return reply("Envie o nome de um time para consultar os próximos jogos.");

    try {
        const { data } = await axios.get(`https://kamuiapi.shop/api/outros/proximos_jogos?query=${encodeURIComponent(q)}&apikey=YT8q4bUNXV`);

        if (!Array.isArray(data) || !data.length) {
            return reply("ok");
        }

        let mensagem = `⚽ *PRÓXIMOS JOGOS - ${q.toUpperCase()}* ⚽\n\n`;
        for (const jogo of data) {
            mensagem += `🏆 *${jogo.liga}*\n`;
            mensagem += `📅 ${jogo.data}\n`;
            mensagem += `🏠 ${jogo.timeCasa} vs ${jogo.timeVisitante}\n\n`;
        }

        mensagem += `• Bot: ${NomeDoBot}`;
        reply(mensagem.trim());

    } catch (error) {
        console.error("Erro ao consultar jogos futuros:", error);
        return reply("ok");
    }
    break;
}
case 'rastrearshop':
case 'rastrearshoppe': {
    if (!q) return reply("Envie o código de rastreio para continuar.");

    try {
        const { data } = await axios.get(`https://kamuiapi.shop/api/outros/rastrear/shoppee?id=${encodeURIComponent(q)}&apikey=YT8q4bUNXV`);

        if (!Array.isArray(data) || !data.length || (!data[0].info && !data[0].infopro)) {
            return reply("ok");
        }

        const info = data[0].info || "Não informado";
        const detalhes = data[0].infopro || "Não informado";

        const message =
            `📦 *RASTREAMENTO SHOPEE* 📦\n\n` +
            `• Código: ${q}\n` +
            `• Info: ${info}\n` +
            `• Detalhes: ${detalhes}\n` +
            `• Bot: ${NomeDoBot}`;

        reply(message);

    } catch (error) {
        console.error("Erro ao consultar rastreio Shopee:", error);
        return reply("ok");
    }
    break;
}

case 'fakemail': {
  try {
    const { data } = await axios.get('https://api.vreden.my.id/api/tools/fakemail/create');
    if (data.status !== 200) return reply("Erro ao criar e-mail temporário.");

    const email = data.result.addresses[0].address;
    const id = data.result.id;
    const expira = data.result.expiresAt;

    const msg = `🕵️ *Email Temporário Criado!*\n\n` +
                `📧 *Email:* ${email}\n` +
                `🆔 *ID:* ${id}\n` +
                `⏳ *Expira em:* ${expira}\n\n` +
                `Use esse ID para consultar a caixa de entrada futuramente.`;

    reply(msg);
  } catch (e) {
    reply("Erro ao gerar o e-mail temporário.");
  }
  break;
}
case 'fakemail-msg': {
  try {
    const emailId = '066sy257qr@spymail.one';  // Insira o ID do e-mail que você deseja verificar
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/fakemail/message?id=${emailId}`);
    
    if (data.status !== 200) return reply("Erro ao consultar as mensagens.");

    if (data.result === null) {
      reply("Não há mensagens recebidas para este e-mail temporário.");
    } else {
      // Processa e exibe as mensagens, caso existam
      const messages = data.result.map(msg => `*Assunto:* ${msg.subject}\n*De:* ${msg.from}\n*Data:* ${msg.date}\n\n`);
      reply(`📥 *Mensagens Recebidas:*\n\n${messages.join('\n')}`);
    }
  } catch (e) {
    reply("Erro ao acessar as mensagens do e-mail temporário.");
  }
  break;
}
case 'numerofake-paises': {
  try {
    const { data } = await axios.get('https://api.vreden.my.id/api/tools/fakenumber/country');

    if (data.status !== 200) return reply("Erro ao obter a lista de países.");

    const lista = data.result.map(p => `- ${p.title} (${p.id})`).join('\n');
    reply(`🌍 *Países disponíveis para número fake:*\n\n${lista}`);
  } catch (e) {
    reply("Erro ao buscar os países para número fake.");
  }
  break;
}
case 'numerofake-lista': {
  if (!q) return reply("Informe o ID do país. Ex: br, us, fr...");

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/fakenumber/listnumber?id=${q}`);

    if (data.status !== 200 || !data.result.length) return reply("Nenhum número encontrado para esse país.");

    const numeros = data.result.map((n, i) => `${i + 1}. ${n.number}`).join('\n');
    reply(`📱 *Números fake disponíveis (${data.result[0].country}):*\n\n${numeros}`);
  } catch (e) {
    reply("Erro ao buscar os números fake.");
  }
  break;
}
case 'numerofake-msg': {
  if (!q) return reply("Informe o número fake. Ex: +556231810448");

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/fakenumber/message?nomor=${encodeURIComponent(q)}`);

    if (data.status !== 200 || !data.result.length) return reply("Nenhuma mensagem encontrada para esse número.");

    const mensagens = data.result.map((msg, i) => {
      return `📩 *Mensagem ${i + 1}*\n👤 De: ${msg.from}\n🕒 ${msg.time_wib}\n💬 ${msg.content}`;
    }).join("\n\n");

    reply(`📨 *Mensagens recebidas por ${q}:*\n\n${mensagens}`);
  } catch (e) {
    reply("Erro ao buscar mensagens do número.");
  }
  break;
}

case 'dnscheck': {
  if (!args[0]) return reply(`Informe uma URL para verificar.\nEx: ${prefix + command} https://vreden.my.id`);
  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/check-dns?url=${encodeURIComponent(args[0])}`);
    if (data.status !== 200) return reply("Não foi possível verificar o DNS.");

    let msg = `*DNS Check para:* ${args[0]}\n\n`;
    for (const res of data.result) {
      const s = res.server;
      const d = res.dns_check;
      msg += `🌐 *Servidor:* ${s.host} (${s.city}, ${s.country})\n`;
      msg += `📌 *IP:* ${s.ip}\n`;
      msg += `🧭 *IPv4:* ${d.ipv4.join(', ')}\n`;
      msg += `🧬 *IPv6:* ${d.ipv6.join(', ')}\n`;
      msg += `⏱ *TTL:* ${d.ttl}\n`;
      msg += `✅ *Status:* ${d.result}\n\n`;
    }
    reply(msg.trim());
  } catch (e) {
    reply("Erro ao consultar o DNS.");
  }
  break;
}
case 'tcpcheck': {
  if (!args[0]) return reply(`Informe uma URL para verificar a conexão TCP.\nEx: ${prefix + command} https://vreden.my.id`);
  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tools/check-tcp?url=${encodeURIComponent(args[0])}`);
    if (data.status !== 200) return reply("Não foi possível realizar o TCP Check.");

    let msg = `*TCP Check para:* ${args[0]}\n\n`;
    for (const res of data.result) {
      const s = res.server;
      const t = res.tcp_check;

      msg += `🌐 *Servidor:* ${s.host} (${s.city}, ${s.country})\n`;
      msg += `📌 *IP do servidor:* ${s.ip}\n`;
      msg += `🧭 *Host verificado:* ${t.host}\n`;
      msg += `📶 *IP da web:* ${t.ip_web || 'Não encontrado'}\n`;
      msg += `⏱ *Tempo de resposta:* ${t.time || 'Indefinido'}\n`;
      msg += `✅ *Status:* ${t.result}\n\n`;
    }
    reply(msg.trim());
  } catch (e) {
    reply("Erro ao consultar o TCP Check.");
  }
  break;
}
case 'chekhost':
try {
  if (!q) return reply('Digite a URL que deseja verificar!\nEx: .chekhost https://www.vreden.my.id');
  reagir(from, "🌐");

  let res = await fetchJson(`https://api.vreden.my.id/api/tools/cekhost?url=${encodeURIComponent(q)}`);
  let data = res.result.checks;

  let texto = `🌍 *Resultado da verificação de host:*\n`;
  texto += `🔗 URL: ${q}\n`;
  texto += `🆔 Request ID: ${res.result.request_id}\n`;
  texto += `✅ Status geral: ${res.result.status ? 'Online' : 'Offline'}\n\n`;

  data.forEach((check, i) => {
    texto += `🌐 *Servidor ${i + 1}*\n`;
    texto += `- País: ${check.server.country} (${check.server.city})\n`;
    texto += `- IP do servidor: ${check.server.ip}\n`;
    texto += `- Host: ${check.http_check.host}\n`;
    texto += `- IP Web: ${check.http_check.ip_web}\n`;
    texto += `- Ping: ${check.http_check.ping}s\n`;
    texto += `- Código HTTP: ${check.http_check.status_code}\n`;
    texto += `- Resultado: ${check.http_check.result}\n\n`;
  });

  await blackmd.sendMessage(from, {text: texto}, {quoted: info});
} catch (error) {
  console.log(error);
  return reply('Deu um erro ao verificar o host, tente novamente mais tarde!');
}
break;
case "jogador":
{
    if (!q) {
        return reply("Você precisa fornecer o nome de um jogador para consulta.");
    }

    try {
        const jogador = encodeURIComponent(q.trim()); // Sanitizando a entrada do usuário

        const { data: res } = await axios.get(`https://world-ecletix.onrender.com/api/jogador/${jogador}`);
        
        if (!res || !res.nome) {
            return reply("Nenhum dado encontrado para o jogador fornecido.");
        }

        // Desestruturando os dados do jogador
        const { nome, time, idade, posicao, pais, altura, peso, numeroCamisa } = res;

        const message = `*Informações do Jogador ${nome}:*\n` +
                        `- Time: ${time}\n` +
                        `- Idade: ${idade} anos\n` +
                        `- Posição: ${posicao}\n` +
                        `- País: ${pais}\n` +
                        `- Altura: ${altura}\n` +
                        `- Peso: ${peso}\n` +
                        `- Número da Camisa: ${numeroCamisa}`;

        reply(message);
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case 'codificar':
  try {
    const query = q[1]; // O texto a ser codificado
    if (!query) return reply("Por favor, forneça o texto para codificação.");

    // Enviando a requisição para a API de codificação
    const res = await axios.get(`https://api.nexfuture.com.br/api/outros/codificar?query=${query}`);
    
    if (res.data.status) {
      const encodedMessage = res.data.codificado;
      return reply(`A mensagem codificada é: *${encodedMessage}*`);
    } else {
      return reply("Ocorreu um erro ao tentar codificar a mensagem.");
    }
  } catch (e) {
    console.log("Erro no codificar:", e);
    reply("Erro ao processar a codificação.");
  }
  break;
  case 'decodificar':
  try {
    const query = q[1]; // O código binário a ser decodificado
    if (!query) return reply("Por favor, forneça o código binário para decodificação.");

    // Enviando a requisição para a API de decodificação
    const res = await axios.get(`https://api.nexfuture.com.br/api/outros/decodificar?query=${query}`);
    
    if (res.data.status) {
      const decodedMessage = res.data.decodificado;
      return reply(`A mensagem decodificada é: *${decodedMessage}*`);
    } else {
      return reply("Ocorreu um erro ao tentar decodificar a mensagem.");
    }
  } catch (e) {
    console.log("Erro no decodificar:", e);
    reply("Erro ao processar a decodificação.");
  }
  break;
  case 'dicionario':
try {
if (!q) return reply('Coloque a palavra que deseja consultar no dicionário!');
reagir(from, "📍");
let dicio = await fetchJson(`https://api.nexfuture.com.br/api/pesquisas/dicionario?query=${encodeURIComponent(q)}`);

await blackmd.sendMessage(from, 
{image: {url: dicio.resultado.imagem}, 
caption: dicio.resultado.significado}, {quoted: info});
} catch (error) {
console.log(error);
return reply('Deu um pequeno erro, tente novamente mais tarde!');
}
break
 case 'printsite': 
try {
if(!q) return reply('Coloque o URL do site que deseja obter o print!');
reply('Buscando print do site...')

await blackmd.sendMessage(from, {image: 
{url: `https://api.nexfuture.com.br/api/outros/printsite?url=${q}`}}, 
{quoted: info});
} catch (error) {
console.log(error);
return reply('Deu um pequeno erro, tente novamente mais tarde!');
}
break;
  case 'morse':
  try {
    const texto = q[1]; // O texto a ser codificado em Morse
    if (!texto) return reply("Por favor, forneça o texto para codificar em Morse.");
    
    // Enviando a requisição para a API de codificação Morse
    const res = await axios.get(`https://api.nexfuture.com.br/api/outros/morse?query=${encodeURIComponent(texto)}`);
    
    if (res.data.status) {
      const morseCode = res.data.resultado;
      reply(`Texto em Morse: ${morseCode}`);
    } else {
      reply("Não foi possível codificar o texto em Morse.");
    }
  } catch (e) {
    console.log("Erro no morse:", e);
    reply("Erro ao codificar o texto em Morse.");
  }
  break;
case 'linkimg3':
try {
  if (!isQuotedImage) return reply(`${pushname}, marque uma imagem para gerar o link.`);
  setTimeout(() => { reagir(from, "📷") }, 300);

  const boij = JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.imageMessage;
  const buffer = await getFileBuffer(boij, "image");

  const FormData = require('form-data');
  const form = new FormData();
  form.append('reqtype', 'fileupload');
  form.append('fileToUpload', buffer, { filename: 'imagem.png' });

  const res = await axios.post("https://catbox.moe/user/api.php", form, {
    headers: form.getHeaders()
  });

  const link = res.data;
  if (!link.startsWith('https://')) throw new Error('Resposta inválida do Catbox');

  return sendUrlText(from, link, `Link da imagem gerado com sucesso ↴`, ``, link, link, seloctt);

} catch (e) {
  console.log("Erro no linkimg3:", e);
  reply("Erro ao gerar link da imagem.");
}
break;
case 'linkmp4':
case 'linkvideo2':
try {
  if (!(isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 31))
    return reply(`${pushname}, marque um vídeo de até 30 segundos.`);

  setTimeout(() => { reagir(from, "🎥") }, 300);

  const boij = JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.videoMessage;
  const buffer = await getFileBuffer(boij, "video");

  const FormData = require('form-data');
  const form = new FormData();
  form.append('reqtype', 'fileupload');
  form.append('fileToUpload', buffer, { filename: 'video.mp4' });

  const res = await axios.post("https://catbox.moe/user/api.php", form, {
    headers: form.getHeaders()
  });

  const link = res.data;
  if (!link.startsWith('https://')) throw new Error('Resposta inválida do Catbox');

  return sendUrlText(from, link, `Link do vídeo gerado com sucesso ↴`, ``, link, link, seloctt);

} catch (e) {
  console.log("Erro no linkmp4:", e);
  reply("Erro ao gerar link do vídeo.");
}
break;
case 'linkaudio2':
case 'linkmp3':
try {
  if (!isQuotedAudio) return reply(`${pushname}, marque um áudio.`);
  setTimeout(() => { reagir(from, "🎧") }, 300);

  const boij = JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.audioMessage;
  const buffer = await getFileBuffer(boij, "audio");

  const FormData = require('form-data');
  const form = new FormData();
  form.append('reqtype', 'fileupload');
  form.append('fileToUpload', buffer, { filename: 'audio.mp3' });

  const res = await axios.post("https://catbox.moe/user/api.php", form, {
    headers: form.getHeaders()
  });

  const link = res.data;
  if (!link.startsWith('https://')) throw new Error('Resposta inválida do Catbox');

  return sendUrlText(from, link, `Link do áudio gerado com sucesso ↴`, ``, link, link, seloctt);

} catch (e) {
  console.log("Erro no linkmp3:", e);
  reply("Erro ao gerar link do áudio.");
}
break;
case 'linkimg2':
case 'linkfoto2':
try { 
    // essa porra foi criada por mim, entao deixe os créditos, by: ryuu
    if (isQuotedImage) {
        const boij = isQuotedImage 
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.imageMessage 
        : info;

        const fetch = require('node-fetch');
        const FormData = require('form-data');

        // Função para fazer upload da imagem no Uguu
        async function uploadImageToUguu(imageBuffer) {
            const form = new FormData();
            form.append('files[]', imageBuffer, { filename: 'image.jpg' });

            const response = await fetch('https://uguu.se/upload', {
                method: 'POST',
                body: form
            });

            const data = await response.json();

            // Verifica se o upload foi bem-sucedido e se a URL foi retornada
            if (response.ok && data.files && data.files[0].url) {
                return data.files[0].url;
            } else {
                throw new Error('Falha ao obter o link da imagem a partir da resposta.');
            }
        }

        // Garante que a função `getFileBuffer` está disponível
        const owgi = await getFileBuffer(boij, "image");
        const imageUrl = await uploadImageToUguu(owgi);
        
        const ryuumods = `_*Link gerado com sucesso*_⚡️\n\n${imageUrl}`;
        reply(ryuumods);

    } else {
        reply(`${pushname}, você tem que marcar a foto desejada.`);
    }
    
} catch (e) {
    console.log('Detalhes do erro:', e); 
    reply('Erro ao processar a imagem e gerar o link...');
} 
break;
case 'linkfoto4':
case 'linkimg':
try { 
    // essa porra foi criada por mim, entao deixe os créditos, by: ryuu
    if (isQuotedImage) {
        const boij = isQuotedImage 
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.imageMessage 
        : info;

        const fetch = require('node-fetch');
        const FormData = require('form-data');

        // Função para fazer upload da imagem no Imgur
        async function uploadImageToImgur(imageBuffer) {
            const form = new FormData();
            form.append('image', imageBuffer, { filename: 'image.jpg' });

            const response = await fetch('https://api.imgur.com/3/image', {
                method: 'POST',
                body: form,
                headers: {
                    'Authorization': 'Client-ID 6c10f331b789cbf'
                }
            });

            const data = await response.json();
            
            // Verifica se o upload foi bem-sucedido e se a URL foi retornada
            if (response.ok && data.data && data.data.link) {
                return data.data.link;
            } else {
                throw new Error('Falha ao obter o link da imagem a partir da resposta.');
            }
        }

        // Garante que a função `getFileBuffer` está disponível
        const owgi = await getFileBuffer(boij, "image");
        const imageUrl = await uploadImageToImgur(owgi);
        
        const ryuumods = `_*Link gerado com sucesso*_⚡️\n\n${imageUrl}`;
        reply(ryuumods);

    } else {
        reply(`${pushname}, você tem que marcar a foto desejada.`);
    }
    
} catch (e) {
    console.log('Detalhes do erro:', e); 
    reply('Erro ao processar a imagem e gerar o link...');
} 
break;
case 'linkfoto':
try { 
    // Verificando se a imagem foi marcada
    if (isQuotedImage) {
        const boij = isQuotedImage 
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.imageMessage 
        : info;

        const fetch = require('node-fetch');
        const FormData = require('form-data');

        // Função para fazer upload da imagem no Uguu
        async function uploadImageToUguu(imageBuffer) {
            const form = new FormData();
            form.append('files[]', imageBuffer, { filename: 'image.jpg' });

            const response = await fetch('https://uguu.se/upload', {
                method: 'POST',
                body: form
            });

            const data = await response.json();

            // Verifica se o upload foi bem-sucedido e se a URL foi retornada
            if (response.ok && data.files && data.files[0].url) {
                return data.files[0].url;
            } else {
                throw new Error('Falha ao obter o link da imagem a partir da resposta.');
            }
        }

        // Garante que a função `getFileBuffer` está disponível
        const owgi = await getFileBuffer(boij, "image");
        const imageUrl = await uploadImageToUguu(owgi);
        
        const ryuumods = `_*Link gerado com sucesso*_⚡️\n\n${imageUrl}`;
        reply(ryuumods);

    } else {
        reply(`${pushname}, você tem que marcar a foto desejada.`);
    }
    
} catch (e) {
    console.log('Detalhes do erro:', e); 
    reply('Erro ao processar a imagem e gerar o link...');
} 
break;

case 'linkvideo':
try { 
    // Verificando se o vídeo foi marcado
    if (isQuotedVideo || (isMedia && info.message.videoMessage.seconds < 30)) {
        const boij = isQuotedVideo
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.videoMessage 
        : info.message.videoMessage;

        const fetch = require('node-fetch');
        const FormData = require('form-data');

        // Função para fazer upload do vídeo no Uguu
        async function uploadVideoToUguu(videoBuffer) {
            const form = new FormData();
            form.append('files[]', videoBuffer, { filename: 'video.mp4' });

            const response = await fetch('https://uguu.se/upload', {
                method: 'POST',
                body: form
            });

            const data = await response.json();

            // Verifica se o upload foi bem-sucedido e se a URL foi retornada
            if (response.ok && data.files && data.files[0].url) {
                return data.files[0].url;
            } else {
                throw new Error('Falha ao obter o link do vídeo a partir da resposta.');
            }
        }

        // Garante que a função `getFileBuffer` está disponível
        const owgi = await getFileBuffer(boij, "video");
        const videoUrl = await uploadVideoToUguu(owgi);
        
        const ryuumods = `_*Link gerado com sucesso*_⚡️\n\n${videoUrl}`;
        reply(ryuumods);

    } else {
        reply(`${pushname}, você tem que marcar o vídeo (máximo de 30 segundos).`);
    }
    
} catch (e) {
    console.log('Detalhes do erro:', e); 
    reply('Erro ao processar o vídeo e gerar o link...');
} 
break;

case 'linkaudio':
try { 
    // Verificando se o áudio foi marcado
    if (isQuotedAudio || (isMedia && info.message.audioMessage)) {
        const boij = isQuotedAudio
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.audioMessage 
        : info.message.audioMessage;

        const fetch = require('node-fetch');
        const FormData = require('form-data');

        // Função para fazer upload do áudio no Uguu
        async function uploadAudioToUguu(audioBuffer) {
            const form = new FormData();
            form.append('files[]', audioBuffer, { filename: 'audio.mp3' });

            const response = await fetch('https://uguu.se/upload', {
                method: 'POST',
                body: form
            });

            const data = await response.json();

            // Verifica se o upload foi bem-sucedido e se a URL foi retornada
            if (response.ok && data.files && data.files[0].url) {
                return data.files[0].url;
            } else {
                throw new Error('Falha ao obter o link do áudio a partir da resposta.');
            }
        }

        // Garante que a função `getFileBuffer` está disponível
        const owgi = await getFileBuffer(boij, "audio");
        const audioUrl = await uploadAudioToUguu(owgi);
        
        const ryuumods = `_*Link gerado com sucesso*_⚡️\n\n${audioUrl}`;
        reply(ryuumods);

    } else {
        reply(`${pushname}, você tem que marcar o áudio.`);
    }
    
} catch (e) {
    console.log('Detalhes do erro:', e); 
    reply('Erro ao processar o áudio e gerar o link...');
} 
break;
case 'fazerlink2':
case 'linkmidia2':
case 'linkcatbox':
try { 
    const fetch = require('node-fetch');
    const FormData = require('form-data');

    // Função para fazer upload no Catbox
    async function uploadToCatbox(buffer, filename) {
        const form = new FormData();
        form.append('reqtype', 'fileupload');
        form.append('fileToUpload', buffer, { filename });

        const response = await fetch('https://catbox.moe/user/api.php', {
            method: 'POST',
            body: form
        });

        const text = await response.text();

        if (response.ok && text.startsWith("https://")) {
            return text.trim();
        } else {
            throw new Error('Resposta inválida do Catbox.');
        }
    }

    // Verificando e processando IMAGEM
    if (isQuotedImage || (isMedia && info.message.imageMessage)) {
        const boij = isQuotedImage 
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.imageMessage 
        : info.message.imageMessage;

        const buffer = await getFileBuffer(boij, "image");
        const url = await uploadToCatbox(buffer, "imagem.jpg");
        reply(`_*Link da imagem gerado com sucesso*_⚡️\n\n${url}`);

    // Verificando e processando VÍDEO
    } else if ((isQuotedVideo && JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.videoMessage.seconds < 30)
        || (isMedia && info.message.videoMessage && info.message.videoMessage.seconds < 30)) {

        const boij = isQuotedVideo 
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.videoMessage 
        : info.message.videoMessage;

        const buffer = await getFileBuffer(boij, "video");
        const url = await uploadToCatbox(buffer, "video.mp4");
        reply(`_*Link do vídeo gerado com sucesso*_⚡️\n\n${url}`);

    // Verificando e processando ÁUDIO
    } else if (isQuotedAudio || (isMedia && info.message.audioMessage)) {
        const boij = isQuotedAudio 
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.audioMessage 
        : info.message.audioMessage;

        const buffer = await getFileBuffer(boij, "audio");
        const url = await uploadToCatbox(buffer, "audio.mp3");
        reply(`_*Link do áudio gerado com sucesso*_⚡️\n\n${url}`);

    } else {
        reply(`${pushname}, você deve marcar uma imagem, vídeo (até 30s) ou áudio.`);
    }

} catch (e) {
    console.log('Erro no linkcatbox:', e); 
    reply('Erro ao gerar o link no Catbox...');
}
break;
case 'fazerlink':
case 'upload':
case 'linkmidia':
try {
    const fetch = require('node-fetch');
    const FormData = require('form-data');

    // Função para fazer upload no Uguu
    async function uploadToUguu(fileBuffer, filename) {
        const form = new FormData();
        form.append('files[]', fileBuffer, { filename: filename });

        const response = await fetch('https://uguu.se/upload', {
            method: 'POST',
            body: form
        });

        const data = await response.json();

        // Verifica se o upload foi bem-sucedido e se a URL foi retornada
        if (response.ok && data.files && data.files[0].url) {
            return data.files[0].url;
        } else {
            throw new Error('Falha ao obter o link a partir da resposta.');
        }
    }

    // Processando a imagem
    if (isQuotedImage || (isMedia && info.message.imageMessage)) {
        const boij = isQuotedImage
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.imageMessage
        : info.message.imageMessage;

        console.log("Processando imagem...");
        const owgi = await getFileBuffer(boij, "image");
        const imageUrl = await uploadToUguu(owgi, 'image.jpg');
        
        const ryuumods = `_*Link gerado com sucesso*_⚡️\n\n${imageUrl}`;
        reply(ryuumods);

    // Processando o vídeo
    } else if ((isQuotedVideo || (isMedia && info.message.videoMessage)) && info.message.videoMessage.seconds < 30) {
        const boij = isQuotedVideo
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.videoMessage
        : info.message.videoMessage;

        console.log("Processando vídeo...");
        const owgi = await getFileBuffer(boij, "video");
        const videoUrl = await uploadToUguu(owgi, 'video.mp4');
        
        const ryuumods = `_*Link gerado com sucesso*_⚡️\n\n${videoUrl}`;
        reply(ryuumods);

    // Processando o áudio
    } else if (isQuotedAudio || (isMedia && info.message.audioMessage)) {
        const boij = isQuotedAudio
        ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.audioMessage
        : info.message.audioMessage;

        console.log("Processando áudio...");
        const owgi = await getFileBuffer(boij, "audio");
        const audioUrl = await uploadToUguu(owgi, 'audio.mp3');
        
        const ryuumods = `_*Link gerado com sucesso*_⚡️\n\n${audioUrl}`;
        reply(ryuumods);

    } else {
        reply("Você deve marcar uma imagem, vídeo (máximo de 30 segundos) ou áudio.");
    }

} catch (e) {
    console.log('Detalhes do erro:', e); 
    reply('Erro ao processar a mídia e gerar o link...');
} 
break;
case 'transcrever2':
case 'transcricao':
case 'transcrição':
{
    if (!isGroup) return reply(enviar.msg.grupo);
    if (!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for um, apenas digite ${prefix}modozoeira`);
    
    // Verifica se há uma mensagem de áudio marcada
    if (!info.quoted || info.quoted.mtype !== 'audioMessage') {
        return reply('Marque um áudio para ser transcrito.');
    }

    try {
        // Obtém o URL do áudio
        const media = await downloadMediaMessage(info.quoted, "buffer", {}, { reuploadRequest: true });
        const filePath = path.join(__dirname, 'temp', `${Date.now()}.mp3`);
        fs.writeFileSync(filePath, media);

        // Envia o áudio para algum servidor público com upload (ex: anonfiles, telegra.ph ou storage próprio)
        const form = new FormData();
        form.append("file", fs.createReadStream(filePath));

        const uploadRes = await axios.post("https://uguu.se/upload.php", form, {
            headers: form.getHeaders()
        });

        fs.unlinkSync(filePath); // Remove o arquivo local

        const audioUrl = uploadRes.data.files[0].url;

        // Faz a transcrição usando a API da NexFuture
        const { data } = await axios.get(`https://api.nexfuture.com.br/api/outros/aspose-transcribe?url=${encodeURIComponent(audioUrl)}&diarization=true&is_multilingual=false`);

        if (!data || !data.result || !data.result.success) {
            return reply("Não foi possível transcrever o áudio.");
        }

        const texto = data.result.data;
        reply(`*Transcrição do áudio:*\n\n${texto}`);

    } catch (err) {
        console.error(err);
        reply("Ocorreu um erro ao tentar transcrever o áudio.");
    }
}
break;

case "audiomeme":
{
    if (!q) {
        return reply(`Por favor, forneça o termo de busca. Exemplo: ${prefix}audio termo_da_busca`);
    }

    try {
        const response = await axios.get(`https://world-ecletix.onrender.com/api/audiomeme?query=${encodeURIComponent(q)}`);
        const result = response.data;

        if (!result || !result.status || !result.results || result.results.length === 0) {
            return reply("Não foram encontrados resultados para o termo fornecido.");
        }

        const firstAudio = result.results[0];
        const audioUrl = firstAudio.audio;
        const title = firstAudio.title;
        console.log(`[AUDIO] Primeiro áudio encontrado: ${title}, URL: ${audioUrl}`);

        const audioResponse = await axios.get(audioUrl, { responseType: 'arraybuffer' });

        if (!audioResponse.data || audioResponse.data.length === 0) {
            throw new Error('Áudio não foi baixado corretamente.');
        }

        await blackmd.sendMessage(
            from,
            {
                audio: Buffer.from(audioResponse.data),
                mimetype: 'audio/mpeg',
                fileName: `${title}.mp3`,
                ptt: true
            },
            { quoted: info }
        );

    } catch (error) {
        console.error('Erro ao processar a solicitação:', error);
        reply("Ocorreu um erro ao processar a solicitação. Tente novamente mais tarde.");
    }
}
break;
case "pesq_audios":
case "pesqaudios":
{
    if (!q) {
        return reply("Você precisa fornecer um termo de busca para consulta.");
    }

    try {
        const query = q.trim();
        if (query.length === 0) {
            return reply("Por favor, forneça um termo válido para a busca.");
        }

        const res = await axios.get(`https://world-ecletix.onrender.com/api/audiomeme?query=${encodeURIComponent(query)}`);
        const result = res.data;

        if (!result || !result.status || !result.results || result.results.length === 0) {
            return reply("Nenhum dado encontrado para o termo de busca fornecido.");
        }

        let message = `*Resultados para a busca "${query}":*\n\n`;
        result.results.forEach((item, index) => {
            message += `${index + 1}. *${item.title}*\n🔊 ${item.audio}\n\n`;
        });

        reply(message);

    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case 'fazernick':{ // BY ALIZINDEV //by: ALIZINDEV 
if (!q) return reply(`Exemple\n${prefix+command} AlizinDev`)
let lizink_res = await fetchJson(`https://alizindev-api.onrender.com/api/tools/styletext?text=${q}&apikey=a93e85c1`)
let lizinn = lizink_res.resultado
let alizinnk =`*NICKS*\n\n`
for (let x of lizinn){
alizinnk +=`RESULTADO : ${x.result}\n\n`
}
reply(alizinnk)
}
break
case 'frases': {
    try {
        if (!q.trim()) return reply(`- Exemplo: ${prefix}frases luz`);

        const response = await fetch(`https://world-ecletix.onrender.com/api/pensador?nome=${encodeURIComponent(q)}`);
        if (!response.ok) return reply("Erro ao buscar as frases.");

        const data = await response.json();

        if (!data.length) return reply("Nenhuma frase encontrada.");

        let message = `*Frases sobre ${q}:*\n\n`;

        data.forEach((fraseInfo) => {
            message += `*Frase:* ${fraseInfo.frase}\n` +
                       `*Compartilhamentos:* ${fraseInfo.compartilhamentos}\n` +
                       `*Imagem:* ${fraseInfo.image}\n\n`;
        });

        return reply(message.trim());

    } catch (e) {
        console.log('Erro no bloco try:', e);
        return reply("Erro ao tentar buscar as frases.");
    }
}
break;
case 'pensador': {
    try {
        const response = await fetch(`https://world-ecletix.onrender.com/api/frasespensador`);
        if (!response.ok) return reply("Erro ao buscar as frases.");

        const data = await response.json();

        if (!data.length) return reply("Nenhuma frase encontrada.");

        let message = "*Frases Inspiradoras:*\n\n";

        data.forEach((frase, index) => {
            message += `*${index + 1}.* ${frase}\n\n`;
        });

        return reply(message.trim());

    } catch (e) {
        console.log('Erro no bloco try:', e);
        return reply("Erro ao tentar buscar as frases.");
    }
}
break;
case "signo":
{
    if (!q) {
        return reply("Por favor, informe o signo. Exemplo: !signo touro");
    }

    try {
        const signo = q.trim().toLowerCase();
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/horoscopo/${encodeURIComponent(signo)}`);

        if (!data || !data.horoscopo) {
            return reply("Não encontrei informações para o signo informado. Verifique se o nome está correto.");
        }

        let msg = `*Horóscopo de ${signo.charAt(0).toUpperCase() + signo.slice(1)}*\n\n`;
        msg += `*Horóscopo:* ${data.horoscopo}\n`;
        msg += `*Palpite:* ${data.palpite}\n`;
        msg += `*Cor:* ${data.cor}\n`;
        msg += `*Elemento:* ${data.elemento}\n`;
        msg += `*Regente:* ${data.regente}\n`;
        msg += `*Flor:* ${data.flor}\n`;
        msg += `*Metal:* ${data.metal}\n`;
        msg += `*Pedra:* ${data.pedra}\n`;
        msg += `*Amuleto:* ${data.amuletos}\n`;
        msg += `*Perfume:* ${data.perfume}\n`;
        msg += `*Anjo:* ${data.anjo}\n`;
        msg += `*Orixá:* ${data.orixa}\n`;
        msg += `*Santo protetor:* ${data.santoProtetor}\n`;

        reply(msg);

    } catch (error) {
        console.error(error);
        reply("Ocorreu um erro ao buscar o horóscopo. Tente novamente mais tarde.");
    }
}
break;
case 'verhtml':
case "html":
{
    if (!q) {
        return reply("Por favor, informe a URL que deseja visualizar o HTML. Exemplo: !html https://youtube.com");
    }

    try {
        const url = q.trim();
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/verhtml?url=${encodeURIComponent(url)}`);

        if (!data || !data.html) {
            return reply("Não foi possível obter o HTML da página informada.");
        }

        // Extrair domínio e formatar para nome do arquivo
        const { hostname } = new URL(url);
        const domainName = hostname.replace(/\./g, "_"); // Ex: youtube.com -> youtube_com
        const fileName = `${domainName}.html`;

        const htmlBuffer = Buffer.from(data.html, 'utf-8');

        await blackmd.sendMessage(
            from,
            {
                document: htmlBuffer,
                fileName: fileName,
                mimetype: 'text/html'
            },
            { quoted: info }
        );

    } catch (error) {
        console.error(error);
        reply("Ocorreu um erro ao tentar buscar o HTML da página.");
    }
}
break;
case "traduzir":
{
    if (!q) {
        return reply("Por favor, envie o texto que deseja traduzir. Exemplo: !traduzir love");
    }

    try {
        const texto = q.trim();
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/traduzir?texto=${encodeURIComponent(texto)}`);

        if (!data || !data.translation) {
            return reply("Não foi possível traduzir o texto informado.");
        }

        const msg = `*Tradução:*\n\nOriginal: ${data.original}\nPortuguês: ${data.translation}`;
        reply(msg);

    } catch (error) {
        console.error(error);
        reply("Ocorreu um erro ao tentar traduzir o texto.");
    }
}
break;

// PESQUISAS
case 'pinstalk':
  if (!q) return reply('Me envie o nome de usuário do Pinterest que deseja consultar.');

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/stalk/pinterest?query=${encodeURIComponent(q)}`);

    if (data?.status === 200 && data?.result?.username) {
      const user = data.result;
      const profilePicUrl = user.image.original; // Imagem de perfil
      const followers = user.stats.followers;
      const following = user.stats.following;
      const pins = user.stats.pins;
      const boards = user.stats.boards;
      const bio = user.bio || 'Não definida';
      const fullName = user.full_name;
      const username = user.username;
      const profileUrl = user.profile_url;

      // Enviar a imagem e as informações do usuário
      await blackmd.sendMessage(from, 
        { image: { url: profilePicUrl }, caption: `
          *• Nome Completo*: ${fullName}
          *• Username*: ${username}
          *• Seguidores*: ${followers}
          *• Seguindo*: ${following}
          *• Pins*: ${pins}
          *• Boards*: ${boards}
          *• Biografia*: ${bio}
          *• Link do Perfil*: ${profileUrl}
        `}, { quoted: info });
    } else {
      reply('Não foi possível obter informações sobre esse usuário.');
    }
  } catch (err) {
    console.log(err);
    reply('Erro ao consultar informações do Pinterest.');
  }
  break;
  
case 'npmstalk':
  if (!q) return reply('Me envie o nome do pacote NPM que deseja consultar.');

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/npmstalk?query=${encodeURIComponent(q)}`);

    if (data?.status === true && data?.result) {
      const packageInfo = data.result;
      const packageName = packageInfo.name;
      const latestVersion = packageInfo.dist-tags.latest;
      const versions = packageInfo.versions;
      const description = packageInfo.description || 'Não há descrição disponível.';
      const repository = packageInfo.repository || 'Não disponível.';
      const distTarball = packageInfo.versions[latestVersion]?.dist?.tarball;

      reply(`
        *• Nome do Pacote*: ${packageName}
        *• Versão mais recente*: ${latestVersion}
        *• Descrição*: ${description}
        *• Repositório*: ${repository}
        *• Link do pacote*: ${distTarball}
      `);
    } else {
      reply('Não foi possível obter informações sobre esse pacote NPM.');
    }
  } catch (err) {
    console.log(err);
    reply('Erro ao consultar informações do pacote NPM.');
  }
  break;
  case 'kwaistalk':
  if (!q) return reply('Me envie o nome de usuário do Kwai que deseja consultar.');

  try {
    const { data } = await axios.get(`https://api.nexfuture.com.br/api/outros/kwstalk?query=${encodeURIComponent(q)}`);

    if (data?.status === true && data?.resultado) {
      const user = data.resultado;
      const avatarUrl = user.foto_perfil;
      const bio = user.bio || 'Não definida';
      const followers = user.seguidores;
      const following = user.seguindo;
      const likes = user.curtidas;
      const username = user.nome_usuario;
      const kwaiUrl = user.url_perfil;
      const videos = user.videos.slice(0, 3); // Pegar os 3 primeiros vídeos

      // Enviar as informações do perfil
      await blackmd.sendMessage(from, {
        image: { url: avatarUrl },
        caption: `
          *• Nome de Usuário*: ${username}
          *• Bio*: ${bio}
          *• Seguidores*: ${followers}
          *• Seguindo*: ${following}
          *• Curtidas*: ${likes}
          *• Link do Perfil*: ${kwaiUrl}
        `
      }, { quoted: info });

      // Enviar vídeos
      for (let i = 0; i < videos.length; i++) {
        const video = videos[i];
        await blackmd.sendMessage(from, {
          video: { url: video.url },
          caption: `
            *• Título*: ${video.titulo}
            *• Descrição*: ${video.descricao}
            *• Curtidas*: ${video.curtidas}
            *• Comentários*: ${video.comentarios}
            *• Compartilhamentos*: ${video.compartilhamentos}
            *• Duração*: ${video.duracao}
            *• Link do Vídeo*: ${video.url}
          `
        }, { quoted: info });
      }
    } else {
      reply('Não foi possível obter informações sobre esse usuário do Kwai.');
    }
  } catch (err) {
    console.log(err);
    reply('Erro ao consultar informações do Kwai.');
  }
  break;
  case 'gitstalk':
 case 'githubStalk':
  case 'githubstalk':
  if (!q) return reply('Me envie o nome de usuário do GitHub que deseja consultar.');

  try {
    const { data } = await axios.get(`https://api.nexfuture.com.br/api/outros/github/stalk?username=${encodeURIComponent(q)}`);

    if (data?.status === true && data?.resultado) {
      const user = data.resultado;
      const avatarUrl = user.avatar_url;
      const bio = user.bio || 'Não definida';
      const followers = user.followers;
      const following = user.following;
      const repos = user.public_repos;
      const username = user.login;
      const githubUrl = user.html_url;

      // Enviar as informações e a foto do perfil juntas
      await blackmd.sendMessage(from, {
        image: { url: avatarUrl },
        caption: `
          *• Nome de Usuário*: ${username}
          *• Bio*: ${bio}
          *• Seguidores*: ${followers}
          *• Seguindo*: ${following}
          *• Repositórios Públicos*: ${repos}
          *• Link do Perfil*: ${githubUrl}
        `
      }, { quoted: info });
    } else {
      reply('Não foi possível obter informações sobre esse usuário do GitHub.');
    }
  } catch (err) {
    console.log(err);
    reply('Erro ao consultar informações do GitHub.');
  }
  break;
case 'tikstalk':
case 'tiktokStalk':
  if (!q) return reply('Me envie o nome de usuário do TikTok que deseja consultar.');

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/tiktokStalk?query=${encodeURIComponent(q)}`);

    if (data?.status === 200 && data?.result?.user) {
      const user = data.result.user;
      const profilePicUrl = user.avatarLarger;
      const followers = data.result.stats.followerCount;
      const following = data.result.stats.followingCount;
      const hearts = data.result.stats.heartCount;
      const videos = data.result.stats.videoCount;
      const signature = user.signature || 'Não definida';
      const nickname = user.nickname;
      const username = user.uniqueId;
      const imageUrl = data.result.image;

      // Enviar a imagem e as informações do usuário
      await blackmd.sendMessage(from, 
        { image: { url: profilePicUrl }, caption: `
          *• Nome*: ${nickname}
          *• Username*: @${username}
          *• Seguidores*: ${followers}
          *• Seguindo*: ${following}
          *• Curtidas*: ${hearts}
          *• Vídeos*: ${videos}
          *• Biografia*: ${signature}
          *• Link da Imagem*: ${imageUrl}
        `}, { quoted: info });
    } else {
      reply('Não foi possível obter informações sobre esse usuário.');
    }
  } catch (err) {
    console.log(err);
    reply('Erro ao consultar informações do TikTok.');
  }
  break;
case 'instalk':
case 'usergram':
case 'igstalk':
  if (!q) return reply('Me envie o nome de usuário do Instagram que deseja consultar.');

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/igstalk?query=${encodeURIComponent(q)}`);
    
    if (data?.status === 200 && data?.result?.user) {
      const user = data.result.user;
      const profilePicUrl = user.profile_pic_url;
      const followers = user.follower_count;
      const following = user.following_count;
      const posts = user.media_count;
      const bio = user.biography || 'Não definida';
      const fullName = user.full_name;
      const username = user.username;
      const imageUrl = user.image;
      
      // Enviar a imagem e as informações do usuário
      await blackmd.sendMessage(from, 
        { image: { url: profilePicUrl }, caption: `
          *• Nome Completo*: ${fullName}
          *• Username*: ${username}
          *• Seguidores*: ${followers}
          *• Seguindo*: ${following}
          *• Posts*: ${posts}
          *• Biografia*: ${bio}
          *• Link da Imagem*: ${imageUrl}
        `}, { quoted: info });
    } else {
      reply('Não foi possível obter informações sobre esse usuário.');
    }
  } catch (err) {
    console.log(err);
    reply('Erro ao consultar informações do Instagram.');
  }
  break;
case 'gimage':
  if (!q) return reply('Me envie o nome que deseja consultar.');

  try {
    const { data } = await axios.get(`https://api.vreden.my.id/api/gimage?query=${encodeURIComponent(q)}`);
    
    if (data?.status === 200 && data?.result?.length > 0) {
      const imageUrl = data.result[0]; // Pegando a primeira imagem da lista

      await blackmd.sendMessage(from, { image: { url: imageUrl }, caption: 'Aqui está a primeira imagem que encontrei!' }, { quoted: info });
    } else {
      reply('Não encontrei nenhuma imagem para essa consulta.');
    }
  } catch (err) {
    console.log(err);
    reply('Erro ao consultar imagens.');
  }
  break;
case 'biblia':
    if (!q) return reply('[📖] Por favor, informe o versículo que deseja buscar. Exemplo: !biblia salmo 91', { quoted: info });

    try {
        const { data } = await axios.get(`https://world-ecletix.onrender.com/api/biblia?vers=${encodeURIComponent(q)}`);
        if (!data || !data.text) return reply('🚨 Versículo não encontrado!', { quoted: info });

        const versiculos = data.verses.map(v => `*${v.book_name} ${v.chapter}:${v.verse}* — ${v.text.trim()}`).join('\n');

        const msg = `📖 *${data.reference}*\n\n${versiculos}\n\n*Tradução:* ${data.translation_name}`;
        reply(msg, { quoted: info });

    } catch (error) {
        console.error(error);
        reply('🚨 Erro ao buscar versículo. Verifique se escreveu corretamente, ex: !biblia salmo 91', { quoted: info });
    }
    break;
    case 'temporal': {
    try {
        if (!q) return reply('Por favor, forneça o nome de uma cidade.');

        let city = q;
        let response = await fetch(`https://wttr.in/${city}?format=j1`);
        let data = await response.json();

        if (data.error) {
            return reply(`Desculpe, não consegui encontrar a previsão do tempo para "${city}".`);
        }

        let weatherDescription = data.current_condition[0].weatherDesc[0].value;
        let temperature = data.current_condition[0].temp_C;
        let feelsLike = data.current_condition[0].FeelsLikeC;
        let humidity = data.current_condition[0].humidity;
        let windSpeed = data.current_condition[0].windspeedKmph;

        let weatherMessage = `Previsão do tempo para ${data.nearest_area[0].areaName[0].value}, ${data.nearest_area[0].region[0].value}, ${data.nearest_area[0].country[0].value}:
        🌡️ Temperatura: ${temperature}°C
        🤔 Sensação térmica: ${feelsLike}°C
        💧 Umidade: ${humidity}%
        🌬️ Velocidade do vento: ${windSpeed} km/h
        ☁️ Condições: ${weatherDescription}`;

        reply(weatherMessage);
    } catch (e) {
        console.error(e);
        reply('Desculpe, ocorreu um erro ao buscar a previsão do tempo. Tente novamente mais tarde.');
    }
    break;
}

case 'significado':
    if (args.length == 0) return await reply('Cadê o nome o qual você deseja ver o significado?');
    
    const significado = encodeURIComponent(args.join(' ')); // Nome formatado para a URL
    try {
        const response = await axios.get(`https://world-ecletix.onrender.com/api/significadodonome?nome=${significado}`);
        const res = response.data;

        if (!res.significado) {
            return await reply('Nenhum significado encontrado para o nome fornecido.');
        }

        const { significado, origem, genero, imageUrl } = res;

        // Baixa a imagem do nome como buffer
        const fotoNome = await axios.get(imageUrl, { responseType: 'arraybuffer' });
        const imageBuffer = Buffer.from(fotoNome.data, 'binary');

        // Formata a mensagem com as informações do nome
        const message = `*Nome:* ${nome}\n` +
                        `*Significado:* ${significado}\n` +
                        `*Origem:* ${origem}\n` +
                        `*Gênero:* ${genero || 'Não especificado'}\n`;

        // Envia a imagem com a legenda formatada
        await blackmd.sendMessage(from, { image: imageBuffer, caption: message }).catch((e) => {
            console.log(e);
            return reply('Ocorreu um erro ao enviar a imagem ou as informações.');
        });
    } catch (error) {
        console.error(error);
        return reply('Ocorreu um erro ao processar a solicitação.');
    }
break;

case 'feriados':
    if (!q) return reply(`Favor informar o ano desejado.`); 
    try {
    const resposta = await fetch(`https://api.invertexto.com/v1/holidays/${q}?token=5980|9n1NZ449fdM1Hxs8K8urHxDZRVfEznwI&state=br`);
    const feriados = await resposta.json();
    let mensagem = `*• Feriados para o ano de ${q}*:\n\n`;
    feriados.forEach(({ date, name, type }) => { mensagem += `*• Data:* _${date}_\n*• Feriado:* _${name}_\n*• Tipo:* _${type}_\n*—*\n`});
    blackmd.sendMessage(from, { text: mensagem }, { quoted: info }) } catch(error) { reply(`Erro ao obter a lista de feriados.`)}
    break;
    case 'receita': // Feito por Slayer
    try {
        let url;
        if (!args[0]) {
            url = 'https://www.themealdb.com/api/json/v1/1/random.php'; // Receita aleatória
        } else {
            const nomeReceita = args.join(' ');
            url = `https://www.themealdb.com/api/json/v1/1/search.php?s=${encodeURIComponent(nomeReceita)}`;
        }

        const response = await axios.get(url);
        const data = response.data;

        if (!data.meals) {
            return reply('❌ Nenhuma receita encontrada! Tente outro nome ou use /receita para uma aleatória.');
        }

        const receita = data.meals[0];
        const titulo = receita.strMeal;
        const categoria = receita.strCategory || "Desconhecida";
        const instrucoes = receita.strInstructions.length > 500 ? receita.strInstructions.slice(0, 500) + '...' : receita.strInstructions;
        const imagem = receita.strMealThumb;
        const link = receita.strSource || `https://www.themealdb.com/meal/${receita.idMeal}`;

        let ingredientes = '';
        for (let i = 1; i <= 20; i++) {
            if (receita[`strIngredient${i}`]) {
                ingredientes += `🔹 ${receita[`strIngredient${i}`]} - ${receita[`strMeasure${i}`]}\n`;
            }
        }

        const mensagemReceita = `
🍽 *Receita Encontrada!* 🍽

🔹 *Nome:* ${titulo}
🔹 *Categoria:* ${categoria}
🔹 *Ingredientes:*  
${ingredientes}
🔹 *Modo de Preparo:*  
${instrucoes}
🔹 *Link Completo:* [Clique Aqui](${link})
        `;

        if (imagem) {
            const buffer = await getBuffer(imagem);
            await blackmd.sendMessage(from, { image: buffer, caption: mensagemReceita }, { quoted: info });
        } else {
            await blackmd.sendMessage(from, { text: mensagemReceita }, { quoted: info });
        }
    } catch (erro) {
        console.error('Erro ao buscar receita:', erro);
        reply('❌ Ocorreu um erro ao buscar a receita. Tente novamente mais tarde.');
    }
    break;
case 'endereco':
case 'maps'://slayer
    if (!args[0]) return reply('❌ Escreva um endereço para pesquisar no Google Maps.');

    let endereco = args.join(' ');
    let linkMaps = `https://www.google.com/maps/search/${encodeURIComponent(endereco)}`;

    reply(`🗺 *Local Encontrado:*  
📍 ${endereco}  
🔗 [Ver no Google Maps](${linkMaps})`);
    break;
    
    case 'Wikipedia':
    case 'wikipedia': //Wikipédia atualizado
    try {
        if (!q) return reply('Insira o termo de busca para Wikipédia!');

        // Função para enviar a imagem e o texto
        const sendImageURL = (texts, url) => {
            const textinhur = `\n${q}\n\n  • ${texts}`;
            
            // Envia a imagem e o texto
            blackmd.sendMessage(from, {
                image: {
                    url
                },
                caption: textinhur
            }, {
                quoted: info
            });
        };

        // Define a base URL da Wikipedia
        const base = 'https://pt.m.wikipedia.org';

        // Faz a busca na Wikipedia
        const { data } = await axios.get(`${base}/w/index.php?search=${q}&title=Special:Search&profile=advanced&fulltext=1&ns0=1`);

        const $ = cheerio.load(data);
        const array = [];

        // Captura os links de resultados
        $('.mw-search-result-heading').each(function() {
            const ref = $(this).find('a').attr('href');
            if (ref) {
                array.push(ref);
            }
        });

        // Verifica se há resultados na pesquisa
        if (array.length === 0) {
            return reply("Nenhum resultado encontrado para o termo de busca.");
        }

        // Acessa o primeiro link de resultado
        const { data: body } = await axios.get(base + array[0]);
        const $$ = cheerio.load(body);
        
        // Captura a imagem do artigo ou define uma imagem padrão
        const image = 'https:' + ($$('a.mw-file-description').find('img').attr('src') || '//pngimg.com/uploads/wikipedia/wikipedia_PNG35.png');

        // Captura o conteúdo dos parágrafos
        let contents = '';
        $$('p').each(function() {
            contents += $$(this).text().trim() + '\n';
        });

        // Envia os resultados
        sendImageURL(contents, image);
    } catch (e) {
        console.error(e);
        reply('Erro ao executar o comando.');
    }
    break;
    case 'checkban':
case 'verificarban': {
    try {
        if (!q.trim()) return reply(`- Exemplo: ${prefix}verificarban 168274223`);

        const res = await fetchJson(`https://world-ecletix.onrender.com/api/banido?id=${encodeURIComponent(q)}`);
        
        if (!res || res.status !== "success") {
            return reply("Erro ao processar a resposta da API.");
        }

        const statusBan = res.isBanned === "yes" ? "🚨 *Usuário BANIDO!* 🚨" : "✅ *Usuário não está banido.*";

        return reply(`🔍 *Verificação de Banimento*\n🆔 *ID:* ${res.uid}\n${statusBan}`);
        
    } catch (error) {
        console.error("Erro ao verificar banimento:", error);
        return reply("Erro ao tentar verificar o banimento.");
    }
}
break;
case "celular": 
{
    try {
        // Obtém o modelo do celular da mensagem do usuário
        const modelo = args.join(" "); // args contém as palavras digitadas pelo usuário
        if (!modelo) {
            return reply("❌ Você precisa informar o modelo do celular. Exemplo: *celular iPhone 15*");
        }

        // Faz a requisição para a API com o modelo informado
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/celular?modelo=${encodeURIComponent(modelo)}`);

        if (!res || !res.specs || Object.keys(res.specs).length === 0) {
            return reply("🔍 Não foi possível encontrar informações sobre este celular no momento.");
        }

        let message = `📱 *Informações do Celular*\n\n`;
        message += `🔹 *Nome:* ${res.name || "Nome não especificado"}\n`;
        message += `🔗 *URL:* [Clique aqui para mais detalhes](${res.url})\n\n`;

        const specs = res.specs;

        // Função para formatar corretamente os textos
        const formatText = (text) => text ? text.replace(/�/g, "").trim() : "Não especificado";

        message += `🛠️ *Especificações Técnicas:*\n`;
        message += `• *Sistema Operacional:* ${formatText(specs["Sistema Operacional"])}\n`;
        message += `• *Disponibilidade:* ${formatText(specs["Disponibilidade"])}\n`;
        message += `• *Dimensões:* ${formatText(specs["Dimensões"])}\n`;
        message += `• *Peso:* ${formatText(specs["Peso"])}\n\n`;

        message += `🖥️ *Tela:*\n`;
        message += `• *Tamanho:* ${formatText(specs["Polegadas"])}\n`;
        message += `• *Resolução:* ${formatText(specs["Resolução"])}\n`;
        message += `• *FPS:* ${formatText(specs["FPS"])}\n\n`;

        message += `📸 *Câmera:*\n`;
        message += `• *Principal:* ${formatText(specs["Megapixel"])}\n`;
        message += `• *Frontal:* ${formatText(specs["Câmera Frontal"])}\n`;
        message += `• *Estabilização:* ${formatText(specs["Estabilização"])}\n`;
        message += `• *Flash:* ${formatText(specs["Flash"])}\n\n`;

        message += `🚀 *Desempenho:*\n`;
        message += `• *Processador:* ${formatText(specs["Processador"])}\n`;
        message += `• *Chipset:* ${formatText(specs["Chipset"])}\n`;
        message += `• *GPU:* ${formatText(specs["GPU"])}\n`;
        message += `• *RAM:* ${formatText(specs["RAM"])}\n`;
        message += `• *Armazenamento:* ${formatText(specs["Memória Max"])}\n`;
        message += `• *Expansível:* ${formatText(specs["Memória Expansível"])}\n\n`;

        message += `🔋 *Bateria:*\n`;
        message += `• *Capacidade:* ${formatText(specs["Ampere"])}\n\n`;

        message += `📡 *Conectividade:*\n`;
        message += `• *Wi-Fi:* ${formatText(specs["Wi-Fi"])}\n`;
        message += `• *Bluetooth:* ${formatText(specs["Bluetooth"])}\n`;
        message += `• *USB:* ${formatText(specs["USB"])}\n`;
        message += `• *GPS:* ${formatText(specs["GPS"])}\n\n`;

        message += `🔒 *Segurança:*\n`;
        message += `• *Leitor de Impressão Digital:* ${formatText(specs["Impresso digital"])}\n`;
        message += `• *Reconhecimento Facial:* ${formatText(specs["Reconhecimento Facial"])}\n\n`;

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API de celular:", error.message, error.stack);
        return reply("⚠️ Ocorreu um erro ao processar a solicitação. Tente novamente mais tarde.");
    }
}
break;
case 'livro':
    if (!q) return reply('[📚] Por favor, forneça o nome do livro que você deseja buscar. Exemplo: !livro Titanic', { quoted: info });

    try {
        const { data } = await axios.get(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(q)}`);

        if (!data.items || data.items.length === 0) return reply('🚨 Livro não encontrado!', { quoted: info });

        const book = data.items[0].volumeInfo;

        const title = book.title || 'Não disponível';
        const authors = book.authors ? book.authors.join(', ') : 'Autor desconhecido';
        const publisher = book.publisher || 'Editora desconhecida';
        const publishedDate = book.publishedDate || 'Data não informada';
        const pageCount = book.pageCount || 'N/A';
        const description = book.description ? book.description.substring(0, 1000) + '...' : 'Descrição indisponível.';
        const language = book.language || 'N/A';
        const thumbnail = book.imageLinks?.thumbnail?.replace('http:', 'https:');

        const caption = `*Título:* ${title}
*Autores:* ${authors}
*Editora:* ${publisher}
*Publicado em:* ${publishedDate}
*Páginas:* ${pageCount}
*Idioma:* ${language}

*Descrição:* ${description}`;

        if (thumbnail) {
            const imgBuffer = await getBuffer(thumbnail);
            await blackmd.sendMessage(from, { image: imgBuffer, caption }, { quoted: info });
        } else {
            await reply(caption, { quoted: info });
        }

    } catch (error) {
        console.error(error);
        reply('🚨 Erro ao buscar informações do livro.', { quoted: info });
    }
    break;
    case 'cotacao':
    if (!q) return reply('[💱] Por favor, informe a moeda que deseja consultar. Exemplo: !cotacao USD-BRL ou !cotacao BTC-BRL', { quoted: info });

    try {
        const { data } = await axios.get(`https://economia.awesomeapi.com.br/json/last/${q.toUpperCase()}`);
        const key = Object.keys(data)[0];
        if (!key || !data[key]) return reply('🚨 Moeda não encontrada! Use o formato: USD-BRL, EUR-BRL, BTC-BRL...', { quoted: info });

        const moeda = data[key];
        const msg = `💹 *Cotação Atual: ${moeda.name}*

*Código:* ${moeda.code} ➜ ${moeda.codein}
*Maior valor (high):* R$ ${parseFloat(moeda.high).toFixed(2)}
*Menor valor (low):* R$ ${parseFloat(moeda.low).toFixed(2)}
*Valor atual (bid):* R$ ${parseFloat(moeda.bid).toFixed(2)}
*Variação:* ${parseFloat(moeda.pctChange).toFixed(2)}%
*Última atualização:* ${new Date(moeda.timestamp * 1000).toLocaleString('pt-BR')}`;

        reply(msg, { quoted: info });
    } catch (error) {
        console.error(error);
        reply('🚨 Erro ao buscar a cotação. Verifique se a moeda está no formato correto, tipo: USD-BRL, EUR-BRL, BTC-BRL', { quoted: info });
    }
    break;
    
case 'letra':
    if (!q) return reply('[⚙️️] Por favor, forneça o nome da música que você deseja buscar. Exemplo: !letra matue 4tal', { quoted: info });

    const texto = encodeURIComponent(q); // Codifica a consulta para a URL
    const apiUrlLetra = `https://world-ecletix.onrender.com/api/letra?texto=${texto}`;

    try {
        // Requisição para a API de letra
        const response = await axios.get(apiUrlLetra);
        const data = response.data;

        // Verificar se a resposta contém informações sobre a música
        if (data && data.titulo) {
            const { titulo, artista, letra, imagem } = data;

            // Montar a mensagem com as informações da música
            const message = `
                *Título:* ${titulo}
                *Artista:* ${artista}
                *Letra:*
                
                ${letra}
            `;

            // Enviar a imagem e a mensagem com a letra da música
            if (imagem) {
                const imageResponse = await axios.get(imagem, { responseType: 'arraybuffer' });
                const imageBuffer = Buffer.from(imageResponse.data, 'binary');

                await blackmd.sendMessage(from, { 
                    image: imageBuffer, 
                    caption: message 
                }, { quoted: info });
            } else {
                await blackmd.sendMessage(from, { text: message }, { quoted: info });
            }
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível encontrar a letra da música pesquisada.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao fazer a requisição à API de letra:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao buscar a letra da música.' }, { quoted: info });
    }
    break;
    case 'filme':
    if (!q) return reply('[⚙️️] Por favor, forneça o nome do filme que você deseja buscar. Exemplo: !filme Deadpool', { quoted: info });

    try {
        const search = await axios.get(`https://api.themoviedb.org/3/search/movie?api_key=ddfcb99fae93e4723232e4de755d2423&query=${encodeURIComponent(q)}&language=pt`);
        const movie = search.data.results[0];
        if (!movie) return reply('🚨 Filme não encontrado!', { quoted: info });

        const imgUrl = `https://image.tmdb.org/t/p/original${movie.backdrop_path}`;
        const imgBuffer = await getBuffer(imgUrl);

        const message = `*Nome do Filme:* ${movie.title}
*Nome original:* ${movie.original_title}
*Data de Lançamento:* ${movie.release_date}
*Avaliações:* ${movie.vote_average} - (${movie.vote_count} votos)
*Popularidade:* ${movie.popularity.toFixed(1)}%
*Classificação adulta?* ${movie.adult ? 'Sim' : 'Não'}
*Linguagem oficial:* ${movie.original_language}

*Sinopse:* ${movie.overview}`;

        await blackmd.sendMessage(from, { image: imgBuffer, caption: message }, { quoted: info });

    } catch (error) {
        console.error(error);
        reply('🚨 Erro ao buscar informações do filme.', { quoted: info });
    }
    break;
case 'serie':
    if (!q) return reply('[⚙️️] Por favor, forneça o nome da série que você deseja buscar. Exemplo: !serie The Boys', { quoted: info });

    try {
        const search = await axios.get(`https://api.themoviedb.org/3/search/tv?api_key=ddfcb99fae93e4723232e4de755d2423&query=${encodeURIComponent(q)}&language=pt`);
        const serie = search.data.results[0];
        if (!serie) return reply('🚨 Série não encontrada!', { quoted: info });

        const imgUrl = `https://image.tmdb.org/t/p/original${serie.backdrop_path}`;
        const imgBuffer = await getBuffer(imgUrl);

        const message = `*Nome da Série:* ${serie.name}
*Nome original:* ${serie.original_name}
*Data de Lançamento:* ${serie.first_air_date}
*Avaliações:* ${serie.vote_average} - (${serie.vote_count} votos)
*Popularidade:* ${serie.popularity.toFixed(1)}%
*Classificação adulta?* ${serie.adult ? 'Sim' : 'Não'}
*Linguagem oficial:* ${serie.original_language}

*Sinopse:* ${serie.overview}`;

        await blackmd.sendMessage(from, { image: imgBuffer, caption: message }, { quoted: info });

    } catch (error) {
        console.error(error);
        reply('🚨 Erro ao buscar informações da série.', { quoted: info });
    }
    break;
case 'filme2':
    if (!q) return reply('[⚙️️] Por favor, forneça o nome do filme que você deseja buscar. Exemplo: !filme Deadpool', { quoted: info });

    const queryFilme = encodeURIComponent(q); // Codifica a consulta para a URL
    const apiUrlFilme = `https://world-ecletix.onrender.com/api/filme?nome=${queryFilme}`;

    try {
        // Requisição para a API de filmes
        const response = await axios.get(apiUrlFilme);
        const data = response.data;

        // Verificar se a resposta contém informações sobre o filme
        if (data.status === 'online' && data.imagem) {
            const { Nome, Lancamento, Avaliacoes, Popularidade, Classificacao_adulta, Linguagem_oficial, Sinopse, imagem } = data;

            // Montar a mensagem com as informações do filme
            const message = `
                *Título:* ${Nome}
                *Lançamento:* ${Lancamento}
                *Avaliações:* ${Avaliacoes}
                *Popularidade:* ${Popularidade}
                *Classificação Adulta:* ${Classificacao_adulta}
                *Linguagem Oficial:* ${Linguagem_oficial}
                *Sinopse:* ${Sinopse}
            `;

            // Função para baixar a imagem
            const getImageBuffer = async (url) => {
                try {
                    const { data } = await axios.get(url, { responseType: 'arraybuffer' });
                    return Buffer.from(data, 'binary');
                } catch (error) {
                    console.error('Erro ao baixar a imagem:', error);
                    return null;
                }
            };

            // Verifica se a URL da imagem é acessível e obtém o buffer
            const imageBuffer = await getImageBuffer(imagem);

            if (imageBuffer && imageBuffer.length > 0) {
                // Envia a mensagem com a imagem
                await blackmd.sendMessage(
                    from,
                    {
                        image: imageBuffer,
                        caption: message, // Adiciona a mensagem como legenda
                    },
                    { quoted: info }
                );
            } else {
                // Se falhar ao baixar a imagem, envia apenas o texto
                await blackmd.sendMessage(
                    from,
                    {
                        text: `${message}\n\nNão foi possível baixar a imagem.`,
                    },
                    { quoted: info }
                );
            }
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível encontrar informações para o filme pesquisado.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao fazer a requisição à API de filmes:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao buscar informações sobre o filme.' }, { quoted: info });
    }
    break;

case 'serie2':
    if (!q) return reply('[⚙️️] Por favor, forneça o nome da série que você deseja buscar. Exemplo: !serie The Boys', { quoted: info });

    const querySerie = encodeURIComponent(q); // Codifica a consulta para a URL
    const apiUrlSerie = `https://world-ecletix.onrender.com/api/serie?nome=${querySerie}`;

    try {
        // Requisição para a API de séries
        const response = await axios.get(apiUrlSerie);
        const data = response.data;

        // Verificar se a resposta contém informações sobre a série
        if (data.status === 'online' && data.imagem) {
            const { Nome, Lancamento, Avaliacoes, Popularidade, Classificacao_adulta, Linguagem_oficial, Sinopse, imagem } = data;

            // Montar a mensagem com as informações da série
            const message = `
                *Título:* ${Nome}
                *Lançamento:* ${Lancamento}
                *Avaliações:* ${Avaliacoes}
                *Popularidade:* ${Popularidade}
                *Classificação Adulta:* ${Classificacao_adulta}
                *Linguagem Oficial:* ${Linguagem_oficial}
                *Sinopse:* ${Sinopse}
            `;

            // Função para baixar a imagem
            const getImageBuffer = async (url) => {
                try {
                    const { data } = await axios.get(url, { responseType: 'arraybuffer' });
                    return Buffer.from(data, 'binary');
                } catch (error) {
                    console.error('Erro ao baixar a imagem:', error);
                    return null;
                }
            };

            // Verifica se a URL da imagem é acessível e obtém o buffer
            const imageBuffer = await getImageBuffer(imagem);

            if (imageBuffer && imageBuffer.length > 0) {
                // Envia a mensagem com a imagem
                await blackmd.sendMessage(
                    from,
                    {
                        image: imageBuffer,
                        caption: message, // Adiciona a mensagem como legenda
                    },
                    { quoted: info }
                );
            } else {
                // Se falhar ao baixar a imagem, envia apenas o texto
                await blackmd.sendMessage(from,
                    {
                        text: `${message}\n\nNão foi possível baixar a imagem.`,
                    },
                    { quoted: info }
                );
            }
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível encontrar informações para a série pesquisada.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao fazer a requisição à API de séries:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao buscar informações sobre a série.' }, { quoted: info });
    }
    break;
// TABELAS FUTEBOL 
case "tabela_ucl":
{

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-ucl`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inválida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui está a tabela atualizada da UCL:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posição: ${team.posicao}, Jogos: ${team.jogos}, Vitórias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "tabela_brasileirao":
{

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-brasileirao`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inválida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui está a tabela atualizada do Brasileirão:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posição: ${team.posicao}, Jogos: ${team.jogos}, Vitórias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "tabela_premierleague":
{

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-premierleague`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inválida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui está a tabela atualizada da Premier League:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posição: ${team.posicao}, Jogos: ${team.jogos}, Vitórias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "tabela_laliga":
{

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-laliga`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inválida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui está a tabela atualizada da La Liga:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posição: ${team.posicao}, Jogos: ${team.jogos}, Vitórias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "tabela_bundesliga":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-bundesliga`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inválida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui está a tabela atualizada da Bundesliga:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posição: ${team.posicao}, Jogos: ${team.jogos}, Vitórias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "tabela_seriea":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-seriea`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inválida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui está a tabela atualizada da Série A:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posição: ${team.posicao}, Jogos: ${team.jogos}, Vitórias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "tabela_ligue1":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-ligue1`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inválida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui está a tabela atualizada da Ligue 1:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posição: ${team.posicao}, Jogos: ${team.jogos}, Vitórias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "tabela_portugal":
{

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tabela-portugal`);
        
        if (!res || !res.logo || !res.tabela) {
            return reply("Nenhuma tabela encontrada ou resposta inválida da API.");
        }

        const logoURL = res.logo;
        let cap = "Aqui está a tabela atualizada da Primeira Liga de Portugal:\n\n";

        // Formatando a tabela para enviar
        res.tabela.forEach(team => {
            cap += `${team.time} - Posição: ${team.posicao}, Jogos: ${team.jogos}, Vitórias: ${team.vitorias}, Empates: ${team.empates}, Derrotas: ${team.derrotas}, Saldo: ${team.saldo}, Pontos: ${team.pontos}\n`;
        });

        blackmd.sendMessage(from, { image: { url: logoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
// GUIA DE TV
case "guia-filmes":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-filmes`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("🔍 Não foi possível encontrar informações sobre o guia de filmes no momento.");
        }

        let message = "*🎬 Guia de Filmes - Programação Atual:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programação
            }

            message += `📺 *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   🕒 *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espaçamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-filmes:", error);
        return reply("⚠️ Ocorreu um erro ao processar a solicitação. Tente novamente mais tarde.");
    }
}
break;
case "guia-series":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-series`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("🔍 Não foi possível encontrar informações sobre o guia de séries no momento.");
        }

        let message = "*📺 Guia de Séries - Programação Atual:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programação
            }

            message += `🎥 *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   🕒 *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espaçamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-series:", error);
        return reply("⚠️ Ocorreu um erro ao processar a solicitação. Tente novamente mais tarde.");
    }
}
break;
case "guia-esportes":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-esportes`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("🔍 Não foi possível encontrar informações sobre o guia de esportes no momento.");
        }

        let message = "*🏅 Guia de Esportes - Programação Atual:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programação
            }

            message += `📺 *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   🕒 *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espaçamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-esportes:", error);
        return reply("⚠️ Ocorreu um erro ao processar a solicitação. Tente novamente mais tarde.");
    }
}
break;
case "guia-infantil":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-infantil`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("🔍 Não foi possível encontrar informações sobre o guia infantil no momento.");
        }

        let message = "*🎨 Guia Infantil - Programação Atual:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programação
            }

            message += `📺 *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   🕒 *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espaçamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-infantil:", error);
        return reply("⚠️ Ocorreu um erro ao processar a solicitação. Tente novamente mais tarde.");
    }
}
break;
case "guia-variedades":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-variedades`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("🔍 Não foi possível encontrar informações sobre o guia de variedades no momento.");
        }

        let message = "*🎭 Guia Variedades - Programação Atual:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programação
            }

            message += `📺 *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   🕒 *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espaçamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-variedades:", error);
        return reply("⚠️ Ocorreu um erro ao processar a solicitação. Tente novamente mais tarde.");
    }
}
break;
case "guia-documentarios":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-documentarios`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("🔍 Não foi possível encontrar informações sobre o guia de documentários no momento.");
        }

        let message = "*📚 Guia de Documentários - Programação Atual:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programação
            }

            message += `📺 *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   🕒 *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espaçamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-documentarios:", error);
        return reply("⚠️ Ocorreu um erro ao processar a solicitação. Tente novamente mais tarde.");
    }
}
break;
case "guia-noticias":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-noticias`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("🔍 Não foi possível encontrar informações sobre o guia de notícias no momento.");
        }

        let message = "*📰 Guia de Notícias - Programação Atual:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programação
            }

            message += `📺 *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   🕒 *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espaçamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-noticias:", error);
        return reply("⚠️ Ocorreu um erro ao processar a solicitação. Tente novamente mais tarde.");
    }
}
break;
case "guia-aberta":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/guia-aberta`);
        // by Luan

        if (!res || res.length === 0) {
            return reply("🔍 Não foi possível encontrar informações sobre o guia de programação aberta no momento.");
        }

        let message = "*📺 Guia de Programação Aberta:*\n\n";

        res.forEach((canal) => {
            const { canal: nomeCanal, programas } = canal;

            if (!nomeCanal || !programas || programas.length === 0) {
                return; // Ignora canais sem nome ou programação
            }

            message += `📺 *Canal:* ${nomeCanal}\n`;

            programas.forEach((programa) => {
                const { hora, titulo } = programa;
                if (hora && titulo) {
                    message += `   🕒 *${hora}* - ${titulo}\n`;
                }
            });

            message += "\n"; // Espaçamento entre os canais
        });

        reply(message.trim());
    } catch (error) {
        console.error("Erro ao consultar a API de guia-aberta:", error);
        return reply("⚠️ Ocorreu um erro ao processar a solicitação. Tente novamente mais tarde.");
    }
}
break;
case "tv":
{
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/tv`);
        //by luan

        if (!res || res.length === 0) { // Corrigido de "res" para "res"
            return reply("Nenhuma programação de TV encontrada no momento.");
        }

        let message = "*📺 Programação da TV:*\n\n";
        
        res.forEach((programa, index) => { // Corrigido de "res" para "res"
            const { title, link, image } = programa;

            message += `*${index + 1}. ${title}*\n`;
            if (link) message += `🔗 *Link:* [Clique aqui](${link})\n`;
            if (image) message += `🖼️ *Imagem:* ${image}\n`;
            message += "\n"; // Adiciona espaçamento entre programas
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API de TV:", error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "tvfutebol":
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/futebol`);
        //by luan

        if (!res || res.length === 0) {
            return reply("Não há informações disponíveis no momento.");
        }

        let message = `*🎥 Futebol e Esportes Ao Vivo*\n\n`;
        res.forEach((evento, index) => {
            message += `*${index + 1}. ${evento.title}*\n`;
            message += `🔗 *Link:* [Clique aqui](${evento.link})\n`;
            message += `🖼️ *Imagem:* ${evento.image}\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API de futebol:", error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
break;
case "jogosdodia": 
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/jogosdodia`);
        //by luan

        if (!res || res.length === 0) {
            return reply("Não há informações de jogos disponíveis no momento.");
        }

        let message = `*🎮 Jogos do Dia - Ao Vivo*\n\n`;
        res.forEach((jogo, index) => {
            message += `*${index + 1}. ${jogo.title}*\n`;
            message += `🔗 *Link:* [Clique aqui](${jogo.link})\n`;
            message += `🖼️ *Imagem:* ${jogo.image}\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API de jogos do dia:", error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
break;		
case "ucl": 
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/ucl`);
        //by luan

        if (!res || res.length === 0) {
            return reply("Não há informações da UCL disponíveis no momento.");
        }

        let message = `*🏆 Liga dos Campeões da UEFA (UCL)*\n\n`;
        res.forEach((jogo, index) => {
            message += `*${index + 1}. ${jogo.match}*\n`;
            message += `🕒 *Horário:* ${jogo.time}\n`;
            message += `📍 *Local:* ${jogo.venue}\n`;
            message += `🔗 *Link:* [Clique aqui](${jogo.link})\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API da UCL:", error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
break;		
case "tvbrasileirao": 
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/brasileirao`);
        //by luan

        if (!res || res.length === 0) {
            return reply("Não há informações sobre a transmissão do Brasileirão disponíveis no momento.");
        }

        let message = `*📺 Jogos do Brasileirão - Transmissão*\n\n`;
        res.forEach((jogo, index) => {
            message += `*${index + 1}. ${jogo.match}*\n`;
            message += `🕒 *Horário:* ${jogo.time}\n`;
            message += `📺 *Canal:* ${jogo.channel}\n`;
            message += `📍 *Local:* ${jogo.venue}\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API do Brasileirão:", error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
break;		
case "nfl": 
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/nfl`);
        //by luan

        if (!res || res.length === 0) {
            return reply("Não há informações sobre jogos da NFL disponíveis no momento.");
        }

        let message = `*🏈 Jogos da NFL*\n\n`;
        res.forEach((jogo, index) => {
            message += `*${index + 1}. ${jogo.match}*\n`;
            message += `🕒 *Horário:* ${jogo.time}\n`;
            message += `📺 *Canal:* ${jogo.channel}\n`;
            message += `📍 *Local:* ${jogo.venue}\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API da NFL:", error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
break;	
		case "ufc":
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/ufc`);
        //by luan

        if (!res || res.length === 0) {
            return reply("Não há informações do UFC disponíveis no momento.");
        }

        let message = `*🥊 Ultimate Fighting Championship (UFC)*\n\n`;
        res.forEach((evento, index) => {
            message += `*${index + 1}. ${evento.title}*\n`;
            message += `🔗 *Link:* [Clique aqui](${evento.link})\n`;
            message += `🖼️ *Imagem:* [Ver imagem](${evento.image})\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API do UFC:", error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
break;
		case "jogosdehoje":
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/jogosdehoje`);
        //by luan

        if (!res || res.length === 0) {
            return reply("Não há jogos disponíveis no momento.");
        }

        let message = `*⚽ Jogos de Hoje*\n\n`;
        res.forEach((jogo, index) => {
            message += `*${index + 1}. ${jogo.time1} x ${jogo.time2}*\n`;
            if (jogo.horario) message += `🕒 *Horário:* ${jogo.horario}\n`;
            message += `📊 *Placar:* ${jogo.placar}\n`;
            if (jogo.status) message += `📝 *Status:* ${jogo.status}\n`;
            message += `\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API de Jogos de Hoje:", error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
break;
case "basquete": 
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/basquete`);
        //by luan

        if (!res || res.length === 0) {
            return reply("Não há informações sobre jogos de Basquete disponíveis no momento.");
        }

        let message = `*🏀 Jogos de Basquete*\n\n`;
        res.forEach((jogo, index) => {
            message += `*${index + 1}. ${jogo.match}*\n`;
            message += `🕒 *Horário:* ${jogo.time}\n`;
            message += `📺 *Canal:* ${jogo.channel}\n`;
            message += `📍 *Local:* ${jogo.venue}\n\n`;
        });

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API de Basquete:", error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
break;		
case "esportedodia": 
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/esportedodia`);
        const esporte = await res.json();

        if (!esporte || !esporte.title || !esporte.description || !esporte.url) {
            return reply("🏟️ Não foi possível encontrar o esporte do dia no momento.");
        }

        // Mensagem formatada
        let message = `*🏅 Esporte do Dia*\n\n`;
        message += `*🔹 Título:* ${esporte.title}\n`;
        message += `*📝 Descrição:* ${esporte.description}\n`;
        message += `*🔗 Saiba mais:* [Clique aqui](${esporte.url})\n`;

        reply(message);
    } catch (error) {
        console.error("Erro ao consultar a API de esporte do dia:", error);
        return reply("⚠️ Ocorreu um erro ao buscar o esporte do dia. Tente novamente mais tarde.");
    }
break;
// WALLPAPERS E ICONS ICONES


case 'aesthetic':
case 'Aesthetic': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/aesthetic"}});
}
break;
case 'gatos':
case 'gato': {
  reply(`Enviando um gatinho fofo pra você, ${pushname}!`);
  
  blackmd.sendMessage(sender, { image: { url: "https://world-ecletix.onrender.com/api/gato" }, caption: "Miau!" });
}
break;

case 'cachorros':
case 'cachorro': {
  reply(`Enviando um doguinho pra você, ${pushname}!`);
  
  blackmd.sendMessage(sender, { image: { url: "https://world-ecletix.onrender.com/api/cachorro" }, caption: "Au au!" });
}
break;
case 'cosplay':
case 'Cosplay': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/cosplay"}});
}
break; 

case 'cosplayloli':
case 'Cosplayloli': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/cosplayloli"}});
}
break;

case 'cosplaysagiri':
case 'Cosplaysagiri': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/cosplaysagiri"}});
}
break;

case 'fotodev':
case 'Fotodev': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/fotodev"}});
}
break;

case 'gameWallp':
case 'GameWallp': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/gameWallp"}});
}
break;

case 'wallpaper_aleatorio':
case 'wall_ale': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/imagens"}});
}
break;

case 'meme':
case 'Meme': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/meme"}});
}
break;

case 'pokemon':
case 'Pokemon': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/pokemon"}});
}
break;

case 'satanic':
case 'Satanic': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/satanic"}});
}
break;

case 'nime':
case 'Nime': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/Nime"}});
}
break;
case 'wallhp2':
case 'Wallhp2': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/wallhp2"}});
}
break;
case 'Montanhas':
case 'montanhas': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/mountain"}});
}
break;

case 'Motos':
case 'motos': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/montor"}});
}
break;

case 'carros':
case 'Carros': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/mobil"}});
}
break;

case 'hakcers':
case 'Hackers': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/hekel"}});
}
break;

case 'Programador':
case 'programador': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/programing"}});
}
break;
case 'pets':
case 'pets': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/anjing"}});
}
break;
case 'Cats':
case 'cats': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/kucing"}});
}
break;
case 'cartun':
case 'Cartun': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/kartun"}});
}
break;
// icone feminino / icon 

case 'elaina':
case 'Elaina': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/elaina  "}});
}
break;  

case 'emilia':
case 'Emilia': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/emilia"}});
}
break;

case 'hinata':
case 'Hinata': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/hinata"}});
}
break;

case 'iconfeminino':
case 'icon_feminino': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/femininotrava"}});
}
break;

case 'erza':
case 'Erza': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/erza"}});
}
break;

case 'mikasa':
case 'Miksasa': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/mikasa"}});
}
break;

case 'rose':
case 'Rose': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/rose"}});
}
break;

case 'Rize':
case 'rize': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/rize"}});
}
break;
case 'nezuko':
case 'Nezuko': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/nezuko"}});
}
break;
case 'sakura':
case 'Sakura': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/sakura"}});
}
break;
case 'sagiri':
case 'Sagiri': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/sagiri"}});
}
break;
case 'tsunade':
case 'Tsunade': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/tsunade"}});
}
break;
case 'waifu':
case 'Waifu': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/waifu"}});
}
break;
case 'waifu2':
case 'Waifu2': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/Waifu2"}});
}
break;
case 'akiyama':
case 'Akiyama': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/akiyama"}});
}
break;

case 'anaicon':
case 'Anaicon': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/ana"}});
}
break;
case 'asuna':
case 'Asuna': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/asuna"}});
}
break;
case 'ayuzawa':
case 'Ayuzawa': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/ayuzawa"}});
}
break;
case 'chitoge':
case 'Chitoge': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/chitoge"}});
}
break;
case 'ebaicon':
case 'Ebaicon': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/eba"}});
}
break;
case 'itori':
case 'itori': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/itori"}});
}
break;
case 'gremory':
case 'Gremory': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/gremory"}});
}
break;
case 'hestia':
case 'Hestia': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/hestia"}});
}
break;
case 'Isuzu':
case 'isuzu': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/isuzu"}});
}
break;
case 'jiso':
case 'Jiso': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/jiso"}});
}
break;
case 'lisakpop':
case 'LisaKpop': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/lisa"}});
}
break;
case 'jeni':
case 'Jeni': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/jeni"}});
}
break;
case 'justina':
case 'Justina': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/justina "}});
}
break;
case 'ryujin':
case 'ryujin': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/ryujin"}});
}
break;
case 'Kpop':
case 'kpop': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/kpop"}});
}
break;
case 'Kotori':
case 'kotori': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/kotori"}});
}
break;
case 'Kaori':
case 'kaori': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/kaori"}});
}
break;  
case 'Kagura':
case 'kagura': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/aesthetic"}});
}
break;
case 'Miku':
case 'miku': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/miku"}});
}
break;
case 'Kurumi':
case 'kurumi': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/kurumi"}});
}
break;
case 'Megumin':
case 'megumin': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/megumin"}});
}
break;
case 'Nekonime':
case 'nekonime': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/nekonime"}});
}
break;
case 'pentol':
case 'Pentol': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/pentol"}});
}
break;
case 'Profil':
case 'profil': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/aesthetic"}});
}
break;

case 'toukachan':
case 'Toukachan': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/toukachan"}});
}
break;

case 'Shinomiya':
case 'shinomiya': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/shinomiya"}});
}
break;
case 'Shinka':
case 'shinka': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/shinka"}});
}
break;
case 'shina':
case 'Shina': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/shina"}});
}
break;
case 'Japinhas':
case 'japinhas': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/yulibocil"}});
}
break;
case 'Tejina':
case 'tejina': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/tejina"}});
}
break;
case 'Tatasurya':
case 'tatasurya': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/tatasurya"}});
}
break;
case 'Shizuka':
case 'shizuka': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/aesthetic"}});
}
break;
case 'Yotsuba':
case 'yotsuba': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/yotsuba"}});
}
break;

// icones masculino // icon masculino
case 'Akira':
case 'akira': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/akira"}});
}
break;
case 'Boruto':
case 'boruto': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/boruto"}});
}
break;
case 'chucky':
case 'Chucky': { 
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/bonek"}});
}
break;
case 'deidara':
case 'deidara': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/deidara"}});
}
break;
case 'Itachi':
case 'itachi': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/aesthetic"}});
}
break;

case 'kakashi':
case 'kakashi': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/minato"}});
}
break;
case 'Naruto':
case 'naruto': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/narutoicon"}});
}
break;
case 'minato':
case 'minato': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/minato"}});
}
break;
case 'sasuke':
case 'sasuke': {
  reply(`Estou enviando ${pushname}.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/sasuke"}});
}
break;

// EDITS / VIDEOS WALLPAPER 

case 'lomotifs':
case 'lomotif': {
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/editsfeminina"}});
}
break;

case 'futedits':
case 'futeboledits': {
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/futeboledits"}});
}
break;

case 'walnimes':
case 'animedits': {
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/walnimes"}});
}
break;

case 'sololeveling':
case 'soloedits': {
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/soloedits"}});
}
break;

case 'Dragonball':
case 'dragonball': {
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/dragonball"}});
}
break;
case 'Narutoedits':
case 'narutoedits': {
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/narutomp4"}});
}
break;

case 'Kimetsu':
case 'kimetsu': {
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/kimetsu"}});
}
break;

case 'Jujutsu':
case 'jujutsu': {
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/editsfeminina"}});
}
break;

case 'Bleach':
case 'bleach': {
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/bleach"}});
}
break;

case 'chainsaw':
case 'chainsaw': {
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/chainsaw"}});
}
break;

case 'hunterx':
case 'hunterx': {
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/hunterx"}});
}
break;

case 'Editaleatoria':
case 'editaleatoria': {
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {video: {url: "https://world-ecletix.onrender.com/api/aleatorios"}});
}
break;

// FUNÇÕES RPG

case 'espada':
case 'comprarespada': {
    if (!isBlackCity) return reply(enviar.rpg.ativar)
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)

    let data = filesDBuserBC(sender)
    const precoEspada = 7000

    if (data.saldo < precoEspada) {
        return reply(`*${pushname} VC NÃO TEM DINHEIRO SUFICIENTE PARA COMPRAR UMA ESPADA*\n\n*PREÇO: R$ ${precoEspada.toFixed(2)}*`)
    }

    if (!q.trim()) {
        return reply(`Cadê o espaço mano?\nExemplo: ${prefix + command} comprar`)
    }

    espada.push(sender)
    fs.writeFileSync('./funcoes_rpg/espada/espada.json', JSON.stringify(espada))

    // Desconta o valor da espada do saldo
    let novoSaldo = data.saldo - precoEspada
    saveCityBlackRPG(sender, novoSaldo, data.banco)

    reply(`*ESPADA COMPRADA COM SUCESSO*\n\n*CUSTO 💰: R$ ${precoEspada.toFixed(2)}*`)
}
break


case 'animal':
  if (!q) {
    reply(`Desculpe, parece que você não forneceu o nome do animal. Você pode usar como exemplo: *${prefixo + comando} gato*`);
     } else {
    const animais = [{ "nome": "Cão", "especie": "Canis lupus familiaris", "habitat": "Doméstico", "dieta": "Carnívoro" }, { "nome": "Gato", "especie": "Felis catus", "habitat": "Doméstico e selvagem", "dieta": "Carnívoro" }, { "nome": "Cavalo", "especie": "Equus ferus caballus", "habitat": "Doméstico e selvagem", "dieta": "Herbívoro" },
  {
    "nome": "Lobo",
    "especie": "Canis lupus",
    "habitat": "Florestas, tundras, montanhas e campos abertos",
    "dieta": "Carnívoro"
  },
  {
    "nome": "Águia",
    "especie": "Aquila chrysaetos",
    "habitat": "Florestas, montanhas e áreas costeiras",
    "dieta": "Carnívoro"
  },
  {
    "nome": "Macaco",
    "especie": "Macaca fascicularis",
    "habitat": "Florestas tropicais e subtropicais",
    "dieta": "Onívoro"
  },
  {
    "nome": "Canarinho",
    "especie": "Serinus canaria",
    "habitat": "Ilhas Canárias e Madeira",
    "dieta": "Granívoro"
  },
  {
    "nome": "Tubarão",
    "especie": "Carcharodon carcharias",
    "habitat": "Oceanos tropicais e subtropicais",
    "dieta": "Carnívoro"
  },
  {
    "nome": "Formiga",
    "especie": "Formicidae",
    "habitat": "Todos os continentes, exceto a Antártida",
    "dieta": "Onívoro"
  },
  {
  "nome": "Tartaruga",
  "especie": "Testudines",
  "habitat": "Aquático e terrestre",
  "dieta": "Onívoro"
},
{
  "nome": "Corvo",
  "especie": "Corvus corax",
  "habitat": "Florestas, campos e cidades",
  "dieta": "Carnívoro"
},
{
  "nome": "Girafa",
  "especie": "Giraffa camelopardalis",
  "habitat": "África",
  "dieta": "Herbívoro"
},
{
  "nome": "Elefante",
  "especie": "Elephas maximus",
  "habitat": "Ásia e África",
  "dieta": "Herbívoro"
},
{
  "nome": "Golfinho",
  "especie": "Delphinus delphis",
  "habitat": "Oceanos e mares",
  "dieta": "Carnívoro"
},
    {
      "nome": "Leão",
      "especie": "Panthera leo",
      "habitat": "África subsaariana",
      "dieta": "Carnívoro"
    },
    {
      "nome": "Tigre",
      "especie": "Panthera tigris",
      "habitat": "Ásia",
      "dieta": "Carnívoro"
    },
    {
      "nome": "Gorila",
      "especie": "Gorilla gorilla",
      "habitat": "África Central e Ocidental",
      "dieta": "Herbívoro"
    },
    {
      "nome": "Papagaio",
      "especie": "Psittaciformes",
      "habitat": "América do Sul, América Central, África e Oceania",
      "dieta": "Onívoro"
    },
    {
      "nome": "Coelho",
      "especie": "Oryctolagus cuniculus",
      "habitat": "Europa, África e Austrália",
      "dieta": "Herbívoro"
    },
      { "nome": "Vaca", "especie": "Bos taurus", "habitat": "Doméstico", "dieta": "Herbívoro" }, { "nome": "Porco", "especie": "Sus scrofa domestica", "habitat": "Doméstico", "dieta": "Onívoro" }, { "nome": "Galinha", "especie": "Gallus gallus domesticus", "habitat": "Doméstico", "dieta": "Onívoro" }, { "nome": "Pato", "especie": "Anas platyrhynchos domesticus", "habitat": "Doméstico e selvagem", "dieta": "Onívoro" }, { "nome": "Ganso", "especie": "Anser anser domesticus", "habitat": "Doméstico e selvagem", "dieta": "Herbívoro" }, { "nome": "Peru", "especie": "Meleagris gallopavo", "habitat": "Doméstico", "dieta": "Onívoro" }, { "nome": "Coelho", "especie": "Oryctolagus cuniculus", "habitat": "Doméstico e selvagem", "dieta": "Herbívoro" }];
    const animal = animais.find(a => a.nome.toLowerCase() === q.toLowerCase());
       if (animal) {
       reply(`*• Nome:* ${animal.nome}\n*• Espécie:* ${animal.especie}\n*• Habitat:* ${animal.habitat}\n*• Dieta:* ${animal.dieta}`);
       } else {
       reply("Animal não encontrado.")}}
       break;
case 'gerarcpff': {
    if (!isBlackCity) return reply(enviar.rpg.ativar)
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)

    let data = filesDBuserBC(sender)
    const precoCpf = 4000

    if (data.saldo < precoCpf) {
        return reply(`*${pushname} VC NÃO TEM DINHEIRO SUFICIENTE PARA COMPRAR*\n\n*PREÇO: R$ ${precoCpf.toFixed(2)}*`)
    }

    let cp1 = `${Math.floor(Math.random() * 300) + 600}`
    let cp2 = `${Math.floor(Math.random() * 300) + 600}`
    let cp3 = `${Math.floor(Math.random() * 300) + 600}`
    let cp4 = `${Math.floor(Math.random() * 30) + 60}`
    let cpf = `${cp1}.${cp2}.${cp3}-${cp4}`

    await blackmd.sendMessage(from, {text: `CPF gerado com sucesso: ${cpf}`}, {quoted: info})

    let novoSaldo = data.saldo - precoCpf
    saveCityBlackRPG(sender, novoSaldo, data.banco)
}
break
case 'tagrico': {
    if (!isBlackCity) return reply(enviar.rpg.ativar)
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)

    let data = filesDBuserBC(sender)
    const precoTagrico = 6000

    if (data.saldo < precoTagrico) {
        return reply(`*${pushname} VC NÃO TEM DINHEIRO SUFICIENTE PARA COMPRAR A TAG DE RICO*\n\n*PREÇO: R$ ${precoTagrico.toFixed(2)}*`)
    }

    if (!q.trim()) {
        return reply(`Cadê o espaço mano?\nExemplo: ${prefix + command} comprar`)
    }

    tagrico.push(sender)
    fs.writeFileSync('./funcoes_rpg/tagrico/tagrico.json', JSON.stringify(tagrico))

    let novoSaldo = data.saldo - precoTagrico
    saveCityBlackRPG(sender, novoSaldo, data.banco)

    reply(`*TAG DE RICO COMPRADA COM SUCESSO* 💰💲💵\n\n*CUSTO 💰: R$ ${precoTagrico.toFixed(2)}*`)
}
break
case 'capacete': {
    if (!isBlackCity) return reply(enviar.rpg.ativar)
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)

    let data = filesDBuserBC(sender)
    const preco = 30000

    if (data.saldo < preco) {
        return reply(`*${pushname} VC NÃO TEM DINHEIRO SUFICIENTE PARA COMPRAR O CAPACETE DE TRABALHO*\n\n*PREÇO: R$ ${preco.toFixed(2)}*`)
    }

    if (!q.trim()) return reply(`Cadê o espaço mano?\nExemplo: ${prefix + command} comprar`)

    carab.push(sender)
    fs.writeFileSync('./funcoes_rpg/carab/carab.json', JSON.stringify(carab))

    let novoSaldo = data.saldo - preco
    saveCityBlackRPG(sender, novoSaldo, data.banco)

    reply(`*CAPACETE COMPRADO COM SUCESSO*\n\n*CUSTO 💰: R$ ${preco.toFixed(2)}*`)
}
break
case 'calca': case 'calça':{
    if (!isBlackCity) return reply(enviar.rpg.ativar)
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)

    let data = filesDBuserBC(sender)
    const preco = 3000

    if (data.saldo < preco) {
        return reply(`*${pushname} VC NÃO TEM DINHEIRO SUFICIENTE PARA COMPRAR A CALÇA DE TRABALHO*\n\n*PREÇO: R$ ${preco.toFixed(2)}*`)
    }

    if (!q.trim()) return reply(`Cadê o espaço mano?\nExemplo: ${prefix + command} comprar`)

    caussa.push(sender)
    fs.writeFileSync('./funcoes_rpg/caussa/caussa.json', JSON.stringify(caussa))

    let novoSaldo = data.saldo - preco
    saveCityBlackRPG(sender, novoSaldo, data.banco)

    reply(`*CALÇA COMPRADA COM SUCESSO*\n\n*CUSTO 💰: R$ ${preco.toFixed(2)}*`)
}
break
case 'sapato':
case 'sapatos': {
    if (!isBlackCity) return reply(enviar.rpg.ativar)
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)

    let data = filesDBuserBC(sender)
    const preco = 3000

    if (data.saldo < preco) {
        return reply(`*${pushname} VC NÃO TEM DINHEIRO SUFICIENTE PARA COMPRAR OS SAPATOS DE TRABALHO*\n\n*PREÇO: R$ ${preco.toFixed(2)}*`)
    }

    if (!q.trim()) return reply(`Cadê o espaço mano?\nExemplo: ${prefix + command} comprar`)

    sapato.push(sender)
    fs.writeFileSync('./funcoes_rpg/sapato/sapato.json', JSON.stringify(sapato))

    let novoSaldo = data.saldo - preco
    saveCityBlackRPG(sender, novoSaldo, data.banco)

    reply(`*SAPATO COMPRADO COM SUCESSO*\n\n*CUSTO 💰: R$ ${preco.toFixed(2)}*`)
}
break
case 'palitor': {
    if (!isBlackCity) return reply(enviar.rpg.ativar)
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)

    let data = filesDBuserBC(sender)
    const preco = 3000

    if (data.saldo < preco) {
        return reply(`*${pushname} VC NÃO TEM DINHEIRO SUFICIENTE PARA COMPRAR O PALITOR DE TRABALHO*\n\n*PREÇO: R$ ${preco.toFixed(2)}*`)
    }

    if (!q.trim()) return reply(`Cadê o espaço mano?\nExemplo: ${prefix + command} comprar`)

    palitor.push(sender)
    fs.writeFileSync('./funcoes_rpg/palitor/palitor.json', JSON.stringify(palitor))

    let novoSaldo = data.saldo - preco
    saveCityBlackRPG(sender, novoSaldo, data.banco)

    reply(`*PALITOR COMPRADO COM SUCESSO*\n\n*CUSTO 💰: R$ ${preco.toFixed(2)}*`)
}
break

case 'hero':
case 'lot': {
    try {
        let ppimg
        try {
            ppimg = await zenitsu.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image')
        } catch {
            ppimg = 'https://telegra.ph/file/b5427ea4b8701bc47e751.jpg'
        }

        const captionInventario = `
┏━──────「🕴️」──────━┓
│          *SEU INVENTÁRIO*
│
│ *${isCarab ? "⛑️" : "❌"} : CAPACETE*
│ *${isRoupab ? "👔" : "❌"} : PALITOR*
│ *${iscasa ? "🏡" : "❌"} : CASA*
│ *${isCaussa ? "👖" : "❌"} : CALÇA*
│ *${isaguacoco ? "💧" : "❌"} : ÁGUA DE COCO*
│ *${isSapato ? "👞" : "❌"} : SAPATO*
│ *${isespada ? "⚔️" : "❌"} : ESPADA*
│
╠━━━━━━━━━━━━━━━━━━━━━━━
│             *TAGS*
╠━━━━━━━━━━━━━━━━━━━━━━━
│
│> RICO: ${istagrico ? "SIM ✅" : "NÃO ❌"}
│
┗━──────「🕴️」──────━┛
        `.trim()

        await blackmd.sendMessage(from, {
            video: { url: 'https://telegra.ph/file/b1febb2db7a727eee9d7d.mp4' },
            gifPlayback: true,
            caption: captionInventario
        }, { quoted: info })

    } catch (e) {
        console.error(e)
    }
}
break
case 'tomaraguacoco': {
    if (!aguacoco.includes(sender)) return reply(`VOCÊ NÃO TEM ÁGUA DE COCO INFINITA. USE ${prefix}aguacoco para comprar!`)
    
    const aguadd = Math.floor(Math.random() * 76) + 15 // entre 15% e 90%
    reply(`VOCÊ TOMOU UMA ÁGUA DE COCO\n\nMATOU [ ${aguadd}% ] DA SUA SEDE!`)
}
break

case 'aguacoco': {
    const dinheiro = checkATMuser(sender)
    if (dinheiro < 30000) return reply(`*${pushname} VOCÊ NÃO TEM DINHEIRO SUFICIENTE PARA COMPRAR ÁGUA DE COCO INFINITA*\n\n*PREÇO: 30000*`)
    
    if (!q.includes(' ')) return reply(`Cadê o espaço mano?\nExemplo: ${prefix + command} comprar`)  

    aguacoco.push(sender)
    fs.writeFileSync('./funcoes_rpg/agua/aguacoco.json', JSON.stringify(aguacoco))
    addKoinUser(sender, -30000)
    reply(`*ÁGUA DE COCO COMPRADA COM SUCESSO* 🥥\n\n*CUSTO 💰: 30000*`)
}
break

case 'pescar': {
    const lagostas = Math.floor(Math.random() * 105)
    const caranguejos = Math.floor(Math.random() * 105)
    const mexilhao = Math.floor(Math.random() * 105)
    const peixe = Math.floor(Math.random() * 105)

    const totalPescado = lagostas + caranguejos + mexilhao + peixe
    const pescando = totalPescado * 15 // Cada "animal" vale 15R$

    blackmd.sendMessage(from, {
        image: fs.readFileSync('./funcoes_rpg/image/pescar.jpg'),
        caption: `
┏━── *「 🎣️ P E S C A 🎣️ 」* ─━┓
│▢ Lagostas: ${lagostas}
│▢ Caranguejos: ${caranguejos}
│▢ Peixes: ${peixe}
│▢ Mexilhões: ${mexilhao}
┗━── *「 🎣️ P E S C A 🎣️ 」* ─━┛

E GANHOU ${pescando}R$ 😉 🎣
        `.trim()
    }, { quoted: info })

    addKoinUser(sender, pescando)
}
break

break

	case 'churrasco': {
	// Verificar se o arquivo JSON existe, e criar se não existir
		if (!fs.existsSync('prenderCooldown.json')) {
			fs.writeFileSync('prenderCooldown.json', JSON.stringify({}));
		}
	
		// Carregar o objeto prenderCooldown do arquivo JSON
		const prenderCooldown = JSON.parse(fs.readFileSync('prenderCooldown.json', 'utf8'));
	
		const currentTimeprender = Date.now();
		const lastprenderTime = prenderCooldown[sender] || 0;
		const timeSinceLastprender = currentTimeprender - lastprenderTime;
		const prenderCooldownTime = 5 * 60 * 1000; // 5 minutos em milissegundos
	
		if (timeSinceLastprender < prenderCooldownTime) {
			const remainingTime = (prenderCooldownTime - timeSinceLastprender) / 1000;
			return reply(`Aguarde ${remainingTime.toFixed(0)} segundos vc estar preso`);
		}
		// Verificar se o arquivo JSON existe, e criar se não existir
		if (!fs.existsSync('./funcoes_rpg/rpg/churrascoCooldown.json')) {
			fs.writeFileSync('./funcoes_rpg/rpg/churrascoCooldown.json', JSON.stringify({}));
		}
	
		// Carregar o objeto churrascoCooldown do arquivo JSON
		const churrascoCooldown = JSON.parse(fs.readFileSync('./funcoes_rpg/rpg/churrascoCooldown.json', 'utf8'));
	
		const currentTimeChurrasco = Date.now();
		const lastChurrascoTime = churrascoCooldown[sender] || 0;
		const timeSinceLastChurrasco = currentTimeChurrasco - lastChurrascoTime;
		const churrascoCooldownTime = 5 * 60 * 1000; // 5 minutos em milissegundos
	
		if (timeSinceLastChurrasco < churrascoCooldownTime) {
			const remainingTime = (churrascoCooldownTime - timeSinceLastChurrasco) / 1000;
			return reply(`Aguarde ${remainingTime.toFixed(0)} segundos antes de fazer outro churrasco.`);
		}
	
		reply(`*OLÁ [ ${pushname} ] AGUARDE 5 SEGUNDOS*`)
		await sleep (5000);
		contrafile = Math.floor((Math.random() * 150) + 50);
		assinhadefrango = Math.floor((Math.random() * 150) + 30);
		filebigno = Math.floor((Math.random() * 150) + 40);
		pikanha = Math.floor((Math.random() * 150) + 50);
		var resultado1 = contrafile + assinhadefrango + filebigno + pikanha;
	
		addFilter(from);
	
		try {
			picc = await zenitsu.profilePictureUrl(m.chat, "image");
		} catch(e) {
			picc = 'https://telegra.ph/file/2bf2e198407f9b8bfbcd0.jpg';
		}
	
		ds = await getBuffer(picc);
	
		let thumbInfo = `
	*┏ *「️🍖 𝐂 𝐇 𝐔 𝐑 𝐑 𝐀 𝐒 𝐂 𝐎 🍖」  ┓*
	*│▢ Carne - Picanha Argentina: ${contrafile}*
	*│▢ Carne - Contra Filé: ${assinhadefrango}*
	*│▢ Carne - Asinhas de Frango: ${filebigno}*
	*│▢ Carne - Filé Mignon: ${pikanha}*
	*┗ 「️🍖 𝐂 𝐇 𝐔 𝐑 𝐑 𝐀 𝐒 𝐂 𝐎 🍖」  ┛*
	[㕚] *Foram vendidas hoje por você em nosso açougue: ${resultado1} peças de carne por você. Parabéns!*
	[㕚] *Isso significa que foi adicionado em sua carteira R$${resultado1},00 em coins!*
	`;
	
		blackmd.sendMessage(from,  {image: ds, caption: `${thumbInfo}`}, {quoted: info});
		addKoinUser(sender, +resultado1);
	
		// Atualizar o tempo do último churrasco no arquivo JSON
		churrascoCooldown[sender] = currentTimeChurrasco;
		fs.writeFileSync('./funcoes_rpg/rpg/churrascoCooldown.json', JSON.stringify(churrascoCooldown));
	
		break;
	}

case 'casa': {
    if (!isBlackCity) return reply(enviar.rpg.ativar);
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar);

    data = filesDBuserBC(sender);
    const quantidader = 300000;

    if (data.saldo < quantidader) return reply(`*${pushname} VC NAO TEM DINHEIRO SUFICIENTE PARA COMPRAR CASA*\n\n*PREÇO: R$ ${quantidader.toLocaleString('pt-BR')}*`);

    var [comprar] = q.split("");
    if (!q.includes("")) return reply(`Cade o espaço mano?\nExemplo: ${prefix + command} comprar`);

    casa.push(`${sender}`);
    fs.writeFileSync('./funcoes_rpg/casa/casa.json', JSON.stringify(casa));
    addKoinUser(sender, -quantidader);

    reply(`*CASA COMPRADA COM SUCESSO* 😃\n\n*CUSTO 💰: R$ ${quantidader.toLocaleString('pt-BR')}*`);
}
break;
case 'alugarcasa': {
    if (!isBlackCity) return reply(enviar.rpg.ativar);
    if (!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar);

    if (!JSON.stringify(casa).includes(sender)) {
        return reply(`*VOCÊ NÃO TEM UMA CASA!*\nUse: ${prefix}casa`);
    }

    casaluge = Math.floor((Math.random() * 10) * 30);
    casapronta = Math.floor((Math.random() * 10) * 500);

    addKoinUser(sender, +casapronta);

    reply(`*VOCÊ ALUGOU A CASA POR ${casaluge} DIAS*\n\n*GANHOU R$ ${casapronta.toLocaleString('pt-BR')}*`);
}
break;

case 'trabalhar': {
    // Calcular a quantidade aleatória de dinheiro obtido pelo trabalho
    const minerag = Math.floor((Math.random() * 10) * 150);

    // Enviar imagem e mensagem sobre o trabalho
    blackmd.sendMessage(from, {
        image: fs.readFileSync('./funcoes_rpg/image/trabalhar.jpg'),
        caption: `*VC TRABALHOU E GANHOU ${minerag}*`
    }, { quoted: info });

    // Adicionar o valor ao saldo do usuário
    addKoinUser(sender, minerag);

    break;
}

case 'trabalhar': {
    let ganhoTrabalho = Math.floor(Math.random() * 10) * 150;
    blackmd.sendMessage(from, { 
        image: fs.readFileSync('./funcoes_rpg/image/trabalhar.jpg'),
        caption: `*VOCÊ TRABALHOU E GANHOU R$ ${ganhoTrabalho.toLocaleString('pt-BR')}*`
    }, { quoted: info });

    addKoinUser(sender, +ganhoTrabalho);
}
break;
case 'minerar': {
    if (!fs.existsSync('./funcoes_rpg/rpg/pescarCooldown.json')) {
        fs.writeFileSync('./funcoes_rpg/rpg/pescarCooldown.json', JSON.stringify({}));
    }

    const pescarCooldown = JSON.parse(fs.readFileSync('./funcoes_rpg/rpg/pescarCooldown.json', 'utf8'));
    const currentTimePescar = Date.now();
    const lastPescarTime = pescarCooldown[sender] || 0;
    const timeSinceLastPescar = currentTimePescar - lastPescarTime;
    const pescarCooldownTime = 5 * 60 * 1000; // 5 minutos

    if (timeSinceLastPescar < pescarCooldownTime) {
        const remainingTime = (pescarCooldownTime - timeSinceLastPescar) / 1000;
        return reply(`Aguarde ${remainingTime.toFixed(0)} segundos antes de minerar novamente.`);
    }

    reply(`*OLÁ ${pushname}, AGUARDE 5 SEGUNDOS PARA CONCLUÍR A MINERAÇÃO*`);
    pescarCooldown[sender] = currentTimePescar;
    fs.writeFileSync('./funcoes_rpg/rpg/pescarCooldown.json', JSON.stringify(pescarCooldown));
    await sleep(5000);

    let pedras = Math.floor(Math.random() * 150) + 40;
    let diamantes = Math.floor(Math.random() * 150) + 30;
    let ouros = Math.floor(Math.random() * 150) + 40;
    let ferro = Math.floor(Math.random() * 150) + 50;
    let totalGanho = pedras + diamantes + ouros + ferro;

    try {
        picc = await loli.profilePictureUrl(m.chat, "image");
    } catch (e) {
        picc = 'https://telegra.ph/file/9651f2a3a24c15ef71dd1.mp4';
    }

    let thumbInfo = `
*┏━── *「️ 🔰  MINE  🔰 」* ─━┓*
│▢ Pedras: ${pedras}
│▢ Diamantes: ${diamantes}
│▢ Ouros: ${ouros}
│▢ Ferro: ${ferro}
│▢ *Total: R$ ${totalGanho.toLocaleString('pt-BR')}*
*┗━── *「️ 🔰  MINE  🔰 」* ─━┛*
[㕚] *Valor adicionado na carteira!*
    `;

    blackmd.sendMessage(from, { image: await getBuffer(picc), caption: thumbInfo }, { quoted: info });
    addKoinUser(sender, +totalGanho);
}
break;
case 'money': {
    blackmd.sendMessage(from, { react: { text: `💵`, key: info.key }});
    blackmd.sendMessage(from, {
        video: { url: `https://telegra.ph/file/7d1a76c9d628836f27e8d.mp4` },
        gifPlayback: true,
        caption: `
╭━➪ _MONEY_
│◦➛ Nome : ${pushname}
│◦➛ Número : ${sender.split("@")[0]}
│◦➛ Dinheiro : R$ ${Number(checkATMuser(sender)).toLocaleString('pt-BR')}
╰━━━━━━━━
        `.trim()
    }, { quoted: info });
}
break;
case 'fuguete': {
    if (!isGroup) return reply('Comando apenas para grupo!');
    
    const aposta = Number(args[0]);
    if (!args[0]) return reply(`Qual o valor que você deseja apostar?`);
    if (isNaN(aposta)) return reply(`Digite "${prefix}fuguete 100" (sem vírgulas ou letras).`);
    if (aposta < 1) return reply(`Aposta mínima é 1 real.`);

    const saldo = checkATMuser(sender);
    if (saldo < aposta) return reply(`Você não tem saldo suficiente para apostar R$${aposta}. Seu saldo: R$${saldo}.`);

    const resultado = Math.floor(Math.random() * 6) + 1; // 1 até 6
    const ganhoMultiplicador = Math.floor(Math.random() * 7) + 1;
    const perdaMultiplicador = Math.floor(Math.random() * 7) + 1;
    const premio = aposta + (ganhoMultiplicador * 10); // Ganho pequeno a mais

    if ([1,3,5].includes(resultado)) { // Perder
        confirmATM(sender, aposta); // Remove a aposta
        blackmd.sendMessage(from, {
            video: { url: `https://telegra.ph/file/02aee2582cf5c3485b239.mp4` },
            gifPlayback: true,
            caption: `
*Você perdeu 00.${perdaMultiplicador}.X!*

*Dinheiro perdido:* *R$${aposta}*`
        }, { quoted: info });
    } else { // Ganhar
        addKoinUser(sender, premio); // Adiciona o prêmio
        blackmd.sendMessage(from, {
            video: { url: `https://telegra.ph/file/f2aa6670076884015f862.mp4` },
            gifPlayback: true,
            caption: `
*Você ganhou 00.${ganhoMultiplicador}.X!*

*Dinheiro ganho:* *R$${premio}*`
        }, { quoted: info });
    }
    break;
}

// DOWNLOADS

//comando de botão para usuários de baleia Mods, vulgo Baileys
//Já com a Key do Channel com +3 k de request




case 'play3':
case 'Playvid2':
case 'playvideo2':
case 'playvid2':
case 'clipe2': {
    try {
        if (!q.trim()) {
            return reply(`- Exemplo: ${prefix}playvideo nome da música\nA música será baixada, só basta escolher áudio ou vídeo. Se não baixar, pode ser devido a restrições do YouTube.`);
        }

        console.log(`[INFO] Pesquisando vídeo: ${q}`);
        const data = await fetchJson(`https://world-ecletix.onrender.com/api/pesquisayt?query=${q}`);

        if (!data || !data.formattedVideos || data.formattedVideos.length === 0) {
            console.log("[ERRO] Nenhum resultado encontrado.");
            return reply("Desculpe, não consegui encontrar o vídeo.");
        }

        const firstResult = data.formattedVideos[0];
        console.log("[INFO] Vídeo encontrado:", firstResult);

        var N_E = "Não encontrado.";
        var bla = `
๖ۣ• Título: ${firstResult.title || N_E}
๖ۣ• Tempo: ${firstResult.duration || N_E}
๖ۣ• Canal: ${firstResult.channel || N_E}
๖ۣ• Visualizações: ${firstResult.views || N_E}
\n■■■■■ 100% \n\nEscolha uma opção...\n\nSe desejar baixar o áudio, use ${prefix}play ${firstResult.link.trim()}`;

        await blackmd.sendMessage(from, { image: { url: firstResult.thumbnail || logoslink?.logo }, caption: bla }, { quoted: info });

        console.log("[INFO] Enviando vídeo...");
        await blackmd.sendMessage(from, {
            video: { url: `https://world-ecletix.onrender.com/api/clipe?name=${encodeURIComponent(firstResult.title)}` },
            mimetype: "video/mp4",
            fileName: firstResult.title || "play.mp4"
        }, { quoted: info });

        console.log("[SUCESSO] Vídeo enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao processar solicitação:", e);
        return reply("Não foi possível baixar ou encontrar esse vídeo 🐞");
    }
}
break;

case 'play_audio':
case 'play2':
case 'Play2':
case 'PLAY2':
case 'musica2':
case 'música2':
case 'music2': {
    try {
        if (!q.trim()) {
            return reply(`- Exemplo: ${prefix}play nome da música\nA música será baixada, só basta escolher áudio ou vídeo. Se não baixar, pode ser devido a restrições do YouTube.`);
        }

        console.log(`[INFO] Pesquisando música: ${q}`);
        const data = await fetchJson(`https://world-ecletix.onrender.com/api/pesquisayt?query=${q}`);

        if (!data || !data.formattedVideos || data.formattedVideos.length === 0) {
            console.log("[ERRO] Nenhum resultado encontrado.");
            return reply("Desculpe, não consegui encontrar a música.");
        }

        const firstResult = data.formattedVideos[0];
        console.log("[INFO] Música encontrada:", firstResult);

        var N_E = "Não encontrado.";
        var bla = `
๖ۣ• Título: ${firstResult.title || N_E}
๖ۣ• Tempo: ${firstResult.duration || N_E}
๖ۣ• Canal: ${firstResult.channel || N_E}
๖ۣ• Visualizações: ${firstResult.views || N_E}
\n■■■■■ 100% \n\nEscolha uma opção...\n\nSe desejar baixar o vídeo, use ${prefix}play_video ${firstResult.link.trim()}`;

        await blackmd.sendMessage(from, { image: { url: firstResult.thumbnail || logoslink?.logo }, caption: bla }, { quoted: info });

        console.log("[INFO] Enviando áudio...");
        await blackmd.sendMessage(from, {
            audio: {
                url: `https://world-ecletix.onrender.com/api/musica?name=${encodeURIComponent(firstResult.title)}`
            },
            mimetype: "audio/mpeg",
            fileName: firstResult.title || "play.mp3",
            ptt: true 
        }, { quoted: info });

        console.log("[SUCESSO] Áudio enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao processar solicitação:", e);
        return reply("Não foi possível baixar ou encontrar esse áudio 🐞");
    }
}
break;
case 'play4': {
    try {
        if (!q.trim()) {
            return reply(`- Exemplo: ${prefix}play2 nome da música\n\nA música será baixada automaticamente em áudio. Se não baixar, pode ser devido a restrições do YouTube.`);
        }

        console.log(`[INFO] Pesquisando música: ${q}`);
        const data = await fetchJson(`https://api.vreden.my.id/api/ytplaymp3?query=${encodeURIComponent(q)}`);

        if (!data || !data.result || data.result.status !== true) {
            console.log("[ERRO] Nenhum resultado encontrado.");
            return reply("Desculpe, não consegui encontrar a música.");
        }

        const metadata = data.result.metadata;
        const download = data.result.download;
        console.log("[INFO] Música encontrada:", metadata);

        var N_E = "Não encontrado.";
        var resposta = `
๖ۣ• Título: ${metadata.title || N_E}
๖ۣ• Tempo: ${metadata.duration?.timestamp || N_E}
๖ۣ• Canal: ${metadata.author?.name || N_E}
๖ۣ• Visualizações: ${metadata.views?.toLocaleString() || N_E}
๖ۣ• Publicado: ${metadata.ago || N_E}
\n■■■■■ 100% \n\nBaixando áudio para você...`;

        await blackmd.sendMessage(from, { image: { url: metadata.thumbnail || logoslink?.logo }, caption: resposta }, { quoted: info });

        console.log("[INFO] Enviando áudio...");
        await blackmd.sendMessage(from, {
            audio: {
                url: download.url
            },
            mimetype: "audio/mpeg",
            fileName: download.filename || "play.mp3",
            ptt: true 
        }, { quoted: info });

        console.log("[SUCESSO] Áudio enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao processar solicitação:", e);
        return reply("Não foi possível baixar ou encontrar esse áudio 🐞");
    }
}
break;
case 'play5':
case 'Play5':
case 'PLAY5':
case 'musica5':
case 'música5':
case 'music5': {
    try {
        if (!q.trim()) {
            return reply(`- Exemplo: ${prefix}play5 nome da música\n\nO vídeo será baixado automaticamente. Se não baixar, pode ser devido a restrições do YouTube.`);
        }

        console.log(`[INFO] Pesquisando vídeo: ${q}`);
        const data = await fetchJson(`https://api.vreden.my.id/api/ytplaymp4?query=${encodeURIComponent(q)}`);

        if (!data || !data.result || data.result.status !== true) {
            console.log("[ERRO] Nenhum resultado encontrado.");
            return reply("Desculpe, não consegui encontrar o vídeo.");
        }

        const metadata = data.result.metadata;
        const download = data.result.download;
        console.log("[INFO] Vídeo encontrado:", metadata);

        var N_E = "Não encontrado.";
        var resposta = `
๖ۣ• Título: ${metadata.title || N_E}
๖ۣ• Tempo: ${metadata.duration?.timestamp || N_E}
๖ۣ• Canal: ${metadata.author?.name || N_E}
๖ۣ• Visualizações: ${metadata.views?.toLocaleString() || N_E}
๖ۣ• Publicado: ${metadata.ago || N_E}
\n■■■■■ 100% \n\nBaixando vídeo para você...`;

        await blackmd.sendMessage(from, { image: { url: metadata.thumbnail || logoslink?.logo }, caption: resposta }, { quoted: info });

        console.log("[INFO] Enviando vídeo...");
        await blackmd.sendMessage(from, {
            video: {
                url: download.url
            },
            mimetype: "video/mp4",
            fileName: download.filename || "play.mp4",
            caption: metadata.title || "",
        }, { quoted: info });

        console.log("[SUCESSO] Vídeo enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao processar solicitação:", e);
        return reply("Não foi possível baixar ou encontrar esse vídeo 🐞");
    }
}
break;
case 'play6':
case 'Play6':
case 'PLAY6':
case 'musica6':
case 'música6':
case 'music6': {
    try {
        if (!q.trim()) {
            return reply(`- Exemplo: ${prefix}play6 link_do_youtube\n\nMande o link do YouTube para baixar o vídeo.`);
        }

        console.log(`[INFO] Buscando vídeo pelo link: ${q}`);
        const data = await fetchJson(`https://api.vreden.my.id/api/ytmp4?url=${encodeURIComponent(q)}`);

        if (!data || !data.result || data.result.status !== true) {
            console.log("[ERRO] Nenhum vídeo encontrado.");
            return reply("Desculpe, não consegui encontrar ou baixar este vídeo.");
        }

        const metadata = data.result.metadata;
        const download = data.result.download;
        console.log("[INFO] Vídeo encontrado:", metadata);

        var resposta = `
๖ۣ• Título: ${metadata.title || "Não encontrado"}
๖ۣ• Tempo: ${metadata.duration?.timestamp || "Não encontrado"}
๖ۣ• Canal: ${metadata.author?.name || "Não encontrado"}
๖ۣ• Visualizações: ${metadata.views?.toLocaleString() || "Não encontrado"}
๖ۣ• Publicado: ${metadata.ago || "Não encontrado"}
\n■■■■■ 100% \n\nBaixando vídeo para você...`;

        await blackmd.sendMessage(from, { image: { url: metadata.thumbnail || logoslink?.logo }, caption: resposta }, { quoted: info });

        console.log("[INFO] Enviando vídeo...");
        await blackmd.sendMessage(from, {
            video: { url: download.url },
            mimetype: "video/mp4",
            fileName: download.filename || "video.mp4",
            caption: metadata.title || "",
        }, { quoted: info });

        console.log("[SUCESSO] Vídeo enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao buscar vídeo:", e);
        return reply("Não foi possível baixar esse vídeo 🐞");
    }
}
break;

case 'play7':
case 'Play7':
case 'PLAY7':
case 'musica7':
case 'música7':
case 'music7': {
    try {
        if (!q.trim()) {
            return reply(`- Exemplo: ${prefix}play7 link_do_youtube\n\nMande o link do YouTube para baixar o áudio.`);
        }

        console.log(`[INFO] Buscando áudio pelo link: ${q}`);
        const data = await fetchJson(`https://api.vreden.my.id/api/ytmp3?url=${encodeURIComponent(q)}`);

        if (!data || !data.result || data.result.status !== true) {
            console.log("[ERRO] Nenhum áudio encontrado.");
            return reply("Desculpe, não consegui encontrar ou baixar este áudio.");
        }

        const metadata = data.result.metadata;
        const download = data.result.download;
        console.log("[INFO] Áudio encontrado:", metadata);

        var resposta = `
๖ۣ• Título: ${metadata.title || "Não encontrado"}
๖ۣ• Tempo: ${metadata.duration?.timestamp || "Não encontrado"}
๖ۣ• Canal: ${metadata.author?.name || "Não encontrado"}
๖ۣ• Visualizações: ${metadata.views?.toLocaleString() || "Não encontrado"}
๖ۣ• Publicado: ${metadata.ago || "Não encontrado"}
\n■■■■■ 100% \n\nBaixando áudio para você...`;

        await blackmd.sendMessage(from, { image: { url: metadata.thumbnail || logoslink?.logo }, caption: resposta }, { quoted: info });

        console.log("[INFO] Enviando áudio...");
        await blackmd.sendMessage(from, {
            audio: { url: download.url },
            mimetype: "audio/mpeg",
            fileName: download.filename || "audio.mp3",
            ptt: true
        }, { quoted: info });

        console.log("[SUCESSO] Áudio enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao buscar áudio:", e);
        return reply("Não foi possível baixar esse áudio 🐞");
    }
}
break;

case 'play': case 'Play': case 'PLAY': case 'musica': case 'música': case 'music': {
    try {
        if (!q.trim()) return reply(`- Exemplo: ${prefix}play nome da música`);
        
        // Enviar apenas o áudio usando a API diretamente
        blackmd.sendMessage(from, { 
            audio: { 
                url: `https://world-ecletix.onrender.com/api/musica?name=${encodeURIComponent(q)}` 
            }, 
            mimetype: "audio/mpeg",
            fileName: q || "play.mp3",
            ptt: true 
        }, { quoted: info }).catch(e => reply("Erro ao tentar baixar a música."));

    } catch (e) {
        console.log(e);
        return reply("Não foi possível baixar ou encontrar esse áudio.");
    }
}
break;
case 'Playvid': case 'playvideo': case 'playvid': case 'clipe': {
    try {
        if (!q.trim()) return reply(`- Exemplo: ${prefix}playvideo nome da música\na música será baixada, só basta escolher áudio ou vídeo, se não baixar, o YouTube privou de não baixarem, ou algo do tipo..`);
        
        // Nova API para download de vídeo
        blackmd.sendMessage(from, { video: { url: `https://world-ecletix.onrender.com/api/clipe?name=${encodeURIComponent(firstResult.title)}` }, mimetype: "video/mp4", fileName: firstResult.title || "play.mp4" }, { quoted: info }).catch(e => {
            return reply("Erro ao tentar baixar o vídeo.");
        });
    } catch (e) {
        console.log(e);
        return reply("não foi possível baixar ou encontrar esse video🐞");
    }
}
break;
case 'Playlink': 
case 'playlink': 
case 'ytbmp3': {
    try {
        if (!q.trim()) {
            console.log("[ERRO] Nenhum texto fornecido para pesquisa.");
            return reply(`- Exemplo: ${prefix}playlink nome da música\na música será baixada, só basta escolher áudio ou vídeo.`);
        }

        console.log(`[INFO] Pesquisando música: ${q}`);
        const data = await fetchJson(`https://world-ecletix.onrender.com/api/pesquisayt?query=${q}`);

        if (!data || !data.formattedVideos || data.formattedVideos.length === 0) {
            console.log("[ERRO] Nenhum resultado encontrado.");
            return reply("Desculpe, não consegui encontrar a música.");
        }

        const firstResult = data.formattedVideos[0];
        console.log("[INFO] Música encontrada:", firstResult);

        var N_E = " Não encontrado.";
        var bla = `
        ๖ۣ• Titulo: ${firstResult.title || N_E}
        ๖ۣ• Tempo: ${firstResult.duration || N_E}
        ๖ۣ• Canal: ${firstResult.channel || N_E}
        ๖ۣ• Visualizações: ${firstResult.views || N_E}

        ■■■■■ 100% 

        E᥉ᥴ᥆ᥣhᥲ ᥙ꧑ᥲ ᥆ρᥴᥲ᥆...

        Se desejar baixar o vídeo, use ${prefix}videolink ${firstResult.link.trim()}
        `;

        await blackmd.sendMessage(from, { 
            image: { url: firstResult.thumbnail || logoslink?.logo }, 
            caption: bla 
        }, { quoted: info });

        console.log("[INFO] Enviando áudio...");
        await blackmd.sendMessage(from, { 
            audio: { url: `https://world-ecletix.onrender.com/api/linkmp3?url=${encodeURIComponent(firstResult.link)}` }, 
            mimetype: "audio/mpeg", 
            fileName: firstResult.title || "play.mp3",
            ptt: true
        }, { quoted: info });

        console.log("[SUCESSO] Áudio enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao processar solicitação:", e);
        return reply("Seja mais específico, não deu pra encontrar com apenas isto... / Erro");
    }
}
break;

case 'clipelink': 
case 'videolink': 
case 'ytbmp4': {
    try {
        if (!q.trim()) {
            console.log("[ERRO] Nenhum texto fornecido para pesquisa.");
            return reply(`- Exemplo: ${prefix}videolink nome da música\na música será baixada, só basta escolher áudio ou vídeo.`);
        }

        console.log(`[INFO] Pesquisando vídeo: ${q}`);
        const data = await fetchJson(`https://world-ecletix.onrender.com/api/pesquisayt?query=${q}`);

        if (!data || !data.formattedVideos || data.formattedVideos.length === 0) {
            console.log("[ERRO] Nenhum resultado encontrado.");
            return reply("Desculpe, não consegui encontrar a música.");
        }

        const firstResult = data.formattedVideos[0];
        console.log("[INFO] Vídeo encontrado:", firstResult);

        var N_E = " Não encontrado.";
        var bla = `
        ๖ۣ• Titulo: ${firstResult.title || N_E}
        ๖ۣ• Tempo: ${firstResult.duration || N_E}
        ๖ۣ• Postado: ${firstResult.creator || N_E}
        ๖ۣ• Descrição: ${firstResult.channel || N_E}
        ๖ۣ• Visualizações: ${firstResult.views || N_E}

        ■■■■■ 100% 

        E᥉ᥴ᥆ᥣhᥲ ᥙ꧑ᥲ ᥆ρᥴᥲ᥆...

        Se desejar baixar a música, use ${prefix}playlink ${firstResult.link.trim()}
        `;

        await blackmd.sendMessage(from, {image: {url: firstResult.thumbnail || logoslink?.logo}, caption: bla}, {quoted: info});
        
        console.log("[INFO] Enviando vídeo...");
        await blackmd.sendMessage(from, {
            video: { url: `https://world-ecletix.onrender.com/api/linkmp4?url=${encodeURIComponent(firstResult.link)}` },
            mimetype: "video/mp4",
            fileName: firstResult.title || "video.mp4"
        }, { quoted: info });

        console.log("[SUCESSO] Vídeo enviado.");
    } catch (e) {
        console.error("[ERRO] Falha ao processar solicitação:", e);
        return reply("Seja mais específico, não deu pra encontrar com apenas isto... / Erro");
    }
}
break;

case 'playdoc': 
case 'Playdoc': {
    try {
        if (!q.trim()) {
            console.log("[ERRO] Nenhum texto fornecido para pesquisa.");
            return reply(`- Exemplo: ${prefix}playdoc nome da música\na música será baixada, só basta escolher áudio ou vídeo.`);
        }

        console.log(`[INFO] Pesquisando música para download como documento: ${q}`);
        const data = await fetchJson(`https://world-ecletix.onrender.com/api/pesquisayt?query=${q}`);

        if (!data || !data.formattedVideos || data.formattedVideos.length === 0) {
            console.log("[ERRO] Nenhum resultado encontrado.");
            return reply("Desculpe, não consegui encontrar a música.");
        }

        const firstResult = data.formattedVideos[0];
        console.log("[INFO] Música encontrada:", firstResult);

        var N_E = " Não encontrado.";
        var bla = `
        ๖ۣ• Titulo: ${firstResult.title || N_E}
        ๖ۣ• Tempo: ${firstResult.duration || N_E}
        ๖ۣ• Canal: ${firstResult.channel || N_E}
        ๖ۣ• Visualizações: ${firstResult.views || N_E}

        ■■■■■ 100% 

        E᥉ᥴ᥆ᥣhᥲ ᥙ꧑ᥲ ᥆ρᥴᥲ᥆...

        Se desejar baixar o vídeo, use ${prefix}play_video ${firstResult.link.trim()}
        `;

        console.log("[INFO] Enviando imagem com detalhes da música...");
        await blackmd.sendMessage(from, { image: { url: firstResult.thumbnail || logoslink?.logo }, caption: bla }, { quoted: info });

        const audioUrl = `https://world-ecletix.onrender.com/api/musica?name=${encodeURIComponent(firstResult.title)}`;
        console.log("[INFO] URL do áudio gerada:", audioUrl);

        console.log("[INFO] Enviando música como documento...");
        await blackmd.sendMessage(from, {
            document: { url: audioUrl },
            mimetype: "audio/mpeg",
            fileName: `${firstResult.title || 'play'}.mp3`
        }, { quoted: info });

        console.log("[SUCESSO] Música enviada como documento.");
    } catch (e) {
        console.error("[ERRO] Falha ao processar solicitação:", e);
        return reply("Não foi possível baixar ou encontrar esse áudio 🐞");
    }
}
break;
case 'audio':
try {
    if (!q) return reply(`Informe o nome da música ou o link`);
    await reagir(from, '⏳');

    let play2;

    // Verifica se o usuário enviou um link
    if (q.includes('youtube.com') || q.includes('youtu.be')) {
        // Se for link, faz a busca diretamente pela URL
        play2 = await fetchJson(`https://api.nexfuture.com.br/api/pesquisas/youtube?query=${encodeURIComponent(q)}`);
    } else {
        // Caso contrário, pesquisa pela string
        play2 = await fetchJson(`https://api.nexfuture.com.br/api/pesquisas/youtube?query=${encodeURIComponent(q)}`);
    }

    await blackmd.sendMessage(from, {
        audio: { url: `https://api.nexfuture.com.br/api/downloads/youtube/mp3-2?url=${play2.resultado.url}` },
        fileName: play2.resultado.titulo + '.mpeg',
        mimetype: "audio/mpeg",
        contextInfo: { 
            externalAdReply: {
                title: play2.resultado.titulo,
                body: `⌗ Lady Bot a melhor🐞 ⌗`,
                mediaType: 1,
                reviewType: "PHOTO",
                thumbnailUrl: play2.resultado.imagem,
                showAdAttribution: true,
                renderLargerThumbnail: true,
            },
        },
    }, { quoted: info });

} catch (error) {
    console.log(error);
    return reply('Ocorreu um erro, tente novamente mais tarde!');
}
break;

case 'video':
try {
    if (!q) return reply(`Informe o nome do vídeo ou o link`);
    await reagir(from, '⏳');

    let play2;

    // Verifica se o usuário enviou um link
    if (q.includes('youtube.com') || q.includes('youtu.be')) {
        // Se for link, faz a busca diretamente pela URL
        play2 = await fetchJson(`https://api.nexfuture.com.br/api/pesquisas/youtube?query=${encodeURIComponent(q)}`);
    } else {
        // Caso contrário, pesquisa pela string
        play2 = await fetchJson(`https://carisys.online/api/pesquisas/youtube?query=${encodeURIComponent(q)}`);
    }

    await blackmd.sendMessage(from, {
        video: { url: `https://api.nexfuture.com.br/downloads/youtube/mp4?url=${play2.resultado.url}` },
        fileName: play2.resultado.titulo + '.mp4',
        mimetype: "video/mp4",
        contextInfo: { 
            externalAdReply: {
                title: play2.resultado.titulo,
                body: `⌗ Lady Bot a melhor🐞 ⌗`,
                mediaType: 1,
                renderLargerThumbnail: true,
                thumbnailUrl: play2.resultado.imagem,
                showAdAttribution: true,
            },
        },
    }, { quoted: info });

} catch (error) {
    console.log(error);
    return reply('Ocorreu um erro, tente novamente mais tarde!');
}
break;
case 'Spotify':
case 'spotify':
case 'spo':
case 'spotify2': {
    try {
        if (!q.trim()) {
            return reply(`Por favor, informe o nome da música.\n\nExemplo: ${prefix}spotify nome da música`);
        }

        const audioUrl = `https://world-ecletix.onrender.com/api/spotify2?name=${encodeURIComponent(q)}`;

        await blackmd.sendMessage(from, { 
            audio: { url: audioUrl }, 
            mimetype: 'audio/mpeg',
            fileName: `${q}.mp3`,
            ptt: true 
        }, { quoted: info });

    } catch (e) {
        console.error("Erro ao enviar áudio do Spotify:", e);
        return reply("Desculpe, não foi possível baixar ou encontrar essa música.");
    }
}
break;

case "Instagram3":
case "igaudii":
case "igaud":
case "ig3":
{
    if (!q) {
        return reply("Você precisa fornecer o URL de qualquer vídeo, postagem, rolo ou imagem do Instagram.");
    }
    
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/insta?url=${q}`);
        // by luan
        
        // Verifica se a resposta contém dados e se 'data' é um array
        if (!res || !res.data || !Array.isArray(res.data.data)) {
            return reply("Nenhum vídeo ou imagem encontrado ou resposta inválida da API.");
        }
        
        const mediaArray = res.data.data;

        // Verifica se há pelo menos um item no array
        if (mediaArray.length < 1) {
            return reply("Não há vídeo disponível para esta postagem.");
        }

        // Pega o primeiro item (índice 0) para a URL do vídeo
        const videoData = mediaArray[0];
        const mediaURL = videoData.url;

        // Baixa o vídeo da URL como áudio
        const { data: videoBuffer } = await axios.get(mediaURL, { responseType: 'arraybuffer' });

        // Envia o vídeo como áudio para o usuário
        await blackmd.sendMessage(
            from,
            {
                audio: Buffer.from(videoBuffer),
                mimetype: 'audio/mpeg',
                fileName: "audio.mp3",
                ptt: false // Define `true` se quiser enviar como áudio de voz (PTT)
            },
            { quoted: info }
        );

        // Se houver uma URL de áudio para baixar
        if (audioUrl) {
            // Baixa o áudio da URL
            const { data: audioBuffer } = await axios.get(audioUrl, { responseType: 'arraybuffer' });

            // Envia o áudio para o usuário
            await blackmd.sendMessage(
                from,
                {
                    audio: Buffer.from(audioBuffer),
                    mimetype: 'audio/mpeg',
                    fileName: "audio.mp3",
                    ptt: false // Define `true` se quiser enviar como áudio de voz (PTT)
                },
                { quoted: info }
            );
        }

    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;

case "instagram2":
case "igvideo":
case "igvid":
case "ig2":
{
    if(!q) {
        return reply("Você precisa fornecer o URL de qualquer vídeo, postagem, rolo ou imagem do Instagram.");
    }
    
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/insta?url=${q}`);
        //by luan
        
        // Verifica se a resposta contém dados e se 'data' é um array
        if (!res || !res.data || !Array.isArray(res.data.data)) {
            return reply("Nenhum vídeo ou imagem encontrado ou resposta inválida da API.");
        }
        
        const mediaArray = res.data.data;

        // Verifica se há pelo menos um item no array
        if (mediaArray.length < 1) {
            return reply("Não há vídeo disponível para esta postagem.");
        }

        // Pega o primeiro item (índice 0) para a URL do vídeo
        const videoData = mediaArray[0];
        const mediaURL = videoData.url;

        // Envia o vídeo usando a URL
        const cap = "aqui seu video";
        blackmd.sendMessage(from, { video: { url: mediaURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;

case "capcut2": case "capcutaudio": case "cpaud": case "cap2": { if (!q) { return reply("Você precisa fornecer o URL de um vídeo do CapCut."); }

try {
    const res = await fetchJson(`https://world-ecletix.onrender.com/api/capcut?url=${q}`);
    
    // Verifica se a resposta contém dados válidos
    if (!res || !res.result || !res.result.status || !res.result.url) {
        return reply("Nenhum vídeo encontrado ou resposta inválida da API.");
    }
    
    const videoURL = res.result.url;
    const caption = res.result.title || "Aqui está seu vídeo do CapCut.";
    
    // Baixa o vídeo da URL como áudio
    const { data: videoBuffer } = await axios.get(videoURL, { responseType: 'arraybuffer' });

    // Envia o vídeo como áudio para o usuário
    await blackmd.sendMessage(
        from,
        {
            audio: Buffer.from(videoBuffer),
            mimetype: 'audio/mpeg',
            fileName: "audio.mp3",
            ptt: false // Define `true` se quiser enviar como áudio de voz (PTT)
        },
        { quoted: info }
    );
} catch (error) {
    console.error(error);
    return reply("Ocorreu um erro ao processar a solicitação.");
}

} break;
case "drivevideo": case "drivevid": case "dvideo": case "dvid": { if (!q) { return reply("Você precisa fornecer a URL de um arquivo do Google Drive."); }

try {
    const res = await fetchJson(`https://api.vreden.my.id/database/gdrive?url=${q}`);
    
    if (!res || !res.result || !res.result.status || !res.result.downloadUrl) {
        return reply("Nenhum vídeo encontrado ou resposta inválida da API.");
    }
    
    const videoURL = res.result.downloadUrl;
    const caption = res.result.fileName || "Aqui está seu vídeo do Google Drive.";
    
    blackmd.sendMessage(from, { video: { url: videoURL }, caption: caption }, { quoted: info });
} catch (error) {
    console.error(error);
    return reply("Ocorreu um erro ao processar a solicitação.");
}

} break;

case "driveaudio": case "driveaud": case "daudio": case "daud": { if (!q) { return reply("Você precisa fornecer a URL de um arquivo do Google Drive."); }

try {
    const res = await fetchJson(`https://api.vreden.my.id/database/gdrive?url=${q}`);
    
    if (!res || !res.result || !res.result.status || !res.result.downloadUrl) {
        return reply("Nenhum áudio encontrado ou resposta inválida da API.");
    }
    
    const audioURL = res.result.downloadUrl;
    
    const { data: audioBuffer } = await axios.get(audioURL, { responseType: 'arraybuffer' });
    
    await blackmd.sendMessage(
        from,
        {
            audio: Buffer.from(audioBuffer),
            mimetype: 'audio/mpeg',
            fileName: "audio.mp3",
            ptt: false 
        },
        { quoted: info }
    );
} catch (error) {
    console.error(error);
    return reply("Ocorreu um erro ao processar a solicitação.");
}

} break;

case "capcut": { if (!q) { return reply("Você precisa fornecer o URL de um vídeo do CapCut."); }

try {
    const res = await fetchJson(`https://world-ecletix.onrender.com/api/capcut?url=${q}`);
    
    // Verifica se a resposta contém dados válidos
    if (!res || !res.result || !res.result.status || !res.result.url) {
        return reply("Nenhum vídeo encontrado ou resposta inválida da API.");
    }
    
    const videoURL = res.result.url;
    const caption = res.result.title || "Aqui está seu vídeo do CapCut.";
    
    // Envia o vídeo
    blackmd.sendMessage(from, { video: { url: videoURL }, caption: caption }, { quoted: info });
} catch (error) {
    console.error(error);
    return reply("Ocorreu um erro ao processar a solicitação.");
}

} break;

case "tiktokad":
case "tiktokaud":
case "tiktokmp3":
case "tiktok_audio":
{
  if (!q) {
    return blackmd.sendMessage(
      from,
      { text: `Por favor, forneça o link do vídeo TikTok.\nExemplo: ${prefix}tiktok_audio https://www.tiktok.com/@granitayt/video/7383381752024272133` },
      { quoted: info }
    );
  }

  try {
    // Solicita o áudio da API
    const { data: result } = await axios.get(`https://world-ecletix.onrender.com/api/tiktok?query=${encodeURIComponent(q)}`);

    if (!result || !result.audio) {
      return blackmd.sendMessage(from, { text: "Não foi possível obter o áudio do TikTok. Tente outro link." }, { quoted: info });
    }

    // Extrai a URL do áudio
    const audioUrl = result.audio;

    // Baixa o áudio da URL
    const { data: audioBuffer } = await axios.get(audioUrl, { responseType: 'arraybuffer' });

    // Envia o áudio para o usuário
    await blackmd.sendMessage(
      from,
      {
        audio: Buffer.from(audioBuffer),
        mimetype: 'audio/mpeg',
        fileName: "audio.mp3",
        ptt: false // Define `true` se quiser enviar como áudio de voz (PTT)
      },
      { quoted: info }
    );

  } catch (error) {
    console.error('Erro ao baixar/enviar o áudio:', error);
    blackmd.sendMessage(from, { text: "Erro ao processar a solicitação. Tente novamente mais tarde." }, { quoted: info });
  }
}
break;
case "tiktokvid":
case "tiktokmp4":
case "tiktokvd":
case "tiktok_video":
{
  if(!q) {
    return blackmd.sendMessage(
      from,
      { text: `Por favor, forneça o link do vídeo TikTok. Exemplo: ${prefix}tiktok_video https://www.tiktok.com/@granitayt/video/7383381752024272133` },
      { quoted: info }
    );
  }

  try {
    // Solicitar o vídeo diretamente da API
    const response = await axios.get(`https://world-ecletix.onrender.com/api/tiktok?query=${encodeURIComponent(q)}`);
    const result = response.data;

    // Verificar se a resposta contém a URL do vídeo
    if (!result || !result.videoOriginal) {
      return blackmd.sendMessage(from, { text: "Não foi possível obter o vídeo do TikTok." }, { quoted: info });
    }

    // Extrair a URL do vídeo
    const videoUrl = result.videoOriginal;

    // Baixar o vídeo do link
    const { data: videoBuffer } = await axios.get(videoUrl, { responseType: 'arraybuffer' });

    // Enviar o vídeo baixado
    await blackmd.sendMessage(
      from,
      {
        video: Buffer.from(videoBuffer),  // Certifique-se de que o vídeo está sendo enviado como Buffer
        mimetype: 'video/mp4',
        fileName: `video.mp4`
      },
      { quoted: info }
    );

  } catch (error) {
    console.error('Erro ao baixar e enviar o vídeo:', error);
    blackmd.sendMessage(from, { text: "Ocorreu um erro ao processar a solicitação." }, { quoted: info });
  }
}
break;
case "instagram":
case "igimage":
case "igimg":
case "ig":
{
    if(!q) {
        return reply("Você precisa fornecer o URL de qualquer vídeo, postagem, rolo ou imagem do Instagram.");
    }
    
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/insta?url=${q}`);
        //by luan
        
        // Verifica se a resposta contém dados e se 'data' é um array
        if (!res || !res.data || !Array.isArray(res.data.data)) {
            return reply("Nenhum vídeo ou imagem encontrado ou resposta inválida da API.");
        }
        
        const mediaArray = res.data.data;

        // Itera sobre cada item no array de mídias
        for (const mediaData of mediaArray) {
            const mediaType = mediaData.url.endsWith('.mp4') ? 'video' : 'image'; // Determina o tipo com base na URL
            const mediaURL = mediaData.url;
            let cap = `aqui sua foto! ${mediaType.toUpperCase()}`;
            
            if (mediaType === "video") {
                blackmd.sendMessage(from, { video: { url: mediaURL }, caption: cap }, { quoted: info });
            } else if (mediaType === "image") {
                blackmd.sendMessage(from, { image: { url: mediaURL }, caption: cap }, { quoted: info });
            }
        }
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "pin_audio":
case "pinterest_audio":
{
    if(!q) {
        return reply("Você precisa fornecer o URL de qualquer vídeo do Pinterest.");
    }

    try {
        const res = await fetchJson(`https://api-pinterest-y7jx.onrender.com/api/vid2?url=${q}`);
        //by luan

        if (!res || !res.video_url) {
            return reply("Nenhum vídeo encontrado ou resposta inválida da API.");
        }

        // Extrair a URL do áudio
    const videoURL = res.video_url;

    // Baixar o áudio do link
    const { data: audioBuffer } = await axios.get(videoURL, { responseType: 'arraybuffer' });

    // Enviar o áudio baixado
    await blackmd.sendMessage(
      from,
      {
        audio: Buffer.from(audioBuffer),  // Certifique-se de que o áudio está sendo enviado como Buffer
        mimetype: 'audio/mpeg',
        fileName: `audio.mp3`,
        ptt: true
      },
      { quoted: info }
    );

  } catch (error) {
    console.error('Erro ao baixar e enviar o áudio:', error);
    blackmd.sendMessage(from, { text: "Ocorreu um erro ao processar a solicitação." }, { quoted: info });
  }
}
break;
case "pin_video":
case "pinterest_video":
{
    if(!q) {
        return reply("Você precisa fornecer o URL de qualquer vídeo do Pinterest.");
    }

    try {
        const res = await fetchJson(`https://api-pinterest-y7jx.onrender.com/api/vid2?url=${q}`);
        //by luan

        if (!res || !res.video_url) {
            return reply("Nenhum vídeo encontrado ou resposta inválida da API.");
        }

        const videoURL = res.video_url;
        let cap = `aqui está!!!`;
        blackmd.sendMessage(from, { video: { url: videoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "kwai_audio":
{
    if(!q) {
        return reply("Você precisa fornecer o URL de qualquer vídeo do Kwai.");
    }

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/kwai?url=${q}`);
        //by luan

        if (!res || !res.videoUrl) {
            return reply("Nenhum vídeo encontrado ou resposta inválida da API.");
        }

        // Extrair a URL do áudio
    const videoURL = res.videoUrl;

    // Baixar o áudio do link
    const { data: audioBuffer } = await axios.get(videoURL, { responseType: 'arraybuffer' });

    // Enviar o áudio baixado
    await blackmd.sendMessage(
      from,
      {
        audio: Buffer.from(audioBuffer),  // Certifique-se de que o áudio está sendo enviado como Buffer
        mimetype: 'audio/mpeg',
        fileName: `audio.mp3`,
        ptt: true
      },
      { quoted: info }
    );

  } catch (error) {
    console.error('Erro ao baixar e enviar o áudio:', error);
    blackmd.sendMessage(from, { text: "Ocorreu um erro ao processar a solicitação." }, { quoted: info });
  }
}
break;

case "kwai_video":
{
    if(!q) {
        return reply("Você precisa fornecer o URL de qualquer vídeo do Kwai.");
    }

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/kwai?url=${q}`);
        //by luan

        if (!res || !res.videoUrl) {
            return reply("Nenhum vídeo encontrado ou resposta inválida da API.");
        }

        const videoURL = res.videoUrl;
        let cap = `Aqui está o vídeo do Kwai!`;
        blackmd.sendMessage(from, { video: { url: videoURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case 'twitter_video':
try {
reply("baixando...")
blackmd.sendMessage(from, {video: {url: `https://api.bronxyshost.com.br/api-bronxys/${command}?url=${q}&apikey=Yuta-Channel`}, mimetype: "video/mp4"}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break;

case 'twitter_audio':
try {
reply("baixando..")
blackmd.sendMessage(from, {audio: {url: `https://api.bronxyshost.com.br/api-bronxys/${command}?url=${q}&apikey=Yuta-Chanel`}, mimetype: "audio/mpeg"}).catch(e => {
return reply("Erro..")
})
} catch (e) {
return reply("Erro..")
}
break;


case 'pinterest':
    if (!q) return reply(`*_❕Coloque a busca que você deseja!_*\n- *🧑‍🏫 Por exemplo:* ${prefix + command} goku`);

    const searchQueryPinterest = encodeURIComponent(q);
    const pinterestApiUrl = `https://world-ecletix.onrender.com/api/pinterest?termo=${searchQueryPinterest}`;

    reply("🔄 Buscando imagens...");

    try {
        const response = await fetch(pinterestApiUrl);

        if (!response.ok) {
            throw new Error('Erro na resposta da API');
        }

        const urls = await response.json();

        if (!Array.isArray(urls) || urls.length === 0) {
            return reply("Nenhuma imagem encontrada para a pesquisa.");
        }

        const randomIndex = Math.floor(Math.random() * urls.length);
        const randomUrl = urls[randomIndex];

        // Faz a requisição da imagem
        const imageResponse = await fetch(randomUrl);
if (!imageResponse.ok) {
    throw new Error('Erro ao buscar a imagem.');
}

const imageArrayBuffer = await imageResponse.arrayBuffer();  // Usando .arrayBuffer() para obter a imagem

// Envia a imagem diretamente do ArrayBuffer
await blackmd.sendMessage(from, { image: Buffer.from(imageArrayBuffer), caption: `Aqui está a imagem: ${q}` });

    } catch (error) {
        console.error("Erro ao obter a imagem:", error);
        reply("🚨 Não foi possível buscar a imagem. Tente novamente mais tarde.");
    }
break;

case "pin_foto":
case "pinterest_foto":
{
    if(!q) {
        return reply("Você precisa fornecer o URL de qualquer foto do Pinterest.");
    }

    try {
        const res = await fetchJson(`https://api-pinterest-y7jx.onrender.com/api/img2?url=${q}`);
        //by luan

        if (!res || !res.image_url) {
            return reply("Nenhuma foto encontrada ou resposta inválida da API.");
        }

        const imageURL = res.image_url;
        let cap = `aqui está!!!`;
        blackmd.sendMessage(from, { image: { url: imageURL }, caption: cap }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "face_video":
case "facebook_video": {
    if (!q) {
        return reply("Você precisa fornecer o URL de um vídeo do Facebook.");
    }
    
    try {
        const res = await fetchJson(`${site}/api/facebook?link=${q}`);
        
        if (!res || !res.data || !res.data.hd_url) {
            return reply("Nenhum vídeo encontrado ou resposta inválida da API.");
        }
        
        const videoURL = res.data.hd_url;
        let caption = "Aqui está seu vídeo do Facebook!";
        
        blackmd.sendMessage(from, { video: { url: videoURL }, caption: caption }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "face_audio":
case "fbaudio":
case "facebookmp3":
case "facebook_audio":
{
  if (!q) {
    return blackmd.sendMessage(
      from,
      { text: `Por favor, forneça o link do vídeo do Facebook. Exemplo: ${prefix}fbaudio https://www.facebook.com/watch/?v=123456789` },
      { quoted: info }
    );
  }

  try {
    // Solicitar o áudio diretamente da API do Facebook
    const response = await axios.get(`https://api.vreden.my.id/api/fbdl?url=${encodeURIComponent(q)}`);
    const res = response.data;

    // Verificar se a resposta contém a URL do áudio
    if (!res || !res.data || !res.data.hd_url) {
      return blackmd.sendMessage(from, { text: "Nenhum áudio encontrado ou resposta inválida da API." }, { quoted: info });
    }

    // Extrair a URL do áudio
    const videoURL = res.data.hd_url;

    // Baixar o áudio do link
    const { data: audioBuffer } = await axios.get(videoURL, { responseType: 'arraybuffer' });

    // Enviar o áudio baixado
    await blackmd.sendMessage(
      from,
      {
        audio: Buffer.from(audioBuffer),  // Certifique-se de que o áudio está sendo enviado como Buffer
        mimetype: 'audio/mpeg',
        fileName: `audio.mp3`,
        ptt: true
      },
      { quoted: info }
    );

  } catch (error) {
    console.error('Erro ao baixar e enviar o áudio:', error);
    blackmd.sendMessage(from, { text: "Ocorreu um erro ao processar a solicitação." }, { quoted: info });
  }
}
break;
case "xvdow":
case "xvdow_video":
{
    if (!q) {
        return reply("Você precisa fornecer o URL de qualquer vídeo do Xvideos.");
    }

    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/xvideosdow?url=${q}`);
        //by luan

        if (!res || !res.videoUrl) {
            return reply("Nenhum vídeo encontrado ou resposta inválida da API.");
        }

        const videoURL = res.videoUrl;
        const thumbnailURL = res.thumbnail[0];
        const title = res.name;
        const description = res.description;
        const uploadDate = res.uploadDate;
        const duration = res.duration;

        // Cria uma legenda com as informações
        let cap = `Título: ${title}\nDescrição: ${description}\nData de Upload: ${uploadDate}\nDuração: ${duration}`;
        
        // Envia o vídeo com a miniatura e a legenda
        blackmd.sendMessage(from, { 
            video: { url: videoURL },
            caption: cap,
            thumbnail: { url: thumbnailURL }
        }, { quoted: info });
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case "xnxxvideo":
case "xnxxvid":
{
    if (!q) {
        return reply("Você precisa fornecer o URL de um vídeo do XNXX.");
    }
    
    try {
        const res = await fetchJson(`https://world-ecletix.onrender.com/api/xnxxdow?url=${q}`);
        
        // Verifica se a resposta contém dados e URL do vídeo
        if (!res || !res.title || !res.files || !res.files.high) {
            return reply("Nenhum vídeo encontrado ou resposta inválida da API.");
        }
        
        const videoURL = res.files.high; // Pegando a melhor qualidade (high)
        const caption = res.title || "Aqui está seu vídeo do XNXX.";
        
        // Envia o vídeo com a URL de melhor qualidade
        blackmd.sendMessage(from, { video: { url: videoURL }, caption: caption }, { quoted: info });
        
    } catch (error) {
        console.error(error);
        return reply("Ocorreu um erro ao processar a solicitação.");
    }
}
break;
case 'mediafire':
try {
if(!q.includes("mediafire.com")) return reply("Faltando o link do mediafire para download do arquivo, cade?");
let nex = await fetchJson(`https://api.nexfuture.com.br/api/downloads/mediafire/dl?url=${q}`)
reply(`Enviando: ${nex.resultado.nome}\n\nPeso: ${nex.resultado.size}`)

await blackmd.sendMessage(from, {document: 
{url: nex.resultado.url}, mimetype: "application/"+nex.resultado.mime, fileName: nex.resultado.nome});
} catch (error) {
console.log(error)
return reply("Deu um pequeno error, tente novamente mais tarde...")
}
break;
case "threads": case "thr":
if(!q.includes("threads.net")) return reply(`Cade o link do threads? Exemplo: ${prefix+command} https://www.threads.net/@tali_mito22/post/C_3_FbKyHtm/?xmt=AQGzOjjOpgW7PRhCZRcda0GvAqfvYqPWDwHgzn_v6_FVLQ`)
reply("Aguarde, estou enviando..")
try {
blackmd.sendMessage(from, {video: {url: `https://api.bronxyshost.com.br/api-bronxys/threads?url=${q}&apikey=Yuta-Chanel`}})
} catch (e) {
return reply("Erro, tente falar com o suporte...")
}
break;

case 'gitclone':
if(!q) return reply(`Exemplo: ${prefix}gitclone https://github.com/m4thxyz/blackofc`)
reply(`*[❕] _Enviando... Aguarde_* ✔`)
let regex1 = /(?:https|git)(?::\/\/|@)github\.com[\/:]([^\/:]+)\/(.+)/i
if(!regex1.test(args[0])) return reply('Aguarde...')
let [, user, repo] = args[0].match(regex1) || []
repo = repo.replace(/.git$/, '')
let url = `https://api.github.com/repos/${user}/${repo}/zipball`
let filename = (await fetch(url, {method: 'HEAD'})).headers.get('content-disposition').match(/attachment; filename=(.*)/)[1]
let finishname = filename.split(`-`).splice(0, filename.split(`-`).length - 1).join(`-`)
blackmd.sendMessage(from, {document: {url: url}, fileName: finishname+'.zip', mimetype: 'application/zip' }, {quoted: info}).catch(e => {
console.log(e)
return reply(`Erro`)
})
break

case 'docfake':
if(!isVip && !isChatOfc) return reply("[ ❗ ] o uso desde recurso fora do chat oficial está restrito apenas aos usuários VIP ❌")
setTimeout(() => {reagir(from, "📝")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
sp = `/`
docfake = [
  {formato: `pdf`, link: `application/pdf`},
  {formato: `xml`, link: `application/xml`},
  {formato: `zip`, link: `application/zip`},
  {formato: `js`, link: `application/javascript`},
  {formato: `json`, link: `application/json`},
  {formato: `jpg`, link: `image/jpeg`},
  {formato: `ppt`, link: `application/vnd.ms-powerpoint`},
  {formato: `pptx`, link: `application/vnd.openxmlformats-officedocument.presentationml.presentation`},
  {formato: `apk`, link: `application/vnd.android.package-archive`},
  {formato: `txt`, link: `text/plain`},
  {formato: `aac`, link: `audio/aac`},
  {formato: `m4a`, link: `audio/mp4`},
  {formato: `mp4`, link: `video/mp4`},
  {formato: `mp3`, link: `audio/mpeg`},
  {formato: `gif`, link: `image/gif`},
  {formato: `svg`, link: `image/svg+xml`},
  {formato: `png`, link: `image/png`}
]
if(contar(q, sp) != 2) return reply(`*Ops, vejo que você está usando o comando de forma errada... Você deve usar neste formato e exemplo ↴*
*Formato:* ${prefix+command} nome${sp}tamanho${sp}formato

*Exemplo:* ${prefix+command} pack do pé${sp}250${sp}zip

${`-`.repeat(40)}

${docfake.map(d => `• ${d.formato}`).join(`\n`)}`)
barra = q.replace(sp+` `, sp).replace(` `+sp, sp).replace(` ${sp} `, sp)
var [nome, tamanho, tipo] = barra.split(sp)
AB = docfake.map(i => i.formato).indexOf(tipo.toLowerCase())
if(AB < 0) return reply(`O formato "${tipo}" não existe no banco de dados...`)
if(Number(tamanho) < 0) return reply(`O tamanho precisa ser um número maior que zero..`)
//======================\\
blackmd.sendMessage(from, {document: fs.readFileSync('./database/docf.txt'), mimetype: docfake[AB].link, fileName: nome+`.`+docfake[AB].formato, fileLength: Number(tamanho) * 1000000, headerType: 4, contextInfo: {forwardingScore: 999, isForwarded:true}}, {quoted: seloblk})
break;

case 'bc': case 'bcgroup': case 'transmitir': case 'transmissão': {
if(!isOwner && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(enviar.msg.dono)
if(!q) return reply( `Texto onde?\n\nExemplo : ${prefix + command} BOA VISTA `)
let getGroups = await blackmd.groupFetchAllParticipating()
let groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
let anu = groups.map(v => v.id)
for (i = 0; i < anu.length; i++) {
await sleep(1500)
let txt = `「 TRANSMISSÃO DO BOT 」\n\n ${q}`
blackmd.sendMessage(anu[i], {text: txt})
}
reply(`Enviando com sucesso `)
}
break



case 'join': case 'entrar': {
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply('Insira um link de convite ao lado do comando.')
if(!q.includes('chat.whatsapp.com/')) return reply('Ops, verifique o link que você inseriu.')
let { key } = await blackmd.sendMessage(from, {text: `*Pode deixar meu senhor, estou entrando no grupo...* 🫡`}, {quoted: info})
link = q.split('app.com/')[1]
await sleep(500)
try {
blackmd.groupAcceptInvite(`${link}`)
await sleep(500)
blackmd.sendMessage(from, {text: `*Entrei* 🥰`, edit: key}, {quoted: info})
} catch(erro) {
console.log(erro)
if(JSON.stringify(erro).includes('resource-limit')) return blackmd.sendMessage(from, {text: `O grupo já está com o número máximo de membros... Não consigo entrar 🫠`, edit: key}, {quoted: info})
if(JSON.stringify(erro).includes('not-authorized')) return blackmd.sendMessage(from, {text: `Não foi possível entrar no grupo pq algum admin me baniu... Pfvr, peça para o meu dono me adicionar (chame ${prefix}dono)`, edit: key}, {quoted: info})
blackmd.sendMessage(from, {text: `Erro, não foi possível entrar no grupo... Melhor adicionar manualmente.`, edit: key}, {quoted: info})
}}
break

case 'request':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
not = `*Use o comando com as 3 escolhas possíveis abaixo:*
• ${prefix+command} -lista
• ${prefix+command} -aceitar
• ${prefix+command} -recusar`
if(!q) return reply(not)
req = await blackmd.groupRequestParticipantsList(from)
if(req.length <= 0) return reply(`[❗] não há solicitações no momento ❌`)
if(args[0].toLowerCase() === "-lista") {
  caixa = []
  for(r = 0; r < req.length; r++) {
    i = req[r]
    lista = `»${r + 1}«\n👤 *Participante:* @${i.jid.split("@")[0]}\n📼 *Número:* ${addNumberMais(i.jid)}\n🎲 *Método:* `
    if(i.request_method == "linked_group_join") {
      comunidade = await blackmd.groupMetadata(i.parent_group_jid)
      lista += `\"solicitação por comunidade\"\n🗂 *Comunidade:* ${comunidade.subject}`
    } else if(i.request_method == "non_admin_add") { lista += `\"adicionado por membro\"\n🥋 *Membro Responsável:* @${i.requestor.split("@")[0]}`
    } else lista += `\"link de convite\"`
    caixa.push(lista)
  }
  return mention(`🧮 *Lista total ${req.length != 1 ? `dos ${req.length} participantes` : `do único participante`} na lista de espera deste grupo ↴*\n${caixa.map(c => c).join(`\n-\n`)}`)
} else if(args[0].toLowerCase() === "-aceitar") {
  if(!args[1]) return reply(`KD o número do usuário na lista? Ex:\n${prefix+command} -aceitar 1`)
  if(args[1].toLowerCase() === "all") {
    total = req.length
    nmr = 0
    for(a of req) {
      await sleep(700)
      aceitar(from, a.jid)
      nmr += 1
    }
    if(nmr >= total) {
      await sleep(500)
      return mention(`${nmr != 1 ? `Todos os ${nmr} participantes da lista foram aceitos` : `O único participante da lista foi aceito`} pelo admin @${sender.split("@")[0]} com sucesso ✅`)
    }
  } else {
    if(Number(args[1]) < 1 || Number(args[1]) > req.length) return reply(enviar.msg.notusu)
    usu = req[Number(args[1]) - 1].jid
    aceitar(from, usu)
    return mention(`O participante @${usu.split("@")[0]} foi aceito pelo admin @${sender.split("@")[0]} com sucesso ✅`)
  }
} else if(args[0].toLowerCase() === "-recusar") {
  if(!args[1]) return reply(`KD o número do usuário na lista? Ex:\n${prefix+command} -recusar 1`)
  if(args[1].toLowerCase() === "all") {
    total = req.length
    nmr = 0
    for(r of req) {
      await sleep(700)
      recusar(from, r.jid)
      nmr += 1
    }
    if(nmr >= total) {
      await sleep(500)
      return mention(`${nmr != 1 ? `Todos os ${nmr} participantes da lista foram recusados` : `O único participante da lista foi recusado`} com sucesso pelo admin @${sender.split("@")[0]} ♨`)
    }
  } else {
    if(Number(args[1]) < 1 || Number(args[1]) > req.length) return reply(enviar.msg.notusu)
    usu = req[Number(args[1]) - 1].jid
    recusar(from, usu)
    return mention(`O participante @${usu.split("@")[0]} foi recusado pelo admin @${sender.split("@")[0]} com sucesso ♨`)
  }
} else return reply(not)
break

case 'attacc':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isAcceptGroup) {
dataGp[0].acceptGroup.active = true
setGp(dataGp)
reply(`🌀 Ativou com sucesso o recurso de aceitar automaticamente o membro no grupo 📝`)
} else {
dataGp[0].acceptGroup.active = false
setGp(dataGp)
reply(`‼️ Desativou com sucesso o recurso de aceitar automaticamente o membro no grupo ✔️`)
}
break

case 'setattacc':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isAcceptGroup) return reply(`É necessário ativar o recurso de auto aceitação primeiro... Use ${prefix}attacc`)
nmr = Number(q.slice(0, q.length - 1))
letra = q.slice(q.length - 1, q.length).toLowerCase()
if(nmr <= 0) return reply(`O tempo precisa ser maior que 0... Ex: ${prefix+command} 10m`)
if(letra != "s" && letra != "m" && letra != "h") return reply(`Use apenas "s", "m" ou "h" para identificar o tempo, ex: ${prefix+command} 10m`)
if(letra == "s") multiplicador = 1
if(letra == "m") multiplicador = 60
if(letra == "h") multiplicador = 3600
nmr *= multiplicador
dataGp[0].acceptGroup.time = nmr
setGp(dataGp)
reply(`O cooldow de tempo para a aceitação automática no grupo ${groupName} foi atualizado para ${q} com sucesso ✅`)
break

case 'antiimg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('Hmmmm')
if(Number(args[0]) === 1) {
if(isAntiImg) return reply('Já Esta ativo')
dataGp[0].antiimg = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti imagem neste grupo✔️')
} else if(Number(args[0]) === 0) {
if(!isAntiImg) return reply('Ja esta Desativado.')
dataGp[0].antiimg = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti imagem neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antivideo':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('Hmmmm')
if(Number(args[0]) === 1) {
if(isAntiVid) return reply('Ja esta ativo')
dataGp[0].antivideo = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti video neste grupo✔️')
} else if(Number(args[0]) === 0) {
if(!isAntiVid) return reply('Ja esta Desativado')
dataGp[0].antivideo = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti video neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antiaudio':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('Hmmmm')
if(Number(args[0]) === 1) {
if(isAntiAudio) return reply('Ja esta ativo')
dataGp[0].antiaudio = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti audio neste grupo✔️')
} else if(Number(args[0]) === 0) {
if(!isAntiAudio) return reply('Ja esta Desativado')  
dataGp[0].antiaudio = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti audio neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antisticker':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('Hmmmm')
if(Number(args[0]) === 1) {
if(isAntiSticker) return reply('Já Esta ativo')
dataGp[0].antisticker = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti sticker neste grupo✔️')
} else if(Number(args[0]) === 0) {
if(!isAntiSticker) return reply('Ja esta Desativado.')
dataGp[0].antisticker = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti sticker neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antidocumento':
case 'antidoc':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(Antidoc) return reply('Ja esta ativo')
dataGp[0].antidoc = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti documento neste grupo✔️')
} else if(Number(args[0]) === 0) {
if(!Antidoc) return reply('Ja esta Desativado')
dataGp[0].antidoc = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de anti documento neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antictt':
case 'anticontato':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntiCtt) return reply('Ja esta ativo')
dataGp[0].antictt = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de anticontato neste grupo 📝')
} else if(Number(args[0]) === 0) {
if(!isAntiCtt) return reply('Ja esta Desativado')
dataGp[0].antictt = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de anticontato neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antiloc':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
try {														 
if(args.length < 1) return reply('1 pra ativar, 0 pra desligar')
if(Number(args[0]) === 1) {
if(Antiloc) return reply('Já está Ativo.')
dataGp[0].antiloc = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti loc neste grupo✔️')
} else if(Number(args[0]) === 0) {
if(!Antiloc) return reply('Já está Desativado.')
dataGp[0].antiloc = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti loc neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
} catch {
reply('Deu erro, tente novamente :/')
}
break

case 'antiporno':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
try {														 
if(args.length < 1) return reply('1 pra ativar, 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntiPorno) return reply('Já está Ativo.')
dataGp[0].antiporno = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti porno neste grupo✔️')
} else if(Number(args[0]) === 0) {
if(!isAntiPorno) return reply('Já está Desativado.')
dataGp[0].antiporno = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti porno neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
} catch {
reply('Deu erro, tente novamente :/')
}
break

case 'addshieldgp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(contar(q, '/') != 1) return reply(`> ${prefix+command} @pessoa/quantidade
_(essa "quantidade" remete a quantos links o usuário pode mandar antes de ser banido)_`)
barra = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/")
var [marc, mxm] = barra.split('/')
usu = identArroba(marc)
if(isShieldGPuser(from, usu)) return reply(enviar.shield.gp.true)
addShieldGP(from, usu, mxm)
mention(`Usuário @${usu.split('@')[0]} está imune do ban ao enviar links de grupo...`)
break

case 'addshieldhard':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(contar(q, '/') != 1) return reply(`> ${prefix+command} @pessoa/quantidade
_(essa "quantidade" remete a quantos links o usuário pode mandar antes de ser banido)_`)
barra = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/")
var [marc, mxm] = barra.split('/')
usu = identArroba(marc)
if(isShieldGPuser(from, usu)) return reply(enviar.shield.hard.true)
addShieldHARD(from, usu, mxm)
mention(`Usuário @${usu.split('@')[0]} está imune do ban ao enviar links em geral...`)
break

case 'rmshieldgp': case 'rmshieldhard':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!marc_tds) return reply(`Marque o usuário, a mensagem ou o @, de quem você quer retirar a proteção do anti link ${command == "rmshieldgp" ? `GP` : `HARD`}...`)
if(command == "rmshieldgp" && !isShieldGPuser(from, marc_tds)) return reply(enviar.shield.gp.false)
if(command == "rmshieldhard" && !isShieldHARDuser(from, marc_tds)) return reply(enviar.shield.hard.false)
rm = command == "rmshieldgp" ? rmShieldGP : rmShieldHARD
rm(from, marc_tds)
reply("Escudo do usuário removido com sucesso...")
break

case 'shieldgplist':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!JSON.stringify(shieldantilinkgp).includes(from)) {
shieldantilinkgp.push({groupId: from, usus: []})
fs.writeFileSync("./basededados/shieldantilinkgp.json", JSON.stringify(shieldantilinkgp))
}
AB = shieldantilinkgp.map(i => i.groupId).indexOf(from)
txt = `[ ❗ ] *Lista de usuários imunes ao ban por link de grupo:*\n`
for(i of shieldantilinkgp[AB].usus) {
  txt += `\n@${i.id.split('@')[0]}`
}
txt += `\n-> *Total:* ${shieldantilinkgp[AB].usus.length}`
mention(txt)
break

case 'shieldhardlist':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!JSON.stringify(shieldantilinkhard).includes(from)) {
shieldantilinkhard.push({groupId: from, usus: []})
fs.writeFileSync("./basededados/shieldantilinkhard.json", JSON.stringify(shieldantilinkhard))
}
AB = shieldantilinkhard.map(i => i.groupId).indexOf(from)
txt = `[ ❗ ] *lista de usuários imunes ao ban por link em geral:*\n`
for(i of shieldantilinkhard[AB].usus) {
  txt += `\n@${i.id.split('@')[0]}`
}
txt += `\n-> *Total:* ${shieldantilinkhard[AB].usus.length}`
mention(txt)
break

case 'antilinkgp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntilinkgp) return reply('Ja esta ativo')
dataGp[0].antilinkgp = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de antilinkgp 📝')
} else if(Number(args[0]) === 0) {
if(!isAntilinkgp) return reply('Ja esta Desativado')
dataGp[0].antilinkgp = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de antilink de grupo ✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'banlinkgp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isBanlinkgp) return reply('Ja esta ativo')
dataGp[0].banlinkgp = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de banir & apagar os links de grupo 📝')
} else if(Number(args[0]) === 0) {
if(!isBanlinkgp) return reply('Ja esta Desativado')
dataGp[0].banlinkgp = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de banir o usuário... Irei só apagar o link ✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antilinkhard':
case 'antilink':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntiLinkHard) return reply('Ja esta ativo')
dataGp[0].antilinkhard = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de antilink hardcore neste grupo 📝')
} else if(Number(args[0]) === 0) {
if(!isAntiLinkHard) return reply('Ja esta Desativado')
dataGp[0].antilinkhard = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de antilink harcore neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'banlinkhard':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isBanLinkHard) return reply('Ja esta ativo')
dataGp[0].banlinkhard = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de banir & apagar os links 📝')
} else if(Number(args[0]) === 0) {
if(!isBanLinkHard) return reply('Ja esta Desativado')
dataGp[0].banlinkhard = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de banir o usuário... Irei só apagar o link ✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'x9':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isx9) return reply('Ja esta ativo')
dataGp[0].x9 = true
setGp(dataGp)
reply('🌀 Ativou o recurso de x9 com sucesso... Irei notificar qualquer alteração disponível feita neste grupo 😏..')
} else if(Number(args[0]) === 0) {
if(!isx9) return reply('Ja esta Desativado')
dataGp[0].x9 = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de x9 neste grupo, não irei notificar mais nenhuma alteração..✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'visualizarmsg':
if(!isOwner) return reply(enviar.msg.dono)
if(!isVisualizar) {
obrigadoEXT.visualizarmsg = true
setObg(obrigadoEXT)
reply('🌀 Ativou com sucesso o recurso de visualizar todas as mensagens enviada em grupos e privado 📝')
} else if(isVisualizar) {
obrigadoEXT.visualizarmsg = false
setObg(obrigadoEXT)
reply('‼️ Desativou com sucesso o recurso de visualizar todas as mensagens enviada em grupos e privado✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

/*case 'antispam':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntiSpam) return reply('Ja esta ativo')
dataGp[0].antispam = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de ANTI SPAM neste grupo 📝')
} else if(Number(args[0]) === 0) {
if(!isAntiSpam) return reply('Ja esta Desativado')
dataGp[0].antispam = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de ANTI SPAM neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break*/

case 'antivisu': case 'antivisuunica':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntiVisuUnica) return reply('Ja esta ativo')
dataGp[0].visuUnica = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de revelar visu única neste grupo 📝')
} else if(Number(args[0]) === 0) {
if(!isAntiVisuUnica) return reply('Ja esta Desativado')
dataGp[0].visuUnica = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de revelar visu única neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'admcmd':
case 'antimembros':
case 'blockgp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntiMembros) return reply('Ja esta ativo')
dataGp[0].soadm = true
setGp(dataGp)
reply('✅ Ativou com sucesso o recurso de só adm utilizar comandos neste grupo 📝')
} else if(Number(args[0]) === 0) {
if(!isAntiMembros) return reply('Ja esta Desativado')
dataGp[0].soadm = false
setGp(dataGp)
reply('‼️ Desativou o recurso de Só ADM utilizar comandos neste grupo ✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'antifake':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAntifake) return reply('Ja esta ativo')
dataGp[0].antifake = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de antifake neste grupo 📝')
} else if(Number(args[0]) === 0) {
if(!isAntifake) return reply('Ja esta Desativado')
dataGp[0].antifake = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de antifake neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'prefixos':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if(!isMultiP) return reply(`Para usar este comando, você deve ativar o comando, multiprefix\nExemplo: ${prefix}multiprefixo 1`)
if(dataGp[0].prefixos.length < 1) return reply("Não contem nenhum prefixo a + adicionado neste grupo.")
bla = `💌 *Olá @${sender.split("@")[0]}, os prefixos disponíveis são:*${dataGp[0].prefixos.map(i => `『 ${i} 』`).join("<->")}`
mention(bla)
break

case 'addprefixo':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if(!isMultiP) return reply(`Para usar este comando, você deve ativar o comando, multiprefix\nExemplo: ${prefix}multiprefixo 1`)
if(antiModLetra(q)) return reply("Não pode letra modificada, nem emoji..")
if(!q.trim()) return reply("Determine o novo prefixo, não pode espaço vazio...")
if(q.trim() > 1) return reply("Não pode adc mais de um prefixo de uma só vez...")
if(dataGp[0].prefixos.indexOf(q.trim()) >= 0) return reply(`Esse prefixo já se encontra incluso, procure ver na lista dos prefixos\nExemplo: ${prefix}prefixos`)
dataGp[0].prefixos.push(q.trim())
setGp(dataGp)
reply(`Prefixo [ ${q.trim()} ] adicionado com sucesso...`)
break

case 'tirarprefixo':
case 'delprefix':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if(!isMultiP) return reply(`Para usar este comando, você deve ativar o comando, multiprefix\nExemplo: ${prefix}multiprefixo 1`)  
if(antiModLetra(q)) return reply("Não pode letra modificada, nem emoji..")
if(!q.trim()) return reply("Determine o prefixo que deseja tirar, não pode espaço vazio...")
if(q.trim() > 1) return reply("Não pode remover mais de um prefixo de uma só vez...")
if(dataGp[0].prefixos.indexOf(q.trim()) < 0) return reply(`Esse prefixo não está incluso, procure ver na lista dos prefixos\nExemplo: ${prefix}prefixos`)
if(dataGp[0].prefixos.length == 1) return reply("Adicione um prefixo para pode tirar este, tem que ter pelo menos 1 prefixo já incluso dentro do sistema para tirar outro.")
dataGp[0].prefixos.splice(dataGp[0].prefixos.indexOf(q.trim()), 1)
setGp(dataGp)
reply(`Prefixo [ ${q.trim()} ] removido com sucesso...`)
break

case 'infomultiprefixo': case 'infomultiprefix':
if(!isOwner) return reply(enviar.msg.dono)
mention(`${tempo} @${sender.split("@")[0]}, irei te dar uma aula básica de como usar o multiprefixo:

${prefix}addprefixo
(Use este comando para adicionar mais prefixos neste grupo)

${prefix}tirarprefixo
(Use este comando para remover um dos prefixos neste grupo)

${prefix}prefixos
(Este comando irá mostrar todos os prefixos disponíveis neste grupo)

${prefix}multiprefixo
(E o básico de todos, este irá ativar/desativar o sistema de multiprefixo)`)
break

case 'multiprefixo': case 'multiprefix':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if(!isMultiP) {
dataGp[0].multiprefix = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de multi prefixos neste grupo 📝')
}
if(isMultiP) {
dataGp[0].multiprefix = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de multi prefixos neste grupo✔️')
}
break

case 'antinotas':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('Hmmmm')
if(Number(args[0]) === 1) {
if(isAntiNotas) return reply('Já Esta ativo')
dataGp[0].antinotas = true
setGp(dataGp)
reply('Ativou com sucesso o recurso de anti notas neste grupo✔️')
} else if(Number(args[0]) === 0) {
if(!isAntiNotas) return reply('Ja esta Desativado.')
dataGp[0].antinotas = false
setGp(dataGp)
reply('Desativou com sucesso o recurso de anti notas neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'anticatalogo':
case 'anticatalg':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAnticatalogo) return reply('Ja esta ativo')
dataGp[0].anticatalogo = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de anticatalogo neste grupo 📝')
} else if(Number(args[0]) === 0) {
if(!isAnticatalogo) return reply('Ja esta Desativado')
dataGp[0].anticatalogo = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de anticatalogo neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'bemvindo':
case 'welcome':
setTimeout(() => {reagir(from, "🫡")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply(`${prefix+command} 1 | ${prefix+command} 0`)
if(Number(args[0]) === 1) {
if(isWelkom) return reply('Ja esta ativo')
dataGp[0].wellcome[0].bemvindo1 = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de bem vindo neste grupo 📝')
} else if(Number(args[0]) === 0) {
if(!isWelkom) return reply('Ja esta Desativado')
dataGp[0].wellcome[0].bemvindo1 = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de bemvindo neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'bemvindo2':
case 'welcome2':
setTimeout(() => {reagir(from, "🫡")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply(`${prefix+command} 1 | ${prefix+command} 0`)
if(Number(args[0]) === 1) {
if(isWelkom2) return reply('✅ O recurso já está ativado no grupo ✅')
dataGp[0].wellcome[1].bemvindo2 = true
setGp(dataGp)
reply('✅O recurso foi ativado✅')
} else if(Number(args[0]) === 0) {
if(!isWelkom2) return reply('❌ O recurso não está ativado no grupo ❌')
dataGp[0].wellcome[1].bemvindo2 = false
setGp(dataGp)
reply('❌O recurso foi desativado❌')
} else {
reply(`Digite da forma correta:\nComando: ${prefix + command} 1, para ativar e 0 para desativar`)
}
break

case 'bemvindo3':
case 'welcome3':
setTimeout(() => {reagir(from, "🫡")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply(`${prefix+command} 1 | ${prefix+command} 0`)
if(Number(args[0]) === 1) {
if(isWelkom3) return reply('✅ O recurso já está ativado no grupo ✅')
dataGp[0].wellcome[2].bemvindo3 = true
setGp(dataGp)
reply('✅O recurso foi ativado✅')
} else if(Number(args[0]) === 0) {
if(!isWelkom3) return reply('❌ O recurso não está ativado no grupo ❌')
dataGp[0].wellcome[2].bemvindo3 = false
setGp(dataGp)
reply('❌O recurso foi desativado❌')
} else {
reply(`Digite da forma correta:\nComando: ${prefix + command} 1, para ativar e 0 para desativar`)
}
break

case 'bemvindo4':
case 'welcome4':
setTimeout(() => {reagir(from, "🫡")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply(`${prefix+command} 1 | ${prefix+command} 0`)
if(Number(args[0]) === 1) {
if(isWelkom4) return reply('✅ O recurso já está ativado no grupo ✅')
dataGp[0].wellcome[3].bemvindo4 = true
setGp(dataGp)
reply('✅O recurso foi ativado✅')
} else if(Number(args[0]) === 0) {
if(!isWelkom4) return reply('❌ O recurso não está ativado no grupo ❌')
dataGp[0].wellcome[3].bemvindo4 = false
setGp(dataGp)
reply('❌O recurso foi desativado❌')
} else {
reply(`Digite da forma correta:\nComando: ${prefix + command} 1, para ativar e 0 para desativar`)
}
break

case 'bemvindo5':
case 'welcome5':
setTimeout(() => {reagir(from, "🫡")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply(`${prefix+command} 1 | ${prefix+command} 0`)
if(Number(args[0]) === 1) {
if(isWelkom5) return reply('✅ O recurso já está ativado no grupo ✅')
dataGp[0].wellcome[4].bemvindo5 = true
setGp(dataGp)
reply('✅O recurso foi ativado✅')
} else if(Number(args[0]) === 0) {
if(!isWelkom5) return reply('❌ O recurso não está ativado no grupo ❌')
dataGp[0].wellcome[4].bemvindo5 = false
setGp(dataGp)
reply('❌O recurso foi desativado❌')
} else {
reply(`Digite da forma correta:\nComando: ${prefix + command} 1, para ativar e 0 para desativar`)
}
break

case 'legendabv':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de boas-vindas*')
teks = body.slice(11)
if(isWelkom) {
dataGp[0].wellcome[0].legendabv = Number(teks) === 0 ? 0 : teks
setGp(dataGp)
reply(`*Mensagem de boas vindas ${Number(teks) !== 0 ? `definida` : `desativada`} com sucesso!*`)
} else {
reply(`Ative o ${prefix}bemvindo 1`)
}
break

case 'legendasaiu':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de saída*')
teks = body.slice(13)
if(isWelkom) {
dataGp[0].wellcome[0].legendasaiu = Number(teks) === 0 ? 0 : teks
setGp(dataGp)
reply(`*Mensagem de saída ${Number(teks) !== 0 ? `definida` : `desativada`} com sucesso!*`)
} else {
reply(`Ative o ${prefix}bemvindo 1`)
}
break

case 'legendabv2':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de boas-vindas*')
teks = body.slice(12)
if(isWelkom2) {
dataGp[0].wellcome[1].legendabv = Number(teks) === 0 ? 0 : teks
setGp(dataGp)
reply(`*Mensagem de boas vindas2 ${Number(teks) !== 0 ? `definida` : `desativada`} com sucesso!*`)
} else {
reply(`Ative o ${prefix}bemvindo2 1`)
}
break

case 'legendasaiu2':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de saída*')
teks = body.slice(14)
if(isWelkom2) {
dataGp[0].wellcome[1].legendasaiu = Number(teks) === 0 ? 0 : teks
setGp(dataGp)
reply(`*Mensagem de saída2 ${Number(teks) !== 0 ? `definida` : `desativada`} com sucesso!*`)
} else {
reply(`Ative o ${prefix}bemvindo2 1`)
}
break

case 'stickerbv':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isWelkom3) return reply(`Ative o ${prefix}bemvindo3 1`)
fig = `./basededados/grupos/figurinhas/sticker-bv-${from}.webp`
if(Number(args[0]) === 0 && fs.existsSync(fig)) {DLT_FL(fig)
dataGp[0].wellcome[2].selobv = false
setGp(dataGp)
return reply(`A figurinha do bem vindo foi deletada com sucesso ✔`)}
if(!isQuotedSticker) return reply(`Marque uma figurinha...`)
sticker = info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage
media = await getFileBuffer(sticker, `sticker`)
fs.writeFileSync(fig, media)
if(q) {dataGp[0].wellcome[2].selobv = true
dataGp[0].wellcome[2].legendabv = q
setGp(dataGp)}
reply(`A figurinha do bem vindo foi definida com sucesso ✅`)
break

case 'stickersaiu':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isWelkom3) return reply(`Ative o ${prefix}bemvindo3 1`)
fig = `./basededados/grupos/figurinhas/sticker-saiu-${from}.webp`
if(Number(args[0]) === 0 && fs.existsSync(fig)) {DLT_FL(fig)
dataGp[0].wellcome[2].selosaiu = false
setGp(dataGp)
return reply(`A figurinha de saída foi deletada com sucesso ✔`)}
if(!isQuotedSticker) return reply(`Marque uma figurinha...`)
sticker = info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage
media = await getFileBuffer(sticker, `sticker`)
fs.writeFileSync(fig, media)
if(q) {dataGp[0].wellcome[2].selosaiu = true
dataGp[0].wellcome[2].legendasaiu = q
setGp(dataGp)}
reply(`A figurinha de saída foi definida com sucesso ✅`)
break

case 'audiobv':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isWelkom4) return reply(`Ative o ${prefix}bemvindo4 1`)
mp3 = `./basededados/grupos/audios/audio-bv-${from}.mp3`
if(Number(args[0]) === 0 && fs.existsSync(mp3)) {DLT_FL(mp3)
dataGp[0].wellcome[3].selobv = false
setGp(dataGp)
return reply(`O áudio do bem vindo foi deletado com sucesso ✔`)}
if(!isQuotedAudio) return reply(`Marque um áudio...`)
audio = info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage
media = await getFileBuffer(audio, 'audio')
fs.writeFileSync(mp3, media)
if(q) {dataGp[0].wellcome[3].selobv = true
dataGp[0].wellcome[3].legendabv = q
setGp(dataGp)}
reply(`O áudio do bem vindo foi definido com sucesso ✅`)
break

case 'audiosaiu':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isWelkom4) return reply(`Ative o ${prefix}bemvindo4 1`)
mp3 = `./basededados/grupos/audios/audio-saiu-${from}.mp3`
if(Number(args[0]) === 0 && fs.existsSync(mp3)) {DLT_FL(mp3)
dataGp[0].wellcome[3].selosaiu = false
setGp(dataGp)
return reply(`O áudio de saída foi deletado com sucesso ✔`)}
if(!isQuotedAudio) return reply(`Marque um áudio...`)
audio = info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage
media = await getFileBuffer(audio, 'audio')
fs.writeFileSync(mp3, media)
if(q) {dataGp[0].wellcome[3].selosaiu = true
dataGp[0].wellcome[3].legendabv = q
setGp(dataGp)}
reply(`O áudio de saída foi definido com sucesso ✅`)
break

case 'legendabv5':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de boas-vindas*')
teks = q
if(isWelkom) {
dataGp[0].wellcome[4].legendabv = Number(teks) === 0 ? 0 : teks
setGp(dataGp)
reply(`*Mensagem de boas vindas ${Number(teks) !== 0 ? `definida` : `desativada`} com sucesso!*`)
} else {
reply(`Ative o ${prefix}bemvindo5 1`)
}
break

case 'legendasaiu5':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de saída*')
teks = q
if(isWelkom) {
dataGp[0].wellcome[4].legendasaiu = Number(teks) === 0 ? 0 : teks
setGp(dataGp)
reply(`*Mensagem de saída ${Number(teks) !== 0 ? `definida` : `desativada`} com sucesso!*`)
} else {
reply(`Ative o ${prefix}bemvindo5 1`)
}
break

case 'legenda-estrangeiro':
case 'legenda-estrangeiros': 
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de remoção de estrangeiros*')
if(isAntifake) {
dataGp[0].legenda_estrangeiro = q
setGp(dataGp)
reply('*Mensagem de remoção de estrangeiros definida com sucesso!*')
} else {
reply(`Ative o antifake primeiro com ${prefix}antifake 1`)
}
break

case 'legenda-video': 
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de remoção de estrangeiros*')
dataGp[0].legenda_video = q
setGp(dataGp)
reply('*Mensagem de remoção de video definida com sucesso!*')
break

case 'legenda-imagem': 
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de remoção de estrangeiros*')
dataGp[0].legenda_imagem = q
setGp(dataGp)
reply('*Mensagem de remoção de imagem definida com sucesso!*')
break

case 'legenda-documento': 
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('*Escreva a mensagem de remoção de estrangeiros*')
dataGp[0].legenda_documento = q
setGp(dataGp)
reply('*Mensagem de remoção de Documento definida com sucesso!*')
break

case 'addautorm':
case 'addautoban':
case 'listanegra':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!mrc_ou_numero) return reply("Marque a mensagem do usuário com o comando ou utilize o comando com o número do usuário que deseja adicionar na lista negra..")
if(dataGp[0].listanegra.includes(mrc_ou_numero)) return reply('*Esse Número ja esta incluso*')
dataGp[0].listanegra.push(mrc_ou_numero)
setGp(dataGp)
reply(`*Número adicionado a lista de autoban* 🙅🏻‍♂️`)
break

case 'autobang':
case 'listanegrag':
if(!isOwner) return reply(enviar.msg.dono)
if(!mrc_ou_numero) return reply("Marque a mensagem do usuário com o comando ou utilize o comando com o número do usuário que deseja adicionar na lista negra Global..")
if(listanegraG.includes(mrc_ou_numero)) return reply('*Esse Número ja esta incluso*')
listanegraG.push(mrc_ou_numero)
fs.writeFileSync('./dono/config-all.json', JSON.stringify(obrigadoEXT, null, '\t'))
reply(`*Número adicionado a lista de autoban*`)
break

case 'delautobang':
case 'tirardalistag':
if(!isOwner) return reply(enviar.msg.dono)
if(!mrc_ou_numero) return reply("Marque a mensagem do usuário com o comando ou utilize o comando com o número do usuário que deseja tirar da lista negra..")
if(!listanegraG.includes(mrc_ou_numero)) return reply('*Esse Número não esta incluso*')
var i = listanegraG.indexOf(mrc_ou_numero)
listanegraG.splice(i, 1)
fs.writeFileSync('./dono/config-all.json', JSON.stringify(obrigadoEXT, null, '\t'))
reply(`*Número foi removido da lista negra*`)
break

case 'admautoban':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply('Precisa ser Dono')
if(!q.includes(`chat.whatsapp.com`)) return reply(`Insira o link do grupo...`)
var linkRegex = /chat.whatsapp.com\/([0-9A-Za-z]{20,24})/i
    var [_, code] = q.match(linkRegex) || []
    if (!code)return reply('Link Invalido')
    var res = await blackmd.groupAcceptInvite(code)
reply("espere um momento")
resp = await blackmd.groupMetadata(res)
ggg = resp.participants.filter((i) => i.admin)
nunber = ``
for(number of ggg){
await delay(1000)
dataGp[0].listanegra.push(number.id)
setGp(dataGp)
nunber += `# ${number.id.match(/([0-9A-Za-z]{10,14})/i)[0]}\n`
}
reply(`*Números Adicionados A Lista De Autoban*
*${ggg.length} Pessoas Adicionadas A Lista De Autoban*
${nunber}`)
await delay(1000)
blackmd.groupLeave(resp.id)
break

case 'delremover':
case 'delautorm':  
case 'delautoban': 
case 'tirardalista':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!mrc_ou_numero) return reply("Marque a mensagem do usuário com o comando ou utilize o comando com o número do usuário que deseja tirar da lista negra..")
if(!dataGp[0].listanegra.includes(mrc_ou_numero)) return reply('*Esse Número não esta incluso*')
var i = dataGp[0].listanegra.indexOf(mrc_ou_numero)
dataGp[0].listanegra.splice(i, 1)
setGp(dataGp)
reply(`*Número foi removido da lista de autoban*`)
break

case 'listban':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(dataGp[0].listanegra.length < 1) return reply('*Nenhum Número não foi adicionado*')
teks = '*Números que vou moer na porrada se voltar 😡:*\n'
for(i=0;i<dataGp[0].listanegra.length;++i) {
teks += `⇒ *${dataGp[0].listanegra[i].split('@')[0]}*\n`
}
teks += '*Esses ai vou descer meu martelo do ban 🥵*'
reply(teks)
break

case 'savemp3': case 'savem4a':
if(!isOwner) return reply(enviar.msg.dono)
var [tx, rct] = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/").split("/")
if(!tx) return reply("KD o título do áudio?")
if(antiModLetra(tx)) return reply("Não pode letras modificadas nem emoji..")
if(!isQuotedAudio) return reply("Marque um áudio por favor...")
mod = rmLetras(tx)
ini = mod.split(" ").join("_")
media = info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage
fim = media.mimetype.split("/")[1] == "mpeg" ? "mp3" : media.mimetype.split("/")[1] == "mp4" ? "m4a" : "ogg"
nome = ini+"."+fim
doc = await getFileBuffer(media, 'audio')
fs.writeFileSync(`./database/audios/save/${nome}`, doc)
AB = audios.map(i => i.rm).indexOf(nome)
if(AB >= 0) {
  audios.splice(AB, 1)
  saveJSON(audios, "./database/data/audios.json")
}
audios.push({txt: mod, rm: nome, emoji: rct || ""})
saveJSON(audios, "./database/data/audios.json")
reply(`*O áudio ${nome} foi salvo na pasta com sucesso...* ✅`)
break

case 'delmp3': case 'delm4a':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply("KD o título do áudio?")
if(antiModLetra(q)) return reply("Não pode letras modificadas nem emoji..")
mod = rmLetras(q)
ini = mod.split(" ").join("_")
exec(`ls ./database/audios/save`, (err, stdout) => {
  if(err) {
    console.log(err)
  }
  if(stdout) {
    nmr = -1
    caixa = []
    for(i of audios) {
      nmr += 1
      if(ini == i.rm.split(`.`)[0]) caixa.push(nmr)
    }
    if(caixa.length <= 0) return reply(`[❗] áudio não encontrado ou inexistente ❌`)
    AB = caixa[0]
    nome = audios[AB].rm
    DLT_FL(`./database/audios/save/${nome}`)
    audios.splice(AB, 1)
    saveJSON(audios, "./database/data/audios.json")
    reply(`*O áudio ${nome} foi deletado da pasta com sucesso...* ✅`)
  }
})
break

case 'listmp3': case 'listm4a':
if(!isOwner) return reply(enviar.msg.dono)
if(audios.length <= 0) return reply("Não há áudios salvos na pasta")
txt = `🎧 *Total:* ${audios.length}`
for(i = 0; i < audios.length; i++) {
txt += `\n${audios[i].emoji.length > 0 ? audios[i].emoji : react1[Math.floor(Math.random()*react1.length)]}⃤ »${i+1}« ${audios[i].rm}`
}
reply(txt)
break

case 'botversion':
botv = JSON.parse(fs.readFileSync(`./package.json`)).version
sendRouletteButton(from, {image: {url: logoslink.logo}, caption: `🎲 Versão atual do bot - ${botv}`, footer: `New Black V4 Oficial Update`}, blackmd, sender, [{type: `copy_url`, text: NomeDoBot, url: `https://github.com/m4thxyz/blackofc`}], seloctt)
break


// INTELIGÊNCIA ARTIFICIAL // IAS

case 'deepimage':
  if (!q) return reply(`Envie o texto para gerar a imagem.\nExemplo: *${prefix}deepimage gato fofo*`);

  if (!global.deepPrompt) global.deepPrompt = {};

  // Se o usuário ainda não escolheu o modelo, salva o prompt
  if (!global.deepPrompt[sender]) {
    global.deepPrompt[sender] = q.trim();
    
    // Lista de modelos disponíveis
    const modelosDeep = [
  { name: `✨ Cute Creature`, title: `Criatura Fofa`, body: 'Gera criaturas fofas', command: `${prefix}deepimage cute-creature-generator` },
  { name: `✨ Fantasy World`, title: `Mundo Fantástico`, body: 'Gera mundos de fantasia', command: `${prefix}deepimage fantasy-world-generator` },
  { name: `✨ Cyberpunk`, title: `Cenário Cyberpunk`, body: 'Gera cenários futuristas cyberpunk', command: `${prefix}deepimage cyberpunk-generator` },
  { name: `✨ Anime Portrait`, title: `Retrato Anime`, body: 'Gera retratos estilo anime', command: `${prefix}deepimage anime-portrait-generator` },
  { name: `✨ Old Style`, title: `Estilo Antigo`, body: 'Gera arte em estilo antigo', command: `${prefix}deepimage old-style-generator` },
  { name: `✨ Renaissance Painting`, title: `Pintura Renascentista`, body: 'Gera imagens no estilo renascentista', command: `${prefix}deepimage renaissance-painting-generator` },
  { name: `✨ Abstract Painting`, title: `Pintura Abstrata`, body: 'Gera arte abstrata', command: `${prefix}deepimage abstract-painting-generator` },
  { name: `✨ Impressionism Painting`, title: `Pintura Impressionista`, body: 'Gera imagens impressionistas', command: `${prefix}deepimage impressionism-painting-generator` },
  { name: `✨ Surreal Graphics`, title: `Gráficos Surreais`, body: 'Gera imagens surreais', command: `${prefix}deepimage surreal-graphics-generator` },
  { name: `✨ 3D Objects`, title: `Objetos 3D`, body: 'Gera objetos em 3D', command: `${prefix}deepimage 3d-objects-generator` },
  { name: `✨ Origami 3D`, title: `Origami 3D`, body: 'Gera imagens de origamis em 3D', command: `${prefix}deepimage origami-3d-generator` },
  { name: `✨ Hologram 3D`, title: `Holograma 3D`, body: 'Gera hologramas 3D', command: `${prefix}deepimage hologram-3d-generator` },
  { name: `✨ 3D Character`, title: `Personagem 3D`, body: 'Gera personagens 3D', command: `${prefix}deepimage 3d-character-generator` },
  { name: `✨ Watercolor Painting`, title: `Pintura em Aquarela`, body: 'Gera aquarelas', command: `${prefix}deepimage watercolor-painting-generator` },
  { name: `✨ Pop Art`, title: `Pop Art`, body: 'Gera arte pop', command: `${prefix}deepimage pop-art-generator` },
  { name: `✨ Contemporary Architecture`, title: `Arquitetura Contemporânea`, body: 'Gera arquitetura moderna', command: `${prefix}deepimage contemporary-architecture-generator` },
  { name: `✨ Future Architecture`, title: `Arquitetura Futurista`, body: 'Gera arquitetura do futuro', command: `${prefix}deepimage future-architecture-generator` },
  { name: `✨ Watercolor Architecture`, title: `Arquitetura em Aquarela`, body: 'Gera prédios em aquarela', command: `${prefix}deepimage watercolor-architecture-generator` },
  { name: `✨ Fantasy Character`, title: `Personagem Fantástico`, body: 'Gera personagens de fantasia', command: `${prefix}deepimage fantasy-character-generator` },
  { name: `✨ Steampunk`, title: `Estilo Steampunk`, body: 'Gera imagens steampunk', command: `${prefix}deepimage steampunk-generator` },
  { name: `✨ Logo`, title: `Logo Criativo`, body: 'Gera logos automáticos', command: `${prefix}deepimage logo-generator` },
  { name: `✨ Pixel Art`, title: `Arte em Pixel`, body: 'Gera pixel arts', command: `${prefix}deepimage pixel-art-generator` },
  { name: `✨ Street Art`, title: `Arte de Rua`, body: 'Gera grafites de rua', command: `${prefix}deepimage street-art-generator` },
  { name: `✨ Surreal Portrait`, title: `Retrato Surreal`, body: 'Gera retratos surreais', command: `${prefix}deepimage surreal-portrait-generator` },
  { name: `✨ Anime World`, title: `Mundo Anime`, body: 'Gera cenários estilo anime', command: `${prefix}deepimage anime-world-generator` },
  { name: `✨ Fantasy Portrait`, title: `Retrato Fantástico`, body: 'Gera retratos de fantasia', command: `${prefix}deepimage fantasy-portrait-generator` },
  { name: `✨ Comics Portrait`, title: `Retrato em HQ`, body: 'Gera retratos estilo quadrinhos', command: `${prefix}deepimage comics-portrait-generator` },
  { name: `✨ Cyberpunk Portrait`, title: `Retrato Cyberpunk`, body: 'Gera retratos futuristas', command: `${prefix}deepimage cyberpunk-portrait-generator` },
  { name: `✨ Neo-Noir`, title: `Neo Noir`, body: 'Gera arte no estilo Neo Noir', command: `${prefix}deepimage neo-noir-generator` },
  { name: `✨ Pixel World`, title: `Mundo Pixelado`, body: 'Gera mundos em pixel', command: `${prefix}deepimage pixel-world-generator` },
  { name: `✨ Manga Panel`, title: `Painel de Mangá`, body: 'Gera painéis de mangás', command: `${prefix}deepimage manga-panel-genarator` },
  { name: `✨ 3D Cartoon`, title: `Cartoon 3D`, body: 'Gera cartoons em 3D', command: `${prefix}deepimage 3d-cartoon-generator` },
  { name: `✨ Fantasy Map`, title: `Mapa Fantástico`, body: 'Gera mapas de fantasia', command: `${prefix}deepimage fantasy-map-generator` },
  { name: `✨ Cyber Beast`, title: `Bestas Cibernéticas`, body: 'Gera feras futuristas', command: `${prefix}deepimage cyber-beast-generator` },
  { name: `✨ Dystopian Landscape`, title: `Paisagem Distópica`, body: 'Gera mundos distópicos', command: `${prefix}deepimage dystopian-landscape-generator` },
  { name: `✨ Ocean Life`, title: `Vida Marinha`, body: 'Gera cenas submarinas', command: `${prefix}deepimage ocean-life-generator` },
  { name: `✨ Space World`, title: `Mundo Espacial`, body: 'Gera cenários espaciais', command: `${prefix}deepimage space-world-generator` },
  { name: `✨ Comics Superhero`, title: `Herói de HQ`, body: 'Gera super-heróis', command: `${prefix}deepimage comics-superhero-generator` },
  { name: `✨ Anime Superhero`, title: `Super-herói Anime`, body: 'Gera heróis estilo anime', command: `${prefix}deepimage anime-superhero-generator` },
  { name: `✨ Prophetic Vision`, title: `Visão Profética`, body: 'Gera imagens de visões', command: `${prefix}deepimage prophetic-vision-generator` },
  { name: `✨ Grotesque Art`, title: `Arte Grotesca`, body: 'Gera imagens bizarras', command: `${prefix}deepimage grotesque-art-generator` },
  { name: `✨ Tribal Art`, title: `Arte Tribal`, body: 'Gera arte tribal', command: `${prefix}deepimage tribal-art-generator` },
  { name: `✨ Mysticism Art`, title: `Arte Mística`, body: 'Gera imagens místicas', command: `${prefix}deepimage mysticism-art-generator` },
  { name: `✨ Urban Fashion`, title: `Moda Urbana`, body: 'Gera looks de rua', command: `${prefix}deepimage urban-fashion-generator` },
  { name: `✨ Children Book`, title: `Livro Infantil`, body: 'Gera ilustrações infantis', command: `${prefix}deepimage children-book-generator` },
  { name: `✨ Minimalistic Art`, title: `Arte Minimalista`, body: 'Gera arte simples e limpa', command: `${prefix}deepimage minimalistic-art-generator` },
  { name: `✨ Art Deco`, title: `Arte Déco`, body: 'Gera arte estilo déco', command: `${prefix}deepimage art-deco-generator` },
  { name: `✨ Haunted Portrait`, title: `Retrato Assombrado`, body: 'Gera retratos assustadores', command: `${prefix}deepimage haunted-portrait-generator` },
  { name: `✨ Steampunk Landscape`, title: `Paisagem Steampunk`, body: 'Gera paisagens steampunk', command: `${prefix}deepimage steampunk-landscape-generator` },
  { name: `✨ Art Nouveau`, title: `Arte Nouveau`, body: 'Gera imagens nouveau', command: `${prefix}deepimage art-nouveau-generator` },
  { name: `✨ Baroque Art`, title: `Arte Barroca`, body: 'Gera imagens barrocas', command: `${prefix}deepimage baroque-art-generator` },
  { name: `✨ Gothic Art`, title: `Arte Gótica`, body: 'Gera arte no estilo gótico', command: `${prefix}deepimage gothic-art-generator` },
  { name: `✨ Cubist Art`, title: `Arte Cubista`, body: 'Gera imagens cubistas', command: `${prefix}deepimage cubist-art-generator` },
  { name: `✨ Romantic Art`, title: `Arte Romântica`, body: 'Gera imagens românticas', command: `${prefix}deepimage romantic-art-generator` },
  { name: `✨ Photorealistic Portrait`, title: `Retrato Realista`, body: 'Gera retratos realistas', command: `${prefix}deepimage photorealistic-portrait-generator` },
  { name: `✨ Chibi Character`, title: `Personagem Chibi`, body: 'Gera personagens chibi', command: `${prefix}deepimage chibi-character-generator` },
  { name: `✨ Dreamscape`, title: `Paisagem dos Sonhos`, body: 'Gera cenas surreais', command: `${prefix}deepimage dreamscape-generator` },
  { name: `✨ Mecha Suit`, title: `Armadura Mecha`, body: 'Gera robôs mecha', command: `${prefix}deepimage mecha-suit-generator` },
  { name: `✨ Abstract Expressionism`, title: `Expressionismo Abstrato`, body: 'Gera arte abstrata', command: `${prefix}deepimage abstract-expressionism-generator` },
];

    const botaodeep = [
      { title: `SELECIONE UM MODELO`, options: modelosDeep.map(m => ({
        name: m.name,
        title: m.title,
        body: m.body,
        command: m.command
      }))}
    ];

    try {
      img = await blackmd.profilePictureUrl(sender, 'image');
    } catch {
      img = semfoto;
    }

    if (isGroup) reply(`Enviando PV 🔰`);

    // Armazena a mensagem que disparou o comando
    const m = msg;

    sendRouletteButton(sender, { image: { url: img }, caption: `✏️ Texto: *${q}*\n\nEscolha o estilo abaixo para gerar a imagem:`, footer: NomeDoBot }, blackmd, sender, [{ type: `list`, title: `🎨 Modelos DeepImage`, rowId: botaodeep }], seloctt);
  } else {
    // Se o usuário já escolheu um modelo, gera a imagem
    const modelo = q.trim(); // O modelo escolhido
    const prompt = global.deepPrompt[sender];

    try {
      let { data } = await axios.get(`https://api.vreden.my.id/api/artificial/deepimage/${modelo}?prompt=${encodeURIComponent(prompt)}&shape=portrait`);
      
      if (data?.result?.output_url) {
        blackmd.sendMessage(sender, { image: { url: data.result.output_url }, caption: `🖼️ Imagem gerada para:\n\n*${prompt}*\n\nModelo: *${modelo.replace('-generator', '').replace(/-/g, ' ')}*` }, { quoted: info });
      } else {
        reply(`❌ Erro ao gerar a imagem.`);
      }
    } catch (e) {
      console.error(e);
      reply(`❌ Ocorreu um erro ao gerar a imagem.`);
    }

    // Apaga o prompt após a geração da imagem
    delete global.deepPrompt[sender];
  }
  break;

case 'animarfoto':
case 'fotoemdesenho':
    try {
        let imageUrl;
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            // Se for mídia (foto enviada ou marcada)
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            let uploadResult = await upload(owgi);
            imageUrl = uploadResult;
        } else if (q && q.includes('http')) {
            // Se for um link enviado no texto
            imageUrl = q.trim();
        } else {
            return reply('⚙️ Marque uma foto ou envie o link direto da imagem.');
        }

        reply(`Aguarde ${pushname}, estou processando sua imagem...`);

        // Faz a chamada na API
        const vredenApi = `https://api.vreden.my.id/api/artificial/aiease/img2img/filter?url=${encodeURIComponent(imageUrl)}&style=4`;
        const vredenResponse = await axios.get(vredenApi);

        if (vredenResponse.data.status === 200 && vredenResponse.data.result && vredenResponse.data.result.length > 0) {
            const resultImage = vredenResponse.data.result[0].origin;

            // Baixa a imagem resultante
            const resultBuffer = await axios.get(resultImage, { responseType: 'arraybuffer' });

            await blackmd.sendMessage(from, {
                image: Buffer.from(resultBuffer.data, 'binary'),
                caption: `Aqui está sua imagem animada!`,
            });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível processar a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao animar/desenhar foto:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao tentar processar a imagem.' }, { quoted: info });
    }
    break;
    case 'expandirfoto':
case 'expandir':
    try {
        let imageUrl;
        
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            // Se for mídia (foto enviada ou marcada)
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            let uploadResult = await upload(owgi);
            imageUrl = uploadResult;
        } else if (q && q.includes('http')) {
            // Se for um link enviado no texto
            imageUrl = q.trim();
        } else {
            return reply('⚙️ Marque uma foto ou envie o link direto da imagem.');
        }

        reply(`Aguarde ${pushname}, estou expandindo sua imagem...`);

        // Faz a chamada na API de Expandir
        const expandApi = `https://api.vreden.my.id/api/artificial/imgedit/expand?url=${encodeURIComponent(imageUrl)}&top=100&bottom=100&left=100&right=100`;
        const expandResponse = await axios.get(expandApi, { responseType: 'arraybuffer' });

        await blackmd.sendMessage(from, {
            image: Buffer.from(expandResponse.data, 'binary'),
            caption: `Aqui está sua imagem expandida!`,
        }, { quoted: info });

    } catch (error) {
        console.error('Erro ao expandir a imagem:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao tentar expandir a imagem.' }, { quoted: info });
    }
    break;

    case 'hdr':
    case 'melhorarfoto':
    try {
        let imageUrl;
        
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            // Se for mídia (foto enviada ou marcada)
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            let uploadResult = await upload(owgi);
            imageUrl = uploadResult;
        } else if (q && q.includes('http')) {
            // Se for um link enviado no texto
            imageUrl = q.trim();
        } else {
            return reply('⚙️ Marque uma foto ou envie o link direto da imagem.');
        }

        reply(`Aguarde ${pushname}, estou processando sua imagem HDR...`);

        // Faz a chamada na API de HDR
        const hdrApi = `https://api.vreden.my.id/api/artificial/hdr?url=${encodeURIComponent(imageUrl)}&pixel=4`;
        const hdrResponse = await axios.get(hdrApi);

        if (hdrResponse.data.status === 200 && hdrResponse.data.result && hdrResponse.data.result.data.downloadUrls.length > 0) {
            const resultImage = hdrResponse.data.result.data.downloadUrls[0];

            // Baixa a imagem resultante
            const resultBuffer = await axios.get(resultImage, { responseType: 'arraybuffer' });

            await blackmd.sendMessage(from, {
                image: Buffer.from(resultBuffer.data, 'binary'),
                caption: `Aqui está sua imagem HDR!`,
            });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível processar a imagem HDR.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao melhorar foto HDR:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao tentar processar a imagem HDR.' }, { quoted: info });
    }
    break;
case 'animagine':
case 'gerar-animagine':
    if (!q) return blackmd.sendMessage(from, { text: '[⚙️️] Por favor, forneça o texto para gerar a imagem. Exemplo: !animagine Sua descrição aqui' }, { quoted: info });

    const promptAnimagine = encodeURIComponent(q);
    const apiUrlAnimagine = `https://api.vreden.my.id/api/artificial/animagine?prompt=${promptAnimagine}`;

    try {
        reply(`Aguarde ${pushname}, estou gerando sua imagem com estilo Animagine...`);

        const responseAnimagine = await axios.get(apiUrlAnimagine);

        if (responseAnimagine.data.status === 200 && responseAnimagine.data.result && responseAnimagine.data.result.output && responseAnimagine.data.result.output.data.length > 0) {
            const animagineImage = responseAnimagine.data.result.output.data[0].image.url;

            const animagineBuffer = await axios.get(animagineImage, { responseType: 'arraybuffer' });

            await blackmd.sendMessage(from, {
                image: Buffer.from(animagineBuffer.data, 'binary'),
                caption: `Aqui está sua imagem gerada: ${q}`,
            });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível gerar a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao gerar imagem Animagine:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao gerar a imagem.' }, { quoted: info });
    }
    break;
    case 'colorir':
case 'colorir-foto':
    try {
        let imageUrl;
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            // Se for imagem enviada ou marcada
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            let uploadResult = await upload(owgi);
            imageUrl = uploadResult;
        } else if (q && q.includes('http')) {
            // Se for link enviado
            imageUrl = q.trim();
        } else {
            return reply('⚙️ Você precisa marcar uma imagem ou enviar o link direto.');
        }

        reply(`Aguarde ${pushname}, estou colorindo sua foto...`);

        const colorizerApi = `https://api.vreden.my.id/api/artificial/colorizer?url=${encodeURIComponent(imageUrl)}`;
        const responseColorizer = await axios.get(colorizerApi);

        if (responseColorizer.data.status === 200 && responseColorizer.data.result) {
            const colorizedImage = responseColorizer.data.result;

            const colorizedBuffer = await axios.get(colorizedImage, { responseType: 'arraybuffer' });

            await blackmd.sendMessage(from, {
                image: Buffer.from(colorizedBuffer.data, 'binary'),
                caption: `Aqui está sua foto colorida!`,
            });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível colorir a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao colorir foto:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao tentar colorir a imagem.' }, { quoted: info });
    }
    break;
case 'flux':
case 'gerar-flux':
    if (!q) return blackmd.sendMessage(from, { text: '[⚙️️] Por favor, forneça o texto para gerar a imagem. Exemplo: !gerar-flux Sua descrição aqui' }, { quoted: info });

    const promptFlux = encodeURIComponent(q);
    const apiUrlFlux = `https://api.vreden.my.id/api/artificial/flux?prompt=${promptFlux}&model=flux_1_schnell&size=1_1_HD&style=anime&color=vibrant&lighting=golden_hour`;

    try {
        reply(`Aguarde um momento ${pushname}, estou gerando sua imagem...`);

        const responseFlux = await axios.get(apiUrlFlux, { responseType: 'arraybuffer' });

        await blackmd.sendMessage(from, {
            image: Buffer.from(responseFlux.data, 'binary'),
            caption: `Imagem gerada para: ${q}`,
        }, { quoted: info });

    } catch (error) {
        console.error('Erro ao gerar imagem usando Flux:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao gerar a imagem.' }, { quoted: info });
    }
    break;
    // Função para gerar imagem Flux
async function gerarImagemFlux(from, info, pushname, q, estilo) {
    if (!q) {
        return blackmd.sendMessage(from, { text: `[⚙️️] Por favor, forneça a descrição.\nExemplo: .flux-${estilo} sua descrição aqui` }, { quoted: info });
    }

    const promptEncoded = encodeURIComponent(q);
    const apiUrlFlux = `https://api.vreden.my.id/api/artificial/flux?prompt=${promptEncoded}&model=flux_1_schnell&size=1_1_HD&style=${estilo}&color=vibrant&lighting=golden_hour`;

    try {
        reply(`Aguarde um momento ${pushname}, estou gerando sua imagem com estilo *${estilo.replace('_', ' ')}*...`);

        const responseFlux = await axios.get(apiUrlFlux, { responseType: 'arraybuffer' });

        await blackmd.sendMessage(from, {
            image: Buffer.from(responseFlux.data, 'binary'),
            caption: `Imagem gerada para: ${q}`,
        }, { quoted: info });
    } catch (error) {
        console.error(`Erro ao gerar imagem estilo ${estilo}:`, error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao gerar a imagem.' }, { quoted: info });
    }
}

// Cases de cada estilo
case 'flux-anime':
    await gerarImagemFlux(from, info, pushname, q, 'anime');
    break;

case 'flux-digital':
    await gerarImagemFlux(from, info, pushname, q, 'digital');
    break;

case 'flux-fantasy':
    await gerarImagemFlux(from, info, pushname, q, 'fantasy');
    break;

case 'flux-neon_punk':
    await gerarImagemFlux(from, info, pushname, q, 'neon_punk');
    break;

case 'flux-dark':
    await gerarImagemFlux(from, info, pushname, q, 'dark');
    break;

case 'flux-low_poly':
    await gerarImagemFlux(from, info, pushname, q, 'low_poly');
    break;

case 'flux-line_art':
    await gerarImagemFlux(from, info, pushname, q, 'line_art');
    break;

case 'flux-pixel_art':
    await gerarImagemFlux(from, info, pushname, q, 'pixel_art');
    break;

case 'flux-comic':
    await gerarImagemFlux(from, info, pushname, q, 'comic');
    break;

case 'flux-analog_film':
    await gerarImagemFlux(from, info, pushname, q, 'analog_film');
    break;

case 'flux-surreal':
    await gerarImagemFlux(from, info, pushname, q, 'surreal');
    break;

case 'fluximg':
    await gerarImagemFlux(from, info, pushname, q, 'no_style');
    break;
case 'escreverlivro':
case 'escrever-livro':
    if (!q) return blackmd.sendMessage(from, { text: '[⚙️] Por favor, forneça o texto que deseja que seja escrito no livro. Exemplo: !escreverlivro Seu texto aqui.' }, { quoted: info });

    try {
        reply(`✍️ Aguarde ${pushname}, estou escrevendo seu livro...`);

        const encodedText = encodeURIComponent(q);
        const apiUrl = `https://api.ownblox.biz.id/api/nulis?text=${encodedText}`;
        
        const response = await axios.get(apiUrl, { responseType: 'arraybuffer' });

        await blackmd.sendMessage(from, {
            image: Buffer.from(response.data, 'binary'),
            caption: `Aqui está seu texto escrito no livro!`,
        }, { quoted: info });

    } catch (error) {
        console.error('Erro ao gerar imagem de escrita:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao tentar escrever no livro.' }, { quoted: info });
    }
    break;
case 'gerarqrcode':
case 'gerar-qrcode':
    try {
        if (!q) return blackmd.sendMessage(from, { text: '⚙️ Por favor, envie o texto ou link que deseja transformar em QR Code.\n\nExemplo: !gerarqrcode https://meusite.com' }, { quoted: info });

        reply(`Aguarde ${pushname}, estou gerando seu QR Code...`);

        const qrApiUrl = `https://api.ownblox.biz.id/api/qrcodegenerator?text=${encodeURIComponent(q)}`;
        const qrResponse = await axios.get(qrApiUrl, { responseType: 'arraybuffer' });

        await blackmd.sendMessage(from, {
            image: Buffer.from(qrResponse.data, 'binary'),
            caption: `QR Code gerado para: ${q}`,
        }, { quoted: info });

    } catch (error) {
        console.error('Erro ao gerar QR Code:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao gerar o QR Code.' }, { quoted: info });
    }
    break;
case 'amazonai':
case 'gerar-amazonai':
    if (!q) return blackmd.sendMessage(from, { text: '[⚙️️] Por favor, forneça o texto para gerar a imagem. Exemplo: !gerar-amazonai Sua descrição aqui' }, { quoted: info });

    const promptAmazon = encodeURIComponent(q); // Codifica o prompt para a URL
    const apiUrlAmazon = `https://api.vreden.my.id/api/artificial/amazonai?prompt=${promptAmazon}&frame=6`;

    try {
        reply(`aguarde um momento ${pushname}, estou gerando sua imagem...`);

        const responseAmazon = await axios.get(apiUrlAmazon);
        
        if (responseAmazon.data.status === 200 && responseAmazon.data.result && responseAmazon.data.result.image_link) {
            const imageUrl = responseAmazon.data.result.image_link;

            // Baixa a imagem para enviar
            const imageBuffer = await axios.get(imageUrl, { responseType: 'arraybuffer' });
            
            await blackmd.sendMessage(from, {
                image: Buffer.from(imageBuffer.data, 'binary'),
                caption: `Imagem gerada para: ${q}`,
            });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível gerar a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao gerar imagem usando AmazonAI:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao gerar a imagem.' }, { quoted: info });
    }
    break;
    case 'Mora': 
    case 'mora':
    if (!q) return blackmd.sendMessage(from, { text: '[⚙️️] Por favor, envie a sua pergunta. Exemplo: .mora Que dia é hoje?' }, { quoted: info });

    const queryMora = encodeURIComponent(q);
    const usernameMora = encodeURIComponent(pushname || 'usuário');
    const apiUrlMora = `https://api.vreden.my.id/api/mora?query=responda empoetugues:${queryMora}&username=${usernameMora}`;

    try {

        const responseMora = await axios.get(apiUrlMora);
        
        if (responseMora.data.status === 200 && responseMora.data.result) {
            blackmd.sendMessage(from, { text: responseMora.data.result }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não consegui obter resposta da Mora.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao consultar Mora:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao tentar falar com a Mora.' }, { quoted: info });
    }
    break;
    case 'qio':
    case 'qioo2':
    if (!q) return blackmd.sendMessage(from, { text: '[⚙️️] Por favor, envie a sua mensagem. Exemplo: .qioo2 Oi, tudo bem?' }, { quoted: info });

    const queryQioo2 = encodeURIComponent(q);
    const usernameQioo2 = encodeURIComponent(pushname || 'usuário');
    const apiUrlQioo2 = `https://api.vreden.my.id/api/qioo2?query=reesponda em português:${queryQioo2}&username=${usernameQioo2}`;

    try {

        const responseQioo2 = await axios.get(apiUrlQioo2);
        
        if (responseQioo2.data.status === 200 && responseQioo2.data.result) {
            blackmd.sendMessage(from, { text: responseQioo2.data.result }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não consegui obter resposta do Qioo2.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao consultar Qioo2:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao tentar falar com o Qioo2.' }, { quoted: info });
    }
    break;
case 'removebg':
case 'tirarfundo':
    try {
        let imageUrl;
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            // Se for mídia (foto enviada ou marcada)
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            let uploadResult = await upload(owgi);
            imageUrl = uploadResult;
        } else if (q && q.includes('http')) {
            // Se for link enviado no texto
            imageUrl = q.trim();
        } else {
            return reply('⚙️ Marque uma foto ou envie o link direto da imagem.');
        }

        reply(`Aguarde ${pushname}, estou removendo o fundo da sua imagem...`);

        const apiUrlRemoveBG = `https://api.vreden.my.id/api/artificial/aiease/img2img/removebg?url=${encodeURIComponent(imageUrl)}`;
        const responseRemoveBG = await axios.get(apiUrlRemoveBG);

        if (responseRemoveBG.data.status === 200 && responseRemoveBG.data.result && responseRemoveBG.data.result.length > 0) {
            const resultImage = responseRemoveBG.data.result[0].origin;

            // Envia o link da imagem sem fundo
            blackmd.sendMessage(from, { text: `✅ Fundo removido com sucesso!\n\n🔗 Link da imagem sem fundo:\n${resultImage}` }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível remover o fundo da imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao remover fundo da imagem:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao tentar remover o fundo da imagem.' }, { quoted: info });
    }
    break;
    case 'gerararte':
case 'text2img':
    if (!q) return blackmd.sendMessage(from, { text: '[⚙️️] Por favor, forneça o texto para gerar a arte. Exemplo: !gerararte Uma cidade futurista entre as nuvens' }, { quoted: info });

    try {
        const promptText2Img = encodeURIComponent(q);
        const apiUrlText2Img = `https://api.vreden.my.id/api/artificial/aiease/text2img?prompt=${promptText2Img}&style=19`;

        reply(`Aguarde um momento ${pushname}, estou criando sua arte...`);

        const responseText2Img = await axios.get(apiUrlText2Img);

        if (responseText2Img.data.status === 200 && responseText2Img.data.result && responseText2Img.data.result.length > 0) {
            for (const imageData of responseText2Img.data.result) {
                const imageUrl = imageData.origin;
                const imageBuffer = await axios.get(imageUrl, { responseType: 'arraybuffer' });

                await blackmd.sendMessage(from, {
                    image: Buffer.from(imageBuffer.data, 'binary'),
                    caption: `Arte gerada para: ${q}`,
                }, { quoted: info });
            }
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível gerar a arte.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao gerar arte:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao gerar a arte.' }, { quoted: info });
    }
    break;
 case 'removermarca':
case 'tirarmarca':
    try {
        let imageUrl;
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            // Se for mídia (foto enviada ou marcada)
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            let uploadResult = await upload(owgi);
            imageUrl = uploadResult;
        } else if (q && q.includes('http')) {
            // Se for link enviado no texto
            imageUrl = q.trim();
        } else {
            return reply('⚙️ Marque uma foto ou envie o link direto da imagem.');
        }

        reply(`Aguarde ${pushname}, estou removendo a marca d'água...`);

        // Chama a API para remover a marca
        const apiWatermark = `https://api.vreden.my.id/api/artificial/aiease/img2img/watermark?url=${encodeURIComponent(imageUrl)}`;
        const responseWatermark = await axios.get(apiWatermark);

        if (responseWatermark.data.status === 200 && responseWatermark.data.result && responseWatermark.data.result.length > 0) {
            const resultImage = responseWatermark.data.result[0].origin;

            const resultBuffer = await axios.get(resultImage, { responseType: 'arraybuffer' });

            await blackmd.sendMessage(from, {
                image: Buffer.from(resultBuffer.data, 'binary'),
                caption: `Marca d'água removida com sucesso!`,
            }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível remover a marca dágua.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao remover marca d\'água:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao tentar remover a marca d\'água.' }, { quoted: info });
    }
    break;
case 'ximage':
case 'gerarximage':
    if (!q) return reply('⚙️ Por favor, forneça a descrição para gerar a imagem. Exemplo: !ximage Sua descrição aqui.');

    try {
        reply(`Aguarde ${pushname}, estou gerando sua imagem XImage...`);

        const promptXimage = encodeURIComponent(q);
        const apiXimage = `https://api.vreden.my.id/api/artificial/ximage?prompt=${promptXimage}`;

        const responseXimage = await axios.get(apiXimage);

        if (responseXimage.data.status === 200 && responseXimage.data.result && responseXimage.data.result.output) {
            const imageUrl = responseXimage.data.result.output;

            const resultBuffer = await axios.get(imageUrl, { responseType: 'arraybuffer' });

            await blackmd.sendMessage(from, {
                image: Buffer.from(resultBuffer.data, 'binary'),
                caption: `Imagem gerada para: ${q}`,
            }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível gerar a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao gerar imagem XImage:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao tentar gerar a imagem.' }, { quoted: info });
    }
    break;
// as novas estão acima
case 'imagem':
    case 'gerar-imagem':
    if (!q) return blackmd.sendMessage(from, { text: '[⚙️️] Por favor, forneça o texto para gerar a imagem. Exemplo: !gerar-imagem Sua frase aqui' }, { quoted: info });

    const textoParaImagem = encodeURIComponent(q); // Codifica o texto para a URL
    const apiUrlImagem = `https://world-ecletix.onrender.com/api/gerar-imagem?texto=${textoParaImagem}`;

    try {
        // Envia a mensagem informando que está gerando a imagem
        reply(`aguarde um momento ${pushname}, pode demorar.`);

        // Envia a imagem diretamente usando a nova API
        const imageResponse = await axios.get(apiUrlImagem, { responseType: 'arraybuffer' });
        
        if (imageResponse.status === 200) {
            const imageBuffer = Buffer.from(imageResponse.data, 'binary');

            // Envia a imagem gerada no chat de onde veio a solicitação
            await blackmd.sendMessage(from, {
                image: imageBuffer,
                caption: `Aqui está a imagem gerada para: ${q}`, // Mensagem opcional
            });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível gerar a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao fazer a requisição à API de geração de imagem:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao gerar a imagem.' }, { quoted: info });
    }
    break;
    case 'gen':
case 'Gen':
    if (!q) return blackmd.sendMessage(from, { text: '[⚙️] Por favor, forneça um prompt para gerar a imagem. Exemplo: !gerar-imagem Sua descrição aqui' }, { quoted: info });

    const prompt = encodeURIComponent(q); // Codifica o texto para URL
    const gen = `http://premium.primaryhost.shop:2050/generate?prompt=${prompt}`;

    try {
        reply(`Aguarde um momento ${pushname}, estou gerando a imagem...`);

        // Faz a requisição para a API de geração de imagem
        const response = await axios.get(gen);
        
        if (response.status === 200 && response.data.image_url) {
            const imageUrl = response.data.image_url;

            // Envia a imagem gerada no chat
            await blackmd.sendMessage(from, {
                image: { url: imageUrl },
                caption: `Aqui está a imagem gerada para: ${q}`,
            });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível gerar a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro ao gerar a imagem:', error);
        blackmd.sendMessage(from, { text: '🚨 Erro ao gerar a imagem.' }, { quoted: info });
    }
    break;
    case 'orbital-img':
case 'gerar-orbital-img':
  if (!q) return blackmd.sendMessage(from, { text: '[⚙️️] Por favor, forneça o texto para gerar a imagem. Exemplo: !orbital-img Sua descrição aqui' }, { quoted: info });

  const textoOrbitalImg = encodeURIComponent(q);
  const apiUrlOrbitalImg = `https://world-ecletix.onrender.com/api/orbital-img?texto=${textoOrbitalImg}`;

  try {
    reply(`Aguarde um momento ${pushname}, estou gerando sua imagem...`);

    const imageResponse = await axios.get(apiUrlOrbitalImg, { responseType: 'arraybuffer' });
    if (imageResponse.status === 200) {
      const imageBuffer = Buffer.from(imageResponse.data, 'binary');
      await blackmd.sendMessage(from, {
        image: imageBuffer,
        caption: `Aqui está a imagem gerada para: ${q}`,
      });
    } else {
      blackmd.sendMessage(from, { text: '🚨 Não foi possível gerar a imagem.' }, { quoted: info });
    }
  } catch (error) {
    console.error('Erro ao fazer a requisição à API Orbital Image:', error);
    blackmd.sendMessage(from, { text: '🚨 Erro ao gerar a imagem.' }, { quoted: info });
  }
  break;
case 'imgsys':
case 'gerar-imgsys':
  if (!q) return blackmd.sendMessage(from, { text: '[⚙️️] Por favor, forneça o texto para gerar a imagem. Exemplo: !imgsys Sua descrição aqui' }, { quoted: info });

  const textoImgSys = encodeURIComponent(q);
  const apiUrlImgSys = `https://world-ecletix.onrender.com/api/imgsys?texto=${textoImgSys}`;

  try {
    reply(`Aguarde um momento ${pushname}, estou gerando sua imagem...`);

    const imageResponse = await axios.get(apiUrlImgSys, { responseType: 'arraybuffer' });
    if (imageResponse.status === 200) {
      const imageBuffer = Buffer.from(imageResponse.data, 'binary');
      await blackmd.sendMessage(from, {
        image: imageBuffer,
        caption: `Aqui está a imagem gerada para: ${q}`,
      });
    } else {
      blackmd.sendMessage(from, { text: '🚨 Não foi possível gerar a imagem.' }, { quoted: info });
    }
  } catch (error) {
    console.error('Erro ao fazer a requisição à API ImgSys:', error);
    blackmd.sendMessage(from, { text: '🚨 Erro ao gerar a imagem.' }, { quoted: info });
  }
  break;
  case 'fluximg':
case 'gerar-fluximg':
  if (!q) return blackmd.sendMessage(from, { text: '[⚙️️] Por favor, forneça o texto para gerar a imagem. Exemplo: !fluximg Sua descrição aqui' }, { quoted: info });

  const textoFluxImg = encodeURIComponent(q);
  const apiUrlFluxImg = `https://world-ecletix.onrender.com/api/fluximg?texto=${textoFluxImg}`;

  try {
    reply(`Aguarde um momento ${pushname}, estou gerando sua imagem...`);

    const imageResponse = await axios.get(apiUrlFluxImg, { responseType: 'arraybuffer' });
    if (imageResponse.status === 200) {
      const imageBuffer = Buffer.from(imageResponse.data, 'binary');
      await blackmd.sendMessage(from, {
        image: imageBuffer,
        caption: `Aqui está a imagem gerada para: ${q}`,
      });
    } else {
      blackmd.sendMessage(from, { text: '🚨 Não foi possível gerar a imagem.' }, { quoted: info });
    }
  } catch (error) {
    console.error('Erro ao fazer a requisição à API FluxImg:', error);
    blackmd.sendMessage(from, { text: '🚨 Erro ao gerar a imagem.' }, { quoted: info });
  }
  break;
  case 'sd':
case 'gerar-sd':
  if (!q) return blackmd.sendMessage(from, { text: '[⚙️️] Por favor, forneça o texto para gerar a imagem. Exemplo: !sd Sua descrição aqui' }, { quoted: info });

  const promptSD = encodeURIComponent(q);
  const apiUrlSD = `https://world-ecletix.onrender.com/api/sd?prompt=${promptSD}`;

  try {
    reply(`Aguarde um momento ${pushname}, estou gerando sua imagem...`);

    const imageResponse = await axios.get(apiUrlSD, { responseType: 'arraybuffer' });
    if (imageResponse.status === 200) {
      const imageBuffer = Buffer.from(imageResponse.data, 'binary');
      await blackmd.sendMessage(from, {
        image: imageBuffer,
        caption: `Aqui está a imagem gerada para: ${q}`,
      });
    } else {
      blackmd.sendMessage(from, { text: '🚨 Não foi possível gerar a imagem.' }, { quoted: info });
    }
  } catch (error) {
    console.error('Erro ao fazer a requisição à API SD:', error);
    blackmd.sendMessage(from, { text: '🚨 Erro ao gerar a imagem.' }, { quoted: info });
  }
  break;
case 'imagine':
case 'Imagine':
  if (!q) return blackmd.sendMessage(from, { text: '[⚙️️] Por favor, forneça o texto para gerar a imagem. Exemplo: !imagine Sua descrição aqui' }, { quoted: info });

  const textoImagine = encodeURIComponent(q);
  const apiUrlImagine = `https://world-ecletix.onrender.com/api/imagine?texto=${textoImagine}`;

  try {
    reply(`Aguarde um momento ${pushname}, estou gerando sua imagem...`);

    const imageResponse = await axios.get(apiUrlImagine, { responseType: 'arraybuffer' });
    if (imageResponse.status === 200) {
      const imageBuffer = Buffer.from(imageResponse.data, 'binary');
      await blackmd.sendMessage(from, {
        image: imageBuffer,
        caption: `Aqui está a imagem gerada para: ${q}`,
      });
    } else {
      blackmd.sendMessage(from, { text: '🚨 Não foi possível gerar a imagem.' }, { quoted: info });
    }
  } catch (error) {
    console.error('Erro ao fazer a requisição à API Imagine:', error);
    blackmd.sendMessage(from, { text: '🚨 Erro ao gerar a imagem.' }, { quoted: info });
  }
  break;

   case 'Gemini2':
case 'gemini2':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o gemini IA.');
  }

  const promptOrbital = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://api-ia.orbital.host/gemini?prompt=${promptOrbital}`);
    const data = await response.json();
    
    if (data.result) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do Gemini IA: ${data.result}` }, { quoted: info });
    } else {
      reply("🚨 Não consegui obter a resposta do Orbital IA. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Orbital IA:", error);
    reply("🚨 Não foi possível. Tente novamente mais tarde.");
  }
  break;
//novas ias
case 'grok':
case 'Grok':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o Grok.');
  }

  const grokTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/grok-2?texto=${grokTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do Grok: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`🚨 Erro: ${response.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do Grok. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Grok:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;

case 'gpt4o':
case 'Gpt4o':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o GPT-4o.');
  }

  const gpt4oTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/gpt-4o?texto=${gpt4oTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do GPT-4o: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`🚨 Erro: ${response.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do GPT-4o. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GPT-4o:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;

case 'gpt4turbo':
case 'Gpt4turbo':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o GPT-4 Turbo.');
  }

  const gpt4turboTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/gpt-4-turbo?texto=${gpt4turboTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do GPT-4 Turbo: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`🚨 Erro: ${response.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do GPT-4 Turbo. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GPT-4 Turbo:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;
case 'claude3opus':
case 'Claude3Opus':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o Claude 3 Opus.');
  }

  const claude3OpusTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/claude-3-opus?texto=${claude3OpusTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do Claude 3 Opus: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`🚨 Erro: ${response.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do Claude 3 Opus. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Claude 3 Opus:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;

case 'grokbeta':
case 'GrokBeta':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o Grok Beta.');
  }

  const grokBetaTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/grok-beta?texto=${grokBetaTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do Grok Beta: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`🚨 Erro: ${response.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do Grok Beta. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Grok Beta:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;

case 'grok2mini':
case 'Grok2Mini':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o Grok 2 Mini.');
  }

  const grok2MiniTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/grok-2-mini?texto=${grok2MiniTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do Grok 2 Mini: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`🚨 Erro: ${response.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do Grok 2 Mini. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Grok 2 Mini:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;
case 'claude3sonnet':
case 'Claude3Sonnet':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o Claude 3 Sonnet.');
  }

  const claude3SonnetTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/claude-3-sonnet?texto=${claude3SonnetTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do Claude 3 Sonnet: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`🚨 Erro: ${response.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do Claude 3 Sonnet. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Claude 3 Sonnet:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;

case 'claude35sonnet':
case 'Claude35Sonnet':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o Claude 3.5 Sonnet.');
  }

  const claude35SonnetTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/claude-3-5-sonnet?texto=${claude35SonnetTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do Claude 3.5 Sonnet: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`🚨 Erro: ${response.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do Claude 3.5 Sonnet. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Claude 3.5 Sonnet:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;

case 'claude35sonnet2':
case 'Claude35Sonnet2':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o Claude 3.5 Sonnet 2.');
  }

  const claude35Sonnet2Texto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/claude-3-5-sonnet-2?texto=${claude35Sonnet2Texto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do Claude 3.5 Sonnet 2: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`🚨 Erro: ${response.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do Claude 3.5 Sonnet 2. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Claude 3.5 Sonnet 2:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;
case 'dalle':
case 'Dalle':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma descrição para a geração de imagem com DALL·E.');
  }

  const dalleTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/dalle?texto=${dalleTexto}`);

    if (response.url) {
      blackmd.sendMessage(from, { image: { url: response.url }, caption: "🖼️ Imagem gerada pelo DALL·E" }, { quoted: info });
    } else if (response.mensagem) {
      reply(`🚨 Erro: ${response.mensagem}`);
    } else {
      reply("🚨 Não consegui gerar a imagem. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter imagem do DALL·E:", error);
    reply("🚨 Não foi possível gerar a imagem, tente novamente mais tarde.");
  }
  break;
case 'lexica':
case 'Lexica':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma descrição para a geração de imagem com Lexica.');
  }

  const lexicaTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/lexica?texto=${lexicaTexto}`);

    if (response.url) {
      blackmd.sendMessage(from, { image: { url: response.url }, caption: "🖼️ Imagem gerada pelo Lexica" }, { quoted: info });
    } else if (response.mensagem) {
      reply(`🚨 Erro: ${response.mensagem}`);
    } else {
      reply("🚨 Não consegui gerar a imagem. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter imagem do Lexica:", error);
    reply("🚨 Não foi possível gerar a imagem, tente novamente mais tarde.");
  }
  break;
//fim das novas ias
case 'lady':
case 'Lady':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para a lady.');
  }

  const ladyTexto = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a nova API da lady
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/lady?texto=${ladyTexto}`);

    if (response.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta da lady: ${response.resposta}` }, { quoted: info });
    } else if (response.mensagem) {
      reply(`🚨 Erro: ${response.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta da lady. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta da lady:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;
  case 'analisaimg': //by luanzin dev
  if (!args[1] || !args[2]) {
    return reply('🚨 Por favor, forneça um prompt e uma URL de imagem. Exemplo: !analiseimg "analisar esta imagem" [URL da imagem]');
  }

  const promptVerImg = encodeURIComponent(args[1]);
  const imageUrl = args[2];

  try {
    const response = await fetchJson(`https://api-ia.orbital.host/gemini/img?prompt=${promptVerImg}&imageUrl=${imageUrl}`);
    const data = await response.json();
    
    if (data.result) {
      blackmd.sendMessage(from, { text: `🖼️ Resultado da análise: ${data.result}` }, { quoted: info });
    } else {
      reply("🚨 Não consegui obter a análise da imagem.");
    }
  } catch (error) {
    console.error("Erro ao analisar a imagem:", error);
    reply("🚨 Não foi possível se conectar ao Orbital IA. Tente novamente mais tarde.");
  }
  break;
case 'ia':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para a IA.');
  }

  const textoIa = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API da IA
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ia?texto=${textoIa}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta da IA: ${data.resposta}` }, { quoted: info });
    } else {
      reply(data.mensagem ? `🚨 Erro: ${data.mensagem}` : "🚨 Não consegui obter a resposta da IA. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta da IA:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;
case 'gemini3':
case 'gptgemini':
    try {
        if (!q) return blackmd.sendMessage(from, { text: '⚙️ Por favor, envie o conteúdo para conversar com o Gemini.\n\nExemplo: !gemini oi amigo' }, { quoted: info });

        reply(`Aguarde ${pushname}, estou consultando o modelo Gemini...`);

        const geminiApiUrl = `https://api.ownblox.biz.id/api/gemini?text=responda em português:${encodeURIComponent(q)}`;
        const geminiResponse = await axios.get(geminiApiUrl);

        if (geminiResponse.data && geminiResponse.data.sukses) {
            await blackmd.sendMessage(from, { text: geminiResponse.data.jawaban }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível obter resposta do Gemini.' }, { quoted: info });
        }

    } catch (error) {
        console.error('Erro ao consultar Gemini:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao consultar o modelo Gemini.' }, { quoted: info });
    }
    break;

case 'gemini':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o Gemini.');
  }

  const textoGemini = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API do Gemini
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/gemini?texto=${textoGemini}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do Gemini: ${data.resposta}` }, { quoted: info });
    } else {
      reply(data.mensagem ? `🚨 Erro: ${data.mensagem}` : "🚨 Não consegui obter a resposta do Gemini. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Gemini:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;

case 'geminipro':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o GeminiPro.');
  }

  const textoGeminipro = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API do GeminiPro
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-geminipro?texto=${textoGeminipro}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do GeminiPro: ${data.resposta}` }, { quoted: info });
    } else {
      reply(data.mensagem ? `🚨 Erro: ${data.mensagem}` : "🚨 Não consegui obter a resposta do GeminiPro. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GeminiPro:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;
  case 'chatgpt':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o ChatGPT.');
  }

  const textoChatGPT = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API do ChatGPT
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/chatgpt?texto=${textoChatGPT}`);

    if (data.response) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do ChatGPT: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`🚨 Erro: ${data.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do ChatGPT. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do ChatGPT:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;

case 'gpt3.5-turbo':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o GPT-3.5-Turbo.');
  }

  const textoGpt35Turbo = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API do GPT-3.5-Turbo
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-gpt3.5-turbo?texto=${textoGpt35Turbo}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do GPT-3.5-Turbo: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`🚨 Erro: ${data.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do GPT-3.5-Turbo. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GPT-3.5-Turbo:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;

case 'gpt4':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o GPT-4.');
  }

  const textoGpt4 = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API do GPT-4
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-gpt4?texto=${textoGpt4}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do GPT-4: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`🚨 Erro: ${data.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do GPT-4. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GPT-4:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;
  case 'gpt4':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o GPT-4.');
  }

  const textoGpt44 = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API do GPT-4
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-gpt4?texto=${textoGpt44}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do GPT-4: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`🚨 Erro: ${data.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do GPT-4. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GPT-4:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;

case 'gpt4v2':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o GPT-4V2.');
  }

  const textoGpt4v2 = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API do GPT-4V2
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-gpt4v2?texto=${textoGpt4v2}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do GPT-4V2: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`🚨 Erro: ${data.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do GPT-4V2. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GPT-4V2:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;
  
case 'Meta':
case 'meta':
case 'gptllama':
    try {
        if (!q) return blackmd.sendMessage(from, { text: '⚙️ Por favor, envie o conteúdo para conversar com o LLaMA.\n\nExemplo: !llama oi' }, { quoted: info });

        reply(`Aguarde ${pushname}, estou consultando o modelo LLaMA...`);

        const llamaApiUrl = `https://api.ownblox.biz.id/api/llama-3.3-70b-versatile?content=${encodeURIComponent(q)}`;
        const llamaResponse = await axios.get(llamaApiUrl);

        if (llamaResponse.data && llamaResponse.data.status === 200) {
            await blackmd.sendMessage(from, { text: llamaResponse.data.response }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível obter resposta do modelo LLaMA.' }, { quoted: info });
        }

    } catch (error) {
        console.error('Erro ao consultar LLaMA:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao consultar o modelo LLaMA.' }, { quoted: info });
    }
    break;
case 'image2text':
    try {
        if (!q && !isMedia) return reply('⚙️ Marque uma imagem ou envie um link de imagem.');

        let imageUrl = '';
        if (isMedia || isQuotedImage) {
            let imgMessage = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            imageUrl = imgMessage.url;
        } else if (q && q.includes('http')) {
            imageUrl = q.trim();
        }

        const imageToTextApi = `https://api.siputzx.my.id/api/ai/image2text?url=${encodeURIComponent(imageUrl)}`;
        const response = await axios.get(imageToTextApi);

        if (response.data.status) {
            blackmd.sendMessage(from, { text: response.data.dados }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível processar a imagem.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro no Image2Text:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao tentar processar a imagem.' }, { quoted: info });
    }
    break;    
case 'explicarfoto':
case 'explicar-foto':
    try {
        let imageUrl;
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            // Se for mídia (foto enviada ou marcada)
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            let uploadResult = await upload(owgi);
            imageUrl = uploadResult;
        } else if (q && q.includes('http')) {
            // Se for um link enviado no texto
            imageUrl = q.trim();
        } else {
            return reply('⚙️ Marque uma foto ou envie o link direto da imagem para explicar.');
        }

        if (!q.replace(imageUrl, '').trim()) {
            return reply('⚙️ Após a imagem, envie também a pergunta/descrição.\n\nExemplo: !explicarfoto [imagem marcada] explique essa foto');
        }

        const userQuestion = q.replace(imageUrl, '').trim();
        reply(`Aguarde ${pushname}, estou analisando a imagem...`);

        const bardApiUrl = `https://api.siputzx.my.id/api/ai/bard-img?imageUrl=${encodeURIComponent(imageUrl)}&query=${encodeURIComponent(userQuestion)}`;
        const bardResponse = await axios.get(bardApiUrl);

        if (bardResponse.data && bardResponse.data.status) {
            await blackmd.sendMessage(from, { text: bardResponse.data.dados }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível analisar a imagem.' }, { quoted: info });
        }

    } catch (error) {
        console.error('Erro ao analisar imagem:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao tentar analisar a imagem.' }, { quoted: info });
    }
    break;
    case 'magicstudio':
    try {
        if (!q) return reply('⚙️ Escreva um prompt para gerar a imagem.');

        const magicStudioApi = `https://api.siputzx.my.id/api/ai/magicstudio?prompt=${encodeURIComponent(q)}`;
        const response = await axios.get(magicStudioApi, { responseType: 'arraybuffer' });

        const buffer = Buffer.from(response.data, 'binary');
        await blackmd.sendMessage(from, { image: buffer, caption: 'Aqui está a imagem gerada!' }, { quoted: info });
    } catch (error) {
        console.error('Erro no MagicStudio:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao gerar a imagem.' }, { quoted: info });
    }
    break;
    case 'trocar-rosto':
    case 'faceswap':
    try {
        if (!q || !q.includes('http') || q.split(' ').length !== 2) {
            return reply('⚙️ Forneça dois links de imagem separados por espaço para trocar os rostos.');
        }

        const [sourceUrl, targetUrl] = q.split(' ');

        const faceswapApi = `https://api.siputzx.my.id/api/ai/faceswap?source=${encodeURIComponent(sourceUrl)}&target=${encodeURIComponent(targetUrl)}`;
        const response = await axios.get(faceswapApi, { responseType: 'arraybuffer' });

        const buffer = Buffer.from(response.data, 'binary');
        await blackmd.sendMessage(from, { image: buffer, caption: 'Aqui está a troca de rostos!' }, { quoted: info });
    } catch (error) {
        console.error('Erro no Faceswap:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao tentar realizar a troca de rostos.' }, { quoted: info });
    }
    break;
case 'Gerar-foto':
case 'gerar-foto':
    try {
        if (!q) return reply('⚙️ Escreva um prompt para gerar a imagem.');

        const fluxApi = `https://api.siputzx.my.id/api/ai/flux?prompt=${encodeURIComponent(q)}`;
        const response = await axios.get(fluxApi, { responseType: 'arraybuffer' });

        const buffer = Buffer.from(response.data, 'binary');
        await blackmd.sendMessage(from, { image: buffer, caption: 'Aqui está a imagem gerada!' }, { quoted: info });
    } catch (error) {
        console.error('Erro no Flux:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao gerar a imagem.' }, { quoted: info });
    }
    break;
case 'bard':
    try {
        if (!q) return reply(`⚙️ Escreva algo para o Bard responder.`);
        const bardApi = `https://api.siputzx.my.id/api/ai/bard?query=${encodeURIComponent(q)}`;
        const bardResponse = await axios.get(bardApi);

        if (bardResponse.data.status && bardResponse.data.data) {
            blackmd.sendMessage(from, { text: bardResponse.data.data }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não consegui gerar a resposta.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro no Bard:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao tentar gerar a resposta.' }, { quoted: info });
    }
    break;
    case 'bard2':
    try {
        if (!q) return reply(`⚙️ Escreva algo para o Bard responder.`);
        const bardApi = `https://api.siputzx.my.id/api/ai/bard?query=${encodeURIComponent(q)}`;
        const bardResponse = await axios.get(bardApi);

        if (bardResponse.data.status && bardResponse.data.data) {
            blackmd.sendMessage(from, { text: bardResponse.data.data }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não consegui gerar a resposta.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro no Bard:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao tentar gerar a resposta.' }, { quoted: info });
    }
    break;

case 'meta-turbo':
case 'meta-llama':
    try {
        if (!q) return blackmd.sendMessage(from, { text: '⚙️ Envie o conteúdo para conversar com o Meta-Llama.\n\nExemplo: .metallama oi' }, { quoted: info });

        const llamaApiUrl = `https://api.siputzx.my.id/api/ai/meta-llama-33-70B-instruct-turbo?content=responda em portugues:${encodeURIComponent(q)}`;
        const llamaResponse = await axios.get(llamaApiUrl);

        if (llamaResponse.data && llamaResponse.data.status) {
            await blackmd.sendMessage(from, { text: llamaResponse.data.data }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não foi possível obter resposta do Meta-Llama.' }, { quoted: info });
        }

    } catch (error) {
        console.error('Erro ao consultar Meta-Llama:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao consultar o modelo Meta-Llama.' }, { quoted: info });
    }
    break;    
case 'llama':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma consulta para o Llama.');
  }

  const textoLlama = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API do Llama
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-llama?texto=${textoLlama}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do Llama: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`🚨 Erro: ${data.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do Llama. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Llama:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;
  case 'blackboxai-pro':
    try {
        if (!q) return reply(`⚙️ Escreva algo para o Blackbox AI Pro responder.`);
        const blackboxProApi = `https://api.siputzx.my.id/api/ai/blackboxai-pro?content=${encodeURIComponent(q)}`;
        const response = await axios.get(blackboxProApi);

        if (response.data.status && response.data.data) {
            blackmd.sendMessage(from, { text: response.data.data }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não consegui gerar a resposta.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro no Blackbox AI Pro:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao tentar gerar a resposta.' }, { quoted: info });
    }
    break;
case 'blackboxai':
    try {
        if (!q) return reply(`⚙️ Escreva algo para o Blackbox AI responder.`);
        const blackboxApi = `https://api.siputzx.my.id/api/ai/blackboxai?content=${encodeURIComponent(q)}`;
        const response = await axios.get(blackboxApi);

        if (response.data.status && response.data.data) {
            blackmd.sendMessage(from, { text: response.data.data }, { quoted: info });
        } else {
            blackmd.sendMessage(from, { text: '🚨 Não consegui gerar a resposta.' }, { quoted: info });
        }
    } catch (error) {
        console.error('Erro no Blackbox AI:', error);
        blackmd.sendMessage(from, { text: '🚨 Ocorreu um erro ao tentar gerar a resposta.' }, { quoted: info });
    }
    break;
case 'blackbox':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma consulta para o BlackBox.');
  }

  const textoBlackbox = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API do BlackBox
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-blackbox?texto=${textoBlackbox}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do BlackBox: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`🚨 Erro: ${data.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do BlackBox. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do BlackBox:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;

case 'lumin':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma consulta para o Lumin.');
  }

  const queryLumin = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API do Lumin
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-lumin?query=${queryLumin}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do Lumin: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`🚨 Erro: ${data.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do Lumin. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do Lumin:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;
  case 'wwdgpt':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma consulta para o WWDGPT.');
  }

  const promptWWDGPT = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API do WWDGPT
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-wwdgpt?prompt=${promptWWDGPT}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do WWDGPT: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`🚨 Erro: ${data.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do WWDGPT. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do WWDGPT:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;

case 'letmegpt':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma consulta para o LetMeGPT.');
  }

  const queryLetMeGPT = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API do LetMeGPT
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-letmegpt?query=${queryLetMeGPT}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do LetMeGPT: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`🚨 Erro: ${data.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do LetMeGPT. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do LetMeGPT:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;

case 'iasimi':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma consulta para o SimSimi.');
  }

  const querySimsimi = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API do SimSimi
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-simsimi?query=${querySimsimi}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do SimSimi: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`🚨 Erro: ${data.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do SimSimi. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do SimSimi:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;


  case 'gpt4-o':
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma pergunta para o GPT-4-O.');
  }

  const textoGpt4O = encodeURIComponent(args.slice(1).join(' '));

  try {
    // Faz a requisição para a API do GPT-4-O
    const data = await fetchJson(`https://world-ecletix.onrender.com/api/ai-gpt4-o?texto=${textoGpt4O}`);

    if (data.resposta) {
      blackmd.sendMessage(from, { text: `🗣️ Resposta do GPT-4-O: ${data.resposta}` }, { quoted: info });
    } else if (data.mensagem) {
      reply(`🚨 Erro: ${data.mensagem}`);
    } else {
      reply("🚨 Não consegui obter a resposta do GPT-4-O. Tente novamente mais tarde.");
    }
  } catch (error) {
    console.error("Erro ao obter resposta do GPT-4-O:", error);
    reply("🚨 Não foi possível, tente novamente mais tarde.");
  }
  break;
case 'gerarimg': // by luanzin dev
  if (!args[1]) {
    return reply('🚨 Por favor, forneça uma descrição para gerar uma imagem.');
  }

  const promptGerarImg = encodeURIComponent(args.slice(1).join(' '));

  try {
    const response = await fetch(`https://api-ia.orbital.host/orbital/img-ai?prompt=${promptGerarImg}&model=v3`);
    const data = await response.json();
    
    if (data.url) {
      const imageBuffer = await getBuffer(data.url);
      blackmd.sendMessage(from, { image: imageBuffer, caption: `*Resultado para: _${args.slice(1).join(' ')}_*` }, { quoted: info });
    } else {
      reply("🚨 Não consegui gerar a imagem.");
    }
  } catch (error) {
    console.error("Erro ao gerar a imagem:", error);
    reply("🚨 Não foi possível se conectar ao Orbital IA. Tente novamente mais tarde.");
  }
  break;
case 'crimg': case 'imagegpt': case 'mdj': case 'imageai':
setTimeout(() => {reagir(from, "🔰")}, 300)
if(!isVip && !isChatOfc) return reply(enviar.msg.vip)
if(!q) return reply(`KD o título da pesquisa?`)
try {
const imageBuffer = await superimg(q)
blackmd.sendMessage(from, {image: imageBuffer}, {quoted: info})
} catch(e) {
console.log(e)
reply(`Erro`)
}
break

case 'photoleap': case 'midjourney':
if(!isVip && !isChatOfc) return reply(enviar.msg.vip)
try {
if(!q) return reply("O que você deseja criar através de seu questionamento?");
reply(enviar.espere);
sendImage(from, `https://aemt.me/ai/text2img?text=${q}`, ``, seloctt)
} catch(e) {
console.log(e)
reply("Erro")
}
break

case 'jeff': case 'simi':
setTimeout(() => {reagir(from, "🤓")}, 300)
if(!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
if(!q) return reply(`Pergunte algo junto ao comando...`)
try {
datasimi = await fetchJson(`https://api.simsimi.vn/v1/simtalk`, {method: 'POST',
headers: {'content-type': "application/x-www-form-urlencoded"},
body: "text="+q+"&lc=pt"})
return reply(datasimi.message)
} catch (e){
return reply("Resposta não encontrada..")
}
break

case 'katy':
setTimeout(() => {reagir(from, "😍")}, 300)
if(!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
if(!q) return reply(`Pergunte algo junto ao comando...`)
try {
datasimi = await fetchJson(`https://api.simsimi.vn/v1/simtalk`, {method: 'POST',
headers: {'content-type': "application/x-www-form-urlencoded"},
body: "text="+q+"&lc=pt"})
const gtts = require('./armor/funcoes/gtts')(`pt`)
dtt = datasimi.message
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
gtts.save(ranm, dtt, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
blackmd.sendMessage(from, {audio: fs.readFileSync(ranm), ptt:true, mimetype: "audio/mp4"}, {quoted: seloctt}).catch(e => {
return reply("Erro..")
})
DLT_FL(ranm)
DLT_FL(rano)
})
})
} catch (e){
return reply("Resposta não encontrada..")
}
break

case 'simih':
if(!isOwner) return reply("Indisponível")
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isSimi) return reply('O modo Simi está ativo')
dataGp[0].simi1 = true
setGp(dataGp)
reply('Ativado com sucesso o modo simi neste grupo 😗..')
} else if(Number(args[0]) === 0) {
if(!isSimi) return reply('Já está Desativado.')
dataGp[0].simi1 = false
setGp(dataGp)
reply('Desativado modo simi com sucesso neste grupo 😡️')
} else {
reply('1 para ativar, 0 para desativar, lerdao vc em KKKKK')
}
break

case 'simih2':
if(!isOwner) return reply("Indisponível")
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isSimi2) return reply('O modo Simi está ativo')
dataGp[0].simi2 = true
setGp(dataGp)
reply('Ativado com sucesso o modo simi neste grupo 😗..')
} else if(Number(args[0]) === 0) {
if(!isSimi2) return reply('Já está Desativado.')
dataGp[0].simi2 = false
setGp(dataGp)
reply('Desativado modo simi com sucesso neste grupo 😡️')
} else {
reply('1 para ativar, 0 para desativar, lerdao vc em KKKKK')
}
break

case 'autofigu': case 'autosticker':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAutofigu) return reply('Ja esta ativo')
dataGp[0].autosticker = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de auto figurinhas neste grupo 📝')
} else if(Number(args[0]) === 0) {
if(!isAutofigu) return reply('Ja esta Desativado')
dataGp[0].autosticker = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de auto figurinhas neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'autoaudio': case 'autotranscricao':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply('1 pra ligar / 0 pra desligar')
if(Number(args[0]) === 1) {
if(isAutoTranscricao) return reply('Ja esta ativo')
dataGp[0].autotranscricao = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de auto transcrição neste grupo 📝')
} else if(Number(args[0]) === 0) {
if(!isAutoTranscricao) return reply('Ja esta Desativado')
dataGp[0].autotranscricao = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de auto transcrição neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break


case 'autoresposta':
setTimeout(() => {reagir(from, "🔊")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply(`${prefix+command} 1 / ${prefix+command} 0`)
if(Number(args[0]) === 1) {
if(isAutorepo) return reply('Ja esta ativo')
dataGp[0].autoresposta = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de auto resposta neste grupo 📝')
} else if(Number(args[0]) === 0) {
if(!isAutorepo) return reply('Ja esta Desativado')
dataGp[0].autoresposta = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de auto resposta neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'modozoeira':
case 'modozueira':
setTimeout(() => {reagir(from, "🤪")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins && !isOwner) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply(`${prefix+command} 1 / ${prefix+command} 0`)
if(Number(args[0]) === 1) {
if(isModobn) return reply('o modozoeira já está ativo')
dataGp[0].jogos = true
setGp(dataGp)
reply('🎯 Ativou com sucesso o recurso de Modo zoeira neste grupo 🪀')
} else if(Number(args[0]) === 0) {
if(!isModobn) return reply('o modozoeira já está Desativado')
dataGp[0].jogos = false
setGp(dataGp)
reply('🎯 Desativou com sucesso o recurso de Modo zoeira neste grupo 🪀')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'rank':
case 'ranklevel':
case 'rankpatente':
if(!isGroup) return reply(enviar.msg.grupo)
setTimeout(() => {reagir(from, "👑")}, 300)
if(!isLevelingOn) return reply(`*É necessário ativar o sistema de level primeiro* 🙆🏻‍♂️
*Use* ${prefix}leveling 1`)
if(level.length > 4) {
matheuzinho = level.map(i => i)
rank = matheuzinho.sort((a, b) => (a.contador < b.contador) ? 0 : -1)
if(level.length > 10) {
var totalR = 10
} else {
var totalR = level.length
}
txt = `▁▂▃▄▅▆▇█ 🔭 𝚁𝙰𝙽𝙺 𝙻𝙴𝚅𝙴𝙻 🔭 █▇▆▅▄▃▂▁`
for ( i = 0; i < totalR; i++) {
  if(i != null) {
    data = levelDBuser(rank[i].id)
txt += `

╓─━⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓━─┒
┢╕\t\t\t🎮 ${NomeDoBot} 🎮
╽╟ ~>『 »${i+1}« 』
╽╟ • ɴɪᴄᴋ: ${getname(data.id)}
╽╟ • ɪᴅ: wa.me/${data.id.split('@')[0]}
╽╟ • ʟᴇᴠᴇʟ: ${data.level}
╽╟ • ᴘᴀᴛᴇɴᴛᴇ: ${patente(data.contador)}
╽╟ • xᴘ: ${data.contador}
┕╨⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋┚`
}
}
caixa = []
for ( i = 0; i < level.length; i++) {
  caixa.push({id: rank[i].id})
}
AB = caixa.map(i => i.id).indexOf(sender)
txt += `\n\n${AB > 9 ? `• ꜱᴜᴀ ᴩᴏꜱɪçãᴏ ɴᴏ ʀᴀɴᴋ ~> ${AB + 1}\n` : ``}🄱🅈: ${NickDono}`
reply(txt)
} else { reply(`Sem dados 🤷🏻‍♂️`) }
break

case 'top10': case 'rank10':
mapa = level.map(i => i)
rank = mapa.sort((a, b) => (a.contador < b.contador) ? 0 : -1)
img = site+`/api/canvas/top?message=${encodeURI("XP:")}&fundo=https://telegra.ph/file/67d9c49eecc1cd1fcd637.jpg`
try { usu1 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[0].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu1 = semfoto }
try { usu2 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[1].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu2 = semfoto }
try { usu3 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[2].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu3 = semfoto }
try { usu4 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[3].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu4 = semfoto }
try { usu5 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[4].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu5 = semfoto }
try { usu6 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[5].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu6 = semfoto }
try { usu7 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[6].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu7 = semfoto }
try { usu8 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[7].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu8 = semfoto }
try { usu9 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[8].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu9 = semfoto }
try { usu10 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[9].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu10 = semfoto }
foto = [usu1, usu2, usu3, usu4, usu5, usu6, usu7, usu8, usu9, usu10]
for(i = 0; i < 10; i++) {
  if(i != null) {
    usu = rank[i]
    nmr = String(i + 1)
    img += `&foto${nmr}=${foto[i]}&nome${nmr}=${encodeURI(getname(usu.id))}&xp${nmr}=${usu.contador}`
  }
}
sendImage(from, img)
break

case 'top1': case 'rank1':
mapa = level.map(i => i)
rank = mapa.sort((a, b) => (a.contador < b.contador) ? 0 : -1)
img = site+`/api/canvas/top?message=${encodeURI("XP:")}&fundo=https://telegra.ph/file/67d9c49eecc1cd1fcd637.jpg`
try { usu1 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[0].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu1 = semfoto }
try { usu2 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[1].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu2 = semfoto }
try { usu3 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[2].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu3 = semfoto }
try { usu4 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[3].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu4 = semfoto }
try { usu5 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[4].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu5 = semfoto }
try { usu6 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[5].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu6 = semfoto }
try { usu7 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[6].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu7 = semfoto }
try { usu8 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[7].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu8 = semfoto }
try { usu9 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[8].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu9 = semfoto }
try { usu10 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${rank[9].id.split('@')[0]}@c.us`, 'image'))}`)).data } catch { usu10 = semfoto }
foto = [usu1, usu2, usu3, usu4, usu5, usu6, usu7, usu8, usu9, usu10]
for(i = 0; i < 10; i++) {
  if(i != null) {
    usu = rank[i]
    nmr = String(i + 1)
    img += `&foto${nmr}=${foto[i]}&nome${nmr}=${encodeURI(getname(usu.id))}&xp${nmr}=${usu.contador}`
  }
}
sendStickerFromUrl(from, img)
break

case 'patente':
case 'level':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isLevelingOn) return reply(`*É necessário ativar o sistema de level primeiro* 🙆🏻‍♂️
*Use* ${prefix}leveling 1`)
if(isYouInLevel(sender)) {
levelstts = levelDBuser(sender)
myexp = levelstts.contador
newpatente = patente(myexp)

AB = dbpt.map(d => d.pat).indexOf(newpatente)
newtt = myexp < 10000000 ? myexp < 5000000 ? dbpt[AB].nmr : 5000000 : myexp
newcont = myexp < 10000000 ? myexp < 5000000 ? dbpt[AB + 1].nmr : 10000000 : myexp

matheuzinho = level.map(i => i)
rank = matheuzinho.sort((a, b) => (a.contador < b.contador) ? 0 : -1)

bar = myexp < 10000000 ? barrinha((myexp - newtt), (newcont - newtt)) : ""
sub = newcont - myexp
//==========reply===========\\
leveltxt = `┏──━━◤ 𝙻𝙴𝚅𝙴𝙻𝙸𝙽𝙶 ◢━━──┓
╽
╟┓
║┢ 𝙽𝙸𝙲𝙺: ${pushname}
║╽
║┢ 𝙻𝙴𝚅𝙴𝙻: ${levelstts.level}
║╽
║┢ 𝙿𝙰𝚃𝙴𝙽𝚃𝙴: ${newpatente}
║╽
║┢ 𝚇𝙿: ${myexp} ${myexp < 10000000 ? `-> ${newcont}` : ``}
║╽${myexp < 10000000 ? `${bar}\n║╽` : ``}
╙┷━━━━━━━───━━━━━━━┛${myexp < 10000000 ? `\n_Falta${Number(sub) > 1 ? `m` : ``} ${sub} XP para upar o próximo level_` : `_Você alcançou a patente máxima_`}`
a1 = levelstts.level
a2 = (rank.map(i => i.id).indexOf(sender)) + 1
a3 = myexp
a4 = myexp < 10000000 ? newcont : myexp
a5 = Number(myexp < 10000000 ? (((myexp - newtt) / (newcont - newtt)) * 100) : 100).toFixed(0)
} else {
leveltxt = `┏──━━◤ 𝙻𝙴𝚅𝙴𝙻𝙸𝙽𝙶 ◢━━──┓
╽
╟┓
║┢ 𝙽𝙸𝙲𝙺: ${pushname}
║╽
║┢ 𝙻𝙴𝚅𝙴𝙻: 1
║╽
║┢ 𝙿𝙰𝚃𝙴𝙽𝚃𝙴: Bronze I 🥉
║╽
║┢ 𝚇𝙿: 0
║╽
╙┷━━━━━━━───━━━━━━━┛`
a1 = 0
a2 = level.length + 1
a3 = 0
a4 = 100
a5 = 0
}
try { ppimg = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image'))}`)).data
} catch(e) { ppimg = semfoto }
img = `https://blacksystemofc.com.br/api/canvas/musicardbun/level?nome=${encodeURI(pushname)}&level=${a1}&brightness=100&perfil=${ppimg}&rank=${a2}&xpb=${a3}&xpa=${a4}&progresso=${a5}`
sendImage(from, img, leveltxt, seloctt)
break

case 'patentes':
if(!isLevelingOn) return reply(`*É necessário ativar o sistema de level primeiro* 🙆🏻‍♂️
*Use* ${prefix}leveling 1`)
setTimeout(() => {reagir(from, react2)}, 300)
reply(`╔═══════════━━──${dbpt.map(i => `
╟ • ${i.pat}
╚═╦─ • ${i.xp} XP ✨`).join(`
─━╩══════╗
╔════════╩══━━──`)}
─━╩═════════━━──`)
break

case 'addlevel':
if(!isOwner) return reply(enviar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Digite o número do usuário e a quantidade de level que deseja adicionar
Ex: ${prefix+command} ${addNumberMais(sender)}/2`)
var [a, b] = q.split(`/`)
usu = rmLetras(a) === "me" ? sender : identArroba(a)
if(!isYouInLevel(usu)) return reply(enviar.msg.notusu)
if(Number(b) <= 0) return reply(`O número precisa ser maior que 0...`)
if(b.includes(".")) return reply("Não pode número decimal")
addlevel(usu, b)
reply(`${b} leve${Number(b) > 1 ? `is` : `l`} adicionado${Number(b) > 1 ? `s` : ``} a este usuário...`)
break

case 'tirarlevel':
if(!isOwner) return reply(enviar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Digite o número do usuário e a quantidade de level que deseja remover
Ex: ${prefix+command} ${addNumberMais(sender)}/2`)
var [a, b] = q.split(`/`)
usu = rmLetras(a) === "me" ? sender : identArroba(a)
if(!isYouInLevel(usu)) return reply(enviar.msg.notusu)
if(Number(b) <= 0) return reply(`O número precisa ser maior que 0...`)
if(b.includes(".")) return reply("Não pode número decimal")
rmlevel(usu, b)
reply(`${b} leve${Number(b) > 1 ? `is` : `l`} retirado${Number(b) > 1 ? `s` : ``} deste usuário...`)
break

case 'addxp':
if(!isOwner) return reply(enviar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Digite o número do usuário e a quantidade de XP que deseja adicionar
Ex: ${prefix+command} ${addNumberMais(sender)}/2`)
var [a, b] = q.split(`/`)
usu = rmLetras(a) === "me" ? sender : identArroba(a)
if(!isYouInLevel(usu)) return reply(enviar.msg.notusu)
if(Number(b) <= 0) return reply(`O número precisa ser maior que 0...`)
if(b.includes(".")) return reply("Não pode número decimal")
addXP(usu, b)
reply(`${b} experiência${Number(b) > 1 ? `s` : ``} fo${Number(b) > 1 ? `ram` : `i`} adicionada${Number(b) > 1 ? `s` : ``} a este usuário...`)
break

case 'tirarxp':
if(!isOwner) return reply(enviar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Digite o número do usuário e a quantidade de XP que deseja adicionar
Ex: ${prefix+command} ${addNumberMais(sender)}/2`)
var [a, b] = q.split(`/`)
usu = rmLetras(a) === "me" ? sender : identArroba(a)
if(!isYouInLevel(usu)) return reply(enviar.msg.notusu)
if(Number(b) <= 0) return reply(`O número precisa ser maior que 0...`)
if(b.includes(".")) return reply("Não pode número decimal")
rmXP(usu, b)
reply(`${b} experiência${Number(b) > 1 ? `s` : ``} fo${Number(b) > 1 ? `ram` : `i`} retirada${Number(b) > 1 ? `s` : ``} deste usuário...`)
break

case 'blocklevel':
if(!isOwner) return reply(enviar.msg.dono)
if(!marc_tds) return reply("Marque a pessoa que deseja bloquear do contador")
if(isBlockGetLevelUser(marc_tds)) return reply("Este usuário já está bloqueado...")
blockLevelUser(marc_tds);
reply("✅ Usuário bloqueado do contador com sucesso... As interações do mesmo não serão mais contabilizadas 🔰")
break

case 'unblocklevel':
if(!isOwner) return reply(enviar.msg.dono)
if(!marc_tds) return reply("Marque a pessoa que deseja bloquear do contador")
if(!isBlockGetLevelUser(marc_tds)) return reply("Este usuário não está bloqueado...")
unBlockLevelUser(marc_tds);
reply("✅ Usuário desbloqueado do contador com sucesso... As interações do mesmo voltarão a serem contabilizadas 🔰")
break

case 'blocklevel-list': case 'blocklevellist':
if(!isOwner) return reply(enviar.msg.dono)
txt = `[ ❗ ]  *Lista de usuários bloqueados do contador de XP:*\n`
let blocklevellist = 0
for(i = 0; i < level.length; i++) {
  if(level[i].block) {
    txt += `⇒ @${level[i].id.split('@')[0]}\n`
    blocklevellist += 1
  }
}
txt += `\n♨️ Total: ${blocklevellist}`
if(blocklevellist > 0) return mention(txt)
reply("Não há usuários bloqueados")
break

case 'execdblevel':
if(!isOwner && !isnit && !info.key.fromMe) return reply('```SOMENTE MEU DONO LINDÃO```')
var allGroups = Object.entries((await blackmd.groupFetchAllParticipating())).slice(0).map(entry => entry[1]).map(v => v).sort((a, b) => (a[0] < b.length))
alllevel = []
for(a of allGroups) {for(b of a.participants) {alllevel.push(b.id)}}
endlevel = []
ttl = level.length
adc = 0
for(c of level) {if(isJsonIncludes(alllevel, c.id)) {adc += 1
endlevel.push(c)}}
sub = ttl - adc
if(sub <= 0) return reply(`Todos os users do level estão nos grupos com o bot...`)
saveLeVeLdb(endlevel);
reply(sub > 1 ? `Foram encontrados/removidos do sistema de leveling ${sub} usuários que não estavam presentes em nenhum grupo com o bot...` : `1 único usu foi deletado... Nem sei quem era kkkk`)
break

case 'rmlevel':
if(!isOwner) return reply(enviar.msg.dono)
if(!marc_tds) return reply("Marque a pessoa que deseja apagar do contador")
if(!JSON.stringify(level).includes(marc_tds)) return reply("Este usuário não está no contador...")
AB = level.map(i => i.id).indexOf(marc_tds)
level.splice(AB, 1)
saveLeVeLdb(level);
reply("✅ Usuário apagado do contador com sucesso...")
break

case 'transferirlevel': case 'trfrlv':
if(!isOwner) return reply(enviar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Este comando é para transferir o level e XP do número antigo de um usuário para o seu novo número... Retorne após o comando o número antigo do usuário, e o seu novo número, separando ambos com uma barra ( / ), ex:
${prefix+command} ${addNumberMais(botNumber)}/${addNumberMais(randomUser)}`)
usu1 = identArroba(q.split(`/`)[0])
usu2 = identArroba(q.split(`/`)[1])
if(!isYouInLevel(usu1)) return mention(`O usuário @${usu1.split("@")[0]} não está na database do level...`)
if(!isYouInLevel(usu2)) return mention(`O usuário @${usu2.split("@")[0]} não está na database do level...`)
lv = levelDBuser(usu1).level
cntd = levelDBuser(usu1).contador
addlevel(usu2, lv)
addXP(usu2, cntd)
AB = level.map(i => i.id).indexOf(usu1)
level.splice(AB, 1)
saveLeVeLdb(level)
mention(`Todos os ${lv} leveis e ${cntd} XP foram transferidos para o usuário @${usu2.split("@")[0]} com sucesso ✔`)
break

case 'leveling':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('Ative pressione 1, Desativar pressione 0')
if(Number(args[0]) === 1) {
if(isLevelingOn) return reply('*O recurso de nível já estava ativo antes*')
dataGp[0].level = true
setGp(dataGp)
reply(enviar.levelon) 
} else if(Number(args[0]) === 0) {
if(!isLevelingOn) return reply(`O recurso de level já está Desativado neste grupo.`)
dataGp[0].level = false
setGp(dataGp)
reply(enviar.leveloff)
} else {
reply('*[ Adicionar parâmetro 1 ou 0 ]*')
}
break

case 'gerarcard':
if(!isOwner) return reply(enviar.msg.dono)
var [i, v, d] = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/").split("/")
if(!i) return reply(`Marque com @ o usuário que vc quer adc o card`)
usu = i.toLowerCase() == "me" ? sender : identArroba(i)
if(!v || !isJsonIncludes(valoresXP, v.toLowerCase())) return reply(`Você deve retornar após o comando, o multiplicador de XP, entre os abaixo:
${valoresXP.map(a => `• ${a.velocidade}`).join(`\n`)}

Exemplo: ${prefix+command} @/${valoresXP[alerandom(valoresXP.length)].velocidade}`)
AB = valoresXP.map(p => p.velocidade).indexOf(v.toLowerCase())
if(!d) return reply(`Ainda falta escolher o tempo... Ex: @/2x/24h`)
nmr = Number(d.slice(0, d.length - 1))
letra = d.slice(d.length - 1, d.length).toLowerCase()
if(letra == `d`) vzs = 24
else vzs = 1
nmr *= vzs
if(!d || !isJsonIncludes(valoresXP[AB].dados, Number(nmr))) return reply(`Você deve retornar após o multiplicador de XP, a quantidade de dias do card, entre os abaixo:
${valoresXP[AB].dados.map(a => `• ${sendLetterTime(a.tempo)}`).join}

Exemplo: ${prefix+command} @/2x/48h`)
addUsuCardXP(mention, prefix, usu, v, d)
break

case 'gerarkeycard': {
if(!isOwner) return reply(enviar.msg.dono)
var [v, d] = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/").split("/")
if(!v || !isJsonIncludes(valoresXP, v.toLowerCase())) return reply(`Você deve retornar após o comando, o multiplicador de XP, entre os abaixo:
${valoresXP.map(a => `• ${a.velocidade}`).join(`\n`)}

Exemplo: ${prefix+command} ${valoresXP[alerandom(valoresXP.length)].velocidade}`)
AB = valoresXP.map(p => p.velocidade).indexOf(v.toLowerCase())
if(!d) return reply(`Ainda falta escolher o tempo... Ex: 2x/24h`)
nmr = Number(d.slice(0, d.length - 1))
letra = d.slice(d.length - 1, d.length).toLowerCase()
if(letra == `d`) vzs = 24
else vzs = 1
nmr *= vzs
if(!isJsonIncludes(valoresXP[AB].dados, Number(nmr))) return reply(`Você deve retornar após o multiplicador de XP, a quantidade de dias do card, entre os abaixo:
${valoresXP[AB].dados.map(a => `• ${sendLetterTime(a.tempo)}`).join}

Exemplo: ${prefix+command} 2x/48h`)
let { key } = await blackmd.sendMessage(from, {text: `🎲 *_KEY GERADA COM SUCESSO_* 🎲`}, {quoted: info})
await sleep(1500)
gerarTypeKey(sender, {type: 5, grupo: from, tempo: d, velocidade: v.toLowerCase()})
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
await sleep(500)
blackmd.sendMessage(from, {text: `${chave}`, edit: key}, {quoted: info})
await sleep(500)
sendMess(from, `🎳 *_Descrição ⤵_*
〔🎯〕⥲ *Tipo:* "CARD XP"
〔⏱〕⥲ *Tempo:* ${Number(d.slice(0, d.length - 1)) > 0 ? d : `∞ INFINITO`}`)
await sleep(500)
blackmd.sendMessage(from, {text: `Copie essa chave ou encaminhe ao privado do cliente ✔`}, {quoted: {
  key: {
    fromMe: false,
    participant: botNumber
  },
  message: {
    conversation: chave
  }
}})
}
break

case 'buycard':
addCardExperience(sender)
var [v, d] = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/").split("/")
if(!isJsonIncludes(valoresXP, v.toLowerCase())) return reply(`Você deve retornar após o comando, o multiplicador de XP, entre os abaixo:
${valoresXP.map(a => `• ${a.velocidade}`).join(`\n`)}

Exemplo: ${prefix+command} ${valoresXP[alerandom(valoresXP.length)].velocidade}`)
AB = valoresXP.map(p => p.velocidade).indexOf(v.toLowerCase())
if(!d) return reply(`Ainda falta escolher o tempo... Ex: 2x/24h`)
nmr = Number(d.slice(0, d.length - 1))
letra = d.slice(d.length - 1, d.length).toLowerCase()
if(letra == `d`) vzs = 24
else vzs = 1
nmr *= vzs
if(!isJsonIncludes(valoresXP[AB].dados, Number(nmr))) return reply(`Você deve retornar após o multiplicador de XP, a quantidade de dias do card, entre os abaixo:
${valoresXP[AB].dados.map(a => `• ${sendLetterTime(a.tempo)}`).join}

Exemplo: ${prefix+command} 2x/48h`)
AC = valoresXP[AB].dados.map(c => c.tempo).indexOf(nmr)
valor = valoresXP[AB].dados[AC].valor
if(getCoinsUsu(sender).saldo < valor) return reply(`💳 Um CARD XP *${v}* válido por *${sendTimeHours(nmr)}* custará *R$ ${(valor).toFixed(2)}*, mas você não possui saldo suficiente para completar a compra... Use o comando *${prefix}recarga* para adicionar saldo a saldo a sua conta e usufruir dos privilégios da loja 😃🎯`)
if(isGroup) reply(`Irei te enviar no PV 🧵`)
rmCoinsInVirtualBalance(sender, valor)
await sleep(1000)
gerarTypeKey(sender, {type: 5, grupo: from, tempo: sendLetterTime(nmr), velocidade: v.toLowerCase(), valor: valor})
dados = getCoinsUsu(sender)
chave = dados.keys[dados.keys.length - 1].key
sendButton(sender, {text: `💡 A chave "${chave}" foi gerada com sucesso... Copie e cole a mesma no seu grupo ou no PV do bot para validar o card e adicionar o seu combo multiplicador de XP 😊`, footer: chave}, blackmd, sender, [{type: `copy_text`, text: `CLIQUE AQUI`, url: chave}], seloctt)
break

case 'mycard':
addCardExperience(sender)
card = getCardXPusu(sender).cards
if(card.length <= 0) return reply(`Vc não possui cards multiplicadores de XP... Caso queira adquirir algum, olhe no comando ${prefix}loja o que melhor de satisfazer 🎯`)
txt =
`🔖 *Seus cartões disponíveis:*`
for(i = 0; i < card.length; i++) {
  txt += `\n\n»${i + 1}«
• *Multiplicador:* ${card[i].multi}x
• *Tempo:* ${sendLetterTime(card[i].horas)}
• *Ativo『 ${i == getCardXPusu(sender).mapa && getCardXPusu(sender).active ? "✅" : "❌"} 』*`
}
txt += `\n\n*Total:* ${card.length > 0 ? card.length + `\n_(Use ${prefix}setcard para ativar seu cartão de XP)_` : card.length}`
reply(txt)
break

case 'setcard':
addCardExperience(sender)
usu = getCardXPusu(sender)
card = usu.cards
if(!Number(q) || Number(q) < 1 || Number(q) > card.length || q.includes(".")) return reply(`*Olhe no comando ${prefix}mycard o número referente ao card que vc quer ativar, ex:*
${prefix+command} 1

Saiba tbm que, depois de ativado o card, não há como ativar outro até que este acabe ⚠️`)
if(usu.active) return reply("💌 *Há um card ativo no momento... Espere o mesmo acabar primeiro para ativar outro* 🔖")
i = Number(q) - 1
usu.mapa = i
usu.active = true
usu.tempo = card[i].horas
saveCardXP()
reply(`🔖 *Seu Card ${card[i].multi}x válido por ${sendLetterTime(card[i].horas)} foi ativado com sucesso* ✔️`)
break

case 'bangp':
case 'unbangp':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if(command == 'bangp'){
if(isBanchat) return reply(`Este grupo ja está banido`)
dataGp[0].bangp = true
setGp(dataGp)
reply(`🚫 *GRUPO BANIDO COM SUCESSO* 🚫`)
} else {
if(!isBanchat) return reply(`Este grupo não está banido`)
dataGp[0].bangp = false
setGp(dataGp)
reply(`✅ *GRUPO DESBANIDO COM SUCESSO* ✅`)
}
break

case 'b':
case 'u':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isOwner) return reply(enviar.msg.dono)
if(command == 'b'){
if(isBanchat) return blackmd.sendMessage(sender, {text: `Este grupo ja está banido`}, {quoted: info})
dataGp[0].bangp = true
setGp(dataGp)
} else {
if(!isBanchat) return blackmd.sendMessage(sender, {text: `Este grupo não está mais banido`}, {quoted: info})
dataGp[0].bangp = false
setGp(dataGp)
}
break

case 'boton':
case 'botoff':
if(!isOwner) return reply(enviar.msg.dono)
if(command == `botoff`) {
if(isBotoff) return reply(`O bot já está desligado...`)
setTimeout(() => {reagir(from, "❌")}, 300)
obrigadoEXT.botoff = true
setObg(obrigadoEXT)
reply('❌ *Desligando todas as funções do BLACK*')
} else {
if(!isBotoff) return reply(`O bot já está ligado...`)
setTimeout(() => {reagir(from, "✅")}, 300)
obrigadoEXT.botoff = false
setObg(obrigadoEXT)
reply(`✅ *Religando todas as funções do BLACK*`)
}
break

case 'modo+18':
case 'modonsfw':
case 'nsfw':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('Hmmmm')
if(Number(args[0]) === 1) {
if(isNsfw) return reply('O modo nsfw já está ativo')
dataGp[0].nsfw = true
setGp(dataGp)
reply(`\`\`\`✓Ativado com sucesso o modo nsfw +18 no grupo\`\`\` *${groupMetadata.subject}*`)
} else if(Number(args[0]) === 0) {
if(!isNsfw) return reply('O modo nsfw já está Desativado')  
dataGp[0].nsfw = false
setGp(dataGp)
reply(`\`\`\`✓Modo Nsfw +18 desativado com sucesso no grupo\`\`\` *${groupMetadata.subject}*`)
} else {
reply('1 para ativar, 0 para desligar')
}
break

case 'antipalavrão':
case 'antipalavrao':  
case 'antipalavra':    
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply(`[❗] 1 / 0, Exemplo ${prefix + command} 1`)
if(Number(args[0]) === 1) {
if(isPalavrao) return reply('Ja esta ativo.')
dataGp[0].antipalavrao.active = true
setGp(dataGp)
reply('🌀 Ativou com sucesso o recurso de Anti Palavras hardcore neste grupo 📝')
} else if(Number(args[0]) === 0) {
if(!isPalavrao) return reply('Ja esta Desativado')
dataGp[0].antipalavrao.active = false
setGp(dataGp)
reply('‼️ Desativou com sucesso o recurso de Anti Palavra harcore neste grupo✔️')
} else {
reply('1 para ativar, 0 para desativar')
}
break

case 'addpalavra':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isPalavrao) return reply('Anti palavrão desativado!')
if(args.length < 1) return reply( `Use assim : ${prefix + command} [palavrão]. exemplo ${prefix + command} puta`)
texto = args.join(' ').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "")
if(isPalavras.includes(texto)) return reply('Já foi adicionada')
dataGp[0].antipalavrao.palavras.push(texto)
setGp(dataGp)
reply('Palavrão adicionado com sucesso!')
break

case 'delpalavra':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isPalavrao) return reply('Anti palavrão desativado!')
if(args.length < 1) return reply( `Use assim : ${prefix + command} [palavrão]. exemplo ${prefix + command} puta`)
texto = args.join(' ').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "")
if(!isPalavras.includes(texto)) return reply('Já foi removida')
var i = dataGp[0].antipalavrao.palavras.indexOf(texto)
dataGp[0].antipalavrao.palavras.splice(i, 1)
setGp(dataGp)
reply('Palavrão removido da lista com sucesso!')
break

case 'listapalavrão': case 'listapalavra':
case 'listpalavra':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isPalavrao) return reply('Anti palavrão desativado!')
let lbw = `Esta é a lista de palavrão\nTotal : ${isPalavras.length}\n`
for (let i of isPalavras) {
lbw += `➸ ${i}\n`
}
await reply(lbw)
break

case 'limitecaracteres':
case 'limiteflood':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(args.length < 1) return reply(`Digite ${prefix + command} 1 para ativar`)
if(Number(args[0]) === 1) {
if(isAntiFlood) return reply(`🌀 O recurso limite de caracteres já está ativo no grupo 🌀`)
dataGp[0].limitec.active = true
setGp(dataGp)
reply(`✔️ O recurso limite de caracteres foi ativado nesse grupo📝`)
} else if(Number(args[0]) === 0) {
 if(!isAntiFlood) return reply('✔️ O recurso limite de caracteres não está ativado no grupo 📝')
dataGp[0].limitec.active = false
setGp(dataGp)
reply('O recurso limite de caracteres foi desativado nesse grupo ✔️')
} else {
reply(`Digite ${prefix + command} 1 para ativar, 0 para desativar o recurso`)
}
break

case 'limitecglobal':
case 'limitec':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isAntiFlood) return reply(`Ative este recurso primeiro ${prefix}limiteflood 1`)
if(!q) return reply(`Cade a quantidade? Ex: ${prefix + command} 5000`)
if(isNaN(q) == true) return reply('Digite apenas números')
if(command == 'limitec'){
dataGp[0].limitec.quantidade = q
setGp(dataGp)
reply(`Foi alterado o limite de caracteres para: ${q}`)
} else {
if(!isOwner) return reply(enviar.msg.dono)
var data = { limitefl: q }
fs.writeFileSync('./database/usuarios/flood.json', JSON.stringify(data, null, '\t'))
reply(`Foi adicionado um limite global de caracteres de: ${q}`)
}
break

case 'status': case 'stts':
  setTimeout(() => {reagir(from, "❔")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
txt =
`ㅤㅤ〘 ＳＴＡＴＵＳ 〙
╭════════════════════╯
│
│⇒ Anti Imagem: ${isAntiImg ? '✅' : '❌'}
│⇒ Anti Vídeo: ${isAntiVid ? '✅' : '❌'}
│⇒ Anti Áudio: ${isAntiAudio? '✅' : '❌'}
│⇒ Anti Sticker: ${isAntiSticker ? '✅' : '❌'}
│⇒ Anti Documento: ${Antidoc ? '✅' : '❌'}
│⇒ Anti Contato ${isAntiCtt ? '✅' : '❌'}
│⇒ Anti Localização: ${Antiloc ? '✅' : '❌'}
│⇒ Anti Link Grupo: ${isAntilinkgp ? '✅' : '❌'}
│⇒ Anti BAN Link Grupo: ${!isBanlinkgp ? '✅' : '❌'}
│⇒ Anti Link Hard: ${isAntiLinkHard ? '✅' : '❌'}
│⇒ Anti BAN Link Hard: ${!isBanLinkHard ? '✅' : '❌'}
│⇒ Anti Fake: ${isAntifake ? '✅' : '❌'}
│⇒ Anti Notas: ${isAntiNotas ? '✅' : '❌'}
│⇒ Anti Catalogo: ${isAnticatalogo ? '✅' : '❌'}
│⇒ Anti Palavrão: ${isPalavrao ? '✅' : '❌'}
│⇒ Limite Caracteres: ${isAntiFlood ? '✅' : '❌'}
│⇒ Bem Vindo 1: ${isWelkom ? '✅' : '❌'}
│⇒ Bem Vindo 2: ${isWelkom2 ? '✅' : '❌'}
│⇒ Bem Vindo 3: ${isWelkom3 ? '✅' : '❌'}
│⇒ Bem Vindo 4: ${isWelkom4 ? '✅' : '❌'}
│⇒ Bem Vindo 5: ${isWelkom5 ? '✅' : '❌'}
│⇒ Auto Aceitação: ${isAcceptGroup ? '✅' : '❌'}
│⇒ Simi 1: ${isSimi ? '✅' : '❌'}
│⇒ Simi 2: ${isSimi2 ? '✅' : '❌'}
│⇒ Auto Sticker: ${isAutofigu ? '✅' : '❌'}
│⇒ Auto Resposta: ${isAutorepo ? '✅' : '❌'}
│⇒ Modo Zoeira: ${isModobn ? '✅' : '❌'}
│⇒ Modo RPG: ${isBlackCity ? '✅' : '❌'}
│⇒ Level: ${isLevelingOn ? '✅' : '❌'}
│⇒ Modo +18: ${isNsfw ? '✅' : '❌'}
│⇒ Anti Ligação: ${isAnticall ? '✅' : '❌'}
│⇒ Anti PV Block: ${isAntiPv ? '✅' : '❌'}
│
╰════════════════════╮`
blackmd.sendMessage(from, {image: {url: logoslink.logo}, caption: txt}, {quoted: seloctt})
break

case 'reiniciar': case 'rr': {//adapted by math
if(!isOwner) return
var carregar = [
`[ ❗ ] Reiniciando meus sistemas em 5️⃣`,
`[ ❗ ] Reiniciando meus sistemas em 4️⃣`,
`[ ❗ ] Reiniciando meus sistemas em 3️⃣`,
`[ ❗ ] Reiniciando meus sistemas em 2️⃣`,
`[ ❗ ] Reiniciando meus sistemas em 1️⃣`,
`[ ❗ ] Reiniciando meus sistemas em 0️⃣`,
`~_*© black system*_~`
]
let { key } = await blackmd.sendMessage(from, {text: tempo+" "+pushname}, {quoted: info})//primeira mensagem
await sleep (1000)
for(let i = 0; i < carregar.length; i++) {
await sleep (1000)
await blackmd.sendMessage(from, {text: carregar[i], edit: key }, {quoted: info})
}
await sleep(1000)
process.exit()
}
break

//==========(Sticker-Stickers)===========\\

case 'emoji':
case 'semoji':
reagir(from, react2)
try {
if(!q.trim()) return reply(`Exemplo: ${prefix}emoji 🤔/whatsapp`)
var [emoji, nm] = q.split("/")
if(nm) {
var txtemoji = nm
} else {
var txtemoji = `whatsapp`
}
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/emoji?q=${emoji}/${txtemoji.toLowerCase()}&apikey=Yuta-Channel`)
sendStickerFromUrl(from, ABC.rst)
} catch {
return reply("Erro..")
}
break

case 'linktxt':
if(!q) return
reply(`${encodeURI(q)}`)
break

case 'wf': case 'fw': case 'qc': case 'wpp':
if(!q) return reply(`Oh, coloca um texto na frente do comando`)
setTimeout(() => {reagir(from, "✅")}, 300)
tttt = q.includes('/') ? q.split('/')[1] : q
if(tttt.length > 50) return reply("Texto muito grande")
const text = q.includes('/') ? q.split('/')[1] : `${q}`

const username = menc_prt ? getname(menc_prt) : q.includes('/') ? getname(identArroba(q.split('/')[0])).replace("usuário", q.split('/')[0]) : pushname

fotousu = menc_prt ? menc_prt : q.includes('/') ? Number(q.split('/')[0].replace("@", "").replace(new RegExp("[()+-/ +/]", "gi"), "")) ? q.split('/')[0].replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` : sender : sender

//IMAGEM DO PERFIL
try {
ppimg = await blackmd.profilePictureUrl(fotousu)
} catch {
ppimg = `https://telegra.ph/file/2a7516ef21d72cf8d9452.jpg`
}
//FIM IMAGEM DO PERFIL

//REQUIRES PRA FIGURINHA
const { writeExifImg } = require('./lib/exif')
//FIM DA REQUIERES

//DEFINIÇÃO FIGU
blackmd.sendImageAsSticker = async (jid, path, quoted, options = {}) => {
        let buff = Buffer.isBuffer(path) ? path : /^data:.*?\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\/\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0)
        let buffer
        if (options && (options.packname || options.author)) {
            buffer = await writeExifImg(buff, options)
        } else {
            buffer = await imageToWebp(buff)
        }

        await blackmd.sendMessage(jid, { sticker: { url: buffer }, ...options }, { quoted })
        return buffer
    }
//FIM DEFINIÇÕES FIGU    
    
    
const avatar = `${ppimg}`

const json = {
  "type": "quote",
  "format": "png",
  "backgroundColor": "#000000",
  "width": 512,
  "height": 768,
  "scale": 2,
  "messages": [
    {
      "entities": [],
      "avatar": true,
      "from": {
        "id": 1,
        "name": username,
        "photo": {
          "url": avatar
        }
      },
      "text": text,
      "replyMessage": {}
    }
  ]
};
        const response = axios.post('https://bot.lyo.su/quote/generate', json, {
        headers: {'Content-Type': 'application/json'}
}).then(res => {
    const buffer = Buffer.from(res.data.result.image, 'base64')
        blackmd.sendImageAsSticker(from, buffer, info, { packname: permuteFigPackName(`↑ 𝙎𝙏𝙄𝘾𝙆𝙀𝙍 𝘽𝙔`), author: permuteFigAuthorName(`${NomeDoBot} 📍`) })
});
break

case 'figfundo':
case 'figvideo':
case 'figusemfundo': 
case 'sfundo':
case 'sf':
setTimeout(() => {reagir(from, react2)}, 300)
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) {
rafa = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
aletxt = [`▧⃯⃟𝚁𝚎𝚖𝚘𝚟𝚎𝚗𝚍𝚘 𝙵𝚞𝚗𝚍𝚘ฺ͘.•🛸 ݈݇─`, `▧⃯⃟𝚁𝚎𝚝𝚒𝚛𝚊𝚗𝚍𝚘 𝙵𝚞𝚗𝚍𝚘ฺ͘.•🛸 ݈݇─`]
reply(aletxt[Math.floor(Math.random()*aletxt.length)])
buff = await getFileBuffer(rafa, 'image')
bas64 = `data:image/jpeg;base64,${buff.toString('base64')}`
anu = args.join(' ').split('|')
satu = anu[0] !== '' ? anu[0] : `📍Criado por↓`
sd = `${NomeDoBot}`
dua = typeof anu[1] !== 'undefined' ? anu[1] : `${sd}`
var mantap = await convertSticker(bas64, `${dua}`, `${satu}`)
var sti = new Buffer.from(mantap, 'base64');
blackmd.sendMessage(from, {sticker: sti}, {quoted: seloctt})
} else {
return reply(`So imagem mn -_-`)
}
break

case 'miih':
case 'mih':
case 'miihzinha':
reagir(from, "💜")
if(!isQuotedSticker) return reply(`Marque uma figurinha com o comando...

> ${prefix+command}`)
encmediats = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
reply(`_De miihzinha_
_Para miihzinha_
_Pela miihzinha_ 👑

*Gerando figu...* 💜`)
bas01 = `data:image/jpeg;base64,${encmediats.toString('base64')}`
var mantap = await convertSticker(bas01, ` ຊ`, `ＭＩＩＨ `)
var sti = new Buffer.from(mantap, 'base64');
blackmd.sendMessage(from, {sticker: sti, contextInfo: { externalAdReply:{title: `ოííհ sմթɾҽოαcվ 💜🧸`,body:"", previewType:"PHOTO",thumbnail: sti}}}, {quoted: seloctt})
.catch((err) => {
reply(`❌ Erro, tenta mais tarde`); 
})
break

case 'flady':
case 'slady':
case 'fl':
setTimeout(() => {reagir(from, "✅")}, 300)
if(!isQuotedSticker) return reply(`Marque uma figurinha com o comando...

- ${prefix+command}`)
reply(`▧⃯⃟𝚁𝚎𝚗𝚘𝚖𝚎𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙵𝚒𝚐𝚞𝚛𝚒𝚗𝚑𝚊ฺ͘.•🛸 ݈݇─`)
renameContextSticker(permuteFigPackName(pushname), permuteFigAuthorName(NomeDoBot), `ROUBADA COM SUCESSO 😎👍🏽`, info)
.catch((err) => {
reply(`❌ Erro, tenta mais tarde`); 
})
break

case 'rename':
case 'roubar':
setTimeout(() => {reagir(from, "✅")}, 300)
if(!isQuotedSticker) return reply('Marque uma figurinha...')
var kls = q
var pack = kls.split("/")[0];
var author2 = kls.split("/")[1];
if(!q) return reply('*Falta um nome para renomear a figurinha... ;-;*')
if(!pack) return reply(`*Necessita de um nome antes da barra ( / ), ex:*
${prefix+command} ${pushname+q}`)
if(!author2) return reply(`*Falta um complemento, ex:*
${prefix+command} ${q}/complemento`)
reply(`𝙿𝚊𝚌𝚔 𝙽𝚊𝚖𝚎: _"${pack.split(`\n`).join(`_\n_`)}"_
𝙰𝚞𝚝𝚑𝚘𝚛 𝙽𝚊𝚖𝚎: _"${author2.split(`\n`).join(`_\n_`)}"_
-------------------------------------------------------------
▧⃯⃟𝚁𝚎𝚗𝚘𝚖𝚎𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙵𝚒𝚐𝚞𝚛𝚒𝚗𝚑𝚊ฺ͘.•🛸 ݈݇─`)
renameContextSticker(pack, author2, `${pack}|${author2}`, info)
.catch((err) => {
reply(`❌ Erro, tenta mais tarde`); 
})
break

/*case 'fblack':
case 'sblack':
case 'fb':
setTimeout(() => {reagir(from, "✅")}, 300)
if(!isQuotedSticker) return reply(`Marque uma figurinha com o comando...

- ${prefix+command}`)
encmediats = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
reply(`▧⃯⃟𝚁𝚎𝚗𝚘𝚖𝚎𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙵𝚒𝚐𝚞𝚛𝚒𝚗𝚑𝚊ฺ͘.•🛸 ݈݇─`)
bas01 = `data:image/jpeg;base64,${encmediats.toString('base64')}`
var mantap = await convertSticker(bas01, permuteFigAuthorName(pushname), permuteFigPackName(NomeDoBot))
var sti = new Buffer.from(mantap, 'base64');
blackmd.sendMessage(from, {sticker: sti, contextInfo: {externalAdReply: {title: `ROUBADA COM SUCESSO 😎👍🏽`, body:"", previewType:"PHOTO", thumbnail: sti}}}, {quoted: seloctt})
.catch((err) => {
reply(`❌ Erro, tenta mais tarde`); 
})
break

case 'rename':
case 'roubar':
setTimeout(() => {reagir(from, "✅")}, 300)
if(!isQuotedSticker) return reply('Marque uma figurinha...')
encmediats = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
var kls = q
var pack = kls.split("/")[0];
var author2 = kls.split("/")[1];
if(!q) return reply('*Falta um nome para renomear a figurinha... ;-;*')
if(!pack) return reply(`*Necessita de um nome antes da barra ( / ), ex:*
${prefix+command} ${pushname+q}`)
if(!author2) return reply(`*Falta um complemento, ex:*
${prefix+command} ${q}/complemento`)
reply(`𝙿𝚊𝚌𝚔 𝙽𝚊𝚖𝚎: _"${pack}"_
𝙰𝚞𝚝𝚑𝚘𝚛 𝙽𝚊𝚖𝚎: _"${author2}"_
-------------------------------------------------------------
▧⃯⃟𝚁𝚎𝚗𝚘𝚖𝚎𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙵𝚒𝚐𝚞𝚛𝚒𝚗𝚑𝚊ฺ͘.•🛸 ݈݇─`)
bas64 = `data:image/jpeg;base64,${encmediats.toString('base64')}`
var mantap = await convertSticker(bas64, `${author2}`, `${pack}`)
var sti = new Buffer.from(mantap, 'base64');
blackmd.sendMessage(from, {sticker: sti, contextInfo: { externalAdReply:{title: `${pack}|${author2}`,body:"", previewType:"PHOTO",thumbnail: sti}}}, {quoted: seloctt})
.catch((err) => {
reply(`❌ Erro, tenta mais tarde`); 
})
break*/

case 'ususticker': case 'us':
if(!isGroup) return mention(privateCmd(sender, prefix+command, `"não encontrado"`, 0))
if(!menc_os2) return reply(`Marque a pessoa de quem você quer transformar a foto de perfil em figurinha...`)
///////////PEGAR A FOTO DO USUÁRIO/////////////
try {
fotoDePerfilDoMath = await blackmd.profilePictureUrl(`${menc_os2.split('@')[0]}@c.us`, 'image')
} catch {
return reply("Usuário está sem foto de perfil ❌")
}
//////////////GERAR LINK DA FOTO////////////////
try {
shortpc = await axios.get(`https://tinyurl.com/api-create.php?url=${fotoDePerfilDoMath}`);
matheuzinho = shortpc.data
} catch {
return reply("Falha ao tentar converter ❌")
}
//////////////FAZER A FIGURINHA/////////////////
reply(`❪∘̥⃟⸽⃟𝙲𝚘𝚗𝚟𝚎𝚛𝚝𝚎𝚗𝚍𝚘 𝙴𝚖 𝙵𝚒𝚐𝚞𝚛𝚒𝚗𝚑𝚊∘̥⃟৴▸`)
sendStickerFromUrl(from, matheuzinho)
break

case 'fstiker':
case 'fsticker':
case 'f':
reagir(from, "✅")
var RSM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var boij = RSM?.imageMessage || info.message?.imageMessage || RSM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSM?.viewOnceMessage?.message?.imageMessage
var boij2 = RSM?.videoMessage || info.message?.videoMessage || RSM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSM?.viewOnceMessage?.message?.videoMessage  
if(boij) {
var pack = permuteFigPackName(`❪👤𝚄𝚜𝚞á𝚛𝚒𝚘 (𝚊)ฺ࣭࣪͘ꕸ▸
❪🤖𝙱𝚘𝚝ฺ࣭࣪͘ꕸ▸
❪👑𝙳𝚘𝚗𝚘ฺ࣭࣪͘ꕸ▸
❪🌐𝚂𝚒𝚝𝚎ฺ࣭࣪͘ꕸ▸`)
var author2 = permuteFigAuthorName(`${pushname}
${NomeDoBot}
${NickDono}
${site}`)
reply(`❪∘̥⃟⸽⃟𝙲𝚘𝚗𝚟𝚎𝚛𝚝𝚎𝚗𝚍𝚘 𝙴𝚖 𝙵𝚒𝚐𝚞𝚛𝚒𝚗𝚑𝚊∘̥⃟৴▸`)
owgi = await getFileBuffer(boij, 'image')
let encmediaa = await sendImageAsSticker(blackmd, from, owgi, info, { packname:pack, author:author2})
await DLT_FL(encmediaa)
} else if(boij2 && boij2?.seconds < 11) {
var pack = permuteFigPackName(`❪👤𝚄𝚜𝚞á𝚛𝚒𝚘 (𝚊)ฺ࣭࣪͘ꕸ▸
❪🤖𝙱𝚘𝚝ฺ࣭࣪͘ꕸ▸
❪👑𝙳𝚘𝚗𝚘ฺ࣭࣪͘ꕸ▸
❪🌐𝚂𝚒𝚝𝚎ฺ࣭࣪͘ꕸ▸`)
var author2 = permuteFigAuthorName(`${pushname}
${NomeDoBot}
${NickDono}
${site}`)
reply(`❪∘̥⃟⸽⃟𝙲𝚘𝚗𝚟𝚎𝚛𝚝𝚎𝚗𝚍𝚘 𝙴𝚖 𝙵𝚒𝚐𝚞𝚛𝚒𝚗𝚑𝚊∘̥⃟৴▸`)
owgi = await getFileBuffer(boij2, 'video')
let encmedia = await sendVideoAsSticker(blackmd, from, owgi, info, { packname:pack, author:author2})
await DLT_FL(encmedia)
} else {
reply(`Marque uma imagem ou vídeo de até 10 segundos com o comando ${prefix+command}`)
}
break
case 'figurinha':
{
(async function () {
var legenda = q ? q?.split("/")[0] : `╼⊳⊰ Solicitado Por:`
var autor = q ? q?.split("/")[1] : q?.split("/")[0] ? '' : `${pushname}`
if (isMedia && !info.message.videoMessage || isQuotedImage) {
var encmedia = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'image')
fs.writeFileSync(rane, buffimg)
rano = getRandom('.webp')
exec(`ffmpeg -i ${rane} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${rano}`, (err) => {
fs.unlinkSync(rane)
// "android-app-store-link": "https://play.google.com/store/search?q=%2B55%2094%209147-2796%20%F0%9F%94%A5%F0%9F%94%A5%F0%9F%94%A5%F0%9F%94%A5%F0%9F%94%A5&c=apps",
var json = {
"sticker-pack-name": legenda,
"sticker-pack-publisher": autor
}
var exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])
var jsonBuff = Buffer.from(JSON.stringify(json), "utf-8")
var exif = Buffer.concat([exifAttr, jsonBuff])
exif.writeUIntLE(jsonBuff.length, 14, 4)
let nomemeta = Math.floor(Math.random() * (99999 - 11111 + 1) + 11111)+".temp.exif"
fs.writeFileSync(`./${nomemeta}`, exif) 
exec(`webpmux -set exif ${nomemeta} ${rano} -o ${rano}`, () => {
blackmd.sendMessage(from, {sticker: fs.readFileSync(rano)}, {quoted: info})
fs.unlinkSync(nomemeta)
fs.unlinkSync(rano)
})
})
} else if (isMedia && info.message.videoMessage.seconds < 11 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 35) {
var encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
rano = getRandom('.webp')
await ffmpeg(`./${rane}`)
.inputFormat(rane.split('.')[1])
exec(`ffmpeg -i ${rane} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 200:200 ${rano}`, (err) => {
fs.unlinkSync(rane)
let json = {
"sticker-pack-name": legenda,
"sticker-pack-publisher": autor
}
let exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])
let jsonBuff = Buffer.from(JSON.stringify(json), "utf-8")
let exif = Buffer.concat([exifAttr, jsonBuff])
exif.writeUIntLE(jsonBuff.length, 14, 4)
let nomemeta = "temp.exif"
fs.writeFileSync(`./${nomemeta}`, exif) 
exec(`webpmux -set exif ${nomemeta} ${rano} -o ${rano}`, () => {
blackmd.sendMessage(from, {sticker: fs.readFileSync(rano)}, {quoted: info})
fs.unlinkSync(nomemeta)
fs.unlinkSync(rano)
})
})
} else {
reply(`Você precisa enviar ou marcar uma imagem ou vídeo com no máximo 10 segundos`)
}
})().catch(e => {
console.log(e)
reply("Hmm deu erro")
try {
if (fs.existsSync("temp.exif")) fs.unlinkSync("temp.exif");
if (fs.existsSync(rano)) fs.unlinkSync(rano);
if (fs.existsSync(media)) fs.unlinkSync(media);
} catch {}
})
}
break
case 'st':
case 'stk':
case 'sticker':
case 's':
setTimeout(() => { reagir(from, "✅") }, 300)
var RSM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var boij2 = RSM?.imageMessage || info.message?.imageMessage || RSM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSM?.viewOnceMessage?.message?.imageMessage
var boij = RSM?.videoMessage || info.message?.videoMessage || RSM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSM?.viewOnceMessage?.message?.videoMessage

if (boij2) {
  var pack = permuteFigPackName(`❪👤𝚄𝚜𝚞á𝚛𝚒𝚘 (𝚊)ฺ࣭࣪͘ꕸ▸`)
  var author2 = permuteFigAuthorName(`${pushname}`)
  owgi = await getFileBuffer(boij2, 'image')
  let encmediaa = await sendImageAsSticker2(blackmd, from, owgi, info, { packname: pack, author: author2 })
  await DLT_FL(encmediaa)
} else if (boij && boij.seconds < 11) {
  var pack = permuteFigPackName(`❪👤𝚄𝚜𝚞á𝚛𝚒𝚘 (𝚊)ฺ࣪`)
  var author2 = permuteFigAuthorName(`${pushname}`)
  owgi = await getFileBuffer(boij, 'video')
  let encmedia = await sendVideoAsSticker2(blackmd, from, owgi, info, { packname: pack, author: author2 })
  await DLT_FL(encmedia)
} else {
  return reply(`Marque uma imagem ou vídeo de até 10 segundos com o comando ${prefix + command}`)
}
break

case 'rgpackfig': case 'rgpf':
if(!isVip) return reply(enviar.msg.vip)
if(!q) return reply("KD o MOD \"pack\" da figurinha?")
if(isJsonIncludes(figname, sender)) {
  AB = figname.map(i => i.id).indexOf(sender)
  if(!isJsonIncludes(figname[AB].fig, "pack")) {
    figname[AB].fig.push({mod: "pack", pack: q})
    saveJSON(figname, "./basededados/figname.json")
    return reply(`*MOD "pack" da figurinha adicionado com sucesso* ✔️`)
  } else {
    BC = figname[AB].fig.map(i => i.mod).indexOf("pack")
    figname[AB].fig[BC].pack = q
    saveJSON(figname, "./basededados/figname.json")
    return reply(`*MOD "pack" da figurinha alterado com sucesso* ✔️`)
  }
} else {
  figname.push(
    {id: sender, fig: [
      {mod: "pack", pack: q}
      ]
    }  
  )
  saveJSON(figname, "./basededados/figname.json")
  return reply(`*MOD "pack" da figurinha adicionado com sucesso* ✔️`)
}
break

case 'rgauthorfig': case 'rgaf':
if(!isVip) return reply(enviar.msg.vip)
if(!q) return reply("KD o MOD \"author\" da figurinha?")
if(isJsonIncludes(figname, sender)) {
  AB = figname.map(i => i.id).indexOf(sender)
  if(!isJsonIncludes(figname[AB].fig, "author")) {
    figname[AB].fig.push({mod: "author", author: q})
    saveJSON(figname, "./basededados/figname.json")
    return reply(`*MOD "author" da figurinha adicionado com sucesso* ✔️`)
  } else {
    BC = figname[AB].fig.map(i => i.mod).indexOf("author")
    figname[AB].fig[BC].author = q
    saveJSON(figname, "./basededados/figname.json")
    return reply(`*MOD "author" da figurinha alterado com sucesso* ✔️`)
  }
} else {
  figname.push(
    {id: sender, fig: [
      {mod: "author", author: q}
      ]
    }  
  )
  saveJSON(figname, "./basededados/figname.json")
  return reply(`*MOD "author" da figurinha adicionado com sucesso* ✔️`)
}
break

case 'rmpackfig': case 'rmpf':
case 'rmauthorfig': case 'rmaf':
case 'rmfigall': case 'rmfa':
if(!isVip) return reply(enviar.msg.vip)
if(isJsonIncludes(figname, sender)) {
  AB = figname.map(i => i.id).indexOf(sender)
  if(command == "rmfigall" || command == "rmfa") {
    figname.splice(AB, 1)
    saveJSON(figname, "./basededados/figname.json")
    return reply(`*MOD's "pack" & "author" da figurinha deletados com sucesso* ✔️`)
  } else if(command == "rmpackfig" || command == "rmpf") {
    txt = "pack"
  } else {
    txt = "author"
  }
  BC = figname[AB].fig.map(i => i.mod).indexOf(txt)
  if(BC < 0) return reply(`🎲 *Você não registrou o MOD "${txt}" da figurinha para deletar o mesmo* 📛`)
  figname[AB].fig.splice(BC, 1)
  saveJSON(figname, "./basededados/figname.json")
  return reply(`*MOD "${txt}" da figurinha deletado com sucesso* ✔️`)
} else reply("🎲 *impossível apagar um dado inexistente* 📛")
break

case 's2':
setTimeout(() => {reagir(from, react2)}, 300)
if(!isVip) { reply(enviar.msg.vip)
return blackmd.sendMessage(from, {audio: {url:'./database/audios/sovip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
try {
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) { 
reply(`❪∘̥⃟⸽⃟𝙲𝚘𝚗𝚟𝚎𝚛𝚝𝚎𝚗𝚍𝚘 𝙴𝚖 𝙵𝚒𝚐𝚞𝚛𝚒𝚗𝚑𝚊∘̥⃟৴▸`)
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
sendStickerFromUrl(from, {url: res})
} else if((isMedia && info.message.videoMessage.seconds < 10 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 10) && !q.length <= 1) { 
reply(`❪∘̥⃟⸽⃟𝙲𝚘𝚗𝚟𝚎𝚛𝚝𝚎𝚗𝚍𝚘 𝙴𝚖 𝙵𝚒𝚐𝚞𝚛𝚒𝚗𝚑𝚊∘̥⃟৴▸`)
boij = isQuotedVideo ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.videoMessage : info.message.videoMessage
owgi = await getFileBuffer(boij, 'video')
res = await upload(owgi)
sendStickerFromUrl(from, {url: res})
} else {
reply("Você deve marcar uma imagem, ou um vídeo de até 10 segundos..")
}
} catch {
reply(`Deu erro... Talvez o arquivo seja muito grande 😕`)
}
break

case 'name1':
setTimeout(() => {reagir(from, "✅")}, 300)
if(!isOwner) return reply(`;-;`)
var RSM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var boij2 = RSM?.imageMessage || info.message?.imageMessage || RSM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSM?.viewOnceMessage?.message?.imageMessage
var boij = RSM?.videoMessage || info.message?.videoMessage || RSM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSM?.viewOnceMessage?.message?.videoMessage
if(boij2){
var n3 = `name3`
var n4 = `name4`
reply(`name2`)
owgi = await getFileBuffer(boij2, 'image')
let encmediaa = await sendImageAsSticker2(blackmd, from, owgi, info, { packname:n3, author:n4})
await DLT_FL(encmediaa)
} else if(boij && boij.seconds < 11){
var n3 = `name3`
var n4 = `name4`
reply(`name2`)
owgi = await getFileBuffer(boij, 'video')
let encmedia = await sendVideoAsSticker2(blackmd, from, owgi, info, { packname:n3, author:n4})
await DLT_FL(encmedia)
} else {
return reply(`name5 (opcional)`)
}
break

case 'toimg':
if(!isQuotedSticker) return reply(`Marque uma figurinha, e eu vou transformar em imagem...\n\nSe for figurinha animada, use ${prefix}togif`)
try {
reply(`❪∘̥⃟⸽⃟𝙲𝚘𝚗𝚟𝚎𝚛𝚝𝚎𝚗𝚍𝚘 𝙴𝚖 𝙸𝚖𝚊𝚐𝚎𝚖∘̥⃟৴▸`)
buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
blackmd.sendMessage(from, {image: buff}, {quoted: seloctt}).catch(e => {
console.log(e);
reply('ERRO!!')
})
} catch {
reply("Erro..")
}
break

//==========(PLAQUINHAS-LOGOS)===========\

case 'placaloli':
if(!q) return reply(enviar.wrongFormat)
reply('Aguarde..')
lod = await fetchJson(`https://nekobot.xyz/api/imagegen?type=kannagen&text=${q}`)
sendStickerFromUrl(from, lod.message, enviar.success)
break
// ENTRETENIMENTO 
  // MENU JOGOS // 

case 'site1':
reagir(from, "🌐")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🌐 *modyolo* https://modyolo.com`)
break
case 'site2':
reagir(from, "🌐")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🌐 *liteapks* https://liteapks.com`)
break
case 'site3':
reagir(from, "🌐")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🌐 *getmods* https://getmodsapk.com/`)
break
case 'site4':
reagir(from, "🌐")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🌐 *apkmody* https://apkmody.com`)
break
case 'site5':
reagir(from, "🌐")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🌐 *apkdone* https://apkdone.com/`)
break

case 'site6':
reagir(from, "🎦")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎦 *pobreflix* https://pobreflix.life`)
break 
case 'site7':
reagir(from, "🎦")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎦 *megaflix* https://megaflix6.com`)
break
case 'site8':
reagir(from, "🎦")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎦 *boralfix* https://www.boraflix.com`)
break
case 'site9':
reagir(from, "🎦")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎦 *superflix* https://superflix.cloud/`)
break
case 'site10':
reagir(from, "🎦")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎦 *filmesxp* https://filmesxp.com/`)
break
case 'site11':
reagir(from, "📺")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
📺 *multicanais* https://multicanais.com`)
break
case 'site12':
reagir(from, "📺")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
📺 *futemax* https://futemax.uk/`)
break
case 'site13':
reagir(from, "📺")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
📺 *redecanais* https://redecanais.gs/`)
break
case 'site14':
reagir(from, "📺")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
📺 *player tv* https://playertv.net/`)
break
case 'site15':
reagir(from, "📺")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
📺 *pirate tv* https://piratetv.pro/`)
break

case 'jogo1':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Minecraft:* https://www.mediafire.com/file/4k6ajlxiht8kp4n/Minecraft_1.21.0_OFFICIAL.apk/file`)
break
case 'jogo2':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *DragonBall Z - Dokkan:* https://www.mediafire.com/file/015ibjiljfkv7uo/Dokkan_v4_12_1_MOD.apk/file`)
break
case 'jogo3':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *GTA SanAndreas:* https://www.mediafire.com/file/ln6r3kx0ie77r9t/GTA_San_Andreas_2021.zip/file`)
break
case 'jogo4':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *GTA SA - Legendado em Português:* http://www.mediafire.com/file/7op13aup1ll7m9y/GTA_SA_COM_TRADU%25C3%2587%25C3%2583O_PT-BR.zip/file`)
break
case 'jogo5':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *GTA SA com Mod Cleo:* http://www.mediafire.com/file/d8cfwzctx95x0dx/GTA_SA_v2.00_Mod_Cleo.zip/file`)
break
case 'jogo6':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *GTA SA Online:* https://www.mediafire.com/file/0xccd5m0zwqstag/GTA_SA_ONLINE_SAMP_ByHT.zip/file`)
break
case 'gpsamp':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu o grupo, espero que você goste!
-
🔥 *Grupo Ofc:* https://chat.whatsapp.com/JDEH0eU70z2LLU4FywshzY`)
break
case 'jogo7':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *GTA SuperLite + Mod Cleo:* http://www.mediafire.com/file/wdkg8pmndtihil3/GTA_SA_super_lite_mod_cleo_ByHT.zip/file`)
break
case 'jogo8':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *LastDay on Eart Survival:* https://www.mediafire.com/file/k4pr6awvr5eb1ak/Last%20Day%20on%20Earth%201.17.7-mod.apk/file `)
break
case 'jogo9':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Bomber Friends MOD:* https://www.mediafire.com/file/dir8pwrb1mpm57w/Bomber_Friends_v4.10_MOD.apk/file`)
break
case 'jogo10':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Arcade Hunter:* https://www.mediafire.com/file/ugcdaclnpodtxxs/Arcade_Hunter-Sword%252CGun%252C_and_Magic_1.11.0-mod.apk/file`)
break
case 'jogo11':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Defesa de Zombie Ocioso:* https://www.mediafire.com/file/8422sjofw1cdnka/Zombie+Idle+Defense+1.5.79.229MOD-t.apk/file`)
break
case 'jogo12':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Pac-Man:* https://www.mediafire.com/file/gxwy01ni99pcur2/PAC-MAN+9.2.7.10150MOD-t.apk/file`)
break
case 'jogo13':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Car Driving School Simulator - APK:* https://www.mediafire.com/file/r6aps8mn6wqoabj/Car+Driving+School+Simulator+3.1.0.283MOD-t.apk/file
🎳 _Obrigatório instalar o OBB:_
 https://www.mediafire.com/file/hcsb5tpr7byh8fg/com.boombitgames.DrivingSchoolParking.zip/file`)
break
case 'jogo14':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Cyber Fighters Premium:* https://www.mediafire.com/file/4tmv2cdahvqamlx/Cyber+Fighters+Premium+1.11.35.68MOD-t.apk/file`)
break
case 'jogo15':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Rag Racing:* https://www.mediafire.com/file/g88v399ks1fpnfq/drag-racing-mod_2.0.37.rar/file`)
break
case 'jogo16':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Mr. Brow:* https://www.mediafire.com/file/i0ii099sejk9fnk/Mr+Bow+4.15.75MOD-t.apk/file`)
break
case 'jogo17':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Airport City:* https://www.mediafire.com/file/vuupmpp3r03lso0/Airport+City+8.7.18.101418MOD-t.apk/file`)
break
case 'jogo18':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Crash Bandicoot:* https://www.mediafire.com/file/nyx8rjqn5m51o3r/Crash+Bandicoot+Mobile+v0.7.6242+Mod.apk/file `)
break
case 'jogo19':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Real Steel World Robot Boxing (APK+OBB):* https://www.mediafire.com/file/zcnsxb55mldn51e/Real+Steel+World+Robot+Boxing+v54.54.126+Mod.apk/file`)
break
case 'jogo20':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Anger of Sticker:* https://www.mediafire.com/file/zfmqmszkhbgoem2/anger-of-stick-5-mod_1.1.39.apk/file`)
break
case 'jogo21':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Angry Birds 2 (APK+OBB)*
https://www.mediafire.com/file/uwnurszwrdbv5ge/angrybirds2-2481.apk/file`)
break
case 'jogo22':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Especial Force Group 2 (CS):* https://www.mediafire.com/file/uwf5cq9u8tjg44x/specialforcesgroup2-421.apk/file`)
break
case 'jogo23':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Roblox:* https://apkadmin.com/k05ck2q6ioo1/ROBLOX_v2.459.415955_MOD_MENU.apk.html`)
break
case 'jogo24':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Critical Striker:* https://www.mediafire.com/file/7yqmk1gn4wrieri/CRITICAL_STRIKE.zip/file`)
break
case 'jogo25':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Dream League Soccer:* http://www.mediafire.com/file/yuw9n5d4phzz5wg/Dream_League_Soccer_2019_v6.13-mod.apk/file`)
break
case 'jogo26':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Clash of Clans:* http://www.mediafire.com/file/aoaem76tyg0hvfv/Clash_Of_Clans_v13.675.6_MOD.apk/file`)
break
case 'jogo27':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Criminal Case Paris:* http://www.mediafire.com/fil...e/i5pbv8d7yjbbtly/Criminal%20Case%20Paris%20v2.36.1-mod.apk/file`)
break 

case 'jogo28':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Drift Max World:* https://www.mediafire.com/file/hqui6asekutsocq/DRIFT+MAX+WORLD+DINHEIRO+INFINITO.zip/file`)
break

case 'jogo29':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Downhill Masters:* https://www.mediafire.com/file/9cdgreyc8amkto9/Downhill_Masters_v1.0.59_MOD.apk/file`)
break
case 'jogosamp':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
☕ IP DO SERVIDOR DO MEU CRIADOR: 23.88.73.88:11627
-
🎳 *SA-MP:* https://play.google.com/store/apps/details?id=ru.unisamp_mobile.launcher`)
break

case 'jogo30':
reagir(from, "🎮")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎳 *Monopoly:* https://www.mediafire.com/file/q5jfi61xwbqiu2x/Monopoly-v1-7-11-mod.zip/file`)
break 

// SÉRIES //

case 'serie1':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Arcane:* https://overflix.online/series/arcane/`)
break

case 'serie2':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Stranger Things:* https://overflix.online/series/stranger-things-gratis-hd/`)
break

case 'serie3':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Soldados ou Zumbis:* https://overflix.online/series/s-o-z-soldados-ou-zumbis/`)
break

case 'serie4':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Senhor dos Aneis:* https://overflix.online/series/o-senhor-dos-aneis-os-aneis-de-poder-online-hd-gratis/`)
break

case 'serie5':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Riverdale:* https://overflix.online/series/riverdale-online-gratis-hd-full/`)
break

case 'serie6':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *A casa do dragão:* https://overflix.online/series/a-casa-do-dragao-online-gratis-hd/`)
break

case 'serie7':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Sintonia:* https://overflix.online/series/sintonia-online-gratis/`)
break

case 'serie8':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Chucky:* https://overflix.online/series/chucky-a-serie/`)
break

case 'serie9':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Flash:* https://overflix.online/series/flash-hd-online-gratis/`)
break

case 'serie10':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Game of Thrones:* https://overflix.online/series/game-of-thrones-hd-online-gratis/`)
break

case 'serie11':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Legados:* https://overflix.online/series/legados-gratis-hd-online/`)
break

case 'serie12':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *The Good Doctor:* https://overflix.online/series/the-good-doctor-o-bom-doutor-hd-online/`)
break

case 'serie13':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *The Walking Dead:* https://overflix.online/series/the-walking-dead/`)
break

case 'serie14':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Peaky Blinders:* https://overflix.online/series/peaky-blinders-sangue-apostas-e-navalhas/`)
break

case 'serie15':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Diarios de um vampiro:* https://overflix.online/series/diarios-de-um-vampiro/`)
break

case 'serie16':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Gavião Arqueiro:* https://overflix.online/series/gaviao-arqueiro-full-online-gratis/`)
break 

case 'serie17':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Westworld:* https://overflix.online/series/westworld-hd-gratis-online/`)
break

case 'serie18':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Lúcifer:* https://overflix.online/series/lucifer-online-hd/`)
break

case 'serie19':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Lobo Adolecentes:* https://overflix.online/series/lobo-adolescente/`)
break

case 'serie20':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *La Casa de Papel:* https://overflix.online/series/la-casa-de-papel/`)
break

case 'serie21':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Cobra Kai:* https://overflix.online/series/cobra-kai-online-gratis-hd/`)
break

case 'serie22':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Love Victor:* https://overflix.online/series/love-victor-gratis-online-hd/`)
break

case 'serie23':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Vikings:* https://overflix.online/series/vikings-hd/`)
break

case 'serie24':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Cavaleiro da Lua:* https://overflix.online/series/cavaleiro-da-lua-online-gratis-hd-full/`)
break

case 'serie25':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Fear The Walking Dead:* https://overflix.online/series/fear-the-walking-dead/`)
break

case 'serie26':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Rick Morty:* https://overflix.online/series/rick-morty/`)
break

case 'serie27':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Round 6:* https://overflix.online/series/round-6-online-gratis-hd-full/`)
break

case 'serie28':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Carnival Row:* https://overflix.online/series/carnival-row-online-hd/`)
break

case 'serie29':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Dark:* https://overflix.online/series/dark/`)
break

case 'serie30':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Arqueiro:* https://overflix.online/series/arqueiro/`)
break 

case 'serie31':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Eu Nunca:* https://overflix.online/series/eu-nunca/`)
break

case 'serie32':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *The Last Kingdom:* https://overflix.online/series/the-last-kingdom/`)
break

case 'serie33':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *O livro de Boba Fett:* https://overflix.online/series/o-livro-de-boba-fett-hd-online-gratis-full/`)
break

case 'serie34':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Ragnarok:* https://overflix.online/series/ragnarok/`)
break 

case 'serie35':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *OS 100:* https://overflix.online/series/os-100/`)
break

case 'serie36':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *FBI:* https://overflix.online/series/fbi/`)
break

case 'serie37':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Extracurricular:* https://overflix.online/series/extracurricular/`)
break

case 'serie38':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Halo:* https://overflix.online/series/halo-online-gratis/`)
break

case 'serie39':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Warrior Nun:* https://overflix.online/series/warrior-nun-online-completo/`)
break

case 'serie40':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Anne With:* https://overflix.online/series/anne-with-an-e/`)
break

case 'serie41':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Patrulha do destino:* https://overflix.online/series/patrulha-do-destino-online/`)
break

case 'serie42':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Dinastia:* https://overflix.online/series/dinastia/`)
break

case 'serie43':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Watchmen:* https://overflix.online/series/watchmen/`)
break

case 'serie44':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_🥶 Olá , aqui está o seu pedido, espero que você goste!_*
-
🎥 *Lovecraft Country:* https://overflix.online/series/lovecraft-country-dublado-legendado-online-hd-gratis/`)
break

// CONTAS FREE //
case 'contas_netflix':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui ssta as contas da Netflix vazadas_*
-
🌐 https://pt.anotepad.com/note/read/ytgrkdgt`)
break
case 'contas_hbo':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui está algumas contas da hbo max_*
-
🌐 https://pt.anotepad.com/note/read/8yxaityw`)
break
case 'contas_star+':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta sua conta da star+_*
-
🌐 https://pt.anotepad.com/note/read/nssgyhhn`)
break
case 'contas_disney+':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta sua conta da disney+_*
-
🌐 https://pt.anotepad.com/note/read/xpgsi45r`)
break
case 'contas_paramount+':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta sua conta da Paramount+_*
-
🌐 https://pt.anotepad.com/note/read/fnt5ks2y`)
break
case 'contas_spotify':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta sua conta do spotify_*
-
🌐 https://pt.anotepad.com/note/read/qfddqeid`)
break
case 'crunchyroll':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta sua conta da crunchyroll_*
-
🌐 https://pt.anotepad.com/note/read/8dqxjewt`)
break
case 'contas_iptv':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta sua conta de iptv_*
-
🌐 https://pt.anotepad.com/note/read/q8r3hh85`)
break
case 'contas_myfamily':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta sua conta my family_*
-
🌐 https://pt.anotepad.com/note/read/n2d4k9q8`)
break
case 'contas_clarotv':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta sua conta da clarotv+_*
-
🌐 https://pt.anotepad.com/note/read/5cfjbs68`)
break
case 'contas_expressvpn':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta sua conta da express_*
-
🌐 https://pt.anotepad.com/note/read/7tge88jb`)
break
case 'contas_dazn':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta sua conta da dazn_*
-
🌐 https://pt.anotepad.com/note/read/hq5fn9ai`)
break
case 'contas_bins':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta algumas bins para criar contas_*
-
🌐 https://pt.anotepad.com/note/read/ergtdncf`)
break
case 'contas_onlyfans':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta algumas contas do onlyfans_*
-
🌐 https://pt.anotepad.com/note/read/7hqa96gi`)
break
case 'contas_facebook':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta algumas contas do Facebook_*
-
🌐 https://pt.anotepad.com/note/read/gj3k5hen`)
break
case 'contas_nordvpn':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta algumas contas do nordvpn_*
-
🌐 https://pt.anotepad.com/note/read/rs2h7mdh`)
break
case 'contas_hotmail':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta alguns Hotmail vazados*
-
🌐 https://pt.anotepad.com/note/read/stder3wm`)
break
case 'contas_outlook':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta emails vazados do Outlook _*
-
🌐 https://pt.anotepad.com/note/read/5knqawjf`)
break
case 'contas_xbox':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta algumas contas do xbox_*
-
🌐 https://pt.anotepad.com/note/read/7mhaapfrf`)
break
case 'contas_nba':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta algumas contas da NBA_*
-
🌐 https://pt.anotepad.com/note/read/i3q54wyw`)
break
case 'contas_primevideo':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta algumas contas da primevideo_*
-
🌐 https://pt.anotepad.com/note/read/j4rgegxm`)
break
case 'contas_minecraft':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta algumas comtas do Minecraft_*
-
🌐 https://pt.anotepad.com/note/read/swmbmbte`)
break
case 'contas_steam':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta algumas contas da steam_*
-
🌐 https://pt.anotepad.com/note/read/bdnpenfp`)
break
case 'contas_terra':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta algumas contas do blog terra_*
-
🌐 https://pt.anotepad.com/note/read/y298dt52`)
break
case 'contas_instagram':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta algumas contas do Instagram_*
-
🌐 https://pt.anotepad.com/note/read/q8gcxsrf`)
break
case 'contas_hulu':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta algumas contas do hulu_*
-
🌐 https://pt.anotepad.com/note/read/q8gcxsrf`)
break
case 'contas_duolingo':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta algumas contas do duolingo_*
-
🌐 https://pt.anotepad.com/note/read/697r98pg`)
break
case 'contas_viki':
reagir(from, "👀")
await sleep(1000)
reply(`*_aqui esta algumas contas viki rukuten_*
-
🌐 https://pt.anotepad.com/note/read/swd4tx9j`)
break
case 'contas_cod':
reagir(from, "🎞️")
await sleep(1000)
reply(`*_aqui esta sua conta do cod_*
-
🌐 https://pt.anotepad.com/note/read/5jxtiamj`)
break
//=============(LOGOS)=============\\

case 'edit1': 

					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_api.jpg?text.0.text=${teks}&text.0.color=000000&text.0.font.family=Pacifico&text.0.font.weight=600&text.0.background.color=ffffff&text.0.outline.color=ffffff&text.0.outline.width=10&text.0.outline.blur=17`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break

case 'edit2':
                           
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis2.jpg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=1%25&text.0.position.y=16%25&text.0.size=80&text.0.color=ff2772&text.0.opacity=67&text.0.font.family=Bangers&text.0.font.style=italic&text.0.background.opacity=50&text.0.outline.width=6`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break

case 'edit3':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis3.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=59%25&text.0.size=89&text.0.color=000000&text.0.opacity=71&text.0.font.family=Changa%20One&text.0.font.style=italic&text.0.background.opacity=10&text.0.outline.color=ffffff&text.0.outline.width=3`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break	
					
					case 'edit4':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis.jpg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=11%25&text.0.position.y=22%25&text.0.size=20&text.0.color=241b1b&text.0.opacity=33&text.0.font.family=Rock%20Salt&text.0.font.style=italic&text.0.background.opacity=49`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break	
					
					case 'edit5':
                   
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis5.jpg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=1%25&text.0.position.y=22%25&text.0.align=left&text.0.size=59&text.0.font.family=Permanent%20Marker&text.0.outline.color=df00ff&text.0.outline.width=2&text.0.outline.blur=18`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break

case 'edit6':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis6.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.x=1%25&text.0.position.y=50%25&text.0.size=68&text.0.color=464646&text.0.opacity=51&text.0.font.family=Sigmar%20One&text.0.background.opacity=2&text.0.outline.color=ffffff&text.0.outline.width=2&text.0.outline.opacity=61`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break	
					
					case 'edit7':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis7.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.x=1%25&text.0.position.y=58%25&text.0.size=69&text.0.color=00ffea&text.0.opacity=37&text.0.font.family=Bangers&text.0.background.opacity=77&text.0.outline.color=ffffff&text.0.outline.width=2&text.0.outline.blur=20`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break

case 'edit8':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					//venomk = await getvenomk(`https://lollityp.sirv.com/venom_apis.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=47%25&text.0.size=99&text.0.color=ff0000&text.0.opacity=50&text.0.font.family=Cookie&text.0.font.style=italic&text.0.background.opacity=92&text.0.outline.width=23&text.0.outline.blur=24&text.0.outline.opacity=87`)
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis.jpg?w=640&h=640&text.0.text=Venom&text.0.position.gravity=north&text.0.position.y=53%25&text.0.size=96&text.0.color=ff0000&text.0.opacity=46&text.0.font.family=Shadows%20Into%20Light&text.0.font.style=italic&text.0.background.opacity=70&text.0.outline.width=9&text.0.outline.blur=52`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break					
					
					case 'edit9':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis9.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=50%25&text.0.size=68&text.0.color=ffffff&text.0.opacity=61&text.0.font.family=Tangerine&text.0.font.style=italic&text.0.background.opacity=61&text.0.outline.color=ff6f00&text.0.outline.width=9`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break

case 'edit10':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis10.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=62%25&text.0.size=63&text.0.color=004124&text.0.opacity=99&text.0.font.family=Permanent%20Marker&text.0.font.style=italic&text.0.background.color=feff00&text.0.outline.color=ffe8a3&text.0.outline.width=9&text.0.outline.blur=21`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break

case 'edit11':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis11.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=60%25&text.0.size=64&text.0.color=0071ff&text.0.font.family=Old%20Standard%20TT&text.0.font.style=italic&text.0.background.opacity=55&text.0.outline.color=00d0ff&text.0.outline.width=19&text.0.outline.blur=30`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break	
					
					case 'edit12':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis12.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=65%25&text.0.size=61&text.0.color=ff00e6&text.0.opacity=32&text.0.font.family=Chewy&text.0.font.style=italic&text.0.outline.width=6`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break	
					
					case 'edit13':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis13.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=63%25&text.0.size=68&text.0.color=ffffff&text.0.opacity=92&text.0.font.family=Permanent%20Marker&text.0.font.weight=800&text.0.outline.color=5dff00&text.0.outline.width=13&text.0.outline.blur=21`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break		
					
					case 'edit14':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis14.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=68%25&text.0.size=60&text.0.color=ffffff&text.0.font.family=Sigmar%20One&text.0.font.style=italic&text.0.background.opacity=17&text.0.outline.color=a99cff&text.0.outline.width=9&text.0.outline.blur=16`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break	
					
					case 'edit15':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis15.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=62%25&text.0.size=63&text.0.color=000000&text.0.font.family=Audiowide&text.0.font.style=italic&text.0.background.opacity=15&text.0.outline.color=ffffff&text.0.outline.width=9&text.0.outline.blur=33`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
					break	
					
					case 'edit16':
                    
					if (args.length < 1) return reply('qual o nome?')
					teks = body.slice(7)
					if (teks.length > 10) return reply('O texto é longo, até 10 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ✓*')
					venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis16.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=58%25&text.0.size=99&text.0.color=fffefe&text.0.font.family=Permanent%20Marker&text.0.background.color=000000&text.0.outline.color=000000&text.0.outline.width=19&text.0.outline.blur=66`)
					blackmd.sendMessage(m.chat, { image: venomk }, { quoted: info})
break	
case 'illuminated-metallic':
case 'carved-wood':
case 'night-sky':
case 'butterfly':
case 'coffee-cup':
case 'picture-of-love':
case 'flower-typography':
case 'harry-potter':
case 'under-grass':
case 'pubg':
case 'naruto':
case 'metallic':
case 'shadow-sky':
case 'flaming':
case 'metalgold':
case 'cemiterio':
case 'efeitoneon':
case 'shadow':
case 'txtborboleta':
case 'cup':
case 'harryp':
case 'lobometal':
case 'neon2':
case 'madeira':
case 'florwooden':
case 'coffecup2':
case 'coffecup':
case 'lovemsg3':
case 'lovemsg2':
case 'lovemsg':
case 'narutologo':
case 'romantico':
case 'darkdragon':
case 'papel':
case 'fire':
case 'sweet-candy':  
  const inputTextForApi = args.join(' '); // Nome alterado para evitar conflitos

  // Usar o texto como está, já que a API aceita apenas um texto
  const singleText = inputTextForApi || 'Indefinido'; 

  reply(`AGUARDE...`);
  console.log('Aguardando resposta da API...');
  
  try {
    // Construir a URL da API
    const apiUrl = `https://world-ecletix.onrender.com/api/${command}?texto=${singleText}`;
    console.log('URL da API:', apiUrl);

    const res = await fetchJson(apiUrl);
    
    // Log da resposta completa da API
    console.log('Resposta da API:', res);

    // Verificar se a resposta contém a URL da imagem
    if (res.imageUrl) {
      const generatedImageUrl = res.imageUrl;

      // Log da URL da imagem recebida
      console.log('URL da imagem recebida:', generatedImageUrl);

      // Enviar a imagem com a URL da resposta
      await blackmd.sendMessage(from, { image: { url: generatedImageUrl }, caption: `${command} gerado com sucesso!` }, { quoted: info });

      console.log(`${command} gerado com sucesso!`);
      
    } else {
      console.log('Erro: A URL da imagem está ausente na resposta.');
      reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
    }
    
  } catch (e) {
    console.error('Erro ao gerar imagem:', e.message, e.stack);
    reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
  }
  break;
case 'vingadores':
case 'ffbanner':
case 'marvel': 
case 'steel':
case 'america':   
case 'deadpool':   
case 'space':
case 'pornhub':
case 'typography':   
case 'pohub':  
case 'graffiti':  
case 'thor':  
  const userInputText = args.join(' '); // Nome mais específico para a entrada do usuário

  // Separar os textos por "/"
  const primaryText = userInputText.split('/')[0] || 'Indefinido';
  const secondaryText = userInputText.split('/')[1] || 'Indefinido';
  
  // Verificar se o separador '/' foi incluído
  if (!userInputText.includes("/")) {
    return reply(`Cadê a "/"?\nExemplo: ${prefix + command} texto1/texto2`);
  }
  
  reply(`AGUARDE...`);
  console.log('Aguardando resposta da API...');
  
  try {
    // Fazer solicitação à API passando os dois textos
    const apiUrl = `https://world-ecletix.onrender.com/api/${command}?texto=${primaryText}&texto2=${secondaryText}`;
    console.log('URL da API:', apiUrl);

    const res = await fetchJson(apiUrl);
    
    // Log da resposta completa da API
    console.log('Resposta da API:', res);

    // Verificar se a resposta contém sucesso
    if (res.status && res.resultado && res.resultado.success) {
      const generatedImageUrl = res.resultado.imageUrl;

      // Log da URL da imagem recebida
      console.log('URL da imagem recebida:', generatedImageUrl);

      // Enviar a imagem com a URL da resposta
      await blackmd.sendMessage(from, { image: { url: generatedImageUrl }, caption: `${command} gerado com sucesso!` }, { quoted: info });

      console.log(`${command} gerado com sucesso!`);
      
    } else {
      console.log('Erro: A API não retornou sucesso ou a URL da imagem está ausente.');
      reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
    }
    
  } catch (e) {
    console.error('Erro ao gerar imagem:', e.message, e.stack);
    reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
  }
  break;
  case 'gameplay':  
  console.log('Comando recebido:', args.join(' '));

  // Separar os dois textos por "/"
  const [gameplayText1 = 'Indefinido', gameplayText2 = 'Indefinido'] = args.join(' ').split('/');

  console.log('Gameplay Text 1:', gameplayText1);
  console.log('Gameplay Text 2:', gameplayText2);

  if (!args.join(' ').includes("/") || args.join(' ').split('/').length < 2) {
    console.log('Erro: Formato incorreto. Textos não estão separados corretamente.');
    return reply(`Cadê os dois textos separados por "/"?\nExemplo: ${prefix + command} texto1/texto2`);
  }

  reply(`AGUARDE...`);
  console.log('Aguardando resposta da API...');

  try {
    // Construir a URL corretamente conforme especificado
    const apiUrl = `https://world-ecletix.onrender.com/api/gameplay?texto=${gameplayText1}&texto=${gameplayText2}`;
    console.log('URL da API:', apiUrl);

    // Fazer solicitação à API passando os 2 textos
    const response = await fetchJson(apiUrl);
    console.log('Resposta da API:', response);

    // Verificar se a URL da imagem foi retornada corretamente
    if (response.imageUrl) {
      let imageUrl = response.imageUrl;

      console.log('URL da imagem recebida:', imageUrl);

      // Corrigir a URL se tiver barra dupla "//"
      if (imageUrl.includes('//')) {
        imageUrl = imageUrl.replace('https://', '').replace('//', '/');
        imageUrl = 'https://' + imageUrl;
      }

      console.log('URL da imagem corrigida:', imageUrl);

      // Enviar a imagem com a URL da resposta
      await blackmd.sendMessage(from, { image: { url: imageUrl }, caption: `${command} gerado com sucesso!` }, { quoted: info });
      console.log('Imagem enviada com sucesso!');
      
    } else {
      console.log('Erro: A URL da imagem está ausente na resposta.');
      reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
    }

  } catch (e) {
    console.error('Erro ao gerar imagem:', e.message, e.stack);
    reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
  }
  break;
case 'googlesg':  
  console.log('Comando recebido:', args.join(' '));

  const textooo = args.join(' ');

  // Separar os três textos por "/"
  const texto1 = textooo.split('/')[0] || 'Indefinido';
  const texto2 = textooo.split('/')[1] || 'Indefinido';
  const texto3 = textooo.split('/')[2] || 'Indefinido';

  console.log('Texto 1:', texto1);
  console.log('Texto 2:', texto2);
  console.log('Texto 3:', texto3);

  if (!textooo.includes("/") || textooo.split('/').length < 3) {
    console.log('Erro: Formato incorreto. Textos não estão separados corretamente.');
    return reply(`Cadê os três textos separados por "/"?\nExemplo: ${prefix + command} texto1/texto2/texto3`);
  }

  reply(`AGUARDE...`);
  console.log('Aguardando resposta da API...');

  try {
    // Construir a URL corretamente conforme especificado
    const apiUrl = `https://world-ecletix.onrender.com/api/googlesg?texto=${texto1}&texto2=${texto2}&texto3=${texto3}`;
    console.log('URL da API:', apiUrl);

    // Fazer solicitação à API passando os 3 textos
    const response = await fetchJson(apiUrl);
    console.log('Resposta da API:', response);

    // Verificar se a URL da imagem foi retornada corretamente
    if (response.imageUrl) {
      let imageUrl = response.imageUrl;

      console.log('URL da imagem recebida:', imageUrl);

      // Corrigir a URL se tiver barra dupla "//"
      if (imageUrl.includes('//')) {
        imageUrl = imageUrl.replace('https://', '').replace('//', '/');
        imageUrl = 'https://' + imageUrl;
      }

      console.log('URL da imagem corrigida:', imageUrl);

      // Enviar a imagem com a URL da resposta
      await blackmd.sendMessage(from, { image: { url: imageUrl }, caption: `${command} gerado com sucesso!` }, { quoted: info });
      console.log('Imagem enviada com sucesso!');
      
    } else {
      console.log('Erro: A URL da imagem está ausente na resposta.');
      reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
    }

  } catch (e) {
    console.error('Erro ao gerar imagem:', e.message, e.stack);
    reply("Erro ao gerar a imagem! Tente novamente mais tarde.");
  }
  break;
case 'steel':
case 'dragon-ball':
case 'praia':
case 'graffiti':
case 'star-wars':
case 'glitch':
case 'royal':
case 'cloud':
case 'birthday':
case 'natal':
case 'matirix':
case 'galaxy':
case 'snow':  
case 'devil':
case 'anonymous':
case 'boom':
case 'mascotegame':
case 'mascoteavatar':
case 'wingeffect':
case 'angelglx':
case 'gizquadro':
case 'blackpink': 
case 'girlmascote':
case 'logogame':
case 'logogame':
case 'smoke':
case 'papel':
case 'angelwing':
case 'hackneon':
case 'fpsmascote':
case 'equipemascote':
case 'txtquadrinhos':
case '3dsilver':
case 'goldtext':
case 'starballons':
case 'frozen':
case 'halloween':
case 'ffavatar':
  textin = args.join(" ")
  if (!q) return reply(`Qual o nome?`)
  reply('enviando...')
  
  try {
    // Fazer solicitação à API usando o comando dinâmico na URL
    const response = await fetchJson(`https://world-ecletix.onrender.com/api/${command}?texto=${textin}`);
    
    // Verificar se o resultado foi bem-sucedido
    if (response.status && response.resultado && response.resultado.success) {
      const imageUrl = response.resultado.imageUrl;
      
      // Baixar a imagem e enviar a resposta
      const blabla = await getBuffer(imageUrl);
      await blackmd.sendMessage(from, { image: blabla }, { quoted: info });
      
    } else {
      reply("Erro ao criar sua logo! Tente novamente mais tarde.");
    }
    
  } catch (e) {
    console.error('Erro ao gerar logo:', e)
    reply("Erro ao criar sua logo! Tente novamente mais tarde.")
  }
  break			               

case 'cria': 
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`▧⃯⃟𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘ฺ͘.•🛸 ݈݇─`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_api.jpg?text.0.text=${teks}&text.0.color=000000&text.0.font.family=Pacifico&text.0.font.weight=600&text.0.background.color=ffffff&text.0.outline.color=ffffff&text.0.outline.width=10&text.0.outline.blur=17`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break

case 'anime1':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`▧⃯⃟𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘ฺ͘.•🛸 ݈݇─`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis2.jpg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=1%25&text.0.position.y=16%25&text.0.size=80&text.0.color=ff2772&text.0.opacity=67&text.0.font.family=Bangers&text.0.font.style=italic&text.0.background.opacity=50&text.0.outline.width=6`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break

case 'ff1':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`▧⃯⃟𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘ฺ͘.•🛸 ݈݇─`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis3.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=59%25&text.0.size=89&text.0.color=000000&text.0.opacity=71&text.0.font.family=Changa%20One&text.0.font.style=italic&text.0.background.opacity=10&text.0.outline.color=ffffff&text.0.outline.width=3`)
blackmd.sendMessage(from, { image: venomk }, {quoted: seloctt })
break	

case 'game':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`▧⃯⃟𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘ฺ͘.•🛸 ݈݇─`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis5.jpg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=1%25&text.0.position.y=22%25&text.0.align=left&text.0.size=59&text.0.font.family=Permanent%20Marker&text.0.outline.color=df00ff&text.0.outline.width=2&text.0.outline.blur=18`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break

case 'ff2':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`▧⃯⃟𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘ฺ͘.•🛸 ݈݇─`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis6.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.x=1%25&text.0.position.y=50%25&text.0.size=68&text.0.color=464646&text.0.opacity=51&text.0.font.family=Sigmar%20One&text.0.background.opacity=2&text.0.outline.color=ffffff&text.0.outline.width=2&text.0.outline.opacity=61`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break	

case 'anime2':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`▧⃯⃟𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘ฺ͘.•🛸 ݈݇─`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis7.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.x=1%25&text.0.position.y=58%25&text.0.size=69&text.0.color=00ffea&text.0.opacity=37&text.0.font.family=Bangers&text.0.background.opacity=77&text.0.outline.color=ffffff&text.0.outline.width=2&text.0.outline.blur=20`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break

case 'entardecer':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`▧⃯⃟𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘ฺ͘.•🛸 ݈݇─`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis9.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=50%25&text.0.size=68&text.0.color=ffffff&text.0.opacity=61&text.0.font.family=Tangerine&text.0.font.style=italic&text.0.background.opacity=61&text.0.outline.color=ff6f00&text.0.outline.width=9`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break

case 'indian':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`▧⃯⃟𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘ฺ͘.•🛸 ݈݇─`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis10.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=62%25&text.0.size=63&text.0.color=004124&text.0.opacity=99&text.0.font.family=Permanent%20Marker&text.0.font.style=italic&text.0.background.color=feff00&text.0.outline.color=ffe8a3&text.0.outline.width=9&text.0.outline.blur=21`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break 

case 'ffrose':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`▧⃯⃟𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘ฺ͘.•🛸 ݈݇─`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis12.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=65%25&text.0.size=61&text.0.color=ff00e6&text.0.opacity=32&text.0.font.family=Chewy&text.0.font.style=italic&text.0.outline.width=6`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break	

case 'ffgren':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`▧⃯⃟𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘ฺ͘.•🛸 ݈݇─`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis13.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=63%25&text.0.size=68&text.0.color=ffffff&text.0.opacity=92&text.0.font.family=Permanent%20Marker&text.0.font.weight=800&text.0.outline.color=5dff00&text.0.outline.width=13&text.0.outline.blur=21`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break		

case 'chufuyu':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`▧⃯⃟𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘ฺ͘.•🛸 ݈݇─`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis14.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=68%25&text.0.size=60&text.0.color=ffffff&text.0.font.family=Sigmar%20One&text.0.font.style=italic&text.0.background.opacity=17&text.0.outline.color=a99cff&text.0.outline.width=9&text.0.outline.blur=16`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break	

case 'wolf':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`▧⃯⃟𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘ฺ͘.•🛸 ݈݇─`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis15.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=62%25&text.0.size=63&text.0.color=000000&text.0.font.family=Audiowide&text.0.font.style=italic&text.0.background.opacity=15&text.0.outline.color=ffffff&text.0.outline.width=9&text.0.outline.blur=33`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break	

case 'dragonred':
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`▧⃯⃟𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘ฺ͘.•🛸 ݈݇─`)
venomk = await getBuffer(`https://lollityp.sirv.com/venom_apis16.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=58%25&text.0.size=99&text.0.color=fffefe&text.0.font.family=Permanent%20Marker&text.0.background.color=000000&text.0.outline.color=000000&text.0.outline.width=19&text.0.outline.blur=66`)
blackmd.sendMessage(from, { image: venomk }, { quoted: seloctt })
break	

case 'purple':              
if (args.length < 1) return reply("KD o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`▧⃯⃟𝙶𝚎𝚛𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙻𝚘𝚐𝚘ฺ͘.•🛸 ݈݇─`)
venomk = await getBuffer(`https://docs-jojo.herokuapp.com/api/text3d?text=${teks}`, {method: 'get'})
blackmd.sendMessage(from, { image: venomk }, {quoted: seloctt, caption: `${teks}`})			     	
break

case 'metadinha':
reagir(from, "😍")
try {
ABC = await fetchJson(apikeymeta);
matheuzinho = ABC[Math.floor(Math.random()*ABC.length)]
blackmd.sendMessage(from, {image: {url: matheuzinho.male}, caption: `🙇🏻‍♂️ *HOMEM* 🙅🏻‍♂️`})
blackmd.sendMessage(from, {image: {url: matheuzinho.female}, caption: `🙆🏻‍♀️ *MULHER* 💁🏻‍♀️`})
} catch (e) {
return reply("Erro..")
}
break;


//========(SORTEIO-VOTAR-CASES)=========\\

case 'infosorteio':
case 'helpsorteio':  
blackmd.sendMessage(from, {text: infosorteio(sender, prefix), mentions: [sender]}, {quoted: selo})
break

case 'substituir':
if(!isOwner && !isnit) return reply("Só dono..")
 if(isMedia && !info.message.videoMessage || isQuotedDocument) {
media = isQuotedDocument ? info.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : info.message.documentMessage
rane = getRandom('.'+await getExtension(media.mimetype))
doc = await getFileBuffer(media, 'document')
fs.writeFileSync(q, doc)
reply(`Arquivo substituído com sucesso 🤭`)
} else {
reply('Marque o documento ou arquivo..')
}
break

case 'index-bot':
setTimeout(() => {reagir(from, "✅")}, 300)
if(!isOwner)return reply(enviar.msg.dono)
if(isMedia && !info.message.videoMessage || isQuotedDocument) {
media = isQuotedDocument ? info.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : info.message.documentMessage
rane = getRandom('.'+await getExtension(media.mimetype))
doc = await getFileBuffer(media, 'document')
fs.writeFileSync('./index.js', doc)
blackmd.sendMessage(from, {text:'*Index atualizada* ✅'},{quoted: seloctt})
setTimeout(async () => {
blackmd.sendMessage(from, {text: "*Irei reiniciar o bot em 3... 2... 1...*"})
setTimeout(async () => {
process.exit()
}, 2200)
}, 2000)
} else {
reply('Marque o documento ou o arquivo que deseja enviar pra determinar pasta ou substituir..')
}
break

case 'banfake': case 'banfakes':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
caixa = []
for(i of somembros) {
  if(!numerodono.includes(i) && !botNumber.includes(i)) {
    if(Number(i.slice(0, 2)) !== 55) caixa.push(i)
  }
}
if(caixa.length > 0) {
  for(a = 0; a < caixa.length; a++) {
    await sleep(1000)
    remover(from, caixa[a])
  }
} else reply("Não há números fake presentes neste grupo...")
break

case 'fakeban':
case 'b4n':
case 'bam':
setTimeout(() => {reagir(from, "🫡")}, 300)
if(!isGroupAdmins) return reply(enviar.msg.adm)
blackmd.sendMessage(from, {text: `*O alvo ↴*
@${menc_os2.split('@')[0]} *foi removido com sucesso...* 🫡`, mentions: [menc_os2]}, {quoted: seloctt})
setTimeout(() => {
blackmd.sendMessage(from, {text: `@${menc_os2.split('@')[0]} caiu na pegadinha do malandro 😂`, mentions: [menc_os2]})
}, 120000)
break

case 'suic': case 'suicui': case 'suicidiuio': case 'suicíuidio': case 'suicídio': case 'suicidio': case 'suicídio︎︎︎︎︎︎︎':
if(!isModobn) return reply(enviar.msg.modobz)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!isGroup) return reply(enviar.msg.grupo)
if(isOwner || JSON.stringify(vip).includes(sender)) return reply("Você não tem permissão de se matar 😁")
reply(`Não ${pushname}, não se mate 😭💔`)
await sleep(3000)
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
await sleep(1000)
reply(`Ah, menos um pá eu me preocupar 😪`)
break

case 'ban': case 'banir': case 'kick': case 'avadakedavra':
reagir(from, "✅")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!menc_os2) return reply(`Marque o usuário que você deseja banir do grupo, a mensagem ou o @`)

//a pessoa não está no grupo
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Esse usuário não se encontra mais no grupo...")

//marcaram @ do bot
if(botNumber.includes(menc_os2)) {
if(!isOwner) {
reply("Aplicando punição pq tentaram me banir... Cê tem sorte de só perder o ADM")
return blackmd.groupParticipantsUpdate(from, [sender], "demote")
} else return reply("Qual foi patrão ?")
}

//marcaram @ do dono
if(isAllOwner(menc_os2)) {
if(!isOwner) {
reply("Tá achando que vai banir meu dono assim na minha frente ?? Sente o poder do ban então pra ver se é bom 😍")
await sleep(1000)
return blackmd.groupParticipantsUpdate(from, [sender], "remove")
} else return reply("Não vou te banir patrão ;-;")
}

//marcaram @ de um vip
if(JSON.stringify(vip).includes(menc_os2) && !isOwner) {
reply("O cara quer banir um ser superior kkkkk")
return blackmd.groupParticipantsUpdate(from, [sender], "demote")
}

//não é vip nem dono
blackmd.sendMessage(from, {audio: {url:'./database/audios/ban.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.groupParticipantsUpdate(from, [menc_os2], "remove")
return blackmd.sendMessage(from, {text: `*USUÁRIO* @${menc_os2.split("@")[0]} *FOI REMOVIDO COM SUCESSO* 😎👍🏽`, mentions: [menc_os2]})
break

case 'band':
reagir(from, "🗑️")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)

//a pessoa não está no grupo
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Esse usuário não se encontra mais no grupo...")

//marcaram @ do bot
if(botNumber.includes(menc_os2)) {
if(!isOwner) {
reply("Aplicando punição pq tentaram me banir... Cê tem sorte de só perder o ADM")
return blackmd.groupParticipantsUpdate(from, [sender], "demote")
} else return reply("Qual foi patrão ?")
}

//marcaram @ do dono
if(numerodono.includes(menc_os2)) {
if(!isOwner) {
reply("Tá achando que vai banir meu dono assim na minha frente ?? Sente o poder do ban então pra ver se é bom 😍")
await sleep(1000)
return blackmd.groupParticipantsUpdate(from, [sender], "remove")
} else return reply("Não vou te banir patrão ;-;")
}

//marcaram @ de um vip
if(JSON.stringify(vip).includes(menc_os2) && !isOwner) {
reply("O cara quer banir um ser superior kkkkk")
return blackmd.groupParticipantsUpdate(from, [sender], "demote")
}

//não é vip nem dono
blackmd.sendMessage(from, {audio: {url:'./database/audios/ban.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.groupParticipantsUpdate(from, [menc_os2], "remove")
blackmd.sendMessage(from, {text: `*USUÁRIO* @${menc_os2.split("@")[0]} *FOI REMOVIDO COM SUCESSO* 😎👍🏽`, mentions: [menc_os2]})
await sleep(2000)
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.message.extendedTextMessage.contextInfo.stanzaId, participant: menc_os2}})
break

case 'vasco':
reagir(from, "🏴‍☠️")
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)

//a pessoa não está no grupo
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Esse usuário não se encontra mais no grupo...")

//marcaram @ do bot
if(botNumber.includes(menc_os2)) {
if(!isOwner) {
reply("Que vasco o que menó ? Eu sou Palmeirense 💚")
return blackmd.groupParticipantsUpdate(from, [sender], "demote")
} else return reply("Qual foi patrão ?")
}

//marcaram @ do dono
if(numerodono.includes(menc_os2)) {
if(!isOwner) {
reply("No No No... Meu Dono é layon 😍")
await sleep(1000)
return blackmd.groupParticipantsUpdate(from, [sender], "remove")
} else return reply("Não vou te banir patrão ;-;")
}

//marcaram @ de um vip
if(JSON.stringify(vip).includes(menc_os2) && !isOwner) {
reply("Esse aí não é vascaíno não kkkkk")
return blackmd.groupParticipantsUpdate(from, [sender], "demote")
}

//não é vip nem dono
vascoban = ["zagueiro", "atacante", "goleiro", "volante", "ponta esquerda", "ponta direita", "meio campo"]
blackmd.sendMessage(from, {text: `@${menc_os2.split("@")[0]} foi jogar no Vasco como ${vascoban[Math.floor(Math.random()*vascoban.length)]} ☠️`, mentions: [menc_os2]})
blackmd.sendMessage(from, {audio: {url:'./database/audios/vasco.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
await sleep(2000)
blackmd.groupParticipantsUpdate(from, [menc_os2], "remove")
break

case 'setmsg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
AB = avisos.map(i => i.groupId).indexOf(from)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(avisos[AB].module == true) {
  avisos[AB].module = false
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
  reply(`Sistema de horários programados desativado com sucesso neste grupo... Caso queira ligar, basta usar o comando novamente 😀`)
} else {
  avisos[AB].module = true
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
  reply(`Sistema de horários programados ativado com sucesso neste grupo... Caso queira desligar, basta usar o comando novamente 😀`)
}
break

case 'rankcmd':
if(!isGroup) return reply(enviar.msg.grupo)
if(rankcmd.length < 5) return reply("O bot ainda não possui comandos salvos o suficiente para calcular o ranking")
matheuzinho = rankcmd.map(i => i)
rank = matheuzinho.sort((a, b) => (a.usado < b.usado) ? 0 : -1)
txt = `❪💎ฺ࣭࣪͘ꕸ▸ ᴛᴏᴩ 5 ᴄᴏᴍᴀɴᴅᴏꜱ ᴍᴀɪꜱ ᴜꜱᴀᴅᴏꜱ ᴩᴏʀ ᴜꜱᴜáʀɪᴏꜱ ᴇᴍ ɢʀᴜᴩᴏ:`
for(i = 0; i < 5; i++) {
  quant = rank[i].usado
  txt += `\n»${i + 1}«
▧⃯⃟ᴄᴏᴍᴀɴᴅᴏ: ${prefix+rank[i].cmd}
ㅤㅤ▧⃯⃟ᴜꜱᴀᴅᴏ: ${quant} vez${Number(quant) > 1 ? `es` : ``}`
}
try {
  matheuzinho = await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image');
  shortpc = await axios.get(`https://tinyurl.com/api-create.php?url=${matheuzinho}`);
  ppimg = shortpc.data
} catch(e) { ppimg = semfoto }
sendUrlText(from, txt, pushname, ``, ppimg, `https://wame/`+sender.split("@")[0], seloctt)
break

case 'checkcmd':
if(!q) return reply(`Informe o nome do comando que você quer puxar, ex:
${prefix+command} play`)
if(q.includes(prefix)) return reply(`Não inclua o prefixo na busca...`)
caixa = []
for(i of rankcmd) {
  if(rmLetras(q) == i.cmd) caixa.push(i)
}
if(caixa.length <= 0) return reply(`Não há registros de uso desde comando em minha database...`)
reply(`🎲 O Comando *${prefix+caixa[0].cmd}* foi usado ${caixa[0].usado} vez${Number(caixa[0].usado) !== 1 ? `es` : ``}, segundo o que consta em minha database...`)
break

case 'revealmsg':
if(!isOwner) return reply(enviar.msg.dono)
var getGroups = await blackmd.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
var ingfoo = groups.map(v => v)
ingfoo.sort((a, b) => (a[0] < b.length))
if(q.toLowerCase() == "grupo") {
if(!isGroup) return reply(enviar.msg.grupo)
idgp = from
nome = groupName
} else if(Number(args[0]) > 0 && Number(args[0]) <= ingfoo.length) {
idgp = ingfoo[Number(args[0])].id
nome = ingfoo[Number(args[0])].subject
} else {
return reply("Olhe no comando "+prefix+command+"listarevgp o número correspondente ao grupo que você quer ativar/desativar o repasse de mensagens... Ex: "+prefix+command+"2\n\nCaso vc opte por \""+prefix+command+" grupo\", ele irá ativar/desativar este grupo aqui...")
}
if(JSON.stringify(revealmsg).includes(idgp)) {
AB = revealmsg.map(i => i.groupId).indexOf(idgp)
revealmsg.splice(AB, 1)
fs.writeFileSync("./basedefuncionamento/revealmsg.json", JSON.stringify(revealmsg, null, 2))
reply("Repasse de mensagens do grupo "+nome+" desativado com sucesso 💢")
} else {
revealmsg.push({groupId: idgp})
fs.writeFileSync("./basedefuncionamento/revealmsg.json", JSON.stringify(revealmsg, null, 2))
reply("Repasse de mensagens do grupo "+nome+" ativado com sucesso ✅")
}
break

case 'listarevgp':
setTimeout(() => {reagir(from, "✅")}, 300)
if(!isOwner) return reply('```SOMENTE MEU DONO LINDÃO```')
var getGroups = await blackmd.groupFetchAllParticipating()
var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
var ingfoo = groups.map(v => v)
ingfoo.sort((a, b) => (a[0] < b.length))
teks1 = "ᏞᏆՏͲᎪ ᎠᎬ ᏀᎡႮᏢϴՏ Ꭰϴ ᏴϴͲ\nͲϴͲᎪᏞ ( "+ingfoo.length+" )\n________________________________________"
for (let i = 0; i < ingfoo.length; i++){
matheuzinho = JSON.stringify(revealmsg).includes(ingfoo[i].id) ? "✅" : "❌"
teks1 += "\n\n»"+i+"«\n⏤͟͟͞͞ ꦿ𝙽𝚘𝚖𝚎 𝙳𝚘 𝙶𝚛𝚞𝚙𝚘 ↴\n〘 "+ingfoo[i].subject+" 〙\n⏤͟͟͞͞ ꦿ𝙸𝙳 𝙳𝚘 𝙶𝚛𝚞𝚙𝚘 ↴\n× "+ingfoo[i].id+"\n⸺͟͞ꪶ𝙰𝚝𝚒𝚟𝚊𝚍𝚘⇒『 "+matheuzinho+" 』\n________________________________________"
}
reply(teks1)
break

case 'resetadsgp':
if(!isOwner) return reply(enviar.msg.dono)
if(!JSON.stringify(adsgp).includes("grupos")) {
  adsgp.push({tipo: "grupos", gps: []})
  fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
if(!JSON.stringify(adsgp).includes("mensagens")) {
  adsgp.push({tipo: "mensagens", msgs: []})
  fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
AB = adsgp.map(i => i.tipo).indexOf("grupos")
AC = adsgp.map(i => i.tipo).indexOf("mensagens")
adsgp[AB].gps = []
fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
adsgp[AC].msgs = []
fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
reply("Sistema resetado")
break

case 'setadsgp':
if(!isOwner) return reply(enviar.msg.dono)
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(adsgp).includes("quantidade")) {
  adsgp.push({tipo: "quantidade", quant: 5})
  fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
if(!JSON.stringify(adsgp).includes("grupos")) {
  adsgp.push({tipo: "grupos", gps: []})
  fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
if(!JSON.stringify(adsgp).includes("mensagens")) {
  adsgp.push({tipo: "mensagens", msgs: []})
  fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
var [linkM4, msgM4] = q.split('|')
AB = adsgp.map(i => i.tipo).indexOf("grupos")
AC = adsgp.map(i => i.tipo).indexOf("mensagens")
if(!linkM4) return reply('Insira um link de convite ao lado do comando.')
if(!msgM4) return reply(`Vejo que você não inseriu a mensagem que será enviada... Faça assim:\n${prefix+command} link do grupo|mensagem para enviar`)
if(linkM4.includes('chat.whatsapp.com/')) {
  link = linkM4.split('app.com/')[1]
  try {
    var getGroups = await blackmd.groupFetchAllParticipating()
    var groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
    var ingfoo = groups.map(v => v)
    ingfoo.sort((a, b) => (a[0] < b.length))
    grupos77 = []
    for(i = 0; i < ingfoo.length; i++) {
      grupos77.push({groupId: ingfoo[i].id})
    }
    adsgp[AB].gps = grupos77
    fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
    adsgp[AC].msgs.push({txt: msgM4, cobrado: false})
    fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
    blackmd.groupAcceptInvite(`${link}`)
    return reply(`Todos os grupos da lista foram salvos na pasta... Qualquer grupo que esteja fora da lista será tratado como indigno e réu de receber anúncios em seu chat`)
  } catch(erro) {
    if(String(erro).includes('resource-limit') ) {
      reply('O grupo já está com o alcance máximo de membros.')
    }
    if(String(erro).includes('not-authorized') ) {
      reply('Não foi possível entrar no grupo.\nMotivo: Banimento.')
    }
  }
} else return reply('Ops, verifique o link que você inseriu.')
break

case 'setadstime': case 'sat':
if(!isOwner) return reply(enviar.msg.dono)
if(!JSON.stringify(adsgp).includes("quantidade")) {
  adsgp.push({tipo: "quantidade", quant: 5})
  fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
}
if(!Number(args[0]) || Number(args[0]) < 1) return reply(`Defina a quantidade de mensagens a serem enviadas no grupo ao usar o comando ${prefix}setadsgp

Ex: ${prefix+command} 5`)
if(q.includes(".")) return reply("Não pode números decimais")
AB = adsgp.map(i => i.tipo).indexOf("quantidade")
adsgp[AB].quant = Number(args[0])
fs.writeFileSync("./basedefuncionamento/adsgp.json", JSON.stringify(adsgp, null, 2))
reply(`Quant. de mensagens definida com sucesso ✅`)
break

case 'startads': case 'endads':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
adsStart = getGroupAds(from)
if(adsStart.acctive) {
adsStart.acctive = false
saveADS()
return reply(`❕ *adssystem desativado com sucesso* 🗯`)
} else {
adsStart.acctive = true
saveADS()
return reply(`🔰 *adssystem ativado com sucesso* 〽`)
}
break

case 'addads': case 'setads':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!q) return reply(`Retorne após o comando a sua mensagem/anúncio... Ex:
${prefix+command} sua mensagem aqui`)
if(!getGroupAds(from).acctive) return reply(enviar.adsatc)
imgads = []
if(isImage || isQuotedImage) {
  try {
    media = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
    gfb = await getFileBuffer(media, 'image')
    img = await upload(gfb)
    imgads.push(img)
  } catch { return reply(`Não foi possível salvar essa imagem... ❌`) }
}
addAdminAds(from, sender, q, imgads)
mention(`Anúncio salvo com sucesso @${sender.split("@")[0]}. Escreva abaixo o tempo desse anúncio, usando *h* para *horas* e *m* para *minutos*, ex: "1h" (escreva sem as aspas) 🙂`)
break

case 'listads':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!getGroupAds(from).acctive) return reply(enviar.adsatc)
groupAds = getGroupAds(from).horarios
if(groupAds.length <= 0) return reply(`Não há anúncios definidos neste grupo...`)
txt = `📛 *Lista de anúncios programados neste grupo:*
🔰 *Total:* ${groupAds.length}

${groupAds.map(i =>
`🎭 *ID:* ${i.id}
📖 *ADS:* ${i.text.length > 100 ? i.text.slice(0, 100) + `...` : i.text}
⏱ *Tempo:* ${String(i.tempo.valor) + i.tempo.type}
🧩 *Próximo ADS:* ${i.tempo.horario}
🖼 *Mídia ( ${i.imagem.length > 0 ? `✔` : `✖`} )*`).join(`\n\n`)}`
reply(txt)
break

case 'diminuirtempoads': case 'dta':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!getGroupAds(from).acctive) return reply(enviar.adsatc)
groupAds = getGroupAds(from).horarios
if(groupAds.length <= 0) return reply(`Não há anúncios definidos neste grupo...`)
if(!q) return reply(`🎭 *Retorne após o comando o id do anúncio que você quer deletar, ex:*
${prefix+command} 010124013045

_(Olhe no comando ${prefix}listads os ID disponíveis)_`)
if(!isIDads(from, q)) return reply(`ID inexistente ❌`)
AB = groupAds.map(a => a.id).indexOf(q)
gth = groupAds[AB].tempo.horario
if(Number(gth.split(":")[1]) !== 0) {
soma = Number(sendHours("HH")) < Number(gth.split(":")[0]) ? gth.split(":")[0] + ":00" : Number(sendHours("HH")) !== 23 ? String(Number(sendHours("HH")) + 1) + ":00" : "00:00"
groupAds[AB].tempo.horario = soma
saveADS()
return reply(`O anúncio de ID ${q} teve seu horário alterado de *${gth}h* para *${soma}h* ⏲`)
} else return reply(`Este anúncio já tem seus minutos em 00`)
break

case 'rmads':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!getGroupAds(from).acctive) return reply(enviar.adsatc)
groupAds = getGroupAds(from).horarios
if(groupAds.length <= 0) return reply(`Não há anúncios definidos neste grupo...`)
if(!q) return reply(`🎭 *Retorne após o comando o id do anúncio que você quer deletar, ex:*
${prefix+command} 010124013045

_(Olhe no comando ${prefix}listads os ID disponíveis)_`)
if(!isIDads(from, q) && q.toLowerCase() !== `all`) return reply(`ID inexistente ❌`)
if(q.toLowerCase() == `all`) {
AB = ads.map(a => a.groupId).indexOf(from)
ads.splice(AB, 1)
saveADS()
return reply(`*Todos os anúncios foram deletados com sucesso* ✔`)
} else {
rmAds(from, q)
return reply(`*O anúncio de ID ${q} foi deletado com sucesso* ✔`)
}
break

case 'addmsg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
AB = avisos.map(i => i.groupId).indexOf(from)
if(!isGroupAdmins) return reply(enviar.msg.adm)
var [write, timezin] = q.split("/")
if(!write) return reply(`KD a mensagem ? Ex:
-> ${prefix+command} Bom dia/06:00 (será enviada uma mensagem neste grupo todo dia às 6 da manhã)`)
if(!timezin) return reply(`KD o horário ? Ex:
-> ${prefix+command} Boa tarde/12:00 (será enviada uma mensagem neste grupo toda tarde ao meio dia)`)
if(!timezin.includes(":")) return reply(`Separe as horas e minutos com "dois pontos" ( : ), ex:
-> ${prefix+command} Boa tarde/15:30 (será enviada uma mensagem neste grupo toda tarde às 15 horas e 30 minutos)`)
if(!Number(timezin.replace(":", ""))) return reply(`Não inclua outro caractere no horário além dos "dois pontos" ( : ), ex:
-> ${prefix+command} Boa noite/18:02 (será enviada uma mensagem neste grupo toda noite às 18 horas e 2 minutos)`)
day = moment.tz('America/Sao_Paulo').format('DD')
avisos[AB].mensagens.push({msg: write, tempo: timezin, dia: "00"})
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Registro criado com sucesso... A mensagem "${write.slice(0, 50)+"..."}" será repassada neste grupo todo dia às ${timezin}

Caso queira apagar o registro, use ${prefix}rmmsg`)
break

case 'addrandom':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
AB = avisos.map(i => i.groupId).indexOf(from)
AC = avisos.map(i => i.groupId).indexOf("matheuzinho")
if(!isGroupAdmins) return reply(enviar.msg.adm)
var [time, typeRandom] = q.split("/")
if(!time) return reply(`Coloque o horário em que as mensagens aleatórias da caixa serão enviadas neste grupo...`)
if(!time.includes(":")) return reply(`Separe as horas e minutos com "dois pontos" ( : ), ex:
-> ${prefix+command} 15:30/0`)
if(!Number(time.replace(":", ""))) return reply(`Não inclua outro caractere no horário além dos "dois pontos" ( : ), ex:
-> ${prefix+command} 18:02/0`)
if(Number(typeRandom) !== 1 && Number(typeRandom) !== 2) return reply(`Coloque uma barra ( / ) após o horário e defina com 1 se as mensagens forem puxadas da caixa do grupo e 2 se as mensagens forem puxadas da caixa global... Ex:
-> ${prefix+command} 14:00/1`)
if(Number(typeRandom) === 1 && avisos[AB].globalAleatory.length <= 1) return reply(`Não há mensagens suficientes na caixa do grupo para sortear aleatoriamente... Use o comando ${prefix}envrandom primeiro`)
if(Number(typeRandom) === 2 && avisos[AC].mensagens.length <= 1) return reply(`Não há mensagens suficientes na caixa global para sortear aleatoriamente... Use o comando ${prefix}envrandom primeiro`)
day = moment.tz('America/Sao_Paulo').format('DD')
avisos[AB].aleatory.push({tempo: time, dia: "00", ativation: Number(typeRandom) > 1 ? true : false})
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Mensagem aleatória da caixa definida todo dia neste grupo às ${time}... Caso queira deletar o horário, use ${prefix}delrandom`)
break

case 'envrandom':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
AB = avisos.map(i => i.groupId).indexOf(from)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!q) return reply(`Coloque após o comando uma mensagem para ser enviada para a caixa do grupo... Ao usar o comando ${prefix}addrandom, o bot enviará aleatoriamente uma das mensagens dessa caixa no horário definido`)
avisos[AB].globalAleatory.push(q)
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Mensagem deste grupo definida com sucesso... Caso queira enivar, use ${prefix}addrandom`)
break

case 'envglobal':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
AB = avisos.map(i => i.groupId).indexOf("matheuzinho")
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`Coloque após o comando uma mensagem para ser enviada para a caixa do grupo... Ao usar o comando ${prefix}addrandom, o bot enviará aleatoriamente uma das mensagens dessa caixa no horário definido`)
avisos[AB].mensagens.push(q)
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Mensagem globlal definida com sucesso... Caso queira enivar, use ${prefix}addrandom`)
break

case 'rmmsg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = avisos.map(i => i.groupId).indexOf(from)
if(avisos[AB].mensagens.length <= 0) return reply(`Não há avisos neste grupo`)
if(!Number(args[0]) || Number(args[0]) < 1 || Number(args[0]) > avisos[AB].mensagens.length) return reply(`Olhe no comando ${prefix}listmsg o número correspondente a mensagem que você quer apagar... Ex:
-> ${prefix+command} 2`)
BC = Number(args[0]) - 1
avisos[AB].mensagens.splice(BC, 1)
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Mensagem deletada com sucesso...`)
break

case 'delrandom':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = avisos.map(i => i.groupId).indexOf(from)
if(avisos[AB].aleatory.length <= 0) return reply(`Não há horário definidos neste grupo`)
if(!Number(args[0]) || Number(args[0]) < 0 || Number(args[0]) > avisos[AB].aleatory.length) return reply(`Olhe no comando ${prefix}listmsg o número correspondente ao horário que você quer apagar... Ex:
-> ${prefix+command} 2`)
BC = Number(args[0]) - 1
avisos[AB].mensagens.splice(BC, 1)
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Horário deletado com sucesso...`)
break

case 'rmrandom':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = avisos.map(i => i.groupId).indexOf(from)
if(avisos[AB].globalAleatory.length <= 0) return reply(`Não há nenhuma mensagem na caixa deste grupo`)
if(!Number(args[0]) || Number(args[0]) < 0 || Number(args[0]) > avisos[AB].globalAleatory.length) return reply(`Olhe no comando ${prefix}listmsg o número correspondente a mensagem que você quer apagar... Ex:
-> ${prefix+command} 2`)
BC = Number(args[0]) - 1
avisos[AB].globalAleatory.splice(BC, 1)
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Mensagem deletada com sucesso...`)
break

case 'rmglobal':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!isOwner) return reply(enviar.msg.dono)
AB = avisos.map(i => i.groupId).indexOf("matheuzinho")
if(avisos[AB].mensagens.length <= 0) return reply(`Não há nenhuma mensagem na caixa global`)
if(!Number(args[0]) || Number(args[0]) < 0 || Number(args[0]) > avisos[AB].mensagens.length) return reply(`Olhe no comando ${prefix}listmsg o número correspondente a mensagem que você quer apagar... Ex:
-> ${prefix+command} 2`)
BC = Number(args[0]) - 1
avisos[AB].mensagens.splice(BC, 1)
fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
reply(`Mensagem deletada com sucesso...`)
break

case 'listmsg':
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = avisos.map(i => i.groupId).indexOf(from)
if(avisos[AB].mensagens.length <= 0) return reply(`Não há avisos neste grupo`)
txt = `🎴 *Exbindo ${avisos[AB].mensagens.length > 1 ? `os ${avisos[AB].mensagens.length} avisos progamados neste grupo` : `o único aviso progamado deste grupo`} ↴*`
for(i = 0; i < avisos[AB].mensagens.length; i++) {
  txt += `\n\n»${i + 1}« *Mensagem:* ${avisos[AB].mensagens[i].msg}
*Horário:* ${avisos[AB].mensagens[i].tempo}`
}
txt += `\n\n_Caso queira apagar uma mensagem, use ${prefix}rmmsg e após o comando, o número correspondente... Ex: ${prefix}rmmsg 1_`
if(avisos[AB].aleatory.length > 0) {
  txt += `\n\n🔁 *Exibindo caixa de mensagens aleatórias porgramadas neste grupo ↴*`
  for(i = 0; i < avisos[AB].aleatory.length; i++) {
    txt += `\n»${i + 1}« -> ${avisos[AB].aleatory[i].tempo}`
  }
  txt += `\n\n_Caso queira apagar uma mensagem, use ${prefix}rmrandom e após o comando, o número correspondente... Ex: ${prefix}rmrandom 1_`
}
reply(txt)
break

case 'infomsg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(avisos).includes("matheuzinho")) {
  avisos.push({groupId: "matheuzinho", mensagens: []})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!JSON.stringify(avisos).includes(from)) {
  avisos.push({groupId: from, mensagens: [], globalAleatory: [], aleatory: [], module: true})
  fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
}
if(!isGroupAdmins) return reply(enviar.msg.adm)
reply(`*Comandos do sistema de mensagem programada:*
-> ${prefix}listmsg
_Lista todos os horários programados neste grupo_

-> ${prefix}addmsg
_Adiciona uma mensagem programada neste grupo_

-> ${prefix}rmmsg
_Deleta a mensagem programada selecionada deste grupo_

-> ${prefix}envrandom
_Cria uma caixa de mensagens dentro do grupo para usar o comando ${prefix}addrandom_

-> ${prefix}addrandom
_Ao definir um horário, será enviado uma mensagem aleatória de dentro da "caixa" do comando acima todo dia no horário definido_

-> ${prefix}delrandom
_Deleta a frase aleatória criada no comando acima_

-> ${prefix}envglobal
_Cria uma caixa global enviando a frase para lá. É útil para quando quiseres usar o comando acima de mensagens aleatórias em vários grupos e não quer fazer o mesmo processo em cada grupo... Basta usar esse comando e após ele o ${prefix}envrandom_

-> ${prefix}rmgloblal
_Deleta a mensagem da caixa global criada acima_`)
break

case 'rggp':
if(!isOwner) return reply(enviar.msg.dono)
if(JSON.stringify(globegroup).includes(from)) return reply(`Grupo já registrado...`)
try {
var fotogp = await blackmd.profilePictureUrl(from, 'image')
} catch {
var fotogp = `https://telegra.ph/file/6ca032835ed7a16748b6f.jpg`
}
linkgp = await blackmd.groupInviteCode(from)
globegroup.push({id: from, thumb: fotogp, nome: groupName, link: `https://chat.whatsapp.com/${linkgp}`})
fs.writeFileSync("./basededados/globegroup.json", JSON.stringify(globegroup, null, 2))
reply(`Grupo adicionado ao comando global ${prefix}grupos`)
break

case 'rmgp':
if(!isOwner) return reply(enviar.msg.dono)
rmgp = q.length > 8 ? q : from
if(!JSON.stringify(globegroup).includes(rmgp)) return reply(`Grupo não registrado...`)
AB = globegroup.map(i => i.id).indexOf(rmgp)
globegroup.splice(AB, 1)
fs.writeFileSync("./basededados/globegroup.json", JSON.stringify(globegroup, null, 2))
reply(`Grupo retirado do comando global ${prefix}grupos`)
break

case 'grupos':
if(isGroupAdmins || isVip) {
  if(globegroup.length > 0) {
    gpale = globegroup[Math.floor(Math.random()*globegroup.length)]
    blackmd.sendMessage(from, {image: {url: gpale.thumb}, caption: `_⏤͟͟͞͞ ꦿLink do grupo ↴_
⇒ ${gpale.nome}

${gpale.link}`}, {quoted: seloctt})
  } else {
    reply("Não há grupos registrados...")
  }
} else {
  reply("[ ❗ ] só ADM ou VIP ❌")
}
break

case 'gerargrupos'://By: Aqua Bot
case 'gerargrupo'://By: Aqua Bot
case 'gerargp'://By: Aqua Bot
if(!q) return reply("Ei, qual tipo de grupo?")
reply(`🔎 _procurando grupos_ 🔍`)
 if(!isVip) return reply(enviar.msg.vip)  
    swp = await fetchJson(`https://tohka.tech/api/pesquisa/gpwhatsapp?nome=${q}&apikey=Misaki`)
    teks = `═══════ ❯❯   *BLACK BOT - GRUPOS* ❮❮\n\n`;
    for(let i of swp) {
        teks += "▧⃯⃟NOME『" + i.nome + "』\n"
        teks += "▧⃯⃟DESCRIÇÃO→ " + i.descrição + "\n"
        teks += "▧⃯⃟LINK→ " + i.link + "\n\n"
    }
    teks += `☆ヅ━━━━━━━BLACK BOT━━━━━━━━ヅ☆`
  reply(teks)
break

case 'mute':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!menc_os2) return reply(prefix + command + " @ da pessoa")
if(sender.includes(menc_os2)) return reply(`Não é possível mutar a si mesmo...`)
if(numerodono.includes(menc_os2)) return reply(`Não é possível mutar meu dono...`)
if(botNumber.includes(menc_os2)) return reply(`Não é possível mutar o bot...`)
if(groupAdmins.includes(menc_os2)) return reply(`Não é possível mutar um ADM...`)
if(JSON.stringify(vip).includes(menc_os2)) return reply(`Não é possível mutar um usuário VIP...`)
if(JSON.stringify(mute).includes(from)) {
AB = mute.map(i => i.gpid).indexOf(from)
if(JSON.stringify(mute[AB].mutados).includes(menc_os2)) return reply(`Este usuário já está mutado...`)
mute[AB].mutados.push({id: menc_os2, sn: false})
fs.writeFileSync("./basededados/mute.json", JSON.stringify(mute, null, 2))
} else {
mute.push({gpid: from,
mutados: [{id: menc_os2, sn: false}]
})
fs.writeFileSync("./basededados/mute.json", JSON.stringify(mute, null, 2))
}
reply(`Usuário mutado com sucesso... Caso ele fale algo, será banido.`)
break

case 'desmute':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!JSON.stringify(mute).includes(from)) return reply(enviar.msg.notusu)
if(menc_os2) {
var qp = menc_os2
} else {
var qp = args[0] + `@s.whatsapp.net`
}
AB = mute.map(i => i.gpid).indexOf(from)
BC = mute[AB].mutados.map(a => a.id).indexOf(qp)
if(BC < 0) return reply(enviar.msg.notusu)
mute[AB].mutados.splice(BC, 1)
fs.writeFileSync("./basededados/mute.json", JSON.stringify(mute, null, 2))
reply(`Usuário desmutado com sucesso...`)
break

case 'mutelist':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!JSON.stringify(mute).includes(from)) return reply(`Não há usuários mutados neste grupo...`)
AB = mute.map(i => i.gpid).indexOf(from)
if(Number(mute[AB].mutados.length) > 0) {
txt = `🤫 *Usuários mutados do grupo ↴*
${groupName}
📟 *Total:* ${mute[AB].mutados.length}\n`
for(a = 0; a < mute[AB].mutados.length; a++) {
txt += `• @${mute[AB].mutados[a].id.split('@')[0]}\n`
}
mention(txt)
} else {
reply(`Não há usuários mutados neste grupo...`)
}
break

case 'infomute':
reply(`${tempo} ${pushname}, os comandos disponíveis são:
• ${prefix}mute
• ${prefix}desmute
• ${prefix}mutelist

-> ${prefix}mute
Marque o usuário com @ ou a mensagem dele, para mutar o mesmo...

-> ${prefix}desmute
Marque o usuário com @ ou a mensagem dele, para desmutar o mesmo... O ban não anula o mute.

-> ${prefix}mutelist
Irá mostrar a lista de todos os usuários mutados... Bem, se houver algum.`)
break

case 'inforoleta':
setTimeout(() => {reagir(from, "💀")}, 300)
reply(`Há duas roletas russas funcionando...

[ ${prefix}roleta ]
O bot irá escolher aleatoriamente uma pessoa do grupo, e banir imediatamente...

[ ${prefix}roleta2 ]
A roleta 2 irá fazer a mesma coisa que a de cima... Porém nesta, os ADMs estarão salvos do banimento.`)
break

case 'roleta':
reagir(from, "💀")
if(!isModobn) return reply(enviar.msg.modobz)
if(!isGroupAdmins) return reply(`Você não tem essa permissão... 🖐🏽😔`)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
membros = []
for(i = 0; i < groupMembers.length; i++) {
if(groupMembers[i].id != nmrdn && groupMembers[i].id != botNumber && groupMembers[i].id != groupMetadata.owner) membros.push({id: groupMembers[i].id})
}
if(membros.length > 0) {
alerl = membros[Math.floor(Math.random() * membros.length)].id
mention(`Entre os sorteados do grupo ${groupName}, @${alerl.split('@')[0]} hoje não é seu dia de sorte...`)
balas = ["vazio", "vazio", "vazio", "vazio", "vazio", "cheio", "cheio", "cheio"]
balinha = balas[alerandom(balas.length)]
await sleep(1000)
if(balinha == "vazio") return sendMess(from, "Hahaha, tô zoando... sorte sua que o cartucho tava vazio 🤡")
blackmd.sendMessage(from, {text: `Suas últimas palavras...`})
blackmd.groupParticipantsUpdate(from, [alerl], "remove")
} else {
reply(`Não há membros suficientes no grupo para efetuar a roleta russa...`)
}
break

case 'roleta2':
reagir(from, "💀")
if(!isModobn) return reply(enviar.msg.modobz)
if(!isGroupAdmins) return reply(`Você não tem essa permissão... 🖐🏽😔`)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(somembros.length <= 0) return reply(`Só foram encontrados admins no grupo ${groupName}`)
membros = []
for(i = 0; i < somembros.length; i++) {
if(!numerodono.includes(somembros[i]) && !botNumber.includes(somembros[i]) && !groupMetadata.owner.includes(somembros[i])) membros.push({id: somembros[i]})
}
if(membros.length > 1) {
alerl = membros[Math.floor(Math.random() * membros.length)].id
mention(`Entre os sorteados do grupo ${groupName}, @${alerl.split('@')[0]} hoje não é seu dia de sorte...`)
balas = ["vazio", "vazio", "vazio", "vazio", "vazio", "cheio", "cheio", "cheio"]
balinha = balas[alerandom(balas.length)]
await sleep(1000)
if(balinha == "vazio") return sendMess(from, "Hahaha, tô zoando... sorte sua que o cartucho tava vazio 🤡")
blackmd.sendMessage(from, {text: `Suas últimas palavras...`})
blackmd.groupParticipantsUpdate(from, [alerl], "remove")
} else {
reply(`Não há usuários suficientes para efetuar o sistema de roleta russa...`)
}
break

case 'promover': case 'promo':
setTimeout(() => {reagir(from, "👑")}, 300)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!menc_os2 || menc_jid2[1]) return reply("Marque a mensagem do usuário ou marque o @ dele.., lembre de só marcar um usuário...")
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Este usuário foi removido do grupo ou saiu, não será possível promover..")
blackmd.sendMessage(from, {text: `@${menc_os2.split("@")[0]} *ACABA DE RECEBER A COROA DE ADMINISTRADOR DO GRUPO... ESPERO QUE HONRE A SUA FUNÇÃO* 👑`, mentions: [menc_os2]})
blackmd.sendMessage(from, {audio: {url:'./database/audios/promovido.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.groupParticipantsUpdate(from, [menc_os2], "promote")  
break

case 'rebaixar': case 'reb':
setTimeout(() => {reagir(from, "🥲")}, 300)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(!menc_os2 || menc_jid2[1]) return reply("Marque a mensagem do usuário ou marque o @ dele.., lembre de só marcar um usuário...")
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Este usuário foi removido do grupo ou saiu, não será possível rebaixar..")
blackmd.sendMessage(from, {text: `@${menc_os2.split("@")[0]} *ACABA DE PERDER A COROA DE ADM DO GRUPO...* 🥲`, mentions: [menc_os2]})
blackmd.groupParticipantsUpdate(from, [menc_os2], "demote")  
break

case 'alfabeto':
case 'a':
setTimeout(() => {reagir(from, react2)}, 300)
if(!q) return reply(`*Ex:* A letra que cair é a inicial da pessoa que vai te fazer feliz esse ano...`)
alfa = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S","T","U","V","W","X","Y","Z"]
reply(`❤️‍🔥 Vamos sortear uma letra para a frase⟩
${q}`)
setTimeout(async() => {
blackmd.sendMessage(from, {text: `${alfa[Math.floor(Math.random()*alfa.length)]} ${react2}`})
}, 2000)
break

case 'sorteio2':
if(!isGroupAdmins) return reply(enviar.msg.adm)
try{
if(!isGroup) return reply(enviar.msg.grupo)
if(!q) return reply(`Coloque algo, após o comando sorteio, por exemplo, ${prefix+command} de 100 R$`)
d = []
teks = `🎉Parabéns, por ganhar o sorteio ${q}:\n\n`
for(i = 0; i < 1; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `🔥፝⃟  ➣ @${groupMembers[r].id.split('@')[0]}\n`
d.push(groupMembers[r].id)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
reply('Deu erro, tente novamente :/')
}
break

case 'sorteio':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(isJsonIncludes(sorteio, from)) return reply(`Há um sorteio em andamento neste grupo...`)
if(!q) return reply(`Você precisa configurar o sorteio primeiro, definindo horário, participante e emoji... Se tiver mais dúvidas, olhe no ${prefix}infosorteio`)
cont = contar(q, " ")
if(cont != 2 && !isJsonIncludes(sorteio, from)) return reply(`Vejo que você está usando de forma errada... Precisa ser desse jeito:
${prefix+command} 12:45 1/all ❤`)
var [time, part, emj] = q.split(` `)
var [p_win, p_all] = part.split(`/`)
if(!Number(time.replace(":", ""))) return reply(`Pfvr ${pushname}, revise o horário que vc colocou...`)
horacerta = converterMin(contarMin(time))
if(contarMin(horacerta) <= contarMin(sendHours("HH:mm"))) return reply(`O sistema de sortieo está em desenvolvimento... Portanto, selecione um horário acima do atual 🎭`)
total_p = p_all.toLowerCase() == "all" ? groupMembers.length - 1 : p_all
lm = converterMin((contarMin(horacerta) - 5) < 0 ? contarMin("24:00") + (contarMin(horacerta) - 5) : contarMin(horacerta) - 5)
if(Number(p_win) > Number(total_p)) return reply(`A quantidade de ganhadores não pode ser maior que a quantidade de participantes`)
if(!antiModLetra(emj)) return reply(`Você não indicou com emoji, a reação devida...`)
msg = info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.conversation || info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.extendedTextMessage?.text
if(!msg) return reply(`Vc não marcou a mensagem ksksks Marque uma mensagem, que no caso é o título do sorteio, e este texto será salvo no banco de dados do bot para ser sorteado no horário determinado 🥰`)
sorteio.push({groupId: from, texto: msg, data: horacerta, dia: sendHours("DD"), emoji: emj, limite: lm, ganhadores: Number(p_win), total: Number(total_p), start: false, participants: []})
saveJSON(sorteio, "./basedefuncionamento/sorteio.json")
txt = `👤 *Admin:* @${sender.split("@")[0]}
⏳ *Horário:* ${horacerta}

\t\t\t⚠ *ATENÇÃO MEMBROS* ⚠

${msg}

_Se você tiver interesse em participar do sorteio acima, reaja esta mensagem com o emoji "${emj}"_
_Há ${total_p} vagas... Entrada será encerrada ${lm} (admins podem mudar esse limite no comando ${prefix}stms)_`
reagir(from, emj)
blackmd.sendMessage(from, {text: txt, mentions: groupMembers.map(i => i.id)}, {quoted: seloctt})
break

case 'sortelist':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = sorteio.map(i => i.groupId).indexOf(from)
if(AB < 0) return reply(enviar.msg.notusu)
txt = `⏳ *Horário do sorteio:* ${sorteio[AB].data}
😎 *Entrada limite:* ${sorteio[AB].limite}
👻 *Total:* ${sorteio[AB].participants.length}/${sorteio[AB].total}
👤 *Participantes:*${sorteio[AB].participants.map(p => `\n• @${p.split("@")[0]}`).join(``)}

\t${sorteio[AB].texto}

_Se você tiver interesse em participar do sorteio acima, basta reagir esta mensagem com o emoji "${sorteio[AB].emoji}"_`
mention(txt)
break

case 'stms':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = sorteio.map(i => i.groupId).indexOf(from)
if(AB < 0) return reply(enviar.msg.notusu)
if(!Number(args[0])) return reply(`Retorne após o comando quantos minutos antes do sorteio, os usuários poderão entrar..., Ex: ${prefix+command} 5`)
nmr = converterMin(contarMin(sorteio[AB].data) - Number(args[0]))
sorteio[AB].limite = nmr
saveJSON(sorteio, "./basedefuncionamento/sorteio.json")
reply(`O horário limite para participar do sorteio neste grupo foi atualizado com sucesso para ${nmr} ✅`)
break

case 'stopsorte':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = sorteio.map(i => i.groupId).indexOf(from)
if(AB < 0) return reply(enviar.msg.notusu)
sorteio.splice(AB, 1)
saveJSON(sorteio, "./basedefuncionamento/sorteio.json")
reply(`O sorteio deste grupo foi cancelado com sucesso...`)
break

case 'nuke': case 'arquivargp':
if(!isOwner) return reply(enviar.msg.dono)
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
if(info.key.fromMe) return 
grupo = groupMembers.map(i => i.id)
grupo.splice(grupo.indexOf(nmrdn), 1)
grupo.splice(grupo.indexOf(botNumber), 1)
if(grupo.length <= 0) return reply("Não há membros para banir aqui...")
for(i = 0; i < grupo.length; i++) {
await sleep(1300)
blackmd.groupParticipantsUpdate(from, [grupo[i]], 'remove')
}
break

case 'sorteionumero':
case 'snmr':
setTimeout(() => {reagir(from, "✅")}, 300)
if(!q) return reply(`Escolha um número máximo...
Ex: ${prefix+command} 300`)
reply(`_Sorteando número aleatório entre 0-${q}_`)
setTimeout(async() => {
try {
blackmd.sendMessage(from, {text: `*Número sorteado ( ${Math.floor(Math.random()*q)} )*`})
} catch {
blackmd.sendMessage(from, {text: `${q} não é número... 😕`})
}
}, 1100)
break

//==========(TTPS/ATTP)============\\

case 'ttp':
    if (!q) return reply(`*_❕Coloque o texto que você quiser!_*\n- *🧑‍🏫 Por exemplo:* ${prefix + command} sandro`);

    reagir(from, "👻");
    await sleep(1000);
    reply('fazendo');

    // Montar a URL da API com o texto fornecido
    const string = args.join(' ') || 'Texto indefinido';
    const post = `https://api.maher-zubair.tech/maker/text2img?q=${encodeURIComponent(string)}`;

    // Função para enviar sticker a partir da URL
    const sendStickerFromUrl = async (to, url, options) => {
        try {
            const buffer = await getBuffer(url);
            const filePath = 'temp.png'; // Caminho temporário para o arquivo
            fs.writeFileSync(filePath, buffer);

            // Converter a imagem para WebP
            const webpPath = 'temp.webp';
            exec(`ffmpeg -i ${filePath} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${webpPath}`, (err) => {
                if (err) {
                    console.error('Erro ao converter imagem para WebP:', err);
                    reply("Erro ao converter imagem para figurinha");
                    return;
                }

                // Enviar a figurinha
                blackmd.sendMessage(to, { sticker: fs.readFileSync(webpPath) }, options);

                // Limpar arquivos temporários
                fs.unlinkSync(filePath);
                fs.unlinkSync(webpPath);
            });
        } catch (error) {
            console.error('Erro ao obter o buffer:', error);
            reply("Erro ao criar a figurinha");
        }
    };

    // Enviar a figurinha
    sendStickerFromUrl(from, post, { quoted: info }).catch(e => {
        reply(mess.error());
    });
    break;

case 'attp1':
case 'attp2':
case 'attp3':
case 'attp4':
case 'attp5':
case 'attp6':
case 'attp7':
case 'attp8':
case 'attp9':
case 'attp10':
    if (!q) return reply("Ei, Cadê o Texto?");
    try {
        reply(`*Gerando figu com a frase* _"${q.split("\n").join("_\n_")}"_`);
        let link = `https://world-ecletix.onrender.com/api/attp?texto=${encodeURIComponent(q)}&tipo=${command}`;
        blackmd.sendMessage(from, { sticker: { url: link } }, { quoted: info });
    } catch (err) {
        reply("Erro ao gerar a figurinha");
    }
    break;

//======================================\\

//===(ZOUEIRAS/BRINCADEIRAS/HUMOR)===\\

case 'modonsfw':
case 'nsfw':  
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(args.length < 1) return reply('Hmmmm')
if(Number(args[0]) === 1) {
if(isNsfw) return reply('O modo nsfw já está ativo')
nsfw.push(from)
fs.writeFileSync('./database/grupos/nsfw.json', JSON.stringify(nsfw))
reply(`\`\`\`✓Ativado com sucesso o modo nsfw +18 no grupo\`\`\` *${groupMetadata.subject}*`)
} else if(Number(args[0]) === 0) {
if(!isNsfw) return reply('O modo nsfw já está Desativado')  
nsfw.splice(from, 1)
fs.writeFileSync('./database/grupos/nsfw.json', JSON.stringify(nsfw))
reply(`\`\`\`✓Modo Nsfw +18 desativado com sucesso no grupo\`\`\` *${groupMetadata.subject}*`)
} else {
reply('1 para ativar, 0 para desligar')
}
break 

case 'sn':
  setTimeout(() => {reagir(from, "🤔")}, 300)
  if(!q) return reply(`*Faça uma pergunta para o bot responder com sim/não...*\n*Exemplo:* ${prefix+command} hj tem gol do Ribamar ?`)
  const sn = ['sim', 'não']
  const sn2 = ["creio que", "acredito que", "acho que", "receio que"]
const sn_ = sn[Math.floor(Math.random() * (sn.length))]
const sn2_ = sn2[Math.floor(Math.random() * (sn2.length))]
  sim_nao = `Pergunta⧽ ${q}\n\n*Pensando bem... ${sn2_} ${sn_}* 🤷🏻‍♂️`
reply(sim_nao)
break

case 'campominado': case 'campo-minado':
if(!isGroup) return reply(enviar.msg.grupo)
game = `./armor/jogo/mina-game/campo-minado-${from}.json`
if(!fs.existsSync(game)) {
barra = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/")
var [mark, difi] = barra.split("/")
if(!mark.includes("@")) return reply("Marque alguém do grupo para jogar com você, o @ ou a mensagem...")
usu = mark.split("@")[1] + "@s.whatsapp.net"
if(!isJsonIncludes(groupMembers, usu)) return reply("Usuário marcado não está mais entre nós...")
if(usu == botNumber) return reply("Eu sou o bot né meu prç, eu não jogo 🤦🏻‍♂️")
pc = prefix+command
if(q.includes("@") && !q.includes("/")) return mention(`💣 Vc deve escolher entre uma das três dificuldades:
🌟⃤ ${pc+" "+q}/easy
⚡⃤ ${pc+" "+q}/medium
💥⃤ ${pc+" "+q}/hard`)
qp = difi.toLowerCase()
if(qp != "easy" && qp != "medium" && qp != "hard") return mention(`Vc deve escolher entre uma das três dificuldades:
${pc+" "+q}/easy
${pc+" "+q}/medium
${pc+" "+q}/hard`)
if(qp == "easy") { mm = 7; mxm = 9 }
if(qp == "medium") { mm = 14; mxm = 7 }
if(qp == "hard") { mm = 21; mxm = 5 }
delt = []
for(a = 1; a < (mxm + 1); a++) {
  for(b = 1; b < (mxm + 1); b++) {
    if(b == 1) c = "a"
    if(b == 2) c = "b"
    if(b == 3) c = "c"
    if(b == 4) c = "d"
    if(b == 5) c = "e"
    if(b == 6) c = "f"
    if(b == 7) c = "g"
    if(b == 8) c = "h"
    if(b == 9) c = "i"
    delt.push(a+c)
  }
}
caixa = []
for(i = 0; i < mm; i++) {
  valor = alerandom(delt.length)
  caixa.push(delt[valor])
  delt.splice(valor, 1)
}
start = {
  ID: sendHours("DDMMYYYYHHmmss"),
  jogadores: [{id: sender, erros: 3}],
  criador: sender,
  chamado: usu,
  play: 0,
  começou: false,
  dificuldade: qp,
  totalminas: mm,
  totalquad: mxm,
  minas: caixa,
  plantado: []
}
fs.writeFileSync(game, JSON.stringify(start, null, 2))
mention(`⚡ ${tempo} @${usu.split('@')[0]},
@${sender.split('@')[0]} está te desafiando para jogar uma partida eletrizante nível ${qp} de "campo minado" 💣😜

Digite » S « para aceitar e » N « para recusar 🫵🏽😄`)
await sleep(900000)
finish = `./armor/jogo/mina-game/campo-minado-${from}.json`
if(fs.existsSync(finish) && JSON.parse(fs.readFileSync(finish)).ID == sendHours("DDMMYYYYHHmmss")) {
  fs.unlinkSync(finish)
  reply("Sessão expirada 💣")
}
} else {
  campominado = JSON.parse(fs.readFileSync(game))
  if(campominado.começou == true) {
    if(isJsonIncludes(campominado.jogadores, sender)) return reply("Você já está jogando "+pushname)
    return mention(`⚡ Os presentes membros ${campominado.jogadores.map(i => `@`+i.id.split("@")[0]).join(` e `)} estão jogando no momento... Pfvr, aguarde a partida terminar 💣`)
  } else {
    if(campominado.chamado == sender) return mention(`*⚡ Você foi convidado pelo @${campominado.criador.split("@")[0]} para jogar "campo minado" nível ${campominado.dificuldade}... Pfvr, digite sim/não 💣*`)
    if(campominado.criador == sender) return mention(`*😓 Tô aguardando confirmação do @${campominado.chamado.split("@")[0]}...* (Caso queira desistir, use ${prefix}resetmina)`)
    return reply("⚡ Há uma partida em andamento neste grupo 💣")
  }
}
break

case 'resetmina': case 'rmn':
if(!isGroup) return reply(enviar.msg.grupo)
game = `./armor/jogo/mina-game/campo-minado-${from}.json`
if(!fs.existsSync(game)) return reply("Nenhuma sessão em andamento neste grupo 💣😜")
campominado = JSON.parse(fs.readFileSync(game))
if(!isGroupAdmins && campominado.criador != sender) return reply("[ ❗ ] apenas admins do grupo ou quem começou o jogo podem cancelar a partida ❌")
fs.unlinkSync(game)
reply("Partida cancelada 💣😜")
break

case 'infominagame':
reply(`💣 O primeiro passo é chamar alguém pra jogar e escolher a dificuldade, que pode ser easy, medium ou hard... Use o comando ${prefix}campo-minado

😜 Após configurada a dificuldade e chamado o jogador, o mesmo terá que responder com sim/não para iniciar ou terminar o jogo.

🎮 Uma vez aceito, já em jogo, ambos os jogadores terão 3 chances de errar... Basta responder a coordenada como 2b ou 5a, sempre colocando a letra após o número.

🏆 Vence o jogador que mais sobreviver`)
break

case 'addforca':
if(!isOwner) return reply(enviar.msg.dono)
if(contar(q, `/`) != 2) return reply(`Retorne após o comando o tema, a palavra e a dica que você deseja adicionar...
Ex: veículo/carro/tem 4 rodas`)
var [tema, palavra, dica] = q.split(`/`)
rgWordForcaGame(tema, palavra, dica);
txt = `🎗 *_Forca registrada com sucesso_* 🎗
🎭 *Tema:* ${iniMai(tema)}
🎨 *Palavra:* ${iniMai(palavra)}
🧶 *Dica:* ${iniMai(dica)}`
reply(txt)
break

case 'rmforca':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`KD a palavra que você quer deletar?`)
rmWordForcaGame(reply, q);
break

case 'rmtema':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply(`KD o tema que você quer deletar?`)
rmThemeForcaGame(reply, q);
break

case 'listword': case 'listaforca':
if(!isOwner) return reply(enviar.msg.dono)
if(forcaWord.length <= 0) return reply(`[❗] não há palavras salvas ❌`)
txt = forcaWord.map(a => `🎈 _*Tema:* ${iniMai(a.title)}_
📚 _*Palavras ↴*_
${a.words.map(b => `\t🎲 *Nome:* ${iniMai(b.nome)}
\t🧸 *Dica:* ${iniMai(b.desc)}`).join(`\n\n`)}`).join(`\n\n-\n\n`)
reply(txt)
break

case 'forca': case 'startforca':
if(!isGroup) return reply(enviar.msg.grupo)
reagir(from, "🎗")
if(!existSomeWordForcaGame) return reply(`Não há palavras na database do bot para seres distribuidas... Chame o dono do bot para ele adicionar mais palavras 🥰`)
if(isForcaGame(from)) {
  reply(`🎗 Há uma sessão em andamento... Use ${prefix}fc para responder ou ${prefix}rrfc para reiniciar`)
  await sleep(5000)
  return sendTextForcaGame(reply, prefix, from)
}
startForcaGame(reply, prefix, from)
break

case 'myforca': case 'minhaforca': case 'myf':
addUsuarioForca(sender);
try { ppimg = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image'))}`)).data
} catch(e) { ppimg = semfoto }
sendUrlText(from, getUsuDatabaseForca(sender, barrinha), pushname, ``, ppimg, `https://wa.me/`+sender.split("@")[0], seloblk)
break

case 'fc':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isForcaGame(from)) return reply(`Não há nenhum jogo em andamento... Para começar, use ${prefix}forca`)
if(!q) return reply(`Retore após o comando a letra ou a palavra toda da forca, ex:
${prefix+command} ${randomLetra.toLowerCase()}`)
jogarLetraForcaGame(mention, from, sender, prefix, q);
break

case 'rfc': case 'rrfc':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!isForcaGame(from)) return reply(`Não há nenhum jogo em andamento... Para começar, use ${prefix}forca`)
if(command == "rrfc") return restartForcaGame(reply, prefix, from);
resetForcaGame(from);
reply(`🧸 Partida de forca encerrada com sucesso..`)
break

//=======================RPG=====================\\

case 'modorpg':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(Number(args[0]) === 1) {
if(isBlackCity) return reply("O RPG já está ativado...")
dataGp[0].modorpg = true
setGp(dataGp)
return reply("LADY CITY RPG ativado com sucesso ✅")
} else if(Number(args[0]) === 0) {
if(!isBlackCity) return reply("O RPG não está ativado...")
dataGp[0].modorpg = false
setGp(dataGp)
return reply("LADY CITY RPG desativado com sucesso ♨️")
} else return reply(`Use ${prefix+command} 1/0`)
break

case 'criarcidade':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(!isOwner) return reply(enivar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Retorne após o comando o nome da cidade e o número do dono dela, ex:
${prefix+command} xarquelândia/${addNumberMais(randomUser)}`)
var [cdd_bc, dono_bc] = q.split(`/`)
usu = identArroba(dono_bc)
createCityBlackRPG(usu, cdd_bc);
mention(`Cidade criada no número de @${usu.split("@")[0]} com sucesso ✅`)
break

case 'cidadesrpg': case 'cidades':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(cidadesRPG.length <= 0) return reply(enviar.rpg.notcdd)
txt = `🏦 *Total:* ${cidadesRPG.length}`
for(i = 0; i < cidadesRPG.length; i++) {
  cdd = cidadesRPG[i]
  AB = cdd.moradores.map(c => c.id).indexOf(cdd.prefeito)
  txt += `\n\n🏘 *Nome:* ${iniMai(cdd.nome)}
🤵🏽 *Prefeito:* ${cdd.moradores[AB].nome}
👤 *Moradores:* ${cdd.moradores.length}/${cdd.level * 30}
📦 *Vagas:* ${!limitCity(cdd.nome) ? `✅` : `❌`}`
}
reply(txt)
break

case 'minhacidade': case 'mycity':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)
AB = cidadesRPG.map(c => c.nome).indexOf(findCity(sender))
cdd = cidadesRPG[AB]
AC = cdd.moradores.map(m => m.id).indexOf(cdd.prefeito)
txt = `🏘 *Nome:* ${iniMai(cdd.nome)}
🤵🏽 *Prefeito:* ${cdd.moradores[AC].nome} ↴
🧮 *Total:* ${cdd.moradores.length}/${cdd.level * 30}
👤 *Moradores:*
${cdd.moradores.map(m => `• ${m.nome}`).join(`\n`)}`
thumb = `https://telegra.ph/file/3b3f6ced554bc4c73b40e.png`
sendUrlText(from, txt, `𝘽𝙀𝙈 𝙑𝙄𝙉𝘿𝙊 (𝘼) 🏙`, ``, thumb, thumb, seloctt)
break

case 'deletarcidade': case 'delcdd':
if(!isOwner) return reply(enivar.msg.dono)
if(!q) return reply(`Retorne após o comando, o nome da cidade que você deseja deletar... Se não souber, olhe no comando ${prefix}cidadesrpg as cidades existentes.`)
AB = cidadesRPG.map(i => i.nome).indexOf(q)
if(AB < 0) return reply(`[❗] Cidade não encontrada ou inexistente ❌`)
cidadesRPG.splice(AB, 1)
saveCityBlackRPG();
reply(`Cidade deletada com sucesso ✅`)
break

case 'rgbc': case 'rgblackcity':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(isYouInBlackCity(sender)) return reply(enviar.rpg.existrg)
if(contar(q, `/`) != 1) return reply(`Retorne após o comando o nome e a cidade que você se registrar, ex:
${prefix+command} John/Rio dos ladrôes`)
var [a, b] = q.replace(`/ `, `/`).replace(` /`, `/`).replace(` / `, `/`).split(`/`)
if(!existCity(b)) return reply(enviar.rpg.notexistcity.replace(`#city#`, b))
if(limitCity(b)) return reply(enviar.rpg.citylimit)
registrarUsuInBlackCity(sender, a, b);
try { ppimg = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image'))}`)).data
} catch(e) { ppimg = semfoto }
img = `https://blacksystemofc.com.br/api/canvas/jxr/welcome?nome=${encodeURI(a)}&guilda=${encodeURI("LADY CITY")}&perfil=https://telegra.ph/file/8599989096be411a4a72b.jpg&membro=${totalUserBlackCity.length}&avatar=${ppimg}&fundo=${Number(sendHours("HH")) >= 6 && Number(sendHours("HH")) < 18 ? `https://telegra.ph/file/82bdf76492757e8dac17a.jpg` : `https://telegra.ph/file/14397844299a8fa11d4a9.jpg`}`
txt = enviar.rpg.welcome.replace(`#usu#`, sender.split("@")[0])
mencionarIMG(txt, img, seloctt)
break

case 'saldo': case 'carteira': case 'banco': case 'meubc':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(!isYouInBlackCity(sender)) return reply(enviar.rpg.registrar)
data = filesDBuserBC(sender)
txt = `
\t\t\t🎲 *_GERAL_* 🎲
📖 *Nome:* ${data.nome}
💰 *Saldo:* R$ ${Number(data.saldo).toFixed(2)}
🏦 *Banco:* R$ ${data.banco}

\t\t\t📃 *_REGISTRO_* 📃
📆 *Data:* ${data.registro.data}
⌚ *Hora:* ${data.registro.hora}
${`- `.repeat(30)}
_Livro de registro, pág. ${(totalUserBlackCity.map(t => t.UID).indexOf(sender)) + 1}_`
sendImage(from, `https://blackstorage.store/midia/1744987995710.jpg`, txt, info)
break

case 'addpix':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(!isOwner) return reply(enivar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Separe o número do usuário e o valor com uma barra ( / ), ex:
${prefix+command} ${addNumberMais(botNumber)}/100`)
usu = identArroba(q.split(`/`)[0])
if(!isYouInBlackCity(usu)) return reply(enviar.msg.notusu)
filesDBuserBC(usu).saldo += Number(q.split(`/`)[1])
saveCityBlackRPG();
mention(`R$ ${Number(q.split(`/`)[1]).toFixed(2)} fo${Number(q.split(`/`)[1]) !== 1 ? `ram` : `i`} adc ao saldo do usuário @${usu.split(`@`)[0]} com sucesso ✅`)
break

case 'rmpix':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(!isOwner) return reply(enivar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Separe o número do usuário e o valor com uma barra ( / ), ex:
${prefix+command} ${addNumberMais(botNumber)}/100`)
usu = identArroba(q.split(`/`)[0])
if(!isYouInBlackCity(usu)) return reply(enviar.msg.notusu)
nmr = (filesDBuserBC(usu).saldo - Number(q.split(`/`)[1])) < 0 ? 0 : filesDBuserBC(usu).saldo - Number(q.split(`/`)[1])
filesDBuserBC(usu).saldo = nmr
saveCityBlackRPG();
mention(`R$ ${Number(q.split(`/`)[1]).toFixed(2)} fo${Number(q.split(`/`)[1]) !== 1 ? `ram` : `i`} rmvd do saldo do usuário @${usu.split(`@`)[0]} com sucesso ✅`)
break

case 'setpix':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(!isOwner) return reply(enivar.msg.dono)
if(contar(q, `/`) != 1) return reply(`Separe o número do usuário e o valor com uma barra ( / ), ex:
${prefix+command} ${addNumberMais(botNumber)}/100`)
usu = identArroba(q.split(`/`)[0])
if(!isYouInBlackCity(usu)) return reply(enviar.msg.notusu)
filesDBuserBC(usu).saldo = Number(q.split(`/`)[1])
saveCityBlackRPG();
mention(`O saldo do usuário @${usu.split(`@`)[0]} foi setado em R$ ${Number(q.split(`/`)[1]).toFixed(2)} com sucesso ✅`)
break

case 'rmusubc':
if(!isBlackCity) return reply(enviar.rpg.ativar)
if(!isOwner) return reply(enivar.msg.dono)
if(!marc_tds) return reply(`Marque o usuário, a mensagem ou o @, de quem você quer deletar da Black City...`)
if(!isYouInBlackCity(marc_tds)) return reply(enviar.msg.notusu)
rmUsuBlackCity(marc_tds);
reply(`Usuário deletado com sucesso... 😪`)
break

case 'getfile':
if(!isOwner) return mention(privateCmd(sender, prefix+command, `"não encontrado"`, 0))
if(!q && !q.startsWith(`./`)) return reply("Tá faltando o caminho até o arquivo... Ex: "+prefix+command+" ./index.js")
try {
nome = q.split(`/`)[contar(q, `/`)]
reply("*Enviando no nosso grupo privado o arquivo "+nome+"*")
await sleep(1000)
blackmd.sendMessage(obrigadoEXT.idprivategp, {document: {url: q}, fileName: nome, mimetype: `application/${nome.endsWith(`js`) ? `javascript` : `json`}`})
} catch(e) { console.log(e)
reply(`Erro`) }
break

case 'modulos': case 'modulo':

case 'criarjson':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply("KD o nome do json?")
qp = q.toLowerCase()
if(fs.existsSync(`./basededados/${qp}.json`)) return reply("JSON já existente")
try {
fs.writeFileSync(`./basededados/${qp}.json`, JSON.stringify([]))
reply("JSON criado com sucesso ✅")
} catch { reply("Erro") }
break

case 'rmjson':
if(!isOwner) return reply(enviar.msg.dono)
if(!q) return reply("KD o nome do json?")
qp = q.toLowerCase()
if(!fs.existsSync(`./basededados/${qp}.json`)) return reply("JSON não existente")
try {
fs.unlinkSync(`./basededados/${qp}.json`)
reply("JSON deletado com sucesso ✔️")
} catch { reply("Erro") }
break

case 'anagrama':
if(!isGroup) return reply('Comando apenas para grupos')
if(!isModobn) return reply(enviar.msg.modobz)
ana = alerandom(palavrasANA.length)
anagrama = `./armor/jogo/anagrama/anagrama-${from}.json`
if(!isGroupAdmins && !fs.existsSync(anagrama)) return reply("Somente admins podem iniciar o jogo do anagrama")
if(args.join(' ') === '1') {
if(fs.existsSync(anagrama)) {
dataAnagrama = JSON.parse(fs.readFileSync(anagrama))
reply(`*O jogo já foi iniciado neste grupo:*
× *Palavra:* ${shuffle(dataAnagrama.embaralhada)}
× *Dica:* ${dataAnagrama.dica}
`)
} else {
saveJSON(palavrasANA[ana], anagrama)
blackmd.sendMessage(from, {text: `
╭─────≽「 👾 ANAGRAMA 👾 」
│➽ *DESCUBRA A PALAVRA*
│➽ *ANAGRAMA:* ${shuffle(palavrasANA[ana].embaralhada)}
│➽ *DICA:* ${palavrasANA[ana].dica}
╰────────────────────────
`}, {quoted: info})
}
} else if(args.join(' ') ==='0') {
if(!fs.existsSync(anagrama)) return reply('Não tem como desativar o jogo do anagrama, pôs ele não foi ativado')
fs.unlinkSync(anagrama)
reply("Jogo anagrama desativado com sucesso neste grupo...")
} else return reply('Use 1 para ativar o jogo do anagrama\nPara desativar use anagrama 0')
break

case 'revelaranagrama': case 'ran': {
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
ana = alerandom(palavrasANA.length)
anagrama = `./armor/jogo/anagrama/anagrama-${from}.json`
if(!fs.existsSync(anagrama)) return reply("Jogo anagrama não iniciado...")
dataAnagrama = JSON.parse(fs.readFileSync(anagrama))
resp = dataAnagrama.original
fs.unlinkSync(anagrama)
var bglh = [
`[ ❗ ] Reiniciando o jogo em 5️⃣`,
`[ ❗ ] Reiniciando o jogo em 4️⃣`,
`[ ❗ ] Reiniciando o jogo em 3️⃣`,
`[ ❗ ] Reiniciando o jogo em 2️⃣`,
`[ ❗ ] Reiniciando o jogo em 1️⃣`,
`[ ❗ ] Reiniciando o jogo em 0️⃣`
]
let { key } = await blackmd.sendMessage(from, {text: `💢 FINALIZANDO GAME 💢`}, {quoted: info})//primeira mensagem
await sleep(1000)
await blackmd.sendMessage(from, {text: `*Fim de jogo, a palavra era ↴*
⇒ 
*Irei resetar o jogo* 😕`, edit: key }, {quoted: info})
await sleep(1000)
for(let b = 0; b < resp.length; b++) {
await blackmd.sendMessage(from, {text: `*Fim de jogo, a palavra era ↴*
⇒ ${resp.slice(0, b+1)}
*Irei resetar o jogo* 😕`, edit: key }, {quoted: info})
}
await sleep(1000)
for(let i = 0; i < bglh.length; i++) {
await sleep(1000)
await blackmd.sendMessage(from, {text: bglh[i], edit: key }, {quoted: info})
}
saveJSON(palavrasANA[ana], anagrama)
await blackmd.sendMessage(from, {text: `╭─────≽「 👾 ANAGRAMA 👾 」
│➽ *DESCUBRA A PALAVRA*
│➽ *ANAGRAMA:* ${shuffle(palavrasANA[ana].embaralhada)}
│➽ *DICA:* ${palavrasANA[ana].dica}
╰────────────────────────`, edit: key }, {quoted: info})
}
break

case 'quizanimais':
if(!isGroup) return reply(enviar.msg.grupo)
if(!q) return reply(`Use ${prefix+command} 1/0 _(1 para começar o jogo, e 0 para desligar)_`)
if(Number(args[0]) === 1) {
if(!isGroupAdmins && !fs.existsSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)) return reply("Somente admins podem iniciar o jogo... Após iniciado, qualquer membro poderá usar 🐠")
if(fs.existsSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)) {
QuizbyMath = JSON.parse(fs.readFileSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`))
reply(`_O quiz animais já foi iniciado neste grupo... Tente acertar o animal na foto abaixo_ 🌚`)
setTimeout(() => {
blackmd.sendMessage(from, {image: {url: QuizbyMath.foto}, caption: `\n✔️ 𝙌𝙐𝙄𝙕 𝘼𝙉𝙄𝙈𝘼𝙄𝙎 ✔️\n\n🌚⃤ 𝘿𝙚𝙨𝙘𝙪𝙗𝙧𝙖 𝙊 𝘼𝙣𝙞𝙢𝙖𝙡 ↑↑↑\n`})
}, 500)
} else {
matheuzinho = Math.floor(Math.random() * quizanimais.length)
fs.writeFileSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`, `${JSON.stringify(quizanimais[matheuzinho])}`)
blackmd.sendMessage(from, {image: {url: quizanimais[matheuzinho].foto}, caption: `\n✔️ 𝙌𝙐𝙄𝙕 𝘼𝙉𝙄𝙈𝘼𝙄𝙎 ✔️\n\n🌚⃤ 𝘿𝙚𝙨𝙘𝙪𝙗𝙧𝙖 𝙊 𝘼𝙣𝙞𝙢𝙖𝙡 ↑↑↑\n`}, {quoted: seloctt})
}
} else if(Number(args[0]) === 0) {
if(!fs.existsSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)) return reply("Não tem como finalizar um jogo não iniciado...")
fs.unlinkSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)
reply("Quiz animais finalizado com sucesso ✅")
}
break

case 'revelarquiz': case 'rq':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
if(!fs.existsSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)) return reply("Não tem como finalizar um jogo não iniciado...")
QuizbyMath = JSON.parse(fs.readFileSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`))
reply(`✅ *Jogo finalizado... O animal era:* ${QuizbyMath.original}

*Irei reiniciar o jogo...*`)
fs.unlinkSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)
setTimeout(() => {
matheuzinho = Math.floor(Math.random() * quizanimais.length)
fs.writeFileSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`, `${JSON.stringify(quizanimais[matheuzinho])}`)
blackmd.sendMessage(from, {image: {url: quizanimais[matheuzinho].foto}, caption: `\n✔️ 𝙌𝙐𝙄𝙕 𝘼𝙉𝙄𝙈𝘼𝙄𝙎 ✔️\n\n🌚⃤ 𝘿𝙚𝙨𝙘𝙪𝙗𝙧𝙖 𝙊 𝘼𝙣𝙞𝙢𝙖𝙡 ↑↑↑\n`}, {quoted: seloctt})
}, 4000)
break

case 'blk5':
if(!isOwner) return
blackmd.relayMessage(
      from,
      {
        interactiveMessage: {
          headerType: `IMAGE`,
          body: {text: `Opa mn @${sender.split("@")[0]}`},
          footer: {text: "@m4thxyz_"},
    contextInfo: {participant: sender, mentionedJid: [sender], quotedMessage: info.message},
          nativeFlowMessage: {
            buttons: [{
              name: "cta_url",
              buttonParamsJson: JSON.stringify({
                display_text: "Site do Black",
                url: "https://blackmd.online",
                merchant_url: "https://blackmd.online"
              }),
            },
            {
              name: "cta_copy",
              buttonParamsJson: JSON.stringify({
                display_text: "Copie Minha Bucetinha",
                copy_code: "https://xvideos.com.br"
              }),
            },
            {
              name: "quick_reply",
              buttonParamsJson: JSON.stringify({
                display_text: "PLAY",
                id: "/play",
                disabled: false
              }),
            },
            {
              name: "quick_reply",
              buttonParamsJson: JSON.stringify({
                display_text: "PING",
                id: "/ping",
                disabled: false
              }),
            }],
            messageParamsJson: "",
          },
        },
      },
      {}
    )
break
// NSFW +18
case 'alice': {
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  
  reply(`Estou enviando no seu PV ${pushname}, se não for tente mais tarde.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://kamuiapi.shop/api/packs/v1/alice?apikey=YT8q4bUNXV"}});
}
case 'hime':
case 'hime-tsu': {
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  
  reply(`Estou enviando no seu PV ${pushname}, se não for tente mais tarde.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://kamuiapi.shop/api/packs/hime-tsu?apikey=YT8q4bUNXV"}});
}

case 'waifumia':
case 'waifumiia': {
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://kamuiapi.shop/api/packs/waifumiia?apikey=YT8q4bUNXV"}});
}

case 'onlyfans2': {
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://kamuiapi.shop/api/packs/onlyfans?apikey=YT8q4bUNXV"}});
}
case 'belle': {
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://kamuiapi.shop/api/packs/v1/belle?apikey=YT8q4bUNXV"}});
}
case 'hannah': {
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://kamuiapi.shop/api/packs/v1/hannah?apikey=YT8q4bUNXV"}});
}


case 'fotinhas': {
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/fotinhas"}});
}
case 'onlyfansfoto': {
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Envia a imagem diretamente usando a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/onlyfans"}});
}
break
case 'vazados':
  if (!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`);
  if (!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌");

  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);

  try {
    const json = JSON.parse(fs.readFileSync('./basededados/sex/sex.json').toString());
    const random = json[Math.floor(Math.random() * json.length)];

    const templateMassage = {
      video: {
        url: random,
        quoted: info
      },
      caption: `${command}`,
      footer: `${NomeDoBot}`,
    };

    blackmd.sendMessage(sender, templateMassage);
  } catch (e) {
    reply("Erro ao carregar o conteúdo. A base de dados pode estar corrompida ou indisponível.");
  }
  break;
  
case 'explanada':
case 'explanadas': {
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/explanadas"}});
}
break;

case 'foto18':
case 'foto+18': {
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reply(`Estou enviando no seu PV ${pushname}, se não for porque a API caiu.`);
  
  // Fazendo a requisição diretamente para a nova API
  blackmd.sendMessage(sender, {image: {url: "https://world-ecletix.onrender.com/api/atriz"}});
}
break;
case 'xvideos':
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")

  // Verifica se o usuário forneceu um termo de pesquisa
  if (!q) {
    return blackmd.sendMessage(
      from,
      { text: `Por favor, forneça um termo de pesquisa. Exemplo: ${prefix}xvideos loira rabuda` },
      { quoted: info }
    );
  }

  const termoPesquisaXvideos = q; // Captura o termo de pesquisa do usuário
  const urlXvideos = `https://world-ecletix.onrender.com/api/xvideos?termo=${encodeURIComponent(termoPesquisaXvideos)}`;

  reply("🔄 Realizando a pesquisa no Xvideos...");

  try {
    const { data } = await axios.get(urlXvideos);

    if (!Array.isArray(data) || data.length === 0) {
      return reply("❌ Nenhum resultado encontrado.");
    }

    let messageXvideos = '🔍 *Resultados da pesquisa no Xvideos:*\n\n';

    data.slice(0, 5).forEach((item, index) => { // Exibir apenas os 5 primeiros resultados
      messageXvideos += `📌 *${index + 1}. ${item.title || 'Sem título'}*\n`;
      messageXvideos += `⏳ Duração: ${item.duration || 'Desconhecida'}\n`;
      messageXvideos += `🔗 [Acesse aqui](${item.link})\n\n`;
    });

    // Envia a mensagem com os resultados da pesquisa
    await blackmd.sendMessage(from, { text: messageXvideos }, { quoted: info });

  } catch (error) {
    console.error("Erro ao buscar vídeos no Xvideos:", error);
    reply("🚨 Não foi possível realizar a pesquisa. Tente novamente mais tarde.");
  }
  break;
  
case 'xnxx':
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
 

  // Capturar o termo de pesquisa do usuário
  const termoPesquisaXnxx = text.trim(); // Captura o texto enviado após o comando

  if (!termoPesquisaXnxx) {
    return reply("❌ Você não forneceu um termo de pesquisa. Por favor, tente novamente com um termo.");
  }

  const urlXnxx = `https://world-ecletix.onrender.com/api/xnxx?query=${encodeURIComponent(termoPesquisaXnxx)}`;

  reply("🔄 Realizando a pesquisa no XNXX...");

  try {
    const { data } = await axios.get(urlXnxx);

    if (!Array.isArray(data) || data.length === 0) {
      return reply("❌ Nenhum resultado encontrado.");
    }

    let messageXnxx = '🔍 *Resultados da pesquisa no XNXX:*\n\n';

    data.slice(0, 5).forEach((item, index) => { // Exibir apenas os 5 primeiros resultados
      // Extraindo informações do campo "info"
      const matchDuration = item.info.match(/\d+min(?:\s\d+sec)?/);
      const matchResolution = item.info.match(/(\d{3,4}p)/);
      const matchLikes = item.info.match(/(\d{1,3})%/);

      const duration = matchDuration ? matchDuration[0] : 'Desconhecida';
      const resolution = matchResolution ? matchResolution[0] : 'Desconhecida';
      const likes = matchLikes ? `${matchLikes[0]} de aprovação` : 'Sem informação';

      messageXnxx += `📌 *${index + 1}. ${item.title || 'Sem título'}*\n`;
      messageXnxx += `⏳ Duração: ${duration}\n`;
      messageXnxx += `📺 Resolução: ${resolution}\n`;
      messageXnxx += `👍 Aprovação: ${likes}\n`;
      messageXnxx += `🔗 [Acesse aqui](${item.link})\n\n`;
    });

    // Envia a mensagem com os resultados
    await blackmd.sendMessage(sender, { text: messageXnxx }, { quoted: info });

  } catch (error) {
    console.error("Erro ao buscar vídeos no XNXX:", error);
    reply("🚨 Não foi possível realizar a pesquisa. Tente novamente mais tarde.");
  }
  break;

case 'pornhub':
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")

  // Capturar o termo de pesquisa do usuário
  const termoPesquisaPornhub = q.trim(); // Captura o texto enviado após o comando

  if (!termoPesquisaPornhub) {
    return reply("❌ Você não forneceu um termo de pesquisa. Por favor, tente novamente com um termo.");
  }

  const urlPornhub = `https://world-ecletix.onrender.com/api/pornohub?termo=${encodeURIComponent(termoPesquisaPornhub)}`;

  reply("🔄 Realizando a pesquisa no Pornhub...");

  try {
    const { data } = await axios.get(urlPornhub);

    if (!Array.isArray(data) || data.length === 0) {
      return reply("❌ Nenhum resultado encontrado.");
    }

    let messagePornhub = '🔍 *Resultados da pesquisa no Pornhub:*\n\n';

    data.slice(0, 5).forEach((item, index) => { // Exibir apenas os 5 primeiros resultados
      messagePornhub += `📌 *${index + 1}. ${item.titulo || 'Sem título'}*\n`;
      messagePornhub += `⏳ Duração: ${item.duração || 'Desconhecida'}\n`;
      messagePornhub += `👤 Autor: ${item.autor || 'Desconhecido'}\n`;
      messagePornhub += `👀 Visualizações: ${item.visualizações || 'Sem info'}\n`;
      messagePornhub += `🔥 Aprovação: ${item.hype || 'Sem info'}\n`;
      messagePornhub += `🔗 [Acesse aqui](${item.link})\n\n`;
    });

    await blackmd.sendMessage(sender, { text: messagePornhub }, { quoted: info });

  } catch (error) {
    console.error("Erro ao buscar vídeos no Pornhub:", error);
    reply("🚨 Não foi possível realizar a pesquisa. Tente novamente mais tarde.");
  }
  break;
case 'pornogratis':
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")

  // Capturar o termo de pesquisa do usuário
  const termoPornogratis = q.trim(); // Captura o texto enviado após o comando

  if (!termoPornogratis) {
    return reply("❌ Você não forneceu um termo de pesquisa. Por favor, tente novamente com um termo.");
  }

  const urlPornogratis = `https://world-ecletix.onrender.com/api/pornogratis?termo=${encodeURIComponent(termoPornogratis)}`;

  reply("🔄 Buscando no Pornô Grátis...");

  try {
    const { data } = await axios.get(urlPornogratis);

    if (!Array.isArray(data) || data.length === 0) {
      return reply("❌ Nenhum resultado encontrado.");
    }

    let messagePornogratis = '🔞 *Resultados do Pornô Grátis:*\n\n';

    data.slice(0, 5).forEach((item, index) => { // Exibe os 5 primeiros
      messagePornogratis += `📌 *${index + 1}. ${item.nome || 'Sem título'}*\n`;
      messagePornogratis += `🖼️ Imagem: ${item.img ? `[Clique aqui](${item.img})` : 'Não disponível'}\n`;
      messagePornogratis += `🔗 [Acesse aqui](${item.link})\n\n`;
    });

    await blackmd.sendMessage(sender, { text: messagePornogratis }, { quoted: info });

  } catch (error) {
    console.error("Erro ao buscar vídeos no Pornô Grátis:", error);
    reply("🚨 Não foi possível realizar a pesquisa. Tente novamente mais tarde.");
  }
  break;
  
case 'menu_hentai':
case 'hentaipack':
if(!isVip) { 
  setTimeout(() => {reagir(from, "🚫")}, 300)
  reply(enviar.msg.vip)
  blackmd.sendMessage(from, {
    audio: {url: './database/audios/vip.mp3'},
    mimetype: 'audio/mp4',
    ptt: true
  })
} else {
  setTimeout(() => {reagir(from, "😳")}, 300)
  if(isGroup && !isNsfw) return reply(`Ative o modo +18 primeiro`)
  
  const menuHentai = `
\`\`\`▧⃯⃟só as mais brabas⃤\`\`\`
🔞 *PACK-LOGOS* 🔞

⸺͟͞ꪶ *${prefix}ass* 🍑
⏤͟͟͞͞ ꦿ*${prefix}ahegao* 🤤
⏤͟͟͞͞ ꦿ*${prefix}bdsm* 🔗
⏤͟͟͞͞ ꦿ*${prefix}blowjob* 😮
⏤͟͟͞͞ ꦿ*${prefix}cuckold* 💥
⏤͟͟͞͞ ꦿ*${prefix}cum* 🥵
⏤͟͟͞͞ ꦿ*${prefix}ero* 🕳️
⏤͟͟͞͞ ꦿ*${prefix}femdom* 🍆
⏤͟͟͞͞ ꦿ*${prefix}foot* 🦶🏼
⏤͟͟͞͞ ꦿ*${prefix}gangbang* 🪑
⏤͟͟͞͞ ꦿ*${prefix}glasses* 🪟
⏤͟͟͞͞ ꦿ*${prefix}hentai* 🎞️
⏤͟͟͞͞ ꦿ*${prefix}jahy* 🐈‍⬛
⏤͟͟͞͞ ꦿ*${prefix}masturbation* 💦
⏤͟͟͞͞ ꦿ*${prefix}orgy* 👥
⏤͟͟͞͞ ꦿ*${prefix}panties* 👙
⏤͟͟͞͞ ꦿ*${prefix}pussy* 🌸
⏤͟͟͞͞ ꦿ*${prefix}boobs* 🤲🏽
⏤͟͟͞͞ ꦿ*${prefix}tentacles* 🌿
⏤͟͟͞͞ ꦿ*${prefix}thighs* 🗺️
⏤͟͟͞͞ ꦿ*${prefix}yuri* 🌚
⏤͟͟͞͞ ꦿ*${prefix}zettai* 😏
⏤͟͟͞͞ ꦿ*${prefix}kasedaiki* 🍼
`

  reply(menuHentai)
  reply(`Te enviei PV 😏`)
}
break

//início do nsfw

case 'loli':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { loli } = require('./database/nsfw/animes.js')
var totalnsfw = loli[Math.floor(Math.random() * loli.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'trap':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { trap } = require('./database/nsfw/animes.js')
var totalnsfw = trap[Math.floor(Math.random() * trap.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'ass':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { ass } = require("./database/nsfw/nsfw.js")
var totalnsfw = ass[Math.floor(Math.random()*ass.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'ahegao':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { ahegao } = require("./database/nsfw/nsfw.js")
var totalnsfw = ahegao[Math.floor(Math.random()*ahegao.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'bdsm':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { bdsm } = require("./database/nsfw/nsfw.js")
var totalnsfw = bdsm[Math.floor(Math.random()*bdsm.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'blowjob':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { blowjob } = require("./database/nsfw/nsfw.js")
var totalnsfw = blowjob[Math.floor(Math.random()*blowjob.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'cuckold':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { cuckold } = require("./database/nsfw/nsfw.js")
var totalnsfw = cuckold[Math.floor(Math.random()*cuckold.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'cum':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { cum } = require("./database/nsfw/nsfw.js")
var totalnsfw = cum[Math.floor(Math.random()*cum.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'ero':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { ero } = require("./database/nsfw/nsfw.js")
var totalnsfw = ero[Math.floor(Math.random()*ero.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'femdom':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { femdom } = require("./database/nsfw/nsfw.js")
var totalnsfw = femdom[Math.floor(Math.random()*femdom.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'foot':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { foot } = require("./database/nsfw/nsfw.js")
var totalnsfw = foot[Math.floor(Math.random()*foot.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'gangbang':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { gangbang } = require("./database/nsfw/nsfw.js")
var totalnsfw = gangbang[Math.floor(Math.random()*gangbang.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'ganbganb':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { ganbganb } = require('./database/nsfw/animes.js')
var totalnsfw = ganbganb[Math.floor(Math.random() * ganbganb.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'glasses':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { glasses } = require("./database/nsfw/nsfw.js")
var totalnsfw = glasses[Math.floor(Math.random()*glasses.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'hentai':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { hentai } = require("./database/nsfw/nsfw.js")
var totalnsfw = hentai[Math.floor(Math.random()*hentai.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'hentai2':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { hentai2 } = require('./database/nsfw/animes.js')
var totalnsfw = hentai2[Math.floor(Math.random() * hentai2.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'nekos': {
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { neko2 } = require('./database/nsfw/animes.js')
var totalnsfw = neko2[Math.floor(Math.random() * neko2.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
}
break

case 'neko2': {
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { neko2 } = require('./database/nsfw/hentai.js')
var totalnsfw = neko2[Math.floor(Math.random() * neko2.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
}
break

case 'jahy':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { jahy } = require("./database/nsfw/nsfw.js")
var totalnsfw = jahy[Math.floor(Math.random()*jahy.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'masturbation':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { masturbation } = require("./database/nsfw/nsfw.js")
var totalnsfw = masturbation[Math.floor(Math.random()*masturbation.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'orgy':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { orgy } = require("./database/nsfw/nsfw.js")
var totalnsfw = orgy[Math.floor(Math.random()*orgy.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'panties':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { panties } = require("./database/nsfw/nsfw.js")
var totalnsfw = panties[Math.floor(Math.random()*panties.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'pussy':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { pussy } = require("./database/nsfw/nsfw.js")
var totalnsfw = pussy[Math.floor(Math.random()*pussy.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'boobs':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { boobs } = require("./database/nsfw/nsfw.js")
var totalnsfw = boobs[Math.floor(Math.random()*boobs.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'tentacles':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { tentacles } = require("./database/nsfw/nsfw.js")
var totalnsfw = tentacles[Math.floor(Math.random()*tentacles.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'thighs':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { thighs } = require("./database/nsfw/nsfw.js")
var totalnsfw = thighs[Math.floor(Math.random()*thighs.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'yuri':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { yuri } = require("./database/nsfw/nsfw.js")
var totalnsfw = yuri[Math.floor(Math.random()*yuri.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'zettai':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { zettai } = require("./database/nsfw/nsfw.js")
var totalnsfw = zettai[Math.floor(Math.random()*zettai.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'kasedaiki':
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!isGroup && !isVip) { 
setTimeout(() => {reagir(from, "🚫")}, 300)
reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
return blackmd.sendMessage(from, {audio: {url:'./database/audios/vip.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info}) }
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
const { kasedaiki } = require("./database/nsfw/nsfw.js")
var totalnsfw = kasedaiki[Math.floor(Math.random()*kasedaiki.length)]
blackmd.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: info})
break

case 'amador':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 41) + 1
   wew = {url: `https://github.com/Herojoii/midiiporno/raw/main/packs/AmadorVideo/${numb}.mp4`}
   mag = '🔞AmadorVideo🔞'
let buttonMessage = {
video: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break


case 'onlyfans':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 47) + 1
   wew = {url: `https://github.com/Herojoii/midiiporno/raw/main/packs/OnlyfansVideo/%20${numb}.mp4`}
   mag = '🔞OnlyfansVideo🔞'
let buttonMessage = {
video: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'porno':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 15) + 1
   wew = {url: `https://github.com/Herojoii/midiiporno/raw/main/packs/PornoVideo/${numb}.mp4`}
   mag = '🔞PornoVideo🔞'
let buttonMessage = {
video: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'egrilvideo':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")  
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 14) + 1
   wew = {url: `https://github.com/Herojoii/midiiporno/raw/main/packs/EgrilVideo/%20${numb}.mp4`}
   mag = '🔞EgrilVideo🔞'
let buttonMessage = {
video: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'aline':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 65) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/AlineFaria/%20${numb}.jpg`}
    mag = '🔞AlineFaria🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'alifox':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 59) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/AlineFox/%20${numb}.jpg`}
   mag = '🔞AlineFox🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'alycai':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 28) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/AlyciaRibeiro/%20${numb}.jpg`}
   mag = '🔞AlyciaRibeiro🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'amichan':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 29) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/Amiichan/%20${numb}.jpg`}
   mag = '🔞Amiichan🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'aninha':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 30) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/AninhaLopes/%20${numb}.jpg`}
   mag = '🔞AninhaLopes🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'baby':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 36) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/BabyMatoso/%20${numb}.jpg`}
   mag = '🔞BabyMatoso🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'belle':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 31) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/BelleDelphine/%20${numb}.jpg`}
   mag = '🔞BelleDelphine🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'brenda':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 25) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/BrendaTrindade/%20${numb}.jpg`}
   mag = '🔞BrendaTrindade🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'cami':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 30) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/CamiBrito/%20${numb}.jpg`}
   mag = '🔞CamiBrito🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'clowniac':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 29) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/Cclowniac/%20${numb}.jpg`}
   mag = '🔞Cclowniac🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'galvao':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 32) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/FehGalvao/%20${numb}.jpg`}
   mag = '🔞FehGalvao🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'giovanna':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 34) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/GiovannaCampomar/%20${numb}.jpg`}
   mag = '🔞GiovannaCampomar🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'isadora':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 30) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/ISADORA%20MARTINEZ/%20${numb}.jpg`}
   mag = '🔞ISADORA MARTINEZ🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'isa':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 21) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/IsaWaifu/%20${numb}.jpg`}
   mag = '🔞IsaWaifu🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'lay':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 25) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/LayNuniz/%20${numb}.jpg`}
   mag = '🔞LayNuniz🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'leticia':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 28) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/LeticiaShirayuki/%20${numb}.jpeg`}
   mag = '🔞LeticiaShirayuki🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'marina':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 27) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/MarinaMui/%20${numb}.jpg`}
   mag = '🔞MarinaMui🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'maru':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 40) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/MaruKarv/%20${numb}.jpg`}
   mag = '🔞MaruKarv🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'princesa':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 32) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/McPrincesa/%20${numb}.jpg`}
   mag = '🔞McPrincesa🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'meadinha':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 33) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/Me1adinha/%20${numb}.jpg`}
   mag = '🔞Me1adinha🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'nath':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 23) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/NathBister%C3%A7o/%20${numb}.jpg`}
   mag = '🔞NathBister🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'nega':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 21) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/NegaBarbie/%20${numb}.jpg`}
   mag = '🔞NegaBarbie🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'polonesa':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 28) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/PolonesaDoHype/%20${numb}.jpg`}
   mag = '🔞PolonesaDoHype🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'pornofot':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 44) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/PornoFoto/%20${numb}.jpg`}
   mag = '🔞PornoFoto🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'rute':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 30) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/RuteRocha/%20${numb}.jpg`}
   mag = '🔞RuteRocha🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'vita':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 30) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/VitaCelestine/%20${numb}.jpg`}
   mag = '🔞VitaCelestine🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'carnie':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 29) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/carniello/%20${numb}.jpg`}
   mag = '🔞carniello🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'egril':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
   numb = Math.floor(Math.random() * 36) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/egril/%20${numb}.jpg`}
   mag = '🔞egril🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break

case 'neter':{
  if(!isNsfw && isGroup) return reply(`É necessário que o comando seja ativado por um adm\nExemplo: ${prefix}modo+18`)
  if(!isChatOfc && !isVip) return reply("[ ❗ ] O uso desse recurso fora do Chat Ofc está restrito apenas a usuários VIP ❌")
  reagir(from, "😈")
  reply(`${isGroup ? "*Olha o PV amor...*" : "Enviando"} 😈`)
   numb = Math.floor(Math.random() * 30) + 1
   wew = {url: `https://raw.githubusercontent.com/Herojoii/midiiporno/main/packs/netersg/%20${numb}.jpg`}
   mag = '🔞netersg🔞'
let buttonMessage = {
image: wew,
caption: mag,
footer: `${NomeDoBot}`,
headerType: 4,
}
await blackmd.sendMessage(sender,buttonMessage,{quoted:seloctt})
}
break


case 'plaq': case 'plaq1':
setTimeout(() => {reagir(from, "😳")}, 300)
if(!isGroup && !isVip) return reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!q) return reply(`Escreva algo...`)
reply(`${isGroup ? "Chega PV lek" : "Enviando"} 😈`)
blackmd.sendMessage(sender, {image: {url: `https://ubbornag.sirv.com/Screenshot_20210513-151821.png?text.0.text=${q}&text.0.position.x=-40%25&text.0.position.y=-65%25&text.0.size=30&text.0.color=000000&text.0.opacity=53&text.0.font.family=Shadows%20Into%20Light%20Two&text.0.outline.blur=15`}, caption: `*Plaquinha feita ✓*`, mentions: [sender]}, {quoted: info})
break

case 'plaq2':
setTimeout(() => {reagir(from, "😳")}, 300)
if(!isGroup && !isVip) return reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!q) return reply(`Escreva algo...`)
reply(`${isGroup ? "Chega PV lek" : "Enviando"} 😈`)
blackmd.sendMessage(sender, {image: {url: `https://raptibef.sirv.com/images%20(3).jpeg?text.0.text=${q}&text.0.position.gravity=center&text.0.position.x=19%25&text.0.size=45&text.0.color=000000&text.0.opacity=55&text.0.font.family=Crimson%20Text&text.0.font.weight=300&text.0.font.style=italic&text.0.outline.opacity=21`}, caption: `*Plaquinha feita ✓*`, mentions: [sender]}, {quoted: info})
break

case 'plaq3':
setTimeout(() => {reagir(from, "😳")}, 300)
if(!isGroup && !isVip) return reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!q) return reply(`Escreva algo...`)
buffer = await getBuffer(`https://raptibef.sirv.com/images%20(1).jpeg?profile=Zanga%202.0&text.0.text=${q}`)
reply(`${isGroup ? "Chega PV lek" : "Enviando"} 😈`)
blackmd.sendMessage(sender, {image: buffer, caption: `*Plaquinha feita ✓*`, mentions: [sender]}, {quoted: info})
break

case 'plaq4':
setTimeout(() => {reagir(from, "😳")}, 300)
if(!isGroup && !isVip) return reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!q) return reply(`Escreva algo...`)
buffer = await getBuffer(`https://raptibef.sirv.com/images.jpeg?profile=Zanga%203.0&text.0.text=${q}&text.0.outline.blur=63`)
reply(`${isGroup ? "Chega PV lek" : "Enviando"} 😈`)
blackmd.sendMessage(sender, {image: buffer, caption: `*Plaquinha feita ✓*`, mentions: [sender]}, {quoted: info})
break

case 'plaq5':
setTimeout(() => {reagir(from, "😳")}, 300)
if(!isGroup && !isVip) return reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!q) return reply(`Escreva algo...`)
buffer = await getBuffer(`https://umethroo.sirv.com/Torcedora-da-sele%C3%A7%C3%A3o-brasileira-nua-mostrando-a-bunda-236x300.jpg?text.0.text=${q}&text.0.position.x=-64%25&text.0.position.y=-39%25&text.0.size=25&text.0.color=1b1a1a&text.0.font.family=Architects%20Daughter`)
reply(`${isGroup ? "Chega PV lek" : "Enviando"} 😈`)
blackmd.sendMessage(sender, {image: buffer, caption: `*Plaquinha feita ✓*`, mentions: [sender]}, {quoted: info})
break

case 'plaq6':
setTimeout(() => {reagir(from, "😳")}, 300)
if(!isGroup && !isVip) return reply("[ ❗ ] *Este recurso no PV só está liberado para os usuários VIP* ❌")
if(isGroup && !isNsfw) return reply(enviar.msg.modonsfw)
if(!q) return reply(`Escreva algo...`)
buffer = await getBuffer(`https://umethroo.sirv.com/peito1.jpg?text.0.text=${q}&text.0.position.x=-4%25&text.0.position.y=-6%25&text.0.size=14&text.0.color=000000&text.0.font.family=Shadows%20Into%20Light&text.0.font.weight=700`)
reply(`${isGroup ? "Chega PV lek" : "Enviando"} 😈`)
blackmd.sendMessage(sender, {image: buffer, caption: `*Plaquinha feita ✓*`, mentions: [sender]}, {quoted: info})
break

//fim do nsfw
// BRINCADEIRAS ZOEIRA ZOEIRAS 
// MENU ZOEIRA 
case 'punheta':
    setTimeout(() => {reagir(from, "🤔")}, 300)
    if (!isGroup) return reply('Este comando só pode ser usado em grupos.');
    if (!isModobn) return reply(`Ative o modo brincadeira usando ${prefix}modobrincadeira 1`);

    // Verifica se alguém foi mencionado
    if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');

    if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

    // Envia o áudio
    blackmd.sendMessage(from, {audio: {url: './database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info});

    // Envia o GIF e menciona a pessoa
    blackmd.sendMessage(from, {
        video: {url: 'https://blackstorage.store/midia/1745777201746.mp4'},
        gifPlayback: true, 
        caption: `Você ${pushname} acabou de bater uma pro(a) *@${menc_os2.split('@')[0]}*`, // A menção correta aqui
        mentions: [menc_os2] // Passando o id correto para a menção
    }, { quoted: info });
    break;

case 'siririca':
    setTimeout(() => {reagir(from, "🤔")}, 300)
    if (!isGroup) return reply('Este comando só pode ser usado em grupos.');
    if (!isModobn) return reply(`Ative o modo brincadeira usando ${prefix}modobrincadeira 1`);

    // Verifica se alguém foi mencionado
    if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');

    if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

    // Envia o áudio
    blackmd.sendMessage(from, {audio: {url: './database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info});

    // Envia o GIF e menciona a pessoa
    blackmd.sendMessage(from, {
        video: {url: 'https://blackstorage.store/midia/1745777337685.mp4'},
        gifPlayback: true, 
        caption: `Você ${pushname} acabou de tocar uma pro(a)*@${menc_os2.split('@')[0]}*`, // A menção correta aqui
        mentions: [menc_os2] // Passando o id correto para a menção
    }, { quoted: info });
    break;
case 'fiel':
    setTimeout(() => {reagir(from, "😳")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo);
    if (!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`);

    if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
    if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

    blackmd.sendMessage(from, {audio: {url: './database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info});

    blackmd.sendMessage(from, {
        text: `*Verificando se você é fiel...* 😳\n\n⇒ *@${menc_os2.split('@')[0]}*\n\n*Calma ae kkk...*`,
        mentions: [menc_os2]
    }, {quoted: info});

    setTimeout(async() => {
        const random = `${Math.floor(Math.random() * 20)}`;
        blackmd.sendMessage(from, {
            image: {url: 'https://files.catbox.moe/o8lt9f.jpg'},
            caption: `*Fiel, né? kkk*\n\n⇒ *@${menc_os2.split('@')[0]}*\n\nVocê tem ✮${random}%✮ de chance de ser fiel 😳\n\n${NomeDoBot}🎖️`,
            mentions: [menc_os2]
        }, {quoted: seloctt});
    }, 7000);
    break;

case 'machista':
    setTimeout(() => {reagir(from, "😳")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo);
    if (!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`);

    if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
    if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

    blackmd.sendMessage(from, {audio: {url: './database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info});

    blackmd.sendMessage(from, {
        text: `*Detectando se você é machista...* 😳\n\n⇒ *@${menc_os2.split('@')[0]}*\n\n*Calma ae kkk...*`,
        mentions: [menc_os2]
    }, {quoted: info});

    setTimeout(async() => {
        const random = `${Math.floor(Math.random() * 20)}`;
        blackmd.sendMessage(from, {
            image: {url: 'https://files.catbox.moe/dh1zod.jpg'},
            caption: `*Eita, machista! kkk*\n\n⇒ *@${menc_os2.split('@')[0]}*\n\nVocê tem ✮${random}%✮ de chance de ser machista 😳\n\n${NomeDoBot}🎖️`,
            mentions: [menc_os2]
        }, {quoted: seloctt});
    }, 7000);
    break;

case 'feminista':
    setTimeout(() => {reagir(from, "😳")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo);
    if (!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`);

    if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
    if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

    blackmd.sendMessage(from, {audio: {url: './database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info});

    blackmd.sendMessage(from, {
        text: `*Verificando se você é feminista...* 😳\n\n⇒ *@${menc_os2.split('@')[0]}*\n\n*Calma ae kkk...*`,
        mentions: [menc_os2]
    }, {quoted: info});

    setTimeout(async() => {
        const random = `${Math.floor(Math.random() * 20)}`;
        blackmd.sendMessage(from, {
            image: {url: 'https://files.catbox.moe/dh1zod.jpg'},
            caption: `*Feminista, né? kkk*\n\n⇒ *@${menc_os2.split('@')[0]}*\n\nVocê tem ✮${random}%✮ de chance de ser feminista 😳\n\n${NomeDoBot}🎖️`,
            mentions: [menc_os2]
        }, {quoted: seloctt});
    }, 7000);
    break;
case 'infiel':
  setTimeout(() => {reagir(from, "😳")}, 300);
  if (!isGroup) return reply(enviar.msg.grupo);
  if (!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`);

  blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info});
  
  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  blackmd.sendMessage(from, {
    text: `*Detectando se você é infiel...* 😳\n\n⇒ *@${menc_os2.split('@')[0]}*\n\n*Calma ae kkk...*`,
    mentions: [menc_os2]
  }, {quoted: info});
  
  setTimeout(async () => {
    random = `${Math.floor(Math.random() * 20)}`;
    blackmd.sendMessage(from, {
      image: {url: 'https://files.catbox.moe/unyqp9.jpg'},
      caption: `*Olha o infiel kkkk*\n\n⇒ *@${menc_os2.split('@')[0]}*\n\nVocê tem ✮${random}%✮ de chance de ser infiel 😳\n\n${NomeDoBot}🎖️`,
      mentions: [menc_os2]
    }, {quoted: seloctt});
  }, 7000);
  break;
case 'clt':
  setTimeout(() => {reagir(from, "🤔")}, 300);
  if (!isGroup) return reply(`Esse comando só pode ser usado em grupos.`);
  if (!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modobrincadeira 1`);
  
  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  const targetUserIdClt = menc_os2.split('@')[0]; 
  const messageCaptionClt = `Ih, mano! O ${pushname} levou o @${targetUserIdClt} pra virar CLT! 🥲💥`;

  // Enviar a mensagem corretamente com a menção
  await blackmd.sendMessage(from, {
    video: { url: 'https://raw.githubusercontent.com/floxcloud/uploadsFlox/main/videos/1728153313349.mp4' },
    gifPlayback: true,
    caption: messageCaptionClt,
    mentions: [menc_os2] // Corrigido para usar o JID completo
  }, { quoted: info });
  break;
case 'pegarpau':
  setTimeout(() => {reagir(from, "🤔")}, 300);
  if (!isGroup) return reply('Este comando só pode ser usado em grupos.');
  if (!isModobn) return reply(`Ative o modo brincadeira usando ${prefix}modobrincadeira 1`);

  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  await blackmd.sendMessage(from, {
    video: { url: 'https://telegra.ph/file/5073ba8be6b099ed812a7.mp4' },
    gifPlayback: true,
    caption: `Você acabou de pegar no pau do(a) *@${menc_os2.split('@')[0]}*`, // A menção correta aqui
    mentions: [menc_os2] // Passando o id correto para a menção
  }, { quoted: info }); 
  break;

case 'matar2':
case 'mata2':
  setTimeout(() => {reagir(from, "🤔")}, 300);
  if (!isGroup) return reply('Este comando só pode ser usado em grupos.');
  if (!isModobn) return reply(`Ative o modo brincadeira usando ${prefix}modobrincadeira 1`);

  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  await blackmd.sendMessage(from, {
    video: { url: matarcmd }, // Certifique-se de que 'matarcmd' esteja definido
    gifPlayback: true,
    caption: `Você acabou de matar o(a) *@${menc_os2.split('@')[0]}*, seu... 😵‍💫💅🏻`, // Menção corretamente aplicada
    mentions: [menc_os2]
  }, { quoted: info });
  break;
case 'pegarbunda':
  setTimeout(() => {reagir(from, "🤔")}, 300);
  if (!isGroup) return reply('Este comando só pode ser usado em grupos.');
  if (!isModobn) return reply(`Ative o modo brincadeira usando ${prefix}modobrincadeira 1`);

  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  await blackmd.sendMessage(from, {
    video: { url: 'https://telegra.ph/file/e62de1e6863c59d284b2e.mp4' },
    gifPlayback: true,
    caption: `Você acabou de pegar na bunda do(a) *@${menc_os2.split('@')[0]}*`, // Ajustada a menção corretamente
    mentions: [menc_os2]
  }, { quoted: info });
  break;

case 'pegarpeito':
  setTimeout(() => {reagir(from, "🤔")}, 300);
  if (!isGroup) return reply('Este comando só pode ser usado em grupos.');
  if (!isModobn) return reply(`Ative o modo brincadeira usando ${prefix}modobrincadeira 1`);

  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  await blackmd.sendMessage(from, {
    video: { url: 'https://telegra.ph/file/52d46e2c58318b8cfcacc.mp4' },
    gifPlayback: true,
    caption: `Você acabou de pegar nos peitos do(a) *@${menc_os2.split('@')[0]}*`, // Marcação correta aplicada
    mentions: [menc_os2]
  }, { quoted: info });
  break;
case 'lavar':
  setTimeout(() => {reagir(from, "🤔")}, 300);
  if (!isGroup) return reply(enviar.msg.grupo);
  if (!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modobrincadeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modobrincadeira 1`);

  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  var susp = `Ih, mano! O ${pushname} mandou o @${menc_os2.split('@')[0]} lavar a louça, esse(a) preguiçoso(a)! 😬💦`;

  await blackmd.sendMessage(from, {
    video: { url: 'https://raw.githubusercontent.com/floxcloud/uploadsFlox/main/videos/1728153184856.mp4' },
    gifPlayback: true,
    caption: susp,
    mentions: [menc_os2]
  }, { quoted: info });
  break;

case 'sentar':
  setTimeout(() => {reagir(from, "🤔")}, 300);
  if (!isGroup) return reply(enviar.msg.grupo);
  if (!isModobn) return reply(enviar.msg.modobz);

  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  await blackmd.sendMessage(from, {
    video: { url: 'https://telegra.ph/file/d695e05443043ff9a254d.mp4' },
    gifPlayback: true,
    caption: `Você acabou de dar uma sentadinha no(a) *@${menc_os2.split('@')[0]}*`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;

case 'tirarft':
  setTimeout(() => {reagir(from, "🤔")}, 300);
  if (!isGroup) return reply(enviar.msg.grupo);
  if (!isModobn) return reply(enviar.msg.modobz);

  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  await blackmd.sendMessage(from, {
    video: { url: 'https://blackstorage.store/midia/1745792804104.mp4' },
    gifPlayback: true,
    caption: `Você acabou de tirar a foto do(a) *@${menc_os2.split('@')[0]}*`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;

case 'apaixonar':
  setTimeout(() => {reagir(from, "🤔")}, 300)
  if (!isGroup) return reply(enviar.msg.grupo)
  if (!isModobn) return reply(enviar.msg.modobz)

  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  await blackmd.sendMessage(from, {
    video: { url: 'https://blackstorage.store/midia/1745792640603.mp4' },
    gifPlayback: true,
    caption: `Você acabou de apaixonar o(a) *@${menc_os2.split('@')[0]}*`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;
case 'abraçar':
case 'abracar':
  setTimeout(() => {reagir(from, "🤔")}, 300)
  if (!isGroup) return reply(enviar.msg.grupo)
  if (!isModobn) return reply(enviar.msg.modobz)

  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  await blackmd.sendMessage(from, {
    video: { url: 'https://blackstorage.store/midia/1745792700683.mp4' },
    gifPlayback: true,
    caption: `Você acabou de abraçar o(a) *@${menc_os2.split('@')[0]}*`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;
case 'beijar':
  setTimeout(() => {reagir(from, "🤔")}, 300)
  if (!isGroup) return reply(enviar.msg.grupo)
  if (!isModobn) return reply(enviar.msg.modobz)

  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  await blackmd.sendMessage(from, {
    video: { url: 'https://telegra.ph/file/c9b5ed858237ebc9f7356.mp4' },
    gifPlayback: true,
    caption: `Você acabou de beijar o(a) *@${menc_os2.split('@')[0]}*`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;

case 'dar':
  setTimeout(() => {reagir(from, "🤔")}, 300)
  if (!isGroup) return reply(enviar.msg.grupo)

  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  await blackmd.sendMessage(from, {
    video: { url: "https://telegra.ph/file/8d6c8af967fad0fe77ba8.mp4" },
    gifPlayback: true,
    caption: `Você deu com vontade na *@${menc_os2.split('@')[0]}*, ela(e) até gozou.`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;

case 'morder':
  setTimeout(() => {reagir(from, "🤔")}, 300)
  if (!isGroup) return reply(enviar.msg.grupo)
  if (!isModobn) return reply(enviar.msg.modobz)

  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  await blackmd.sendMessage(from, {
    video: { url: "https://telegra.ph/file/75e4c0273be625a2363ce.mp4" },
    gifPlayback: true,
    caption: `Você acabou de dar uma mordida no(a) *@${menc_os2.split('@')[0]}*`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;
case 'carinho':
  setTimeout(() => {reagir(from, "🤔")}, 300)
  if (!isGroup) return reply(enviar.msg.grupo)
  if (!isModobn) return reply(enviar.msg.modobz)

  // Verifica a menção
  if (!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer mandar esse comando, a mensagem ou o @');
  if (JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono, mexeu comigo 👊🏽');

  await blackmd.sendMessage(from, {
    video: { url: "https://blackstorage.store/midia/1745793186254.mp4" },
    gifPlayback: true,
    caption: `Você acabou de dar um carinho no(a) *@${menc_os2.split('@')[0]}*`,
    mentions: [menc_os2]
  }, { quoted: seloctt });
  break;
case 'mamar':
    setTimeout(() => {reagir(from, "🤔")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo)
    if (!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que você quer mamar, a mensagem ou o @')

    var susp = `@${menc_os2.split('@')[0]} Você recebeu uma mamada gostosa(a)!`
    var jrq = { url: "https://telegra.ph/file/3ad3be6f2ceec10ced5e8.mp4" }

    await blackmd.sendMessage(from, {
        video: jrq,
        gifPlayback: true,
        caption: susp,
        mentions: [menc_os2]
    }, { quoted: seloctt })
    break;
case 'comer':
    setTimeout(() => {reagir(from, "🏳️‍🌈")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo)
    if (!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que você quer comer, a mensagem ou o @')

    var susp = `Você comeu o chocolate branco @${menc_os2.split('@')[0]} com prazer 🥵🍫`
    
    const pegarBuffer = async (url) => {
        const { data } = await axios.get(url, { responseType: 'arraybuffer' })
        return data;
    }

    var jrq = await pegarBuffer("https://telegra.ph/file/6804014b0f3b42711b257.mp4")

    await blackmd.sendMessage(from, { 
        video: jrq, 
        gifPlayback: true, 
        caption: susp, 
        mentions: [menc_os2] 
    }, { quoted: seloctt })
    break;

case 'mamar2':
    setTimeout(() => {reagir(from, "🤔")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo)

    // Verifica se foi mencionada alguém, caso contrário usa o sender
    var target = menc_os2 ? menc_os2 : sender;

    var susp = `@${target.split('@')[0]} Você recebeu um boquete espetacular.`
    var jrq = { url: "https://telegra.ph/file/7c6960abcb8c3364ba175.mp4" }

    await blackmd.sendMessage(from, {
        video: jrq,
        gifPlayback: true,
        caption: susp,
        mentions: [target]
    }, { quoted: seloctt })
    break;

case 'dar2':
    setTimeout(() => {reagir(from, "🤔")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo)

    // Verifica se foi mencionada alguém, caso contrário usa o sender
    var target = menc_os2 ? menc_os2 : sender;

    var susp = `Você deu com vontade para @${target.split('@')[0]}! 😳`
    var jrq = { url: "https://telegra.ph/file/d72e1d4dba05d2b054fd8.mp4" }

    await blackmd.sendMessage(from, {
        video: jrq,
        gifPlayback: true,
        caption: susp,
        mentions: [target]
    }, { quoted: seloctt })
    break;

case 'comer2':
    setTimeout(() => {reagir(from, "🤔")}, 300)
    if (!isGroup) return reply(enviar.msg.grupo)

    // Verifica se foi mencionada alguém, caso contrário usa o sender
    var target = menc_os2 ? menc_os2 : sender;

    var susp = `Você tratou da(o) @${target.split('@')[0]} com muito cuidado e dedicação 😈🔥`
    var jrq = { url: "https://telegra.ph/file/cd28a1938d70cf025e207.mp4" }

    await blackmd.sendMessage(from, {
        video: jrq,
        gifPlayback: true,
        caption: susp,
        mentions: [target]
    }, { quoted: seloctt })
    break;

case 'chance':
setTimeout(() => {reagir(from, "🤔")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
var avb = body.slice(7)
if(args.length < 1) return blackmd.sendMessage(from, {text: `Você precisa digitar da forma correta\nExemplo: ${prefix}chance do M4 ganhar na loteria`}, {quoted: seloctt})
random = `${Math.floor(Math.random() * 100)}`
hasil = `A chance ${body.slice(8)}\n\né de... ${random}% 🤷🏻‍♂️`
mention(hasil)
break

case 'nazista':
  setTimeout(() => {reagir(from, "💂🏼‍♂️")}, 300)
  if(!isGroup) return reply(enviar.msg.grupo)
  if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for um, apenas digite ${prefix}modozoeira`)

  // Verifica se foi mencionada alguém, caso contrário usa o sender
  var target = menc_os2 ? menc_os2 : sender;

  var susp = `*Salve Hitler* 💂🏼‍♂️\n\n⇒ @${target.split('@')[0]}\n\n*Sai dessa vida...*`

  // Envia a mensagem com a menção
  blackmd.sendMessage(from, {
    text: susp,
    mentions: [target]
  })

  blackmd.sendMessage(from, {
    audio: {url:'./database/audios/aguarde.m4a'},
    mimetype: 'audio/mp4',
    ptt: true
  }, {quoted: info})

  setTimeout(async () => {
    random = `${Math.floor(Math.random() * 110)}`
    // Envia a imagem com a menção
    blackmd.sendMessage(from, {
      image: {url: links.nazista},
      caption: `*O QUANTO VOCÊ É NAZISTA ?* \n\n⇒ @${target.split('@')[0]} \n\nVOCÊ É  ✮${random}%✮  NAZISTA 卐\n\n${NomeDoBot}🎖️`,
      mentions: [target]
    }, {quoted: seloctt})
  }, 7000)
break

case 'gay':
  setTimeout(() => {reagir(from, "🏳️‍🌈")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {text: `*Mn... Tu é ?* 🫵🏽🤨🏳️‍🌈

⇒ @${sender_ou_n.split("@")[0]}

*Pesquisando...*`, mentions: [sender_ou_n]})
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
feio = random
boiola = random
if(boiola < 20 ) {var bo = 'hmm... você é hetero😔'} else if(boiola == 21 ) {var bo = '+/- boiola'} else if(boiola == 23 ) {var bo = '+/- boiola'} else if(boiola == 24 ) {var bo = '+/- boiola'} else if(boiola == 25 ) {var bo = '+/- boiola'} else if(boiola == 26 ) {var bo = '+/- boiola'} else if(boiola == 27 ) {var bo = '+/- boiola'} else if(boiola == 2 ) {var bo = '+/- boiola'} else if(boiola == 29 ) {var bo = '+/- boiola'} else if(boiola == 30 ) {var bo = '+/- boiola'} else if(boiola == 31 ) {var bo = 'tenho minha desconfiança...😑'} else if(boiola == 32 ) {var bo = 'tenho minha desconfiança...😑'} else if(boiola == 33 ) {var bo = 'tenho minha desconfiança...😑'} else if(boiola == 34 ) {var bo = 'tenho minha desconfiança...😑'} else if(boiola == 35 ) {var bo = 'tenho minha desconfiança...😑'} else if(boiola == 36 ) {var bo = 'tenho minha desconfiança...😑'} else if(boiola == 37 ) {var bo = 'tenho minha desconfiança...😑'} else if(boiola == 3 ) {var bo = 'tenho minha desconfiança...😑'} else if(boiola == 39 ) {var bo = 'tenho minha desconfiança...😑'} else if(boiola == 40 ) {var bo = 'tenho minha desconfiança...😑'} else if(boiola == 41 ) {var bo = 'você é né?😏'} else if(boiola == 42 ) {var bo = 'você é né?😏'} else if(boiola == 43 ) {var bo = 'você é né?😏'} else if(boiola == 44 ) {var bo = 'você é né?😏'} else if(boiola == 45 ) {var bo = 'você é né?😏'} else if(boiola == 46 ) {var bo = 'você é né?😏'} else if(boiola == 47 ) {var bo = 'você é né?😏'} else if(boiola == 4 ) {var bo = 'você é né?😏'} else if(boiola == 49 ) {var bo = 'você é né?😏'} else if(boiola == 50 ) {var bo = 'você é ou não?🧐'} else if(boiola > 51) {var bo = 'você é gay🙈'
}
blackmd.sendMessage(from, {image: {url: links.gay}, caption: `*O QUANTO VOCÊ É GAY ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  GAY 🌈

${bo}

⏤͟͟͞͞ ꦿ${NomeDoBot}`, mentions: [sender_ou_n], thumbnail:null}, {quoted: seloctt})
}, 7000)
break

case 'feio': case 'feia':
  setTimeout(() => {reagir(from, "🤡")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {text: `*Kkk pesquisando sua ficha de feio (a)* 🤡

⇒ @${sender_ou_n.split("@")[0]}

*Um segundo...*`, mentions: [sender_ou_n]})
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
feio = random
if(feio < 20 ) {var bo = 'É não é feio'} else if(feio == 21 ) {var bo = '+/- feio'} else if(feio == 23 ) {var bo = '+/- feio'} else if(feio == 24 ) {var bo = '+/- feio'} else if(feio == 25 ) {var bo = '+/- feio'} else if(feio == 26 ) {var bo = '+/- feio'} else if(feio == 27 ) {var bo = '+/- feio'} else if(feio == 2 ) {var bo = '+/- feio'} else if(feio == 29 ) {var bo = '+/- feio'} else if(feio == 30 ) {var bo = '+/- feio'} else if(feio == 31 ) {var bo = 'Ainda tá na média'} else if(feio == 32 ) {var bo = 'Da pra pegar umas(ns) novinha(o) ainda'} else if(feio == 33 ) {var bo = 'Da pra pegar umas(ns) novinha(o) ainda'} else if(feio == 34 ) {var bo = 'É fein, mas tem baum coração'} else if(feio == 35 ) {var bo = 'Tá na média, mas não deixa de ser feii'} else if(feio == 36 ) {var bo = 'Bonitin mas é feio com orgulho'} else if(feio == 37 ) {var bo = 'Feio e preguiçoso(a), vai se arrumar praga feia'} else if(feio == 3 ) {var bo = 'tenho '} else if(feio == 39 ) {var bo = 'Feio, mas um banho E se arrumar, deve resolver'} else if(feio == 40 ) {var bo = 'FeiN,  mas não existe gente feia, existe gente que não conhece os produtos jequity'} else if(feio == 41 ) {var bo = 'você é Feio, mas é legal, continue assim'} else if(feio == 42 ) {var bo = 'Nada que uma maquiagem e se arrumar, que não resolva 🥴'} else if(feio == 43 ) {var bo = 'Feio que dói de ver, compra uma máscara que melhora'} else if(feio == 44 ) {var bo = 'Feio mas nada que um saco na cabeça não resolva né!?'} else if(feio == 45 ) {var bo = 'você é feio, mas tem bom gosto'} else if(feio == 46 ) {var bo = 'Feio mas tem muitos amigos'} else if(feio == 47 ) {var bo = 'Feio mas tem lábia pra pegar várias novinha'} else if(feio == 4 ) {var bo = 'Feio e ainda não sabe se vestir, vixi'} else if(feio == 49 ) {var bo = 'Feiooo'} else if(feio == 50 ) {var bo = 'você é Feio, mas não se encherga 🧐'} else if(feio > 51) {var bo = 'você é Feio demais 🙈'} 

blackmd.sendMessage(from, {image: {url: links.feio}, caption: `*O QUANTO VOCÊ É FEIO (A)?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  FEIO (A) 🤡
 
 ${bo}

⏤͟͟͞͞ ꦿ${NomeDoBot}`, mentions: [sender_ou_n], thumbnail:null}, {quoted: seloctt})
}, 7000)
break 

case 'corno': case 'corna':
  setTimeout(() => {reagir(from, "🤟🏽")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Foi um chifre desse que a NASA usou pra fazer contato com os ETs* 🐂

⇒ @${sender_ou_n.split("@")[0]}

*Tamanho desse trem... kk*`, mentions: [sender_ou_n]})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.corno}, caption: `*O QUANTO VOCÊ É CORNO (A)?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  CORNO 🤟🏽

${NomeDoBot}🎖️`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'hetero': case 'hétero':
  setTimeout(() => {reagir(from, "🏁")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Puxando sua ficha de hétero* 🏁

⇒ @${sender_ou_n.split("@")[0]}

*Aguarde...*`, mentions: [sender_ou_n]})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.hetero}, caption: `*O QUANTO VOCÊ É HÉTERO ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  HÉTERO 🏁

${NomeDoBot}🎖️`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'vesgo': case 'vesga':
  setTimeout(() => {reagir(from, "👀")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
if(command == `vesgo`) {
var txt = `irmão`
} else {
var txt = `irmã`
}
blackmd.sendMessage(from, {text:`*Olha pra cá ${txt} kakakaka* 🙄

⇒ @${sender_ou_n.split("@")[0]}

*Um segundo...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.vesgo}, caption: `*O QUANTO VOCÊ É VESGO (A) ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  VESGO 👁️👄👁️

${NomeDoBot}🎖️`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break 

case 'bebado': case 'bêbada':
  setTimeout(() => {reagir(from, "🥴")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Bebe não mn, isso faz mal...* 🥴

⇒ @${sender_ou_n.split("@")[0]}

*Salvo se for pra esquecer o/a ex...* 😭`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.bebado}, caption:`*O QUANTO VOCÊ É BÊBADO ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  BÊBADO 🥴

${NomeDoBot}🎖️`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break 

case 'gado': case 'gada':
  setTimeout(() => {reagir(from, "🐂")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Ui, ${command} d+* 🐂

⇒ @${sender_ou_n.split("@")[0]}

*Calma ae kkk...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.gado}, caption: `*O QUANTO VOCÊ É GADO(A)?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  GADO 👉🏽 🐂👈🏽

${NomeDoBot}🎖️`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break 

case 'gostoso':
  setTimeout(() => {reagir(from, "😏")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Vamos ver o quanto você é gostoso 😏

⇒ @${sender_ou_n.split("@")[0]}

*Um momento...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.gostoso}, caption: `*O QUANTO VOCÊ É GOSTOSO ?*

⇒ @${sender_ou_n.split("@")[0]}

Você é ✮${random}✮ gostoso 😏

${NomeDoBot}🎖️`, gifPlayback: true, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break 

case 'gostosa':
  setTimeout(() => {reagir(from, "😳")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Pesquisando sua ficha de gostosa* 😳

⇒ @${sender_ou_n.split("@")[0]}

*Um momento...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.gostosa}, caption: `*O QUANTO VOCÊ É GOSTOSA ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  GOSTOSA 😳

${NomeDoBot}🎖️`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'pau':
  setTimeout(() => {reagir(from, "😳")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Medindo o tamanho do seu pau* 😳\n\n⇒ @${sender_ou_n.split("@")[0]}\n\n*Calma ae kkk...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 30)}`
blackmd.sendMessage(from, {image: {url: links.pau}, caption: `*Oh mds*

⇒ @${sender_ou_n.split("@")[0]}

Seu pau mede ✮${random}cm✮ 😳

${NomeDoBot}🎖️`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'bct':
case 'buceta':
case 'xrc':
case 'xereca':
  setTimeout(() => {reagir(from, "😳")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Medindo o tamanho da sua ${command}* 😳\n\n⇒ @${sender_ou_n.split("@")[0]}\n\n*Calma ae kkk...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 20)}`
blackmd.sendMessage(from, {image: {url: links.buceta}, caption: `*Eita kkkk*

⇒ @${sender_ou_n.split("@")[0]}

Sua ${command} mede ✮${random}cm✮ 😳

${NomeDoBot}🎖️`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'pocoto':
  setTimeout(() => {reagir(from, "🐴")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/pocoto.mp3'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Cavalgando e pesquisando... O quanto você é pocoto* 🐴

⇒ @${sender_ou_n.split("@")[0]}

*Um momento...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.pocoto}, caption: `*O QUANTO VOCÊ É POCOTO ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  POCOTO 🐴

${NomeDoBot}🎖️`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'dojob': case 'puta': case 'prostituta':
  setTimeout(() => {reagir(from, "😈")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Pesquisando o quanto você é puta* 😈

⇒ @${sender_ou_n.split("@")[0]}

*Um momento...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.puta}, caption: `*O QUANTO VOCÊ É PUTA ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  PUTA 😈

${NomeDoBot}🎖️`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'calvo': case 'calva':
  setTimeout(() => {reagir(from, "👨🏼‍🦲")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Vai comprar um produto aí, enquanto eu pesquiso o quanto você é ${command}* 👨🏼‍🦲

⇒ @${sender_ou_n.split("@")[0]}

*Um momento...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.calvo}, caption: `*O QUANTO VOCÊ É CALVO (A) ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  ${command.toUpperCase()} 👨🏼‍🦲

${NomeDoBot}🎖️`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'rico': case 'rica':
  setTimeout(() => {reagir(from, "🤑")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Eitah kkk Já faz o pix enquanto eu puxo sua conta do banco* 🤑

⇒ @${sender_ou_n.split("@")[0]}

*Um momento...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.rico}, caption: `*O QUANTO VOCÊ É RICO (A) ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  RICO 🤑

${NomeDoBot}🎖️`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'pobre':
  setTimeout(() => {reagir(from, "🤣")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Zero comentários... Kkkk vamos ver o quanto você é pobre* 🤣

⇒ @${sender_ou_n.split("@")[0]}

*Um momento...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.pobre}, caption: `*O QUANTO VOCÊ É POBRE ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  POBRE 🤣

${NomeDoBot}🎖️`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'lindo': case 'bonito':
setTimeout(() => {reagir(from, "🤩")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Que que isso papai* 🤩

⇒ @${sender_ou_n.split("@")[0]}

*Olha essa lindeza...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.lindo}, caption: `*O QUANTO VOCÊ É LINDO ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  LINDO 🤩

⏤͟͟͞͞ ꦿ${NomeDoBot}`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'linda': case 'bonita':
  setTimeout(() => {reagir(from, "😍")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Opaisso ADM... cê tá vendo isso ?* 😍

⇒ @${sender_ou_n.split("@")[0]}

*Xonei nela...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.linda}, caption: `*O QUANTO VOCÊ É LINDA ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  LINDA 😍

⏤͟͟͞͞ ꦿ${NomeDoBot}`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'noia':
  setTimeout(() => {reagir(from, "👽")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*iqjakdksjgaijduaha eu sla* 👽

⇒ @${sender_ou_n.split("@")[0]}

*Calma ae, kkk...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.noia}, caption: `*O QUANTO VOCÊ É NOIA ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  NOIA 👽

⏤͟͟͞͞ ꦿ${NomeDoBot}`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'sigma':
  setTimeout(() => {reagir(from, "🍷")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Conversa de alto nível senhores* 🗿🍷

⇒ @${sender_ou_n.split("@")[0]}

*Aguarde...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.sigma}, caption: `*O QUANTO VOCÊ É SIGMA ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  SIGMA 🗿🍷

⏤͟͟͞͞ ꦿ${NomeDoBot}`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'beta':
  setTimeout(() => {reagir(from, "🤓")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {text:`*Processando seu nível de beta* 🤓

⇒ @${sender_ou_n.split("@")[0]}

*Aguarde...*`, mentions: [sender_ou_n]})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
blackmd.sendMessage(from, {image: {url: links.beta}, caption: `*O QUANTO VOCÊ É BETA ?* 

⇒  @${sender_ou_n.split("@")[0]}

 VOCÊ É  ✮${random}%✮  BETA 🤓

⏤͟͟͞͞ ꦿ${NomeDoBot}`, mentions: [sender_ou_n]}, {quoted: seloctt})
}, 7000)
break

case 'amor':
case 'odio':
if(!isModobn) return reply(enviar.msg.modobz)
if(command == `amor`) {
if(!menc_os2) return reply(`Marque a pessoa para quem você quer dedicar o seu amor...`)
blackmd.sendMessage(from, {text: `Olá @${menc_os2.split('@')[0]}, ${tempo} ^^
@${sender.split('@')[0]} mandou dizer que te ama 🥺💖`, mentions: [menc_os2, sender]}, {quoted: seloctt})
enviarfigu(`./database/figu/loveyou.webp`)
} else {
if(!menc_os2) return reply(`Marque a pessoa para quem você quer dedicar o seu ódio...`)
blackmd.sendMessage(from, {text: `Olá @${menc_os2.split('@')[0]}, ${tempo} '-'
@${sender.split('@')[0]} mandou dizer que te odeia com todas as forças 🖕🏽😝`, mentions: [menc_os2, sender]}, {quoted: seloctt})
enviarfigu(`./database/figu/hateyou.webp`)
}
break

case 'matar':
case 'mata':
  setTimeout(() => {reagir(from, "💀")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
if(!menc_os2 || menc_jid2[1]) return reply('marque o alvo que você quer matar, a mensagem ou o @')
if(JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Não irei matar o meu dono... Mas posso matar você 😈')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.matar}, gifPlayback: true, caption: `*⚔️VOCÊ ACABA DE MATAR O (A)⚔️*

⇒ @${menc_os2.split('@')[0]} 🗡️👺

${NomeDoBot} ✨`, mentions: [menc_os2]})
break 


case 'beijo': case 'beijar':
  setTimeout(() => {reagir(from, "💋")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
if(!menc_os2 || menc_jid2[1]) return reply('marque a pessoa que você quer beijar, a mensagem ou o @')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.beijo}, gifPlayback: true, caption: `*VOCÊ DEU UM BEIJO TOTOSO NA (O)*

  ⇒  @${menc_os2.split('@')[0]} 👉🏽💞👈🏽🥺

 ✮${NomeDoBot}✮` , mentions: [menc_os2]})
break

case 'biografia':
case 'bio':
try {
status = (await blackmd.fetchStatus(sender_ou_n)).status
} catch {
status = "🔒 Privada 🔒"
}
reply(status)
break

case 'tapa':
  setTimeout(() => {reagir(from, "😏")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for, apenas digite ${prefix}modozoeira`)
if(!menc_os2 || menc_jid2[1]) return reply('marque o alvo que você quer da um tapa, a mensagem ou o @')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.tapa}, gifPlayback: true, caption: `*VOCÊ DEU UM TAPA NA RABA DA*

 ⇒   @${menc_os2.split('@')[0]} 👉🏽👈🏽😏

✮${NomeDoBot}✮`, mentions: [menc_os2]})
break

case 'chute':
case 'chutar':
  setTimeout(() => {reagir(from, "🤡")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for um, apenas digite ${prefix}modozoeira 1`)
if(!menc_os2 || menc_jid2[1]) return reply('marque o alvo que você quer da um chute, a mensagem ou o @')
if(JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Você não está autorizado a chutar meu dono... 😐')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.chute}, gifPlayback: true, caption: `*VOCÊ DEU UMA BICUDA NO(A)*

 ⇒ @${menc_os2.split('@')[0]} 👉🏽👈🏽🤡

✮${NomeDoBot}✮`, mentions: [menc_os2]})
break 

case 'abraco':
case 'abraço':
case 'abraçar':
  setTimeout(() => {reagir(from, "🤗")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for um, apenas digite ${prefix}modozoeira`)
if(!menc_os2 || menc_jid2[1]) return reply('marque a pessoa que você quer dar um abraço, a mensagem ou o @')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.abraco}, gifPlayback: true, caption: `*VOCÊ DEU UM ABRAÇO APERTADO NO (A)*

 ⇒ @${menc_os2.split('@')[0]} 🫂

${NomeDoBot} 🤗`, mentions: [menc_os2]})
break

case 'soco':
case 'socar':
  setTimeout(() => {reagir(from, "👊🏽")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for um, apenas digite ${prefix}modozoeira`)
if(!menc_os2 || menc_jid2[1]) return reply('marque a pessoa que você quer dar um soco, a mensagem ou o @')
if(JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('Vou te descer na porrada irmão... Mexeu com meu dono; mexeu comigo 👊🏽')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.socar}, gifPlayback: true, caption: `*VOCÊ DEU UM MURRO NA CARA DO (A)*

 ⇒ @${menc_os2.split('@')[0]} 🤡

${NomeDoBot} 👊🏽`, mentions: [menc_os2]})
break

case 'mano':
case 'bro':
case 'brother':
case 'toque':
case 'tocar':
setTimeout(() => {reagir(from, "🤝🏽")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
if(!menc_os2 || menc_jid2[1]) return reply('marque a pessoa que você quer dar um aperto de mão, a mensagem ou o @')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.bro}, gifPlayback: true, caption: `*VOCÊ DEU UM APERTO DE MÃO NO (A)*

 ⇒ @${menc_os2.split('@')[0]} 🤜🏽🤛🏽

${NomeDoBot} 🤝🏽`, mentions: [menc_os2]})
break

case 'estuprar': case 'estupro':
setTimeout(() => {reagir(from, "🌚")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
if(!isNsfw) return reply(enviar.msg.modonsfw)
if(!menc_os2 || menc_jid2[1]) return reply('marque a pessoa que você quer estuprar, a mensagem ou o @')
blackmd.sendMessage(from, {audio: {url:'./database/audios/aguarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
blackmd.sendMessage(from, {video: {url: links.estuprar}, gifPlayback: true, caption: `*VOCÊ ACABOU DE ESTUPRAR O (A)*

 ⇒ @${menc_os2.split('@')[0]} 🕳️🙈

${NomeDoBot} 🌚🍷`, mentions: [menc_os2]})
break

case 'namorar': case 'namoracomigo':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
reagir(from, "❤")
if(!menc_os2) return reply(`Marque um usuário para pedir este em namoro, a mensagem ou o @`)
if(botNumber.includes(menc_os2)) return reply(`Não pode pedir o bot em namoro kkk 😂`)
if(sender.includes(menc_os2)) return reply(`Tu não pode pedir tu msm em namoro kkk 😂`)
if(userEstaNamorando(sender)) {
  mention(`💞 Você já está ${userEstaCasado(sender) ? "casado" : "em um relacionamento sério"} com o/a @${getDBFZuser(sender).usu2}.. 🥰`)
  await sleep(500)
  return blackmd.sendMessage(identArroba(getDBFZuser(sender).usu2), {text: `🐂 Aí ${getname(getDBFZuser(sender).usu2)}, tua dupla @${sender.split("@")[0]} tá pedido outra pessoa em namoro ali...`, mentions: [sender]}, {quoted: info})
}
if(userEstaNamorando(menc_os2)) {
  mention(`Cê para lek, O/a @${menc_os2.split("@")[0]} ${userEstaCasado(sender) ? "é casado/a" : "está namorando"} com o/a @${getDBFZuser(menc_os2).usu2}`)
  await sleep(500)
  return blackmd.sendMessage(identArroba(getDBFZuser(menc_os2).usu2), {text: `🐂 Aí ${getname(getDBFZuser(menc_os2).usu2)}, tão pedindo a tua dupla @${menc_os2.split("@")[0]} em namoro ali...`, mentions: [menc_os2]}, {quoted: info})
}
deletarAntigoPedidoDeNamoro(sender)
deletarAntigoPedidoDeNamoro(menc_os2)
gerarPedidoDeNamoro(sender, menc_os2, from)
txt = `${tempo_emoji} *${tempo.toUpperCase()}*
⇒ @${menc_os2.split('@')[0]}
  
_${pushname} está te pedindo em namoro... Digite『 s 』caso queira aceitar, ou『 n 』caso queira recusar_ 🥰`
blackmd.sendMessage(from, {video: {url: links.namoracomigo}, caption: txt, gifPlayback: true, mentions: [menc_os2]}, {quoted: seloctt})
break

case 'casar': case 'casacomigo':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
reagir(from, "💍")
if(!menc_os2) return reply(`Marque um usuário para pedir este em casamento, a mensagem ou o @`)
if(botNumber.includes(menc_os2)) return reply(`Não pode pedir o bot em casamento kkk 😂`)
if(sender.includes(menc_os2)) return reply(`Tu não pode pedir tu msm em casamento kkk 😂`)
if(!userEstaNamorando(sender)) return reply(`Para pedir alguém em casamento, você precisa primeiro estar namorando essa pessoa...`)
if(userEstaCasado(sender)) {
  mention(`💞 Você já está casado/a com o/a @${getDBFZuser(sender).usu2}.. 🥰`)
  await sleep(500)
  return blackmd.sendMessage(identArroba(getDBFZuser(sender).usu2), {text: `🐂 Aí ${getname(getDBFZuser(sender).usu2)}, tua dupla @${sender.split("@")[0]} tá pedido outra pessoa em casamento ali...`, mentions: [sender]}, {quoted: info})
}
if(menc_os2 != identArroba(getDBFZuser(sender).usu2)) {
  mention(`Sua dupla é o/a @${getDBFZuser(sender).usu2}... Fica esperto em 🐂`)
  await sleep(500)
  return blackmd.sendMessage(identArroba(getDBFZuser(sender).usu2), {text: `🐂 Aí ${getname(getDBFZuser(sender).usu2)}, tua dupla @${sender.split("@")[0]} tá pedido outra pessoa em casamento ali...`, mentions: [sender]}, {quoted: info})
}
if(isWaitUsuFZ_casamento(sender)) return mention(`👻 Você já pediu sua dupla @${getDBFZuser(sender).usu2} em casamento... Aguarde resposta ou use ${prefix}cancelar`)
gerarPedidoDeCasamento(sender, from)
txt = `${tempo_emoji} *${tempo.toUpperCase()}*
⇒ @${menc_os2.split('@')[0]}
  
_${pushname} está te pedindo em casamento... Digite『 s 』caso queira aceitar, ou『 n 』caso queira recusar_ 🫴🏽💍`
blackmd.sendMessage(from, {video: {url: links.casacomigo}, caption: txt, gifPlayback: true, mentions: [menc_os2]}, {quoted: seloctt})
break

case 'terminar': case 'termino': case 'divorciar': case 'divorcio':
if(Number(args[0]) !== 1) return reply(`Tem crtz disso ${pushname} ? Se estiver mesmo disposto a ${command.startsWith("termi") ? "terminar" : "divorciar"} com sua dupla, use ${prefix+command} 1`)
if(!userEstaNamorando(sender)) return reply(`Você não está se relacionando com ninguém para terminar ou se divorciar...`)
terminarOuDivorciar(sender)
reply(`${command.startsWith("termi") ? "Término" : "Divórcio"} efetuado com sucesso 💔`)
break

case 'cancelar':
if(userPediuAlguemEmNamoro(sender)) {
cancelarPedidoDeNamoro(sender)
} else if(userPediuAlguemEmCasamento(sender)) {
cancelarPedidoDeCasamento(sender)
} else return reply(`Não há pedidos de namoro nem casamento...`)
reply(`👻 O pedido a sua dupla foi cancelado com sucesso...`)
break

case 'minhadupla': case 'dupla':
reagir(from, "❤️‍🩹")
if(!userEstaNamorando(sender)) return reply(`Você não está casado (a) com ninguém... Sinto muito 😕`)
if(isWaitUsuFZ_namoro(sender)) return reply(`A pessoa quem você pediu em namoro não aceitou o pedido ainda... Portanto, não é possível consultar os dados da dupla 😶‍🌫️`)
i = getDBFZuser(sender)
n = i.namoro
c = i.casamento

//============contador de tempo================\\

data_pedido = `📆⃤ Namorando desde ${n.day}/${n.mm}/${n.year}`

if(!userEstaCasado(sender)) {
  tipo = "Namoro"
  tempo_total = "_Namorando a "
  sub = contarDias(sendHours("DD/MM/YYYY")) - contarDias(`${n.day}/${n.mm}/${n.year}`)
  horas = (sub * 24) + (Number(sendHours("HH")) - n.hora)
  if(horas <= 0) {
    sec = "aproximadamente "
    if((Number(sendHours("mm")) - n.minuto) <= 0) {
      sec += Number(sendHours("ss")) - n.segundo
      sec += ` segundo${(Number(sendHours("ss")) - n.segundo) != 1 ? "s" : ""}`
    } else {
      sec += Number(sendHours("mm")) - n.minuto
      sec += ` minuto${(Number(sendHours("mm")) - n.minuto) != 1 ? "s" : ""}`
    }
    tempo_total += sec
  } else if(horas > 0 && horas <= 24) {
    tempo_total += `aproximadamente ${horas} hora${horas != 1 ? "s" : ""}`
  } else tempo_total += converterDias(sub)
  tempo_total += "_\n"
  if(Number(sendHours("DD")) === Number(n.day) && horas > 24) {
    if(Number(sendHours("MM")) === Number(n.mm) && Number(sendHours("YYYY")) !== Number(n.year)) {
      ano = Number(sendHours("YYYY")) - Number(n.year)
      tempo_total = `_Namorando a exatamente ${ano} ano${ano != 1 ? "s" : ""}_`
      tempo_total += "\n\t\t"
      tempo_total += "*_Parabéns_* 💗😍"
    } else {
      mês = ((Number(sendHours("YYYY")) - Number(n.year)) * 12) + (Number(sendHours("MM")) - Number(n.mm))
      tempo_total = `_Namorando a exatamente ${mês} m${mês != 1 ? "eses" : "ês"}_`
      tempo_total += "\n\t\t"
      tempo_total += "*_Parabéns_* 💖✨"
    }
  }
} else {
  tipo = "Casamento"
  tempo_total = "_Casados a "
  sub = contarDias(sendHours("DD/MM/YYYY")) - contarDias(`${c.day}/${c.mm}/${c.year}`)
  horas = (sub * 24) + (Number(sendHours("HH")) - c.hora)
  if(horas <= 0) {
    sec = "aproximadamente "
    if((Number(sendHours("mm")) - c.minuto) <= 0) {
      sec += Number(sendHours("ss")) - c.segundo
      sec += ` segundo${(Number(sendHours("ss")) - c.segundo) != 1 ? "s" : ""}`
    } else {
      sec += Number(sendHours("mm")) - c.minuto
      sec += ` minuto${(Number(sendHours("mm")) - c.minuto) != 1 ? "s" : ""}`
    }
    tempo_total += sec
  } else if(horas > 0 && horas <= 24) {
    tempo_total += `aproximadamente ${horas} hora${horas != 1 ? "s" : ""}`
  } else tempo_total += converterDias(sub)
  tempo_total += "_\n"
  data_pedido += `\n💍⃤ Casados desde ${c.day}/${c.mm}/${c.year}`
  if(Number(sendHours("DD")) === Number(c.day) && horas > 24) {
    if(Number(sendHours("MM")) === Number(c.mm) && Number(sendHours("YYYY")) !== Number(c.year)) {
      ano = Number(sendHours("YYYY")) - Number(c.year)
      tempo_total = `_Casados a exatamente ${ano} ano${ano != 1 ? "s" : ""}_ 🎂`
      tempo_total += "\n\t\t\t\t"
      tempo_total += "*_Feliz aniversário_* 😍💍"
    } else {
      mês = ((Number(sendHours("YYYY")) - Number(c.year)) * 12) + (Number(sendHours("MM")) - Number(c.mm))
      tempo_total = `Casados a exatamente ${mês} m${mês != 1 ? "eses" : "ês"}_ 🎂`
      tempo_total += "\n\t\t\t\t"
      tempo_total += "*_Feliz aniversário_* 💘🛐"
    }
  }
}

//===================fotos=======================\\
db = getDBFZuser(sender)

try { foto1 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${db.usu1.split("@")[0]}@c.us`, 'image'))}`)).data
} catch(e) { foto1 = semfoto }

try { foto2 = (await axios.get(`https://tinyurl.com/api-create.php?url=${(await blackmd.profilePictureUrl(`${db.usu2}@c.us`, 'image'))}`)).data
} catch(e) { foto2 = semfoto }

logocasal = site+`/api/canvas/ship?foto1=${foto1}&foto2=${foto2}&mat=100&fundo=https://telegra.ph/file/070ced9a362da470ae3f9.jpg`

//=========distribuição de informações===========\\

txt = `
💕 ${tipo} entre ↴
『😍』@${db.usu1.split('@')[0]}
ㅤ &
〘❤️‍🩹〙@${db.usu2}
⇒ ${tempo_total}
---------------------------------------------------------
${data_pedido}`
mencionarIMG(txt, logocasal)
break

case 'dogolpe': case 'golpe': case 'golpista':
setTimeout(() => {reagir(from, "😳")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for um, apenas digite ${prefix}modozoeira 1`)
if(!menc_os2 || menc_jid2[1]) return reply(`Marque a mensagem da pessoa ou use:\n${prefix+command} @alguém do grupo`)
random = `${Math.floor(Math.random() * 100)}`
golpenmr = random
if(golpenmr < 25){var golpetxt = `Não é golpe`}; if(golpenmr >= 25 && golpenmr < 50){var golpetxt = `Varia de pessoa pra pessoa`}; if(golpenmr >=50 && golpenmr < 75){var golpetxt = `Idiota gosta de ferir sentimentos`}; if(golpenmr > 75){var golpetxt = `Famoso destrói corações`}
blackmd.sendMessage(from, {text:`@${menc_os2.split("@")[0]} é golpe ? 🤔

*CALCULANDO GOLPE⟩* ✮${random}%✮

${golpetxt} 💔🤡`, mentions: [menc_os2]})
break

case 'shipo': case 'shippe': case 'shipe': case 'shipar':
setTimeout(() => {reagir(from, "😏")}, 300)
if(!menc_os2) return reply(`Marque a mensagem da pessoa ou use:\n${prefix+command} @alguém do grupo`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/shipo.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
mention(`*Hmm... Eu shipo o (a):*
 ⏤͟͟͞͞ ꦿ😍⧽ @${menc_os2.split("@")[0]}
*Com o (a):*
 ⏤͟͟͞͞ ꦿ😏⧽ @${groupMembers[Math.floor(Math.random() * groupMembers.length)].id.split('@')[0]}

 Com uma porcentagem de⧽ ✮${Math.floor(Math.random() * 100)+"%"}✮ ❤️`)
break

case 'casal':
setTimeout(() => {reagir(from, "😍")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for um, apenas digite ${prefix}modozoeira`)
txt = `*Hmmm.... Eu Shipo eles 2💘💘*
1= @${groupMembers[alerandom(groupMembers.length)].id.split("@")[0]}
e esse
2= @${groupMembers[alerandom(groupMembers.length)].id.split("@")[0]}
com uma porcentagem de: ${alerandom(100)}%`
mention(txt)
break

case 'rankativos':
case 'rankativo':  
if(!isGroup) return reply(enviar.msg.grupo)
AB = countMessage.map(a => a.groupId).indexOf(from)
if(AB < 0) return reply(`Não há dados de mensagens deste grupo salvos na database do bot...`)
grupo = countMessage[AB].participants.map(i => i)
rank = grupo.sort((a, b) => ((a.mensagens + a.comandos) < (b.mensagens + b.comandos)) ? 0 : -1)
caixa = []
for(i = 0; i < (countMessage[AB].participants.length < 5 ? countMessage[AB].participants.length : 5); i++) {
caixa.push({nmr: i+1, id: rank[i].id, mensagens: rank[i].mensagens, comandos: rank[i].comandos})

}
if(caixa.length <= 0) return reply(`Não há membros suficientes no grupo para efetuar o rank...`)
txt = `❤️‍🔥 *${countMessage[AB].participants.length < 5 ? countMessage[AB].participants.length : 5} mais ativos do grupo ↴*
⏤͟͟͞͞ ꦿ${groupName}

${caixa.map(c => `»${c.nmr}« @${c.id.split('@')[0]}
\t⇒𝙼𝚎𝚗𝚜𝚊𝚐𝚎𝚗𝚜: ${largeNumber(c.mensagens)}
\t\t⇒𝙲𝚘𝚖𝚊𝚗𝚍𝚘𝚜: ${largeNumber(c.comandos)}`).join(`\n\n`)}`
mention(txt)
break

case 'rankinativo':
case 'rankinativos':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
AB = countMessage.map(a => a.groupId).indexOf(from)
if(AB < 0) return reply(`Não há dados de mensagens deste grupo salvos na database do bot...`)
grupo = countMessage[AB].participants.map(i => i)
rank = grupo.sort((a, b) => ((a.mensagens + a.comandos) < (b.mensagens + b.comandos)) ? -1 : 0)
caixa = []
for(i = 0; i < (countMessage[AB].participants.length < 5 ? countMessage[AB].participants.length : 5); i++) {
caixa.push({nmr: i+1, id: rank[i].id, mensagens: rank[i].mensagens, comandos: rank[i].comandos})

}
if(caixa.length <= 0) return reply(`Não há ghosts neste grupo...`)
txt = `👻 *Top ${countMessage[AB].participants.length < 5 ? countMessage[AB].participants.length : 5} mais ghosts deste grupo ↴*

${caixa.map(c => `»${c.nmr}« @${c.id.split('@')[0]}
*Mensagens:* ${c.mensagens}
*Comandos:* ${c.comandos}`).join(`\n\n`)}`
mention(txt)
break

case 'check':
if(menc_os2) {
mark = menc_os2
} else {
mark = sender
}
wppuser(mark)
try {
checkimg = await blackmd.profilePictureUrl(`${mark.split('@')[0]}@c.us`, 'image')
} catch {
checkimg = "https://telegra.ph/file/5446d1f9da3df07e98699.jpg"
}
check = `
⏤͟͟͞͞ ░⃟⃛ ➮ @${mark.split('@')[0]}
╭═════════════════╮
╟ ▧⃯⃟🔱 *ADM『 ${groupAdmins.includes(mark) ? `✅` : `❌`} 』*
╟ ▧⃯⃟⚜️ *CRIADOR (A)『 ${groupMetadata.owner.includes(mark) ? `✅` : `❌`} 』*
╟ ▧⃯⃟💎 *VIP『 ${isJsonIncludes(vip, mark) ? `✅` : isJsonIncludes(vipgp, from) ? `✅` : `❌`} 』*
╟ ▧⃯⃟👑 *DONO『 ${numerodono.includes(mark) ? `✅` : `❌`} 』*
╰═════════════════╯`
blackmd.sendMessage(from, {image: {url: checkimg}, caption: check, mentions: [mark]})
break

case 'checkativo':
setTimeout(() => {reagir(from, "📖")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
AB = countMessage.map(a => a.groupId).indexOf(from)
if(AB < 0) return reply(`Não há dados de mensagens deste grupo salvos na database do bot...`)
if(!menc_os2 || menc_jid2[1]) return reply('Marque o @ de quem deseja puxar a atividade / Só pode um por vez..')
if(menc_os2.includes(sender)) return reply(`Para puxar os próprios dados, use ${prefix}checkme`)
AC = countMessage[AB].participants.map(b => b.id).indexOf(menc_os2)
if(AC <= 0) return reply(enviar.msg.notusu)
usu = AC >= 0 ? countMessage[AB].participants[AC] : {}
mention(`
▄︻̷̿┻̿═━一 🅲🅷🅴🅲🅺
⇒@${menc_os2.split('@')[0]}
________________________________________

⏤͟͟͞͞ ꦿ𝙼𝚎𝚗𝚜𝚊𝚐𝚎𝚗𝚜 *↴*
⇒( ${AC >= 0 ? usu.mensagens : 0} )

⏤͟͟͞͞ ꦿ𝙲𝚘𝚖𝚊𝚗𝚍𝚘𝚜 *↴*
⇒( ${AC >= 0 ? usu.comandos : 0} )
________________________________________

ೈ፝͜͡📖 ${NomeDoBot}
`)
break

case 'checkme':
setTimeout(() => {reagir(from, "📖")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
AB = countMessage.map(a => a.groupId).indexOf(from)
if(AB < 0) return reply(`Não há dados de mensagens deste grupo salvos na database do bot...`)
AC = countMessage[AB].participants.map(b => b.id).indexOf(sender)
usu = AC >= 0 ? countMessage[AB].participants[AC] : {}
txt =
`
ㅤㅤ»⟩ S̷U̷A̷ A̷T̷I̷V̷I̷D̷A̷D̷E̷ ⟨«
╭════════════════╯
 | 🧾⃤ grupσ: ${groupName}
 | ✏️⃤ níck: ${pushname}
 | 📖⃤ mєnsαgєns: ${AC >= 0 ? usu.mensagens : 0}
 | 💻⃤ cσmαndσs: ${AC >= 0 ? usu.comandos : 0}
╰════════════════╮
`
try {img = await blackmd.profilePictureUrl(`${sender.split('@')[0]}@c.us`, 'image')
} catch { img = semfoto }
sendUrlText(from, txt, NomeDoBot, ``, img, `https://wa.me/`+sender.split("@")[0], seloctt)
break

case 'rankcorno':
if(!isGroup) return reply(`[❗] Este comando só pode ser usado em grupo...`)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for um, apenas digite ${prefix}modozoeira 1`)
membr = []
const corno1 = groupMembers
const corno2 = groupMembers
const corno3 = groupMembers
const corno4 = groupMembers
const corno5 = groupMembers
const cornos1 = corno1[Math.floor(Math.random() * corno1.length)]
const cornos2 = corno2[Math.floor(Math.random() * corno2.length)]
const cornos3 = corno3[Math.floor(Math.random() * corno3.length)]
const cornos4 = corno4[Math.floor(Math.random() * corno4.length)]
const cornos5 = corno5[Math.floor(Math.random() * corno5.length)]
var porcentagemcorno = ["1%", `2%`, `3%`, `4%`, `5%`, `6%`, `7%`, `8%`, `9%`, `10`, `11%`, `12%`,`13%`, `14%`, `15%`, `16%`, `17%`, `1%`, `19%`, `20%`, `21%`, `22`, `23%`, `24%`, `25%`, `26%`, `27%`, `2%`, `27%`, `2%`, `29%`, `30%`, `31%`, `32%`, `33%`, `34%`, `35%`, `36%`, `37%`, `3%`, `39%`, `40%`, `41%`, `42%`, `43%`, `44%`, `45%`, `46%`, `47%`, `4%`, `49%`, `50%`, `51%`, `52%`, `53%`, `54%`, `55%`, `56%`, `57%`, `5%`, `59%`, `60%`, `61%`, `62%`, `63%`, `64%`, `65%`, `66%`, `67%`, `6%`, `69%`, `70%`, `71%`, `72%`, `73%`, `74%`, `75%`, `76%`, `77%`, `7%`, `79%`, `0%`, `1%`, `2%`, `5%`, `4%`, `5%`, `6%`, `7%`, `%`, `9%`, `90%`, `91%`, `92%`, `93%`, `94%`, `95%`, `96%`, `97%`, `9%`, `99%`, `O chifre desse ai bate na lua ksksksk`]
const porcentagemc = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const porcentag = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const porcent = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const porcl = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const porg = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
const prg = porcentagemcorno[Math.floor(Math.random() * porcentagemcorno.length)]
ABC = `
*Esses são os cornos do grupo* ${groupName}\n@${cornos1.id.split('@')[0]}\nCom uma porcentagem de ${porcent}\n@${cornos2.id.split('@')[0]}\nCom uma porcentagem de ${porcentag}\n@${cornos3.id.split('@')[0]}\nCom uma porcentagem de ${porcl}\n@${cornos4.id.split('@')[0]}\nCom uma porcentagem de ${porg}\n@${cornos5.id.split('@')[0]}\nCom uma porcentagem de ${prg}\n\n✮${setting.NomeDoBot}✮`
membr.push(cornos1.id)
membr.push(cornos2.id)
membr.push(cornos3.id)
membr.push(cornos4.id)
membr.push(cornos5.id)
mentions(ABC, membr, true)
break

case 'rankgostoso': case 'rankgostosos':
if(!isGroup) return reply(`[❗] Este comando só pode ser utilizado em grupo`)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for um, apenas digite ${prefix}modozoeira 1`)
membr = []
const ogstz1 = groupMembers
const ogstz2 = groupMembers
const ogstz3 = groupMembers
const ogstz4 = groupMembers
const ogstz5 = groupMembers
const ogstzs1 = ogstz1[Math.floor(Math.random() * ogstz1.length)]
const ogstzs2 = ogstz2[Math.floor(Math.random() * ogstz2.length)]
const ogstzs3 = ogstz3[Math.floor(Math.random() * ogstz3.length)]
const ogstzs4 = ogstz4[Math.floor(Math.random() * ogstz4.length)]
const ogstzs5 = ogstz5[Math.floor(Math.random() * ogstz5.length)]
const ogstzmsg = [`trabalhando em nossa agência de modelos 😊 by: ${NomeDoBot}`, ` mandando nuds no pv do dono ☺️ by: ${NickDono}`]
const ogstzmsg_ = ogstzmsg[Math.floor(Math.random() * (ogstzmsg.length))]
ABC = `
Parados !✋🏽😶🤚🏽

1= ✋🏽😶@${ogstzs1.id.split('@')[0]}😶🤚🏽


2= ✋🏽😶@${ogstzs2.id.split('@')[0]}😶🤚🏽


3= ✋🏽😶@${ogstzs3.id.split('@')[0]}😶🤚🏽


4= ✋🏽😶@${ogstzs4.id.split('@')[0]}😶🤚🏽


5= ✋🏽😶@${ogstzs5.id.split('@')[0]}😶🤚🏽


Multa por serem gostosos dms 😳 pague pena ${ogstzmsg_}`
membr.push(ogstzs1.id)
membr.push(ogstzs2.id)
membr.push(ogstzs3.id)
membr.push(ogstzs4.id)
membr.push(ogstzs5.id)
mentions(ABC, membr, true)
break

case 'rankgostosa': case 'rankgostosas':
if(!isGroup) return reply(`[❗] Este comando só pode ser utilizado em grupo`)
if(!isModobn) return reply(`Este tipo de comando só pode ser utilizado com o modozoeira ativo, fale com um adm ou se você for um, apenas digite ${prefix}modozoeira 1`)
membr = []
const agstz1 = groupMembers
const agstz2 = groupMembers
const agstz3 = groupMembers
const agstz4 = groupMembers
const agstz5 = groupMembers
const agstzs1 = agstz1[Math.floor(Math.random() * agstz1.length)]
const agstzs2 = agstz2[Math.floor(Math.random() * agstz2.length)]
const agstzs3 = agstz3[Math.floor(Math.random() * agstz3.length)]
const agstzs4 = agstz4[Math.floor(Math.random() * agstz4.length)]
const agstzs5 = agstz5[Math.floor(Math.random() * agstz5.length)]
const agstzmsg = [`trabalhando em nossa agência de modelos 😊 by: ${NomeDoBot}`, ` mandando nuds no pv do dono ☺️ by: ${NickDono}`]
const agstzmsg_ = agstzmsg[Math.floor(Math.random() * (agstzmsg.length))]
ABC = `
Paradas !✋🏽😶🤚🏽

1= ✋🏽😶@${agstzs1.id.split('@')[0]}😶🤚🏽


2= ✋🏽😶@${agstzs2.id.split('@')[0]}😶🤚🏽


3= ✋🏽😶@${agstzs3.id.split('@')[0]}😶🤚🏽


4= ✋🏽😶@${agstzs4.id.split('@')[0]}😶🤚🏽


5= ✋🏽😶@${agstzs5.id.split('@')[0]}😶🤚🏽


Multa por serem gostosas dms 😳 pague pena ${agstzmsg_}`
membr.push(agstzs1.id)
membr.push(agstzs2.id)
membr.push(agstzs3.id)
membr.push(agstzs4.id)
membr.push(agstzs5.id)
mentions(ABC, membr, true)
break

case 'rankgay': case 'rankgays':
setTimeout(() => {reagir(from, "🌈")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS GAYS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `🌈⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break;

case 'rankhetero':
  setTimeout(() => {reagir(from, "🏁")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS HÉTEROS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `🏁⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankgado': case 'rankgados':
setTimeout(() => {reagir(from, "🐂")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS GADOS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `🐂⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break;

case 'ranknazista': case 'ranknazistas':
  setTimeout(() => {reagir(from, "💂🏼‍♂️")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS NAZISTAS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `💂🏼‍♂️⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break;

case 'rankotaku': case 'rankotakus':
  setTimeout(() => {reagir(from, "🧽")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS OTAKUS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `🧽⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break;

case 'rankpau':
  setTimeout(() => {reagir(from, "🍆")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*Esses são os cara com maior e menor pau do grupo* ${groupName}\n\n`
TMPAU = ["Minúsculo", `Pequenininho chega ser até fofo 🥺`, `Pequeno`, `Mediano`, `Grandinho 🥵`, `Grande até`, `Gigantesco`, `Enorme`, `QUEIMADO !! Tão grande que bateu no sol e queimou`, `Ponte Rio Niterói`, "Nem existe"]
for (var i = 0; i < 5; i++) {
ABC += `@${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n${TMPAU[Math.floor(Math.random() * TMPAU.length)]}\n`
}
ABC += `\nBy 🔥 ${NomeDoBot} 🔥`
mention(ABC);
break;

case 'rankbct':
case 'rankbuceta':
case 'rankxrc':
case 'rankxereca':
setTimeout(() => {reagir(from, "😏")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSAS SÃO AS MAIS BUCETUDAS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `😏⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankpocoto':
setTimeout(() => {reagir(from, "🐴")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS POCOTO DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `🐴⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'ranklindo':
case 'ranklinda':
case 'rankbonito':
case 'rankbonita':
setTimeout(() => {reagir(from, react2)}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
lindo = ["Base da Virgínia", "Sem comentários...", "Feio que dá dó", "Feio mas engraçado", "Feio (a)", "Nada que uma maquiagem não resolva", "Na média", "Nem um, nem outro", "Bonito (a)", "Nada mal", "Lindo (a)", "Extremamente lindo (a)", "Perfeito (a)"]
ABC = `*GRAU DE LINDEZA DO GRUPO⟩*
⇒${groupName}\n`
for (var i = 0; i < 5; i++) {
ABC += `✮ @${groupMembers[Math.floor(Math.random() * groupMembers.length)].id.split("@")[0]}\nㅤ⇒${lindo[Math.floor(Math.random()*lindo.length)]}\n\n`
}
mention(ABC);
break

case 'rankputa':
setTimeout(() => {reagir(from, "😈")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSAS SÃO AS MAIS PUTAS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `😈⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankcalvo':
  setTimeout(() => {reagir(from, "👨🏼‍🦲")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS CALVOS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `👨🏼‍🦲⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankrico':
  setTimeout(() => {reagir(from, "🤑")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS RICOS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `🤑⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankpobre':
  setTimeout(() => {reagir(from, "🤣")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS POBRES DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `🤣⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankpobre':
  setTimeout(() => {reagir(from, "🤣")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS POBRES DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `🤣⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankfeio':
  setTimeout(() => {reagir(from, "🤡")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS FEIOS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `🤡⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break
case 'rankvesgo':
  setTimeout(() => {reagir(from, "👀")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS VESGO DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `👀⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'ranknoia':
  setTimeout(() => {reagir(from, "👽")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS NOIA DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `👽⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'ranksigma':
  setTimeout(() => {reagir(from, "🗿")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS SIGMA DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `🗿🍷⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'rankbeta':
  setTimeout(() => {reagir(from, "🤓")}, 300)
if(!isGroup) return reply(enviar.msg.grupo)
if(!isModobn) return reply(enviar.msg.modobz)
ABC = `*ESSES SÃO OS MAIS BETAS DO GRUPO*\n`
for (var i = 0; i < 5; i++) {
ABC += `🤓⧽ @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
mention(ABC);
break

case 'piadas': case 'piada':
setTimeout(() => {reagir(from, "😂")}, 300)
reply(`*_Sorteando_*

${pia[Math.floor(Math.random() * (pia.length))]}
________________________________________
*_By Black 2K25_*`)
break

case 'cantada':
case 'cantadas':
setTimeout(() => {reagir(from, "😏")}, 300)
const cantm1 = ['Você não é mexicana mas mexicomigo', 'Eu não sou gato, mas me miamarro em vc', 'Pra virar bombom, só falta a valsa... Pq vc já é um sonho', 'Eu não sou astronauta mas eu posso te fazer chegar aos céus', 'Se beleza fosse crime, vc seria inocente', 'Se beleza fosse merda, vc estaria toda cagada', 'Se o universo soubesse o quanto eu te amo... Ele teria vergonha de ser tão pequeno', 'A lua deve estar cansada de me ouvir falar de vc', 'Cansei de correr atrás de vc... Agora eu vou de moto', 'Me chame de thur, pq o Ar eu perdi quando te vi', 'Me passa seu insta aí... Minha mãe disse pra eu seguir meu sonho', 'Vc é um eixo terrestre ? Pq meu mundo gira em torno de vc', 'Tem algo de errado no meu celular... Não consigo encontrar seu número nele', 'Rosas são vermelhas, violetas são azuis... Eu não sei rimar, mas posso namorar com vc ?', 'Tá calor né ? Mas não é de hj que eu me derreto por vc...', 'Estou sentindo uma dor no peito... Espero que seja amor, porque se for infarto, eu nunca mais te verei', 'Se te amar um dia me matar, saiba que eu morri sorrindo', 'Eu tenho uma memória terrível... Felizmente, vc é inesquecível', 'Seu nome é Google ? Pq em vc, tem tudo o que eu preciso...']
const cantm2 = cantm1[Math.floor(Math.random() * (cantm1.length))]
cantmtxt = `*_Chega na mina e fala assim..._*

_"${cantm2}"_ 😏
*_By ~M4TH 2K25_*`
blackmd.sendMessage(from, {text: cantmtxt, mentions: [menc_os2]})
blackmd.sendMessage(from, {audio: {url:'./database/audios/shipo.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
break

case 'cantada+18':
case 'cantadas+18':
if(!isNsfw) return reply(`*Este comando só pode ser executado com o modo+18 ativo...*
*Para ativa-lo, digite* ${prefix}modo+18`)
setTimeout(() => {reagir(from, "🌚")}, 300)
const cantf1 = ['Não quero problema para cima de mim, só se o problema for você', 'Minha roupa ficaria linda jogada no chão do seu quarto', 'Me chama de videogame e me joga no sofá', 'Sabe que horas são? hora da gente se pegar', 'Eu não sei fazer seu mundo girar, mas sei fazer sua cama balançar', 'Estou pegando no sono, mas queria estar pegando você', 'Minha boca na sua, rola? Se quiser, a gente tira a vírgula...', 'Gosto de café assim como de sexo... Quente, forte e todos os dias', 'Oi, a minha cama mandou perguntar se você quer dormir aqui', 'Queria ser o seu sabonete, para deslizar no seu corpo', 'Vc é fazendeira ? Pq vc fez o meu pepino crescer...', 'Posso te chamar de picolé de uva ? Pra vc deixar minha boca roxa...', 'Me chama de Buzz Lightyear e deixa eu te mostrar o infinito e além...', 'Deixa eu te ensinar o que eu aprendi com Danone... Enquanto você me ensina o que aprendeu com pirulito']
const cantf2 = cantf1[Math.floor(Math.random() * (cantf1.length))]
cantftxt = `*Cantadas +18 pra vc...*

_"${cantf2}"_ 🥵
*_By_* 🔥 ${NomeDoBot} 🔥`
reply(cantftxt)
break

case 'akinator':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(akinator).includes(from) && akinator.length > 0 && Number(akinator[0].dia) === Number(moment.tz('America/Sao_Paulo').format('DD'))) return reply("Volte mais tarde...")
if(!JSON.stringify(akinator).includes(from) && akinator.length > 0 && Number(akinator[0].dia) !== Number(moment.tz('America/Sao_Paulo').format('DD'))) {
jogo.now = true
akinator.splice(0, 1)
fs.writeFileSync("./armor/jogo/akinator.json", JSON.stringify(akinator, null, 2))
}
if(!JSON.stringify(akinator).includes(from)) {
reply(`Atenção ${pushname}, irei iniciar o jogo do akinator... Responda com "Sim", "Não", "Não sei", "Provavelmente Sim" ou "Provavelmente não" (sem as aspas)`)
dateAKI = moment.tz('America/Sao_Paulo').format('DD')
var region = 'pt'
var childMode = false;
var proxy = undefined;
let startAki = async () => {
global.aki = new Aki({ region, childMode, proxy });
await aki.start()
}
await startAki()
jogo.now = false
jogo.jogador = sender
akinator.push({id: from, jogador: sender, finish: 0, dia: dateAKI})
fs.writeFileSync("./armor/jogo/akinator.json", JSON.stringify(akinator, null, 2))
reply(`*⏤͟͟͞͞ ꦿAKINATOR* 🧙🏼‍♂️
🔮⃤ ${aki.question}`)
} else return mention(`@${akinator[akinator.map(i => i.id).indexOf(from)].jogador.split('@')[0]} já iniciou a partida, espere ele/a terminar...`)
break

case 'resetaki':
if(!isGroup) return reply(enviar.msg.grupo)
if(!JSON.stringify(akinator).includes(from) && !isOwner) return reply("Nenhuma sessão em andamento... 🧙🏼‍♂️")
if(akinator.length <= 0) return reply("Nenhuma sessão em andamento... 🧙🏼‍♂️")
matheuzinho = isOwner ? 0 : akinator.map(i => i.id).indexOf(from)
if(akinator[matheuzinho].jogador == sender || isGroupAdmins || isOwner) {
jogo.now = true
akinator.splice(matheuzinho, 1)
fs.writeFileSync("./armor/jogo/akinator.json", JSON.stringify(akinator, null, 2))
reply("🧙🏼‍♂️ Akinator resetado com sucesso ✨")
} else {
reply("[ ❗ ] Somente admins do grupo ou a pessoa que iniciou o jogo podem finalizar o akinator ❌")
}
break

case 'infowa':
datewa = sendHours('MM');
datetime = `${(Number(datewa) - 3) + 12}`
infowa2 = `${tempo} ${pushname} ${tempo_emoji}

Aproximadamente ${datetime} meses atrás, Mark Zuckerberg, dono do whatsapp, atualizou o mesmo, quebrando assim, a nossa conexão com a Baileys.

A Baileys é uma web criptopasta em que todos os bot de whatsapp puxam, de forma hiperbólica, inúmeras informações para seu funcionamento... Desde então, as listas e botões pararam de funcionar. Com um esforço incansável, nós, criadores e desenvolvedores, conseguimos uma baileys, em que os botões estavam funcionando perfeitamente em grupos, e as listas no privado. Bem, parece que até isso foi retirado de nós...

Novamente houve uma atualização na conexão do whatsapp, e dessa vez, o botões foram realmente de base...

O bot está funcionando em perfeito estado, em relação a outros comandos... Apenas os botões e listas foram desativados, devido não estarem funcionando.

Caso haja ainda algum bug que necessite de conserto, use o comando ${prefix}bug para reportar o mesmo... Se houver solução, irei imediatamente arrumar. Caso contrário, só podemos esperar que seja descoberto ou criada uma nova conexão para os bot, pq a Baileys, não funciona mais.

Conto com a sua compreensão ${pushname}... Repasse para a maioria de usuários de bot de whatsapp que conseguir, pois isso é um problema global. Não é problema no Black, nem no bot que você usa, nem na hospedagem... É problema no próprio whatsapp, e como todos os bot utilizam a mesma conexão *(por ser a única que existe)*, todos estão sofrendo com esse problema.

Nosso grupo tbm está disponível no comando ${prefix}blackgp. Lá, você tem um contato maior com vários usuários, obtendo maiores informações assim tbm.

✅ *Ass:* ${NickDono}
ㅤ✍🏽 *BY:* ${NomeDoBot}`
reply(infowa2)
break

case 'dado':
if(!isModobn) {
setTimeout(() => {reagir(from, "❌")}, 300)
return reply(enviar.msg.modobz)
} else {
setTimeout(() => {reagir(from, "🎲")}, 300)
reply(`▧⃯⃟𝚂𝚘𝚛𝚝𝚎𝚊𝚗𝚍𝚘 𝙳𝚊𝚍𝚘ฺ͘.•🛸 ݈݇─`)
dadoale = Math.floor(Math.random() * 5) + 1
enviarfigu(`./database/figu/${dadoale}.webp`)
}
break

case 'caraoucoroa':
setTimeout(() => {reagir(from, "🪙")}, 300)
if(!isModobn) {
setTimeout(() => {reagir(from, "❌")}, 300)
return reply(enviar.msg.modobz)
} else {
enviarfigu(`./database/figu/caraoucoroa.webp`)
setTimeout(async() => {
cr1 = [`cara 😎`, `coroa 👑`]
txtcr = `ೈ፝͜͡𝙈𝙊𝙀𝘿𝘼 𝙎𝙊𝙍𝙏𝙀𝘼𝘿𝘼:
> ${cr1[Math.floor(Math.random()*cr1.length)]}`
reply(txtcr)
}, 1000)
}
break

case 'jogodavelha':
if(!isGroup) return reply(enviar.msg.grupo)
if(!menc_jid2) return reply("Marque junto com o comando, o @ do usuário que deseja desafiar..")
if(menc_os2.includes(botNumber)) return reply("Estou aqui para ser mediador e não jogador...")
joguinhodavelhajs.push(sender)
fs.writeFileSync('./database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.push(from)
fs.writeFileSync('./database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
if(fs.existsSync(`./armor/tictactoe/db/${from}.json`)) {
const boardnow = setGame(`${from}`);
const matrix = boardnow._matrix;
const chatMove = `*🎮Ꮐ̸Ꭺ̸Ꮇ̸Ꭼ̸ Ꭰ̸Ꭺ̸ Ꮩ̸Ꭼ̸Ꮮ̸Ꮋ̸Ꭺ̸🕹️*
     
[❗] Alguém está jogando no momento...\n\n@${boardnow.X} VS @${boardnow.O}
     
❌ : @${boardnow.X}
⭕ : @${boardnow.O}
     
 Sua vez : @${boardnow.turn == "X" ? boardnow.X : boardnow.O}
     
${matrix[0][0]}  ${matrix[0][1]}  ${matrix[0][2]}
${matrix[1][0]}  ${matrix[1][1]}  ${matrix[1][2]}
${matrix[2][0]}  ${matrix[2][1]}  ${matrix[2][2]}
`;
blackmd.sendMessage(from, {text: chatMove}, {quoted: seloctt,
mentions: [
boardnow.X + "@s.whatsapp.net",
boardnow.O + "@s.whatsapp.net",
]});
return;
}
if(argss.length === 1)
return reply(`*⟅❗⟆ Jogue com Alguem!!!!*
*para inicar a partida : ${prefix + command} @membro do gp*`);
const boardnow = setGame(`${from}`);
console.log(`Start No jogodavelha ${boardnow.session}`);
boardnow.status = false;
boardnow.X = sender.replace("@s.whatsapp.net", "");
boardnow.O = argss[1].replace("@", "");
var blabord = [`${boardnow.X}`, `${boardnow.O}`]
fs.writeFileSync(`./armor/tictactoe/db/${from}.json`,
JSON.stringify(boardnow, null, 2)
);
const strChat = `*『📌ᎬՏᏢᎬᎡᎪΝᎠϴ ϴ ϴᏢϴΝᎬΝͲᎬ⚔️』*
     
@${sender.replace("@s.whatsapp.net",
"")} _está te desafiando para uma partida de jogo da velha..._
_[ ${argss[1]} ] Use *『S』* para aceitar ou *『N』* para não aceitar..._\n\nEm caso de problemas, marque algum administrador para resetar o jogo com o comando ${prefix}rv`;
b = [sender, menc_jid]
mentions(strChat, b, true)
break

case 'resetarvelha':
case 'resetavelha':  
case 'resetarv':
case 'resetav': 
case 'resetvelha':
case 'rv': 
if(!isJoguin && !isGroupAdmins) return reply(`Fale com quem iniciou o jogo, só ele pode resetar, ou então algum ADM`)
if(fs.existsSync("./armor/tictactoe/db/" + from + ".json")) {
DLT_FL("./armor/tictactoe/db/" + from + ".json");
reply(`Jogo da velha resetado com sucesso nesse grupo!`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./database/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
} else {
reply(`Não a nenhuma sessão em andamento...`);
}
break

case 'ppt':
if(args.length < 1) return reply(`Você deve digitar ${prefix}ppt pedra, ${prefix}ppt papel ou ${prefix}ppt tesoura`)
ppt = ["pedra", "papel", "tesoura"]
ppy = ppt[Math.floor(Math.random() * ppt.length)]
ppg = Math.floor(Math.random() * 1) + 10
pptb = ppy
if((pptb == "pedra" && args == "papel") ||
(pptb == "papel" && args == "tesoura") ||
(pptb == "tesoura" && args == "pedra")) {
var vit = "vitoria"
} else if((pptb == "pedra" && args == "tesoura") ||
(pptb == "papel" && args == "pedra") ||
(pptb == "tesoura" && args == "papel")) {
var vit = "derrota"
} else if((pptb == "pedra" && args == "pedra") ||
(pptb == "papel" && args == "papel") ||
(pptb == "tesoura" && args == "tesoura")) {
var vit = "empate"
} else if(vit = "undefined") {
return reply(`Você deve digitar ${prefix}ppt pedra, ${prefix}ppt papel ou ${prefix}ppt tesoura`)
}
if(vit == "vitoria") {
var tes = "*Vitória do jogador* 🙇🏻‍♂️"
}
if(vit == "derrota") {
var tes = "*A vitória é do BOT* 🤖"
}
if(vit == "empate") {
var tes = "*O jogo terminou em empate* 🤜🏽🤛🏽"
}
reply(`${NomeDoBot} *jogou:*
> ${pptb}

${pushname} *jogou:*
> ${args}`)
setTimeout(async() => {
reply(tes)
}, 2000)
break

case 'cassino':
inicio_frutas = ['🍊', '🍒', '🍐', '🔔', '🍇', '🍌']
total_frutas = []
for(a of inicio_frutas) {
  for(b = 0; b < inicio_frutas.length; b++) {
    for(c = 0; c < inicio_frutas.length; c++) {
      total_frutas.push(`${a}/${inicio_frutas[b]}/${inicio_frutas[c]}`)
    }
  }
}
random_frutas = total_frutas[alerandom(total_frutas.length)]
var [ft1, ft2, ft3] = random_frutas.split("/")
if(ft1 == ft2 && ft2 == ft3) { victory = "VOCÊ GANHOU !!!"
addCoinsInVirtualBalance(sender, 0.1)
} else { victory = "ㅤVocê perdeu..." }
const cassino = (result, vic) => {return `
ㅤㅤㅤ┏━━━━❪🎰❫━━━━\t\t\t\t
ㅤㅤㅤ┣► ${result}◄┛
ㅤㅤㅤ┗━━━━❪💰❫━━━━

ㅤㅤㅤ  ${vic ? `*`+vic+`*` : ``}`}
let { key } = await blackmd.sendMessage(from, {text: cassino(`❗ : ❗ : ❗`)}, {quoted: info})
await sleep(700)
await blackmd.sendMessage(from, {text: cassino(`❓ : ❓ : ❓`), edit: key}, {quoted: info})
await sleep(700)
await blackmd.sendMessage(from, {text: cassino(`${ft1} : ❓ : ❓`), edit: key}, {quoted: info})
await sleep(700)
await blackmd.sendMessage(from, {text: cassino(`${ft1} : ${ft2} : ❓`), edit: key}, {quoted: info})
await sleep(700)
await blackmd.sendMessage(from, {text: cassino(`${ft1} : ${ft2} : ${ft3}`), edit: key}, {quoted: info})
await sleep(700)
await blackmd.sendMessage(from, {text: cassino(`${ft1} : ${ft2} : ${ft3}`, victory), edit: key}, {quoted: info})
break

case 'eununca':
reagir(from, "❤️‍🔥")
if(!isModobn) return reply(enviar.msg.modobz)
const euja1 = ['Eu nunk fiquei com dois/duas numa festa', 'Eu nunk meti chifre no namorado (a)', 'Eu nunk fui corno', 'Eu nunk roubei nada do supermercado', 'Eu nunk beijei alguém do mesmo sexo que eu', 'Eu nunk parei alguém na rua achando que era um conhecido', 'Eu nunk joguei fora a comida e fiz que comi', 'Eu nunk fuji de casa', 'Eu nunk fiz coisas +18 em casa', 'Eu nunk fumei ou usei drogas']
euja2 = euja1[Math.floor(Math.random() * (euja1.length))]
eununcatxt = `*_Sorteando..._*

> _"${euja2}"_`
sendAsPoll(from, eununcatxt, ["Eu já 🌚", "Eu nunca 🌝"])
break

//==(AUDIOS/DE-MUSICA/ZOUEIRA/ETC..)===\\

case 'bot': case 'boot':
setTimeout(() => {reagir(from, "😡")}, 300)
const soundft = fs.readFileSync('./database/audios/qsaco.m4a')
blackmd.sendMessage(from, {audio: soundft, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
break

case 'infobot':
setTimeout(() => {reagir(from, "👻")}, 300)
const cmdoo = fs.readFileSync('./database/audios/infobot.m4a')
blackmd.sendMessage(from, {audio: cmdoo, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
break 

//=======================================\\


//=====(ALTERADOR-DE-AUDIO/VIDEO)=======\\

case 'videocontrario':
case 'reversemp4':
if((isMedia && info.message.videoMessage || !isQuotedImage) && !q.length <= 1) { 
reply(enviar.espere)
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -vf reverse -af areverse ${ran}`, (err) => {
DLT_FL(media)
if(err) return reply(`Err: ${err}`)
buffer453 = fs.readFileSync(ran)
blackmd.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: seloctt})
DLT_FL(ran)
})
} else {
reply("Marque um vídeo..")
}
break 

case 'videolento':
case 'slowvid':  
if((isMedia && info.message.videoMessage || !isQuotedImage) && !q.length <= 1) {
reply(enviar.espere) 
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -filter_complex "[0:v]setpts=2*PTS[v];[0:a]atempo=0.5[a]" -map "[v]" -map "[a]" ${ran}`, (err) => {
DLT_FL(media)
if(err) return reply(`Err: ${err}`)
buffer453 = fs.readFileSync(ran)
blackmd.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: seloctt })
DLT_FL(ran)
})
} else {
reply("Marque um vídeo..")
}
break

case 'videorapido':
case 'fastvid':  
if((isMedia && info.message.videoMessage || !isQuotedImage) && !q.length <= 1) {
reply(enviar.espere)
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -filter_complex "[0:v]setpts=0.5*PTS[v];[0:a]atempo=2[a]" -map "[v]" -map "[a]" ${ran}`, (err) => {
DLT_FL(media)
if(err) return reply(`Err: ${err}`)
buffer453 = fs.readFileSync(ran)
blackmd.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: seloctt })
DLT_FL(ran)
})	
} else {
reply("Marque o vídeo..")
}
break

case 'grave2':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=1.6,asetrate=22100" ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o áudio..")
}
break

case 'grave':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=44100" ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o áudio..")
}
break

case 'adolesc':
case 'vozmenino':  
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a atempo=1.06,asetrate=44100*1.25 ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o áudio..")
}
break  

case 'tomp3':
case 'viraraudio':
setTimeout(() => {reagir(from, "✅")}, 300)
if((isMedia && !info.message.imageMessage || isQuotedVideo)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.videoMessage
reply(`❪∘̥⃟⸽⃟𝙲𝚘𝚗𝚟𝚎𝚛𝚝𝚎𝚗𝚍𝚘 𝙴𝚖 Á𝚞𝚍𝚒𝚘∘̥⃟৴▸`)
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane 
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} ${ran}`, (err) => { 
DLT_FL(media)
if(err) return reply('❌ Falha ao converter vídeo para mp3 ❌')
buffer = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: buffer, mimetype: 'audio/mp4'}, {quoted: seloctt})
DLT_FL(ran)
})
} else {
reply("Marque o vídeo para transformar em áudio por favor..")
}
break

case 'shazam': {
    if (!isVip) return reply(enviar.msg.vip);
    if (!isQuotedAudio) return reply('⚠️ Envie o áudio para eu detectar o nome da música!');

    try {
        let music = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage, 'audio');
        let mime = info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage.mimetype;
        let m = mime.split('/')[1];
        let filePath = `./armor/assets/${sender}.${m}`;
        fs.writeFileSync(filePath, music);
        let base64 = fs.readFileSync(filePath, { encoding: "base64" });

        // Detectar música com a função arcloud
        let resultado = await arcloud(base64);

        if (!resultado || !resultado[0] || !resultado[0].titulo) {
            DLT_FL(filePath);
            return reply('Desculpe, não consegui identificar a música. Por favor, tente novamente!');
        }

        // Nova pesquisa com o título retornado pelo arcloud
        let data = await fetchJson(`https://world-ecletix.onrender.com/api/pesquisayt?query=${encodeURIComponent(resultado[0].titulo)}`);

        if (!data || !data.formattedVideos || data.formattedVideos.length === 0) {
            DLT_FL(filePath);
            return reply("Desculpe, não consegui encontrar a música.");
        }

        const firstResult = data.formattedVideos[0];
        let N_E = " Não encontrado.";
        let txt = `
        🎙️⃤ Título: ${firstResult.title || N_E}
        ⏰⃤ Tempo: ${firstResult.duration || N_E}
        📹⃤ Canal: ${firstResult.channel || N_E}
        👁️⃤ Visualizações: ${firstResult.views || N_E}

        ■■■■■ 100%

        Se desejar baixar o vídeo, use ${prefix}play_video ${firstResult.link.trim()}
        `;

        reagir(from, `⚡`);
        blackmd.sendMessage(from, {
            image: { url: firstResult.thumbnail || logoslink?.logo },
            caption: txt
        }, { quoted: info });

        // Enviar música como nota de voz
        blackmd.sendMessage(from, {
            audio: {
                url: `https://world-ecletix.onrender.com/api/musica?name=${encodeURIComponent(firstResult.title)}`
            },
            mimetype: "audio/mpeg",
            fileName: firstResult.title || "shazam.mp3",
            ptt: true
        }, { quoted: info });

        DLT_FL(filePath);
    } catch (e) {
        console.log(e);
        return reply("Erro ao identificar ou buscar a música.");
    }
}
break;

case 'bass3':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=20:width_type=o:width=2:g=15 ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o áudio..")
}
break

case 'bass': 
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=20:width_type=o:width=2:g=15 ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o áudio..")
}
break

case 'bass2': 
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=94:width_type=o:width=2:g=30 ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o áudio..")
}
break

case 'estourar': 
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=90:width_type=o:width=2:g=30 ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o áudio..")
}
break

case 'fast':
case 'audiorapido':  
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=95100" ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o áudio...")
}
break

case 'esquilo':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.7,asetrate=65100" ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o áudio...")
}
break

case 'audiolento': 
case 'slow':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(enviar.espere)
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=44100" ${ran}`, (err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Erro!')
hah = fs.readFileSync(ran)
blackmd.sendMessage(from, {audio: hah, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
DLT_FL(ran)
})
} else {
reply("Marque o áudio..")
}
break

//==========(EFEITOS-MARCAR)==========\\
// CANVA // CANVAS // EDIÇÃO DE FOTOS
case 'togif':
if(!isQuotedSticker) return reply('*[ ❗ ] Marque a figurinha animada!*')
if(info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.stickerMessage && info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.stickerMessage?.isAnimated) {
let media = await downloadAndSaveMediaMessage(info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.stickerMessage)
try {
reply('[❗] convertendo em gif, aguarde ♨')
a = await webp_mp4(media)
mp4 = await getBuffer(a.result)
blackmd.sendMessage(from, {video: mp4, gifPlayback: true, filename: `stick.gif`}, {quoted: info})
} catch(e) {
console.log(e)
reply('Erro ao converter para gif')
}
await fs.unlinkSync(media)
} else {
reply('*[ ❗ ] Marque a figurinha animada!*')
}
break

case 'cartonizar': case 'cartoon':
try { 
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
link = await upload(owgi)
reply(`[❗] Desenhando pixel a pixel, isso pode demorar 💢`)
blackmd.sendMessage(from, {image: {url:`http://br3.bronxyshost.com.br:4017/imagem/cartoon?img=${link}&apitoken=Yuta-Channel`}}, {quoted: info}).catch(e => {
return reply("Erro..")
})
} else {
reply('Marque uma imagem com rosto visível!') 
}
} catch (e) {
reply('ERROR!!')
}
break

case 'toanime': case 'tohd': case 'tozombie':
if(!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
link = await upload(owgi)
reply(`[❗] Desenhando pixel a pixel, isso pode demorar 💢`)
ABC = await fetchJson(`https://blacksystemofc.com.br/api/ia/${command}?link=${link}&apikey=black`)
sendImage(from, ABC.resultado.image_data).catch(e => {
return reply("Erro ao converter a imagem")
})
} else {
reply('Marque uma imagem para eu atribuir o efeito')
}
break

case 'perfilzap':
    try {
        if (!q.includes('/')) {
            return reply('⚙️ Use o formato: .perfilzap Nome/Número/Bio/Horas marcando a foto.');
        }

        let imageUrl;
        
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            imageUrl = await upload(owgi); // Gera o link da imagem marcada
        } else {
            return reply('⚙️ Você precisa marcar uma foto para usar nesta função.');
        }

        const [nome, numero, bio, horas] = q.split('/');

        reply(`✍️ Criando seu perfil zap personalizado, aguarde...`);

        const perfilZapApi = `https://kamuiapi.shop/api/canvas/perfilzap?nome=${encodeURIComponent(nome)}&numero=${encodeURIComponent(numero)}&bio=${encodeURIComponent(bio)}&horas=${encodeURIComponent(horas)}&perfil=${encodeURIComponent(imageUrl)}&apikey=YT8q4bUNXV`;

        const response = await axios.get(perfilZapApi, { responseType: 'arraybuffer' });
        const resultImage = Buffer.from(response.data, 'binary');

        await blackmd.sendMessage(from, {
            image: resultImage,
            caption: `✅ Aqui está seu perfil zap personalizado!`,
        }, { quoted: info });

    } catch (error) {
        console.error('Erro no .perfilzap:', error);
        reply('🚨 Ocorreu um erro ao tentar gerar seu perfil zap.');
    }
    break;
case 'Vasco-edit':
case 'vasco-edit':
    try {
        if (!q.includes('/')) {
            return reply('⚙️ Use o formato: .vasco-edit Título/Nome marcando a foto.');
        }

        let imageUrl;
        
        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            imageUrl = await upload(owgi); // Aqui ele gera o link da foto marcada
        } else {
            return reply('⚙️ Você precisa marcar uma foto para usar nesta função.');
        }

        const [titulo, nome] = q.split('/');

        reply(`✍️ Processando a imagem do ${nome}, aguarde...`);

        const vascoApi = `https://kamuiapi.shop/api/canvas/vasco?titulo1=${encodeURIComponent(titulo)}&nome=${encodeURIComponent(nome)}&perfil=${encodeURIComponent(imageUrl)}&apikey=YT8q4bUNXV`;

        const response = await axios.get(vascoApi, { responseType: 'arraybuffer' });
        const resultImage = Buffer.from(response.data, 'binary');

        await blackmd.sendMessage(from, {
            image: resultImage,
            caption: `✅ Aqui está a imagem personalizada do ${nome}!`,
        }, { quoted: info });

    } catch (error) {
        console.error('Erro no .vasco-edit:', error);
        reply('🚨 Ocorreu um erro ao tentar gerar a imagem do Vasco.');
    }
    break;
    case 'editvermelha':
case 'editbranca':
case 'editroxo':
    try {
        if (!q) {
            return reply('⚙️ Envie o nome que deseja usar. Exemplo: .editvermelha Dantes');
        }

        let imagemFixa;
        if (command === 'editvermelha') {
            imagemFixa = 'https://telegra.ph/file/d3f32c55c57b738806acf.png';
        } else if (command === 'editbranca') {
            imagemFixa = 'https://i.pinimg.com/564x/96/70/98/967098685058d9b14f5b715fd43e88d1.jpg';
        } else if (command === 'editroxo') {
            imagemFixa = 'https://telegra.ph/file/edd98b4aefa226c05e60d.jpg';
        }

        const urlApi = `https://kamuiapi.shop/api/canvas/${command}?nick=${encodeURIComponent(q)}&img=${encodeURIComponent(imagemFixa)}&apikey=YT8q4bUNXV`;

        const { data } = await axios.get(urlApi, { responseType: 'arraybuffer' });

        await blackmd.sendMessage(from, {
            image: Buffer.from(data, 'binary'),
            caption: `✅ Aqui está sua imagem personalizada!`,
        }, { quoted: info });
    } catch (error) {
        console.error('Erro ao gerar imagem edit:', error);
        reply('🚨 Ocorreu um erro ao gerar a imagem.');
    }
    break;

case 'interro':
case 'brasil':    
case 'adorartv':
case 'lolifofaa':
case 'lolifofa':
case 'lolinopc':
case 'carinho':
    try {
        let imageUrl;

        if ((isMedia && !info.message.videoMessage) || isQuotedImage) {
            let boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage;
            let owgi = await getFileBuffer(boij, 'image');
            imageUrl = await upload(owgi); // gera link da imagem
        } else {
            return reply('⚙️ Marque uma foto para usar.');
        }

        reply('🔄 Processando sua imagem, aguarde...');

        const endpoint = command; // pega o nome do comando atual (.adorartv, .lolifofaa, etc)
        const apiUrl = `https://kamuiapi.shop/api/canvas/${endpoint}?img=${encodeURIComponent(imageUrl)}&apikey=YT8q4bUNXV`;

        const response = await axios.get(apiUrl, { responseType: 'arraybuffer' });
        const mediaBuffer = Buffer.from(response.data, 'binary');

        const mediaType = endpoint === 'carinho' ? { video: mediaBuffer } : { image: mediaBuffer };

        await blackmd.sendMessage(from, {
            ...mediaType,
        }, { quoted: info });

    } catch (error) {
        console.error(`Erro no .${command}:`, error);
        reply('🚨 Erro ao tentar gerar a imagem.');
    }
    break;    
case 'affect': case 'comunismo': case 'mms': case 'bobross': case 'bolsonaro': case 'blur': case 'beautiful': case 'circle': case 'del': case 'invert': case 'facepalm': case 'rip': case 'wasted': case 'wanted': case 'trash': case 'sepia': case 'pixelate': case 'lgbt':
if(!isVip && !isGroup) return reply(enviar.msg.pvnotvip)
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
try {
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
link = await upload(owgi)
reply(`[❗] Desenhando pixel a pixel, isso pode demorar 💢`)
sendImage(from, `https://blacksystemofc.com.br/api/canvas/${command}?link=${link}&apikey=black`)
} catch {
return reply("Erro ao converter a imagem")
}
} else {
reply('Marque uma imagem para eu atribuir o efeito')
}
break

//=======(FIM-EFEITOS-MARCAR)=========\\

default:

if(isGroup && isBotGroupAdmins && !isGroupAdmins) {
if(isAntiCtt || Antiloc || isAnticatalogo) {
if(type === 'contactMessage' || type === 'contactsArrayMessage' || type === 'locationMessage' || type === 'productMessage') {
if(isGroupAdmins) return blackmd.sendMessage(from, {text: `Uma dessas opções estão ativada, mas por você ser ADM, não será removido(a) _(ANTI CONTATO - ANTI CATALOGO - ANTI LOCALIZAÇÃO)`}, {quoted: seloctt})
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
clear = `🗑${"\n".repeat(255)}🗑️\n❲❗❳ *Lɪᴍᴘᴇᴢᴀ ᴅᴇ Cʜᴀᴛ Cᴏɴᴄʟᴜɪ́ᴅᴀ* ✅`
blackmd.sendMessage(from, {text: clear, contextInfo : { forwardingScore: 500, isForwarded:true}})
blackmd.sendMessage(from, {text: 'reporte aos adm o ocorrido ', mentions: groupAdmins})
}}}

if(isGroup && isAntiFlood && !isOwner && !isVip && !isnit && isBotGroupAdmins && !isGroupAdmins && !isBot) { 
if(isLimitec == null){
var limitefl = limitefll.limitefl
} else {
var limitefl = isLimitec
}
if(budy.length >= limitefl){
setTimeout( () => {
return reply('Muitas Caracteres enviadas, isto é contra as normas do grupo, por precaução, eu irei remover.')
console.log(colors.red('Deram Spam de caracteres..'))
}, 100)
setTimeout(async () => {
setTimeout(() => {
blackmd.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 1500)
if(!JSON.stringify(groupMembers).includes(sender)) return  
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}, 1000)
}
}

switch(testat){
}

const EnvAudio_SMP = async (direcao, nome1, nome2, nome3, nome4, nome5) => {
bla = [nome1, nome2, nome3, nome4, nome5]
for ( i of bla) {
if(i == undefined) return  
if(messagesC.includes(i)) {
blackmd.sendMessage(from, {audio: {url: direcao}, mimetype: "audio/mp4", ptt:true})
}}}

const EnvAudio2_SMP = async (direcao, nome1, nome2, nome3, nome4, nome5) => {
bla = [nome1, nome2, nome3, nome4, nome5]
for ( i of bla) {
if(i == undefined) return  
if(messagesC.includes(i)) {
blackmd.sendMessage(from, {audio: {url: direcao}, mimetype: "audio/mp4", ptt:true})
}}}

const EnvTXT_SMP = async (texto, nome1, nome2, nome3, nome4, nome5) => {
bla = [nome1, nome2, nome3, nome4, nome5]
for ( i of bla) {
if(i == undefined) return  
if(messagesC.includes(i)) {
blackmd.sendMessage(from, {text: texto})
}}}

const EnvAudio2_GTTS = async (lingua, texto, txt1, txt2, txt3, txt4, txt5) => {
bla = [txt1, txt2, txt3, txt4, txt5]
for ( i of bla) {
if(i == undefined) return
if(budy2.includes(i)) {
var gtt = require('./armor/funcoes/gtts')(lingua)
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
gtt.save(ranm, texto, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
DLT_FL(ranm)
buffer = fs.readFileSync(rano)
blackmd.sendMessage(from, {audio: buffer, ptt:true}, {quoted: seloctt})
DLT_FL(rano)
})
})
}}}

var hora_sla = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

EnvAudio2_GTTS("pt", `São ${realtime()}`, "que horas sao?")

/*EnvTXT_SMP(prefix, "prefixo")*/

if(budy2.includes("luan") && !isOwner){
matheustxt = [`Tá falando do meu programador ? 🫵🏽🤨`, `O que você quer com meu dono ? 🔪`, `O que você quer com meu programador ? 😡`, `Vou falar pro meu dono que você anda falando dele por aí 😐👍🏽`]
sendButton(from, {text: matheustxt[Math.floor(Math.random()*matheustxt.length)], footer: NomeDoBot}, blackmd, sender, [{type: `cmd`, text: `👑 𝙈𝙀𝙐 𝘿𝙊𝙉𝙊 👑`, command: `${prefix}dono`}], seloctt)
await sleep(500)
blackmd.sendMessage(obrigadoEXT.idprivategp, {text: `${pushname} tava falando de tu ${isGroup ? `no grupo ${groupName} 😐👍🏽` : `no meu PV...`}`}, {quoted: info})
}

if(budy2 === `abrir grupo` && isGroup && isGroupAdmins && isBotGroupAdmins && groupMetadata.announce == true) {
setTimeout(() => {reagir(from, "✅")}, 300)
blackmd.groupSettingUpdate(from, 'not_announcement')
reply(`✅ *${tempo} à todos... O grupo foi aberto novamente*`)
}

if(budy2 === `fechar grupo` && isGroup && isGroupAdmins && isBotGroupAdmins && groupMetadata.announce == false) {
setTimeout(() => {reagir(from, "🚫")}, 300)
blackmd.groupSettingUpdate(from, 'announcement')
reply(`🚫 *Grupo fechado... As suas ordens vossa senhoria*`)
}

if(budy2 === 'prefixo' && !isBanchat) {
reagir(from, "🥰")
reply(`*Prefixo de comandos usado〘 ${prefix} 〙 ❤️‍🔥*`)
}

if(!isNaN(budy2) && isJsonIncludes(nicks, sender)) {
  AB = nicks.map(i => i.id).indexOf(sender)
  caixa = []
  for(i of nicks[AB].titulos) {
    if(Number(budy2) === Number(i.nmr)) caixa.push(i.txt)
  }
  if(caixa.length > 0) {
    blackmd.sendMessage(from, {text: caixa[0], contextInfo: {isForwarded: true, forwardingScore: 1}}, {quoted: seloctt})
    if(nicks[AB].quant > 1) {
      nicks[AB].quant -= 1
      saveJSON(nicks, "./basededados/nicks.json")
    } else {
      nicks.splice(AB, 1)
      saveJSON(nicks, "./basededados/nicks.json")
    }
  }
}

if(isJsonIncludes(waitFriendZone, sender)) {
  mini = rmLetras(budy2)
  if(isGroup && isGroupOfPedidoFriendZone(sender, from)) {
    if(isWaitUsuFZ_namoro(sender)) {
      if(mini == "sim" || mini == "s") {
        aceitarPedidoDeNamoro(sender)
        return sendButton(from, {text: `💞 Felicitações @${getDBFZuser(sender).usu2}, parece que o @${sender.split("@")[0]} aceitou seu pedido de namoro... Seus dados podem ser acessados no comando ${prefix}dupla 🥰`, mentions: [identArroba(getDBFZuser(sender).usu2), sender], footer: NomeDoBot}, blackmd, sender, [{type: `cmd`, text: `𝙈𝙄𝙉𝙃𝘼 𝘿𝙐𝙋𝙇𝘼 💘`, command: prefix+`dupla`}], seloctt)
      }
      if(mini == "nao" || mini == "n") {
        A1 = waitFriendZone.map(i => i.id).indexOf(sender)
        mention(`😔 Sinto muito @${waitFriendZone[A1].pedido}, parece que o usu ${pushname} recusou seu pedido de namoro...`)
        return recusarPedidoDeNamoro(sender)
      }
    }
    if(isWaitUsuFZ_casamento(sender)) {
      if(mini == "sim" || mini == "s") {
        aceitarPedidoDeCasamento(sender)
        return sendButton(from, {text: `💍 Felicitações @${getDBFZuser(sender).usu2}, parece que o @${sender.split("@")[0]} aceitou seu pedido de casamento... Seus dados foram atualizados no comando ${prefix}dupla 👻`, mentions: [identArroba(getDBFZuser(sender).usu2), sender], footer: NomeDoBot}, blackmd, sender, [{type: `cmd`, text: `𝙈𝙄𝙉𝙃𝘼 𝘿𝙐𝙋𝙇𝘼 💞`, command: prefix+`dupla`}], seloctt)
      }
      if(mini == "nao" || mini == "n") {
        recusarPedidoDeCasamento(sender)
        mention(`😪 Sinto muito @${getDBFZuser(sender).usu2}, parece que o usu @${sender.split("@")[0]} recusou seu pedido de casamento... Felizmente, vocês ainda são um casal de namorados 🥰`)
      }
    }
  }
}

//fim das funções do namoro/casamento

//ads func
// FUNÇÕES DE AUDIO E AUTORESPOSTA
if(isGroup && isGroupAdmins && existAdminAds(from, sender) && budy2.length > 1) {
  letra = budy2.toLowerCase().slice(budy2.length - 1, budy2.length)
  if((letra == "h" || letra == "m") && Number(budy2.split(letra)[0])) {
    gaa = getAdminAds(from, sender)
    isimg = gaa.imagem.length > 0 ? true : false
    addAds(from, sender, budy2)
    mention(`*O anúncio foi setato no grupo ${groupName} a cada ${budy2} pelo adm @${sender.split("@")[0]} com sucesso* ✅\n\n*Caso queira ativar a menção do ads, use* ${prefix}ama ${gaa.id}`)
    setTimeout(() => {
      if(isimg) {
        blackmd.sendMessage(from, {image: {url: gaa.imagem[0]}, caption: gaa.text, contextInfo: {forwardingScore: 1, isForwarded: true}})
      } else {
        blackmd.sendMessage(from, {text: gaa.text, contextInfo: {forwardingScore: 1, isForwarded: true}})
      }
    }, 500)
  }
}
if (budy2.toLowerCase() === "oi") {
  console.log('[DEBUG] Mensagem "oi" detectada');
  const nome = pushname || "usuário";
  const resp = [
    `${tempo} ${nome}, posso ajudar em algo?`,
    `${tempo} ${nome}, como você está?`,
    `${tempo} ${nome}, tudo bem por aqui?`
  ];
  reply(resp[alerandom(resp.length)]);
}

if (budy2.toLowerCase().startsWith('chatgpt') && args.length > 0) {
  reagir(from, "🤖")
  try {
    const ABC = await fetchJson(`https://world-ecletix.onrender.com/api/chatgpt?texto=` + encodeURIComponent(q))
    reply(ABC.response) // Corrigido de resultado para resposta
  } catch (e) {
    reply('Erro')
  }
}

if(budy2 === "menu" && !isBanchat && !isBotoff) {
reagir(from, "👀")
sendButton(from, {text: "Fl ✋🏽😳🤚🏽", footer: `${tempo} ${pushname}`}, blackmd, sender, [{type: `cmd`, text: `𝙈𝙀𝙉𝙐 ✨`, command: prefix+`menu`}], seloctt)
}

if(isAutorepo) {

if(audios.length > 0 && isGroup) {
  for(i of audios) {
    caminho = `./database/audios/save/${i.rm}`
    if(rmLetras(budy2).includes(i.txt) && fs.existsSync(caminho)) {
      if(i.emoji.length > 0) reagir(from, i.emoji)
      blackmd.sendMessage(from, {audio: {url: caminho}, mimetype: `audio/mpeg`, ptt: true}, {quoted: seloctt})
    }
  }
}


if (budy2.toLowerCase().startsWith('lady') && args.length > 0) {
  reagir(from, "🤩")
  try {
    const ABC = await fetchJson(`https://world-ecletix.onrender.com/api/lady?texto=` + encodeURIComponent(q))
    reply(ABC.resposta) // Corrigido de resultado para resposta
  } catch (e) {
    reply('Erro')
  }
}
 
if(budy2.toLowerCase().startsWith('simi') && args.length > 0 && isGroup) {
setTimeout(() => {reagir(from, "😍")}, 300)
try {
datasimi = await fetchJson(`https://api.simsimi.vn/v1/simtalk`, {method: 'POST',
headers: {'content-type': "application/x-www-form-urlencoded"},
body: "text="+q+"&lc=pt"})
const gtts = require('./armor/funcoes/gtts')(`pt`)
dtt = datasimi.message
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
gtts.save(ranm, dtt, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
blackmd.sendMessage(from, {audio: fs.readFileSync(ranm), ptt:true, mimetype: "audio/mp4"}, {quoted: seloctt}).catch(e => {
return reply("Erro..")
})
DLT_FL(ranm)
DLT_FL(rano)
})
})
} catch (e){
return reply("Nsei")
}
}

if(budy2.toLowerCase().startsWith('jeff') && args.length > 0 && isGroup) {
setTimeout(() => {reagir(from, "🤓")}, 300)
try {
datasimi = await fetchJson(`https://api.simsimi.vn/v1/simtalk`, {method: 'POST',
headers: {'content-type': "application/x-www-form-urlencoded"},
body: "text="+q+"&lc=pt"})
return reply(datasimi.message)
} catch (e){
return reply("Nsei")
}
}

if(budy2 === "bot") {
blars = ["Oi delícia", "Oi amor da minha vida", "Oi princesa do meu coração"] 
blarnd = blars[Math.floor(Math.random() * blars.length)]
reply(blarnd)
}

if(budy2.includes("bot corno")){
if(info.key.fromMe) return 
reply("Corno é você, seu animal")
}

if(budy2 === ":)") {
blackmd.sendMessage(from, {text: `hihi ^-^`})
}

if(budy2.toLowerCase() === "f") {
blackmd.sendMessage(from, {text: '```Press F no chat```'})
}

if(budy2.toLowerCase() === "kkkk") {
reagir(from, "😂")
}

if(budy2.toLowerCase() === "bot fdp") {
setTimeout(() => {reagir(from, "🤬")}, 300)
reply(`FILHO DA PUTA, VOU COMER SEU CU. ARROMBADO DO CARALHO, SUA MÃE ALUGA A BUCETA PRA COMPRAR FIXADOR DE DENTADURA PRO SEU PAI, AQUELE CORNO BROXA. CHIFRUDO, VOU ENFIAR MEU BRAÇO NO SEU ÂNUS E ARRANCAR SEU INTESTINO. LOGO DEPOIS VOU ENFORCAR SUA AVÓ COM ELE, AQUELA VELHA BISCATE QUE FAZ CROCHÊ PRA FORA EM TROCA DE PICA.\n\nSUAS TIAS TÊM PÊLO NO DENTE E SUA IRMÃ TEM POLENGUINHO NA VIRILHA, SEU GRANDE FILHO DA PRÊULA. SUA MÃE DAVA LEITE DA CABEÇA DO PAU DO SEU PAI PRA VOCÊ BEBER, FILHO DA PUTA. ISSO MESMO, VOCÊ TOMAVA MAMADEIRA DE PORRA DESDE CRIANÇA. POR ISSO É O RETARDADO MENTAL QUE É HOJE, SEU ZÉ BEBEDOR DE SUCO DE CARALHO.\n\nO PADRE TE BENZEU COM ÁGUA PARADA, HOJE VOCÊ SOFRE OS EFEITOS RETARDADOS DO AEDES AEGYPT QUE SE ALOJA DENTRO DO SEU OUVIDO, SEU MONTE DE ESTERCO. SEU AVÔ ARROMBADO USA FRALDA E TE OBRIGA A LIMPAR OS CAGÕES DELE COM UMA COLHER DE DANONINHO, SEU CAPACHO DO CARALHO.\n\nSUA MÃE TE FAZ DORMIR COM O REX, AQUELE CHIUAUA FILHO DA PUTA E CHEIO DE SARNA. E DURANTE A MADRUGADA O REX ABUSA SEXUALMENTE DE VOCÊ, ATÓLA A PATINHA DENTRO DESSE SEU CU PELÚDO, SEU FRACASSADO. LEMBRA DA JANDIRA, AQUELA SUA PRIMA MONOTETA ? POIS É, ENFIEI UM TACO DE BASEBALL NO CU DELA. A MÃE DELA DEU O FLAGRANTE NA GENTE E AO INVÉS DE FICAR BRAVA, PEDIU O TACO EMPRESTADO. VADIA DO CARALHO ESSA SUA TIA, SÓ PODE TER APRENDIDO COM SUA MÃE, AQUELA BISCATE.\n\nQUE ALIÁS, CONTINUA CHUPANDO O CARALHO DO ZÉ DO PACOTE, O TRAFICANTE QUE MORA AÍ DO LADO DA SUA CASA DE BARRO, SEU FILHO DUMA MACONHEIRA VAGABUNDA. O CABELO DA SUA MÃE É TÃO RUIM QUE ELA FAZ CHAPINHA NOS PÊLOS DO SOVACO E USA UM DESODORANTE COM CONDICIONADOR CAPILAR, AQUELA VELHA CARCOMIDA DESGRAÇADA.\n\nVOCÊ FOI ENCONTRADO NO LIXO, SEU MERDA. E ATÉ HOJE SUA MÃE PEDE DESCULPAS PRA DEUS PELO PEDAÇO DE MERDA QUE PARIU. ATÉ TE EMBALOU NUM SACO PRETO ANTES DE JOGAR NO LIXO, MAS VOCÊ É TÃO HORRÍVEL QUE UM MENDIGO TE ENCONTROU E QUASE TE COMEU ACHANDO QUE TU ERA UMA LAZANHA, SEU ESCROTO FILHO DA PUTA. SEU PAI VENDE CARTA DE MAGIC ROUBADA PRA JOGAR UMA HORA NA LAN HOUSE E ENTRAR EM SITE PORNÔ. DEPOIS ELE SE MASTURBA E GOZA DENTRO DO SEU TRAVESSEIRO. ISSO MESMO, AQUELA MANCHA BRANCA QUE INSISTE EM APARECER TODA VEZ QUE VOCÊ ACORDA NÃO É SUA SALíVA, SEU FILHO DA PUTA.\n\nVOCÊ SEMPRE FOI O MAIS ALOPRADO DA CLASSE. LEMBRA QUANDO ENFIARAM UM GIZ NO SEU CU ? VOCÊ FICOU UMA SEMANA CAGANDO BRANCO, PARECIA GESSO. E QUANDO VOCÊ IA RECLAMAR COM A PROFESSORA, ELA TE MANDAVA CALAR A BOCA. AQUELA VELHA SEMPRE SOUBE QUE VOCÊ TEM PROBLEMAS MENTAIS, SEU RETARDADO. AÍ VOCÊ TINHA QUE CALAR ESSA SUA BOCA ENQUANTO O GIZ DERRETIA DENTRO DO SEU INTESTINO, HAHA.\n\nFRACASSADO, VÊ SE PASSA UMA GILLETTE NESSE SEU BIGODINHO RIDÍCULO. TU PARECE O MANO BROWN, PORRA. E DÁ UM JEITO NESSAS SUAS TETINHAS DE BRIGADEIRO, ELAS ESTÃO COMEÇANDO A FEDER. TODA VEZ QUE EU PASSO DO SEU LADO, SINTO CHEIRO DE CACHORRO MORTO. QUE ALIÁS, SE ASSEMELHA AO CHEIRO DA XAVASCA DA SUA MÃE, AQUELA LEITOA MALDITA. DIZ PRA ELA CONGELAR O FEIJÃO QUE HOJE EU VOU CHEGAR TARDE, SEU PUTO. SEU FILHO DUMA PUTA DO CARALHO SE ENXERGA PORRA...\n\nVAI TOMAR NO MEIO DA ÍRIS DO OLHO DO TEU CÚ SEU FILHO DUMA VENDEDORA DE PIROCÓPTERO! SEU PAI VENDE BILHETE DE LOTERIA ESPORTIVA NA FRENTE DA SAPATARIA SEU FILHO DUMA PUTA DO CARALHO.! TOMARA Q SUA VÓ ESCORREGUE NO BOX ENQTO TIVER TOMANDO BANHO E CAIA DE TESTA NA SABONETEIRA SEU CORNO DO CARALHO.! QUERO MAIS EH QUE VC SE FODA JUNTO COM TODA A SUA FAMÍLIA AKELE BANDO DE CATADOR DE GARRAFA DO CENTRO COMUNITÁRIO.!\n\nSUA MÃE DA AULA DE MAMULENGO PROS PRESIDIÁRIOS DO CARANDIRÚ SEU FILHO DA PUTA.! SEU PAI ANDA PUXANDO UMA CARROÇA PELA CIDADE CATANDO PAPELÃO PRA DEPOIS FAZER UM PACOTÃO E VENDER TUDO POR 1 REAL! SUA MÃE ENCAPA SEUS LIVROS E CADERNOS COM SACO DE ARROZ TIO JOÃO SEU FILHO DUMA LAVADERA DO CARALHO.! SEU PAI VENDE REDE NO FAROL SEU FILHO DA PUTA.! SEU AVÔ CONSERTA PANELA DE PRESSÃO E AMOLA FACA DE PORTA EM PORTA SEU FILHU DUM PÉ DE AIPIM.! SEU PAI FAZ CARRETO DE KOMBI PORRA... CARALHO.! VAI TOMA NO CÚ SEU FILHO DA PUTA EH ESSA PORRA DESSE CARALHO ESPACIAL VUANU ATRÁS DE VOCÊ PORRA VAI TOMA NO CÚ CARALHO.!\n\nQUERO MAIS EH Q VC SE FODA E QUE A TOWNER Q SEU PAI USA PRA TRABALHAR (PERUEIRO FILHO DA PUTA) PEGUE FOGO COM VC, SUA MÃE, SUA IRMÃ, SUA VÓ E MAIS 3 CLIENTES... SEM CONTAR TBM Q QUERO Q TENHA INFILTRAÇÃO NO SEU BARRACO TODO.! QUERO Q SUA FAMÍLIA TODA SEJA VÍTIMA DUMA EPIDEMIA DE MALÁRIA E FEBRE AMARELA.! E DIGO MAIS! DESEJO QUE VOCÊ TENHA CANCER NO CÉREBRO E QUE SUA MÃE CAIA COM O CÚ NA QUINA DA MESA DA SALA.!\n\nSUA MÃE GUARDA PÉ DE MOLEQUE E SUSPIRO QUE ELA FAZ PRA VENDE EM PACOTE DE MANTEIGA CAMPESINA SEU FILHO DUMA BISCATE RAMPEIRA E SEM DONO DO CARALHO QUERO MAIS EH Q VC MORRA JUNTO COM TODA SUA FAMÍLIA PORRA CARALHO VAI TOMA NO CÚ MERDA VAI SE FUDER... FILHO DUM SACO DE ADUBO MANAH...! SEU PAI FAZ GLOBO DA MORTE DE BARRAFORTE COM SUA MÃE NA GARUPA FILHO DA PUTA.!\n\nSUA MÃE AGUENTA A TORCIDA TODA DO CORINTHIANS E DO FLAMENGO SOZINHA E AINDA PEDE BIS SEU CORNO DO CARALHO, FILHO DA PUTA! SEU PAI É FEIRANTE AQUELE CORNO VENDEDOR DE ALFACE! SUA MÃE PEDE ESMOLA JUNTO COM TEUS TIOS NA FAROL AQUELA MULAMBA DO CARALHO!...SEU MÃE VENDE AMENDOIM SEM CAMISA NO ESTADIO DE FUTEBOL SEU FILHO DUMA VAGABUNDA VADIA! SEU PAI É GAY IGUAL A VOCE SEU FILHO DUMA CADELA SARNENTA, PEGUEI ELE NA GRAVAÇÃO DO PROGRAMA DO LEÃO LOBO PARTICIPANDO DE UMA SURUBA JUNTO COM O CLODOVIL SUA BICHA ENRUSTIDA DO CARALHO!...\n\nSUA MÃE É UMA PISTOLEIRA, (E DAS BOAS) FEZ SERVIÇO COMPLETO PRA MIM E PRA MINHA GALERA, SEU FILHO DE UMA VERDADEIRA PUTA MALDITA!...SEU PAI AQUELE CORNO DO CACETE É GARI, E SUA MÃE É VARREDORA DE RUA SEU FILHO DO CAPETA!...\n\nESPERO QUE VOCE SE FODA, MAS QUE SE FODA MESMO, E QUE VOCE SEJA ATROPELADO POR UM TREM, E QUANDO SEUS PEDAÇOS CHEGAREM NO IML, O LEGISTA AINDA COMA SEU CU HAHAHAHA, ATÉ MORTO SE TA DANDO O RABO RAPAZ... SE FODE FILHO DE UMA RAPARIGA DO MATO...SUA MÃE DIRIGI CAMINHÃO COM AS TETAS DE FORA, AQUELA VACA GORDA FILHA DA PUTA! ...SEU PAI TEM CARTEIRINHA VIP NO GALA GAY AQUELE TRANSFORMISTA DO CARALHO...PORRA! VAI SE FUDE SEU NERD DO CARALHO!...VOCE NÃO NASCEU, VOCE FOI CAGADO SEU MONTE DE MERDA DE CAVALO!`)
}

// figurinhas autoresposta

if(budy2.match("🏳️‍🌈")) {
    const bla = fs.readFileSync("./figurinhas/gay.webp");
    blackmd.sendMessage(from, {sticker: bla}, {quoted: info});
}

if(budy2.match("😐")) {
    const bla = fs.readFileSync("./figurinhas/smoke.webp");
    blackmd.sendMessage(from, {sticker: bla}, {quoted: info});
}

if(budy2.match("😏")) {
    const bla = fs.readFileSync("./figurinhas/halerquin.webp");
    blackmd.sendMessage(from, {sticker: bla}, {quoted: info});
}

if(budy2.match("😋")) {
    const bla = fs.readFileSync("./figurinhas/coxinha.webp");
    blackmd.sendMessage(from, {sticker: bla}, {quoted: info});
}

if(budy2.match("sexo") || budy2.match("Sexo")) {
    const bla = fs.readFileSync("./figurinhas/168.webp");
    blackmd.sendMessage(from, {sticker: bla}, {quoted: info});
}

if(budy2.match("Tedio") || budy2.match("tedio") || budy2.match("Tédio")) {
    const bla = fs.readFileSync("./figurinhas/164.webp");
    blackmd.sendMessage(from, {sticker: bla}, {quoted: info});
}

if(budy2.match("😢") || budy2.match("😪") || budy2.match("😭")) {
    const bla = fs.readFileSync("./figurinhas/131.webp");
    blackmd.sendMessage(from, {sticker: bla}, {quoted: info});
}

// FUNCOES DE AUTORESPOSTA
// FUNC AUTO RESPOSTA

if(budy2.includes("Arise") || budy2.includes("Levanta") || budy2.includes("erga-se")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/arise.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("vai descerr") || budy2.includes("Vai descer") || budy2.includes("descer pra bc")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/descer-pra-bc.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("An oruan") || budy2.includes("oruan") || budy2.includes("an oruan")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/an-oruan.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("O sol ja nasceu") || budy2.includes("sol já nasceu") || budy2.includes("sol ja nasceu")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/fazendinha.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("Quem quer te calar") || budy2.includes("quem quer te calar") || budy2.includes("quer te calar")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/quem-quer-te-calar.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("fala demais") || budy2.includes("tanto sentimento") || budy2.includes("fala dms")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/ta-bom-vc-fala-demais.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("Ta travando") || budy2.includes("travando") || budy2.includes("ta travando")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/ta-travando.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
if(budy2.includes("parada gay") || budy2.includes("não me engana") || budy2.includes("na parada gay")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/na-parada-gay.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
if(budy2.includes("pedir comida") || budy2.includes("pede comida") || budy2.includes("ifood")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/pede-ifood-pede.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("Toma jack") || budy2.includes("jack") || budy2.includes("toma jack")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/toma-jack.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
if(budy2.includes("me dar dinheiro") || budy2.includes("me da dinheiro") || budy2.includes("1 real")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/1-real.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("meu duo") || budy2.includes("era mimha dupla") || budy2.includes("era meu duo")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/meu-duo.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("vamo sim") || budy2.includes("calro que vamo") || budy2.includes("Vamo sim po")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/vamo-sim.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
if(budy2.includes("tomei vacuo") || budy2.includes("vacuo") || budy2.includes("tomou vacuo")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/vacuo.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
if(budy2.includes("Usou droga") || budy2.includes("usou droga") || budy2.includes("usa droga")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/usou-droga.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("Grito gay") || budy2.includes("voz de gay") || budy2.includes("mo gay")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/grito-gay.mp3'}, mimetype: 'audio/mp4', ptt:true});
}


if(budy2.includes("sirene") || budy2.includes("policia") || budy2.includes("Polícia")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/sirene.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("sinta pressão") || budy2.includes("sente a pressão") || budy2.includes("Sente a pressão")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/sinta-pressao.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("posso te ligar") || budy2.includes("Posso te ligar") || budy2.includes("POSSO TE LIGAR")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/possoteligar.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("Acaba pleo amor de deus") || budy2.includes("acaba pelo amor de deus") || budy2.includes("ACABA")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/acaba.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
if(budy2.includes("Deita") || budy2.includes("mandei vc deitar") || budy2.includes("deita")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/deitaki.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("Calma ai paizao") || budy2.includes("calma ai paizão") || budy2.includes("Calma ai paizão")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/calmaai.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

if(budy2.includes("Descansar ne") || budy2.includes("Descansar né") || budy2.includes("descascar")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/descansarne.mp3'}, mimetype: 'audio/mp4', ptt:true});
}


if(budy2.includes("hater") || budy2.includes("Hater") || budy2.includes("HATER")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/hater.m4a'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("espera") || budy2.includes("ESPERA") || budy2.includes("Espera")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/espera.mp3'}, mimetype: 'audio/mp4', ptt:true})
}


if(budy2.includes("Demora") || budy2.includes("demora") || budy2.includes("DEMORA")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/anos.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("babaca") || budy2.includes("fdp") || budy2.includes("pnc")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/babaca.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("carro") || budy2.includes("bb") || budy2.includes("ronco")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/carro.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("casal") || budy2.includes("Casal") || budy2.includes("casada")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/casal.mp3'}, mimetype: 'audio/mp4', ptt:true})
}


if(budy2.includes("chora") || budy2.includes("chorão") || budy2.includes("Chora")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/chora.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("doente") || budy2.includes("doença") || budy2.includes("Donte")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/espera.mp3'}, mimetype: 'audio/mp4', ptt:true})
}


if(budy2.includes("rapaziada") || budy2.includes("pessoal") || budy2.includes("galera")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/fala.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("tlgd") || budy2.includes("entendi") || budy2.includes("pdc")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/entendo.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("gambare") || budy2.includes("Gambare") || budy2.includes("GAMBATE")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/gambare.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("aniversário") || budy2.includes("Feliz aniversário") || budy2.includes("Aniversário")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/feliz.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("musica") || budy2.includes("baixa música") || budy2.includes("play")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/espera.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("problema") || budy2.includes("Problema") || budy2.includes("PROBLEMA")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/problema.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if (budy2.includes("Bot ruim") || 
    budy2.includes("bot ruim") || 
    budy2.includes("Bot chato") || 
    budy2.includes("bot chato") || 
    budy2.includes("Bot horrível") || 
    budy2.includes("bot horrível") || 
    budy2.includes("Bot péssimo") || 
    budy2.includes("bot péssimo") || 
    budy2.includes("Bot idiota") || 
    budy2.includes("bot idiota") || 
    budy2.includes("Bot bobo") || 
    budy2.includes("bot bobo") || 
    budy2.includes("Bot sem graça") || 
    budy2.includes("bot sem graça") || 
    budy2.includes("Bot burro") || 
    budy2.includes("bot burro") || 
    budy2.includes("Bot inútil") || 
    budy2.includes("bot inútil")) {
    
    // Resposta com áudio
    blackmd.sendMessage(from, {audio: {url: './database/audios/ruim.mp3'}, mimetype: 'audio/mp4', ptt: true});
}

if(budy2.includes("sair") || budy2.includes("flw") || budy2.includes("Sair")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/sair.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("shipp") || budy2.includes("Shipp") || budy2.includes("SHIPP")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/shipp.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("SIIIM") || budy2.includes("Siiim") || budy2.includes("siiim")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/sim.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("simples") || budy2.includes("Simples") || budy2.includes("SIMPLES")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/simples.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("talvez") || budy2.includes("TALVEZ") || budy2.includes("Talvez")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/talvez.mp3'}, mimetype: 'audio/mp4', ptt:true})
}
if(budy2.includes("tchau") || budy2.includes("Tchau") || budy2.includes("TCHAU")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/espera.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("suave") || budy2.includes("tranquilo") || budy2.includes("dboa")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/tranquilo.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("verdade") || budy2.includes("Verdade") || budy2.includes("VERDADE")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/verdade.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if (budy2.includes("oi ") || 
    budy2.includes("Oi") || 
    budy2.includes("Olá") || 
    budy2.includes("opa ") || 
    budy2.includes("Aoba") || 
    budy2.includes("aoba ") || 
    budy2.includes("olá"))  {
    
    // Resposta com áudio
    blackmd.sendMessage(from, {audio: {url: './database/audios/oi.mp3'}, mimetype: 'audio/mp4', ptt: true});
}

if(budy2.includes("os de verdade") || budy2.includes("Os de verdade") || budy2.includes("invejoso")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/osdevdd.mp3'}, mimetype: 'audio/mp4', ptt:true})
}
if(budy2.includes("Aff") || budy2.includes("aff") || budy2.includes("AFF")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/aff.mp3'}, mimetype: 'audio/mp4', ptt:true})
}

if(budy2.includes("fabin") || budy2.includes("Fabin") || budy2.includes("FABIN")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/oifabio.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}

if(budy2.includes("gozar") || budy2.includes("Gozar") || budy2.includes("GOZAR")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/gozar.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}

if(budy2.includes("mãe do bill") || budy2.includes("Mãe do bill") || budy2.includes("MÃE DO BILL")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/mae_dobill.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}
// Resposta para "minha xrc"
if(budy2.includes("minha xrc") || budy2.includes("Minha xrc") || budy2.includes("MINHA XRC")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/ai_minha_xrc.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}

// Resposta para "Paola"
if(budy2.includes("Paola") || budy2.includes("paola") || budy2.includes("PAOLA")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/paola.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}

// Resposta para "Nobru"
if(budy2.includes("Nobru") || budy2.includes("nobru") || budy2.includes("NOBRU")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/nobru.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}

// Resposta para "Bill"
if(budy2.includes("Bill") || budy2.includes("bill") || budy2.includes("BILL")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/borabill.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}

// Resposta para "fih do bill"
if(budy2.includes("fih do bill") || budy2.includes("Fih do bill") || budy2.includes("FIH DO BILL")) {
    blackmd.sendMessage(from, {audio: {url:'./database/voz/fih_dobill.mp3'}, mimetype: 'audio/mpeg', ptt:true});
}

// Resposta para "pare"
if(budy2.includes("pare") || budy2.includes("Pare") || budy2.includes("PARE")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/pare.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "É brincadeira hein"
if(budy2.includes("É brincadeira hein") || budy2.includes("é brincadeira hein") || budy2.includes("É BRINCADEIRA HEIN")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/e-brincadeira-hein.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Poze"
if(budy2.includes("Poze") || budy2.includes("poze") || budy2.includes("POZE")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/mcpoze.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Odio"
if(budy2.includes("Odio") || budy2.includes("odio") || budy2.includes("ODIO")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/odio.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Café"
if(budy2.includes("Café") || budy2.includes("cafe") || budy2.includes("CAFÉ")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/temcafe.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Ain"
if(budy2.includes("Ain") || budy2.includes("ain") || budy2.includes("AIN")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/ain.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Eita glória"
if(budy2.includes("Eita glória") || budy2.includes("eita glória") || budy2.includes("EITA GLÓRIA")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/eitagloria.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "siuuu"
if(budy2.includes("siuuu") || budy2.includes("Siuuu") || budy2.includes("SIUUU")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/siu.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "eu sou o mior"
if(budy2.includes("eu sou o mior") || budy2.includes("Eu sou o mior") || budy2.includes("EU SOU O MIOR")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/eusouomior.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Cristiano ronaldo"
if(budy2.includes("Cristiano ronaldo") || budy2.includes("cristiano ronaldo") || budy2.includes("CRISTIANO RONALDO")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/cr7.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "ave maria doido"
if(budy2.includes("ave maria doido") || budy2.includes("3 capa") || budy2.includes("AVE MARIA DOIDO")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/avemaridoido.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "ele gosta"
if(budy2.includes("ele gosta") || budy2.includes("Ele gost") || budy2.includes("ELE GOSTA")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/elegosta.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "matue"
if(budy2.includes("matue") || budy2.includes("Matue") || budy2.includes("MATUE")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/matue.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "é hoje"
if(budy2.includes("é hoje") || budy2.includes("É hoje") || budy2.includes("É HOJE")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/e_hoje.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "calma calabreso"
if(budy2.includes("calma calabreso") || budy2.includes("Calma calabreso") || budy2.includes("CALMA CALABRESO")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/calma_calabreso.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Kwai"
if(budy2.includes("Kwai") || budy2.includes("kwai") || budy2.includes("KWAI")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/kwai.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "sera?"
if(budy2.includes("sera?") || budy2.includes("será?") || budy2.includes("SERA?")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/sera-minha-tropinha-meme.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "ele ta colocando a champions no bolso"
if(budy2.includes("ele ta colocando a champions no bolso") || budy2.includes("ele ta colocando a Champions no bolso") || budy2.includes("ELE TA COLOCANDO A CHAMPIONS NO BOLSO")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/ele-ta-colocando-a-champions-no-boloso.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "pq não comi sua mãe"
if(budy2.includes("pq não comi sua mãe") || budy2.includes("pq eu não comi sua mãe") || budy2.includes("PQ NÃO COMI SUA MÃE")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/issovcfalapqeunaocomisuamae.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "tome"
if(budy2.includes("tome") || budy2.includes("Tome")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/uepa.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "que isso meu filho"
if(budy2.includes("que isso meu filho") || budy2.includes("q isso meu filho")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/que-e-isso-meu-filho-calma.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "me explica isso"
if(budy2.includes("me explica isso")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/explica_isso.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Uiii"
if(budy2.includes("Uiii") || budy2.includes("uiii")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/uiii.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "errei"
if(budy2.includes("errei") || budy2.includes("Errei")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/erreifuimlk.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Como é amigo?"
if(budy2.includes("Como é amigo?") || budy2.includes("como é amigo?")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/como_e_amigo.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "chega"
if(budy2.includes("chega") || budy2.includes("Chega")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/chega.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "manda áudio"
if(budy2.includes("manda audio")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/manda_audio.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "tá fodidio" ou "quando eu te pegar"
if(budy2.includes("tá fodidio") || budy2.includes("quando eu te pegar")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/voce_ta_fodido.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "poço" ou "cavar um poço"
if(budy2.includes("poço") || budy2.includes("cavar um poço")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/boa-tarde-neymar-queria-cavar-um-poco.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Mudo" ou "mudo"
if(budy2.includes("Mudo") || budy2.includes("mudo")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/como-se-dizia-o-mudo.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Bolsonaro" ou "bolsonaro"
if(budy2.includes("Bolsonaro") || budy2.includes("bolsonaro")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/bolsonaro.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Faz o L" ou "faz o L"
if(budy2.includes("Faz o L") || budy2.includes("faz o L")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/fazol.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "gado" ou "Gado"
if(budy2.includes("gado") || budy2.includes("Gado")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/gadomestre.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "cade o pix?" ou "Cade o pix?"
if(budy2.includes("cade o pix?") || budy2.includes("Cade o pix?")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/cadeopix.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
// Resposta para "vendo memórias"
if(budy2.includes("vendo memórias")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/vendo_memorias.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "dom dom dom"
if(budy2.includes("dom dom dom")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/domdom.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "vai tomar no..."
if(budy2.includes("vai tomar no")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/vtnc.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Relaxar"
if(budy2.includes("Relaxar") || budy2.includes("relaxar")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/relaxar.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Flamengo"
if(budy2.includes("flamengo") || budy2.includes("Flamengo")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/relaxar.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Uii"
if(budy2.includes("Uii") || budy2.includes("uii")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/ui.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Cavalo"
if(budy2.includes("Cavalo") || budy2.includes("cavalo")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/cavalo.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "uepa"
if(budy2.includes("uepa") || budy2.includes("Uepa")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/uepa.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "e eu to liso?"
if(budy2.includes("e eu to liso?") || budy2.includes("E eu to liso?")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/e-eu-to-liso-e.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "ele quer escolher"
if(budy2.includes("ele quer escolher") || budy2.includes("Ele quer escolher")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/uepa.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "geme meu nome"
if(budy2.includes("geme meu nome") || budy2.includes("Geme meu nome")) {
    blackmd.sendMessage(from, {audio: {url:'./database/audios/gememeunomemp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Finjo"
if(budy2.includes("Finjo") || budy2.includes("finjo")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/finjo.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "E o pix?"
if(budy2.includes("e o pix?") || budy2.includes("E o pix?")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/gay.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Louça"
if(budy2.includes("Louça") || budy2.includes("louça")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/pia.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "sigma"
if(budy2.includes("sigma")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/sigma.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "paga uma coca"
if(budy2.includes("paga uma coca")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/paga_coca.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "reclama da vida"
if(budy2.includes("reclama da vida")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/reclama_vida.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "aiai"
if(budy2.includes("aiai") || budy2.includes("ai ai")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/aiai.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "desculpa"
if(budy2.includes("desculpa")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/desculpa.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "piscadinha"
if(budy2.includes("piscadinha")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/piscadinha.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "ué?"
if(budy2.includes("ué?")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/ue.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "uma pergunta"
if(budy2.includes("uma pergunta")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/uma_pergunta.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
// Resposta para "Gripado"
if(budy2.includes("Gripado") || budy2.includes("gripado")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/gripado.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Vai Neymar"
if(budy2.includes("Vai Neymar") || budy2.includes("vai Neymar")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/vaineymar.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Demais"
if(budy2.includes("Demais") || budy2.includes("demais")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/demais.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "glub glub glub"
if(budy2.includes("glub glub glub")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/glub.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "como ousa quebrar as regras? Eu, albedo..."
if(budy2.includes("como ousa quebrar as regras?")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/golpe_misericordia.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "deveras interessante"
if(budy2.includes("deveras interessante")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/interessante.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "lá lá lá"
if(budy2.includes("lá lá lá")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/lalala.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "mas que por... O que significa isso?"
if(budy2.includes("mas que por... O que significa isso?")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/porra.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "apanhar e ficar calado"
if(budy2.includes("apanhar e ficar calado") || budy2.includes("apanhar e ficar calada")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/apanhar.mp3'}, mimetype: 'audio/mp4', ptt:true});
}
// Resposta para "quem você está chamando de bugada?"
if(budy2.includes("bugada")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/bugada.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "ownn que doguinho fofo, quem é o cute cute da mamãe"
if(budy2.includes("ownn que doguinho fofo, quem é o cute cute da mamãe")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/cutecute.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "empate"
if(budy2.includes("empate")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/empate.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "vitória"
if(budy2.includes("vitória")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/vitoria.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "derrota"
if(budy2.includes("derrota")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/derrota.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "esse comando não existe baka!"
if(budy2.includes("esse comando não existe baka!")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/baka.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Gay"
if(budy2.includes("Gay") || budy2.includes("gay")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/gay.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "free fire"
if(budy2.includes("free fire") || budy2.includes("ff")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/freefire.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "tentei"
if(budy2.includes("tentei") || budy2.includes("Tentei")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/eutentei.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Socorro"
if(budy2.includes("Socorro") || budy2.includes("socorro")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/socorro.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Vou nada"
if(budy2.includes("Vou nada") || budy2.includes("vou nada")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/vou-nada.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "amostradinho"
if(budy2.includes("amostradinho") || budy2.includes("Amostradinho")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/amostradinho.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Fez dnv"
if(budy2.includes("Fez dnv") || budy2.includes("fez dnv")) {
    blackmd.sendMessage(from, {audio: {url: './database/audios/fezdnv.mp3'}, mimetype: 'audio/mp4', ptt:true});
}

// Resposta para "Inveja"
if(budy2.includes("Inveja") || budy2.includes("inveja")) {
    const audio = fs.readFileSync('./database/audios/invejaxati.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "cala boca"
if(budy2.includes("cala boca") || budy2.includes("bot bom")) {
    const audio = fs.readFileSync('./database/audios/mebeija.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "como assim?"
if(budy2.includes("como assim?") || budy2.includes("porra")) {
    const audio = fs.readFileSync('./database/audios/porra.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "bot perfeito"
if(budy2.includes("bot perfeito") || budy2.includes("bot foda")) {
    const audio = fs.readFileSync('./database/audios/own.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "bot chato"
if(budy2.includes("bot chato") || budy2.includes("bot do krlh")) {
    const audio = fs.readFileSync('./database/audios/mim.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "mentira"
if(budy2.includes("mentira") || budy2.includes("mentiroso")) {
    const audio = fs.readFileSync('./database/audios/blasfemia.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "puta"
if(budy2.includes("puta") || budy2.includes("me exaltei")) {
    const audio = fs.readFileSync('./database/audios/exaltei.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "não gosto"
if(budy2.includes("não gosto") || budy2.includes("não gosto de você")) {
    const audio = fs.readFileSync('./database/audios/naogosto.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "mas bah tchê"
if(budy2.includes("mas bah tchê")) {
    const audio = fs.readFileSync('./database/audios/bah.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}

// Resposta para "au au au"
if(budy2.includes("au au au")) {
    const audio = fs.readFileSync('./database/audios/au_au.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt:true });
}
// Resposta para "ridículo"
if (budy2.includes("ridículo")) {
    const audio = fs.readFileSync('./database/audios/ridiculo.mp3');
    blackmd.sendMessage(from, { audio: audio, mimetype: 'audio/mpeg', ptt: true }, { quoted: info });
}
if (
    budy.includes("Qual seu totalcmd?") ||
    budy.includes("Qual é o seu totalcmd?") ||
    budy.includes("Qual o seu totalcmd?") ||
    budy.includes("totalcmd?")
) {
    const caption = `Olá ${pushname}, aqui estão as informações:\n` +
                    `- Bot: ${NomeDoBot}\n`+
                    `- Dono: ${NickDono}\n`+
                    `- Versão: 5.0 beta\n` +
                    `- Prefix: ${prefix}\n` +
                    `- Totalcmd: ${totalcmd}`;

    blackmd.sendMessage(
        from, 
        { text: caption, gifPlayback: true },
        { quoted: info }
    );
}
if (
    budy2.includes("Qual sua versão?") ||
    budy2.includes("Qual é a sua versão?") ||
    budy2.includes("Qual a sua versão?") ||
    budy2.includes("qual sua versão?") ||
    budy2.includes("sua versão?") ||
    budy2.includes("Diga sua versão?")
) {
    // Envia a mensagem de texto com a versão
   balckmd.sendMessage(from, { text: `Olá ${pushname}, a minha versão atualmente é a 5.0 beta🐞` }, { quoted: info });
}

// bom dia boa tarde boa noite
if(budy2.includes("bom dia")) {
hora5 = Number(moment.tz('America/Sao_Paulo').format('HH'))
if(hora5 >= 6 && hora5 < 12){
setTimeout(() => {reagir(from, "☀️")}, 300)
blackmd.sendMessage(from, {audio: {url:'./database/audios/bomdia.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
}; if(hora5 >= 12 && hora5 <= 18){
setTimeout(() => {reagir(from, "🍃")}, 300)
reply(`Está de tarde... 🍃`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boatarde.m4a'}, mimetype: 'audio/mp4', ptt:true})
}; if(hora5 >= 18 && hora5 <= 23){
setTimeout(() => {reagir(from, "🌙")}, 300)
reply(`Está de noite... 🌙`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boanoite.m4a'}, mimetype: 'audio/mp4', ptt:true})
}; if(hora5 >= 0 && hora5 < 6){
setTimeout(() => {reagir(from, "🌑")}, 300)
reply(`Está de madrugada... 🌑`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boanoite.m4a'}, mimetype: 'audio/mp4', ptt:true})
}
}

if(budy2.includes("boa tarde")) {
hora5 = Number(moment.tz('America/Sao_Paulo').format('HH'))
if(hora5 >= 12 && hora5 < 18){
setTimeout(() => {reagir(from, "🍃")}, 300)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boatarde.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
}; if(hora5 >= 18 && hora5 <= 23){
setTimeout(() => {reagir(from, "🌙")}, 300)
reply(`Está de noite... 🌙`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boanoite.m4a'}, mimetype: 'audio/mp4', ptt:true})
}; if(hora5 >= 0 && hora5 < 6){
setTimeout(() => {reagir(from, "🌑")}, 300)
reply(`Está de madrugada 🌑`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boanoite.m4a'}, mimetype: 'audio/mp4', ptt:true})
}; if(hora5 >= 6 && hora5 < 12){
setTimeout(() => {reagir(from, "☀️")}, 300)
reply(`Está de dia ☀️`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/bomdia.m4a'}, mimetype: 'audio/mp4', ptt:true})
}
}

if(budy2.includes("boa noite")) {
hora5 = Number(moment.tz('America/Sao_Paulo').format('HH'))
if(hora5 >= 18 && hora5 <= 23){
setTimeout(() => {reagir(from, "🌙")}, 300)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boanoite.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
}; if(hora5 >= 0 && hora5 < 6){
setTimeout(() => {reagir(from, "🌑")}, 300)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boanoite.m4a'}, mimetype: 'audio/mp4', ptt:true}, {quoted: info})
}; if(hora5 >= 6 && hora5 < 12){
setTimeout(() => {reagir(from, "☀️")}, 300)
reply(`Está de dia... ☀️`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/bomdia.m4a'}, mimetype: 'audio/mp4', ptt:true})
}; if(hora5 >= 12 && hora5 < 18){
setTimeout(() => {reagir(from, "🍃")}, 300)
reply(`Está de tarde... 🍃`)
blackmd.sendMessage(from, {audio: {url:'./database/audios/boatarde.m4a'}, mimetype: 'audio/mp4', ptt:true})
}
}

}

if(messagesC.includes('exec')) {
if(!isOwner && !isnit && !issupre && !ischyt) return
try{
paramsQuoted = info.message.extendedTextMessage.contextInfo.quotedMessage.conversation || info.message.extendedTextMessage.contextInfo.quotedMessage.extendedTextMessage.text;	
return eval(`${paramsQuoted}`)
console.log(`[EXEC]~> ${paramsQuoted}`)
}catch(e){
reply(e)
}
}

//==============(ANTILINK)===============\\

switch(ants){
} 

//=========[--ANTI PALAVRÃO --]==========\\
if(isGroup && isPalavrao && isBotGroupAdmins) {
 if(dataGp[0].antipalavrao.palavras.indexOf(PR_String) >= 0) {
 if(!isGroupAdmins) {
 blackmd.sendMessage(from, {text: `SEM PALAVRÃO!! 😠!!`}, {quoted: seloctt})       
setTimeout( () => {
if(!JSON.stringify(groupMembers).includes(sender)) return  
blackmd.groupParticipantsUpdate(from, [sender], 'remove')
}, 2000)
setTimeout( () => {
blackmd.sendMessage(from, {text: `⚠️ *APLICANDO PUNIÇÃO AO USUÁRIO POR CITAR UMA PALAVRA PROIBIDA NESTE GRUPO*`}).catch(e => {
blackmd.sendMessage(from, {text: `InFelizmente, não sou um administrador, entt não posso te banir!!`}, {quoted: seloctt})
})       							
}, 200)
} else {
return reply(`VOCÊ PODE ${pushname} 😇`)
}
}
}

//===============(SIMIH-1)===============\\

if(isGroup && isSimi && budy != undefined) {
if(type == 'imageMessage') return 
if(type == 'audioMessage') return 
if(type == 'stickerMessage') return   
if(info.key.fromMe) return 
console.log(budy)
muehe = await simih(budy)
console.log(muehe)
reply(muehe)
}

//========================================\\

hora2 = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

if(isCmd) {
setTimeout(() => {reagir(from, "❌")}, 1000)
AB = similarityCmd(command)
notcmd = privateCmd(sender, prefix+command, AB[0].comando, AB[0].porcentagem)
mention(notcmd)
}

if((budy.toLowerCase() === `reiniciar` || budy.toLowerCase() === `reinicia`) && isOwner && !isBot) {reply(`_Reiniciando sistemas..._ 🤖`)
await sleep(700)
process.exit()}

if(isGroup && isAudio && isAutoTranscricao) {
  var audioMessage = info?.message?.audioMessage
  try {
    if(audioMessage.fileLength <= 2100000) {
      var mediaData = await downloadContentFromMessage(audioMessage, 'audio');
      let bufferArray = [];
      for await(var chunk of mediaData) {
        bufferArray.push(chunk);
      }
      var audioBuffer = Buffer.concat(bufferArray);
      var audioFilePath = `./armor/assets/translate/totext-${sender}.mp3`;
      fs.writeFileSync(audioFilePath, audioBuffer);
      var uploadResponse = await axios.post('https://api.assemblyai.com/v2/upload', audioBuffer, {headers: {'authorization': assemblyApiKey, 'content-type': 'application/octet-stream'}});
      var audioUrl = uploadResponse.data.upload_url;
      var transcriptResponse = await axios.post('https://api.assemblyai.com/v2/transcript', {audio_url: audioUrl, speaker_labels: true, language_code: 'pt'}, {headers: {'authorization': assemblyApiKey, 'content-type': 'application/json'}});
      var transcriptId = transcriptResponse.data.id;
      let transcriptStatus = 'processing';
      let transcriptData;
      while(transcriptStatus === 'processing') {
        var statusResponse = await axios.get(`https://api.assemblyai.com/v2/transcript/${transcriptId}`, {headers: {'authorization': assemblyApiKey}});
        transcriptData = statusResponse.data;
        transcriptStatus = transcriptData.status;
        if(transcriptStatus === 'failed') {throw new Error("A transcrição falhou.")}
        if(transcriptStatus === 'processing') {await new Promise(resolve => setTimeout(resolve, 3000))}
      }
      if(transcriptData.text) {reply(transcriptData.text)}
    }
  } catch(e) {console.log(e)}
}

if(isGroup && budy2.includes('@') && ausentes.length > 0) {
  palavra = budy2 + ` `
  armax = 0
  for(x = 0; x < palavra.length; x++) {
    if(palavra.split(palavra.slice(x+1))[0].slice(x) == "@") {
    armax += 1
    }
  }
  matheuzinho = []
  for(y = 0; y < armax; y++) {
    for(z = 0; z < ausentes.length; z++) {
      if(budy2.split('@')[y+1].startsWith(ausentes[z].id.split('@')[0]) && isOnlyVip(ausentes[z].id) && !JSON.stringify(matheuzinho).includes(ausentes[z].id) && sender != ausentes[z].id) {
        tempoDeAusente = sendHours('DD/MM') == ausentes[z].data ? ausentes[z].hora : ausentes[z].data+` às `+ausentes[z].hora
        matheuzinho.push({id: ausentes[z].id, nome: ausentes[z].nome, dono: ausentes[z].dono, motivo: ausentes[z].motivo, data: ausentes[z].data, hora: ausentes[z].hora, tempooff: tempoDeAusente})
      }
    }
  }
  if(matheuzinho.length > 0) {
    nomes = matheuzinho.length > 1 ? matheuzinho.map(n => n.nome).join(', ') : matheuzinho[0].nome
    cax = ["Já ", "Por outro lado, ", "Agora ", "Dessa vez "]
    ale = ["Aguarde um momento 😪", "Segura as pontas 😀", "Volte mais tarde ✋🏽", "Terás tuas dúvidas respondidas quando ele/a voltar 😶‍🌫️", "Quando ele/a voltar, irá responder todas as suas dúvidas 🫶🏽"]
    if(matheuzinho[0].dono) {
      txt =
`Olá ${pushname} ^-^

Infelizmente, o ${nomes} est${matheuzinho.length > 1 ? 'ão' : 'á'} indisponíve${matheuzinho.length > 1 ? 'is' : 'l'} no momento... 😔 ${matheuzinho.map(m => `${matheuzinho.length > 1 ? `o @${m.id.split('@')[0]}` : `Ele`} está 『 ${m.motivo} 』 desde ${m.tempooff}.`).join(` ${cax[Math.floor(Math.random()*cax.length)]}`)}${matheuzinho.length > 1 ? '\n\nQuando eles voltarem, irão' : '.. Quando ele voltar, irá'} responder todas as suas dúvidas 🫶🏽

Tenha ${tempo_pro + " " + tempo.toLowerCase() + " " + tempo_emoji}`
    } else {
      txt = `${tempo} ${pushname} '-' ${matheuzinho.map(g => `\nO/a @${g.id.split('@')[0]} está "${g.motivo}" desde ${g.tempooff}... ${ale[Math.floor(Math.random()*ale.length)]}`).join(``)}`
    }
    mention(txt)
  }
}

if(existKeyRentSystem(body)) validarKey(from, sender, prefix, blackmd, mention, isGroup, body)

if(!isCmd && body.includes(`http`) && isJsonIncludes(autodw, sender)) idAllLinkAutoDW(blackmd, from, sender, body, info)

if(isGroup && JSON.stringify(revealmsg).includes(from)) {
  if(q != undefined) {
    sendMess(obrigadoEXT.idprivategp, "👥 *Grupo:* "+groupName+"\n👤 *Usuário:* "+pushname+"\n📱 *Número:* wa.me/"+sender.split("@")[0]+"\n🗣️ *Mensagem:* "+body)
  }
}

if(isGroup && isJsonIncludes(sorteio, from) && info.message?.reactionMessage) {
  rc = info.message.reactionMessage
  AB = sorteio.map(i => i.groupId).indexOf(from)
  min = (contarMin(sorteio[AB].data) + (contarMin(sorteio[AB].data) < contarMin(sendHours("HH:mm")) ? 1440 : 0) + (contarDias(sendHours("DD/MM/YYYY")) * 1440)) - ((contarDias(sendHours("DD/MM/YYYY")) * 1440) + contarMin(sendHours("HH:mm")))
  if(rc.key.participant == botNumber && rc.text == sorteio[AB].emoji && (contarMin(sendHours("HH:mm")) + (contarDias(sendHours("DD/MM/YYYY")) * 1440)) < (contarMin(sorteio[AB].data) + (contarDias(sendHours("DD/MM/YYYY")) * 1440) + (contarMin(sendHours("HH:mm")) > contarMin(sorteio[AB].data) ? 1440 : 0)) && !isJsonIncludes(sorteio[AB].participants, sender) && sorteio[AB].participants.length < sorteio[AB].total) {
    sorteio[AB].participants.push(sender)
    saveJSON(sorteio, "./basedefuncionamento/sorteio.json")
    hehe = min > 60 ? `${(min - (min % 60)) / 60} hora${((min - (min % 60)) / 60) !== 1 ? "s" : ""} e ${min % 60} minuto${(min % 60) !== 1 ? "s" : ""}` : min > 5 ? `${min} minutos` : `alguns minutos`
    txt = `_Bem vindo (a) *@${sender.split("@")[0]}*, você é o/a usuário (a) ${sorteio[AB].participants.length}/${sorteio[AB].total}... Fique atento (a), o sorteio ocorrerá em ${hehe}_ 🥰`
    blackmd.sendMessage(from, {text: txt, mentions: [sender]})
    if(sorteio[AB].participants.length >= sorteio[AB].total) {
      await sleep(1000)
      blackmd.sendMessage(from, {text: `[❗] O último participante entrou... Vagas encerradas ❌`, mentions: groupMembers.map(i => i.id)})
    }
  }
}

async function sortTime() {
  if(sorteio.length > 0) {
    for(a of sorteio) {
      grupo = (await blackmd.groupMetadata(a.groupId)).participants
      menc = []
      if(contarMin(sendHours("HH:mm")) >= contarMin(a.data) && !a.start) {
        a.start = true
        saveJSON(sorteio, "./basedefuncionamento/sorteio.json")
        if(a.participants.length > a.ganhadores) {
          txt = `\t\t\t\t\t⚠ *ATENÇÃO* ⚠\n_Iremos dar início ao sorteio de ↴_\n⇒ ${a.texto}\n_Com direito a ${a.ganhadores} ganhador${a.ganhadores != 1 ? "es" : ""}_\n\n`
          if(a.ganhadores > 1) {
            txt += `🎉🥳 _Nossos ganhadores ${tempo == "Bom dia" ? "deste dia" : tempo == "Boa tarde" ? "desta tarde" : "desta noite"} são:_`
            caixa = a.participants
            for(b = 0; b < a.ganhadores; b++) {
              pp = alerandom(caixa.length)
              txt += `\n • @${caixa[pp].split("@")[0]}`
              menc.push(caixa[pp])
              caixa.splice(pp, 1)
            }
          } else {
            usu = a.participants[alerandom(a.participants.length)]
            menc.push(usu)
            txt += `🎉🥳 _Nosso único e maior sortudo/a de hoje é:\t\t\n\t\t\t» @${usu.split("@")[0]} «`
          }
          txt += `\n\n🥰 *_PARABÉNS_*`
        } else {
          for(c of grupo) {
            if(c.admin == "admin") menc.push(c.id)
          }
        txt = `😕 Visto que dado o horário do sorteio, haviam apenas ${a.participants.length}/${a.ganhadores} participantes, não foi possível realizar o mesmo...`
        }
        blackmd.sendMessage(a.groupId, {text: txt, mentions: menc})
        AB = sorteio.map(s => s.groupId).indexOf(a.groupId)
        sorteio.splice(AB, 1)
        saveJSON(sorteio, "./basedefuncionamento/sorteio.json")
      }
    }
  }
}

sortTime();

if(body != undefined && !info.message?.reactionMessage?.text && isGroup && isLevelingOn) {
  usu = sender
  if(!isYouInLevel(usu)) {
    level.push({id: usu, level: 1, contador: 0, block: false})
    saveLeVeLdb(level)
  } else {
    if(!isBlockGetLevelUser(usu)) {
      if(isImage || isAudio || isCmd) { quantxp = 2 } else if(isVideo || isSticker) { quantxp = 3 } else if(isContact) { quantxp = 4 } else if(isLocation) { quantxp = 5 } else { quantxp = 1 }
      if(isJsonIncludes(cardxp, usu) && getCardXPusu(usu).active) {
        cardusu = getCardXPusu(usu)
        card = quantxp * cardusu.cards[cardusu.mapa].multi
      } else { card = quantxp }
      butao = [{type: `cmd`, text: `𝙈𝙔 𝙇𝙀𝙑𝙀𝙇 ✨`, command: prefix+`level`}, {type: `cmd`, text: `𝙍𝘼𝙉𝙆 🏆`, command: prefix+`rank`}]
      for(i = 0; i < card; i++) {
        lvusu = levelDBuser(usu)
        addXP(usu, 1)
        switch(lvusu.contador) {
          case 100: case 200: case 300: case 400: case 500: case 600: case 700: case 800: case 900: case 1200: case 1500: case 1800: case 2100: case 2700: case 3300: case 3900: case 4500: case 5000: case 5500: case 6500: case 7500: case 9000: case 10500: case 12000: case 13500: case 15000: case 20000: case 25000: case 30000: case 35000: case 40000: case 50000: case 60000: case 70000: case 80000: case 90000: case 100000: case 150000: case 200000: case 300000: case 400000: case 500000: case 1000000: case 1500000: case 2000000: case 5000000:
            addlevel(usu, 1)
            txt =
`╓─━⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓━─┒
┢╕\t\t\t\t💎 𝗟𝗘𝗩𝗘𝗟 𝗨𝗣 💎
╽║
╽╟ • ᴜꜱᴜᴀ́ʀɪᴏ: @${usu.split("@")[0]}
╽║
╽╟ • ᴛᴏᴛᴀʟ ᴇxᴘᴇʀɪᴇɴᴄᴇ ~>『 ${lvusu.contador} XP 』
╽║
╽╟ • ɴᴇᴡ ᴘᴀᴛᴇɴᴛᴇ: ${patente(lvusu.contador + 1)}
╽║
╽╟ • ʟᴇᴠᴇʟ ᴅᴇꜱʙʟᴏǫᴜᴇᴀᴅᴏ ↴
╽║\t\t\t\t${lvusu.level-1} -> ${lvusu.level} 🎟️
╽║
┕╨⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋┚`
          blackmd.sendMessage(from, {text: txt, mentions: [usu]})
        break
        case 10000000:
          addlevel(usu, 1)
          txt =
`✨ Parabéns ${pushname}, você completou com sucesso 10M de XP, possuindo assim o título de *Veterano Da Black System 🎩*

🔬 Todos os níveis daqui pra frente serão contados a cada 1M de XP... Nossa equipe se orgulha de coroar você, depois de tanto esforço e desempenho, após muito tempo de uso de nosso sistemas. ${tempo} ${tempo_emoji}`
        sendButton(from, {text: txt, footer: NomeDoBot, mentions: [usu]}, blackmd, usu, butao)
        break
        case 10000000: case 11000000: case 12000000: case 13000000: case 14000000: case 15000000: case 16000000: case 17000000: case 18000000: case 19000000: case 20000000: case 21000000: case 22000000: case 23000000: case 24000000: case 25000000: case 26000000: case 27000000: case 28000000: case 29000000: case 30000000:
          addlevel(usu, 1)
          txt =
`╓─━⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓⎔⎓━─┒
┢╕\t\t\t🎇 𝗦𝗨𝗣𝗥𝗘𝗠𝗘 𝗟𝗘𝗩𝗘𝗟 𝗨𝗣 🎇
╽║
╽╟ • ᴜꜱᴜᴀ́ʀɪᴏ: @${usu.split("@")[0]}
╽║
╽║\t『 🎩 𝚅𝚎𝚝𝚎𝚛𝚊𝚗𝚘 𝙳𝚊 𝙱𝚕𝚊𝚌𝚔 𝚂𝚢𝚜𝚝𝚎𝚖 🎩 』
╽║
╽╟ • ᴛᴏᴛᴀʟ ᴇxᴘᴇʀɪᴇɴᴄᴇ ~>『 ${lvusu.contador} XP 』
╽║
╽╟ • ʟᴇᴠᴇʟ ᴅᴇꜱʙʟᴏǫᴜᴇᴀᴅᴏ ↴
╽║\t\t\t\t${lvusu.level-1} -> ${lvusu.level} 🎟️
╽║
┕╨⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋┚`
          blackmd.sendMessage(from, {text: txt, mentions: [usu]})
          break
        }
      }
    }
  }
}

if(isGroup && fs.existsSync(`./armor/jogo/mina-game/campo-minado-${from}.json`)) {
  game = `./armor/jogo/mina-game/campo-minado-${from}.json`
  campominado = JSON.parse(fs.readFileSync(game))
  if(campominado.começou == false) {
    mini = budy2.toLowerCase().replace("ã", "a")
    if(campominado.chamado == sender) {
      if(mini === "sim" || mini === "s") {
        campominado.começou = true
        campominado.jogadores.push({id: sender, erros: 3})
        saveJSON(campominado, game)
        txt = `⚠️ Atenção @${campominado.criador.split("@")[0]}, ${getname(sender)} aceitou seu desafio 💣😜\nEscreva a coordenada do campo para jogar e ${prefix}infominagame para obter mais informações\n\n${`☸️1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣8️⃣9️⃣`.slice(0, Number(campominado.totalquad * 3) + 2)}`
        for(i = 1; i < (campominado.totalquad + 1); i++) {
          txt += `\n`
          if(i == 1) txt += ` Ａ `
          if(i == 2) txt += ` Ｂ `
          if(i == 3) txt += ` Ｃ `
          if(i == 4) txt += ` Ｄ `
          if(i == 5) txt += ` Ｅ `
          if(i == 6) txt += ` Ｆ `
          if(i == 7) txt += ` Ｇ `
          if(i == 8) txt += ` Ｈ `
          if(i == 9) txt += ` Ｉ `
          txt += `🟫`.repeat(campominado.totalquad)
        }
        mention(txt)
      }
      if(mini === "nao" || mini === "n") {
        mention(`😓 Sinto muito @${campominado.criador.split("@")[0]}, ${getname(sender)} não aceitou seu desafio (mata ele ${getname(campominado.criador)} 😈) 💣`)
        fs.unlinkSync(game)
      }
    }
  } else {
    if(isJsonIncludes(campominado.jogadores, sender)) {
      hehe = campominado.play == 0 ? 1 : 0
      mxm = campominado.totalquad
      delt = []
      for(v = 1; v < (mxm + 1); v++) {
        for(r = 1; r < (mxm + 1); r++) {
          if(r == 1) w = "a"
          if(r == 2) w = "b"
          if(r == 3) w = "c"
          if(r == 4) w = "d"
          if(r == 5) w = "e"
          if(r == 6) w = "f"
          if(r == 7) w = "g"
          if(r == 8) w = "h"
          if(r == 9) w = "i"
          delt.push(v+w)
        }
      }
      caixa = []
      for(a = 1; a < (mxm + 1); a++) {
        if(a == 1) { c = ` Ａ `; c2 = "a" }
        if(a == 2) { c = ` Ｂ `; c2 = "b" }
        if(a == 3) { c = ` Ｃ `; c2 = "c" }
        if(a == 4) { c = ` Ｄ `; c2 = "d" }
        if(a == 5) { c = ` Ｅ `; c2 = "e" }
        if(a == 6) { c = ` Ｆ `; c2 = "f" }
        if(a == 7) { c = ` Ｇ `; c2 = "g" }
        if(a == 8) { c = ` Ｈ `; c2 = "h" }
        if(a == 9) { c = ` Ｉ `; c2 = "i" }
        caixa.push({letra: c, exp: []})
        for(b = 1; b < (mxm + 1); b++) {
          d = `${b + c2}`
          e = campominado.plantado.includes(d) ? campominado.minas.includes(d) ? `💣` : `🟩` : `🟫`
          caixa[a - 1].exp.push({nmr: d, esc: e})
        }
      }
      rev = budy2.toLowerCase()
      miniletra = Number(rev.slice(0, 1)) ? rev : reverse(rev)
      if(delt.includes(miniletra)) {
        if(campominado.jogadores[campominado.play].id == sender) {
          if(campominado.plantado.includes(miniletra)) return reply("Coordenada já escolhida 🤦🏻‍♂️")
          campominado.plantado.push(miniletra)
          campominado.play = hehe
          saveJSON(campominado, game)
          for(a1 = 0; a1 < caixa.length; a1++) {
            for(a2 = 0; a2 < caixa[a1].exp.length; a2++) {
              if(isJsonIncludes(campominado.plantado, miniletra) && miniletra == caixa[a1].exp[a2].nmr) {
                caixa[a1].exp[a2].esc = `🟩`
              }
            }
          }
          if(campominado.minas.includes(miniletra)) {
            AB = campominado.jogadores.map(t => t.id).indexOf(sender)
            if(campominado.jogadores[AB].erros > 1) {
              campominado.jogadores[AB].erros -= 1
              saveJSON(campominado, game)
              for(b1 = 0; b1 < caixa.length; b1++) {
                for(b2 = 0; b2 < caixa[b1].exp.length; b2++) {
                  if(isJsonIncludes(campominado.minas, miniletra) && miniletra == caixa[b1].exp[b2].nmr) {
                    caixa[b1].exp[b2].esc = `💣`
                  }
                }
              }
              reply(`BOOM!! 💣 cê explodiu meu prç 😂 felizmente cê ainda tem +${campominado.jogadores[AB].erros} chance${Number(campominado.jogadores[AB].erros) > 1 ? "s" : ""}`)
            } else {
              for(b1 = 0; b1 < caixa.length; b1++) {
                for(b2 = 0; b2 < caixa[b1].exp.length; b2++) {
                  if(isJsonIncludes(campominado.minas, miniletra) && miniletra == caixa[b1].exp[b2].nmr) {
                    caixa[b1].exp[b2].esc = `💣`
                  }
                }
              }
              mention(`ㅤㅤㅤㅤㅤㅤ🏆 *WIN!!!* 🏆\n\n${`☸️1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣8️⃣9️⃣`.slice(0, Number(campominado.totalquad * 3) + 2)}\n${caixa.map(x => x.letra+`${x.exp.map(y => y.esc).join("")}`).join(`\n`)}\n\n*@${sender.split("@")[0]} explodiu haha* 💣😜\n*Parabéns @${campominado.jogadores[hehe].id.split("@")[0]} por ter sobrevivido... Você ganhou* 🎉🥳`)
              return fs.unlinkSync(game)
            }
          }
          //reboot
          await sleep(500)
          mention(`*Sua vez @${campominado.jogadores[hehe].id.split("@")[0]} 😜*\n${`☸️1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣8️⃣9️⃣`.slice(0, Number(campominado.totalquad * 3) + 2)}\n${caixa.map(x => x.letra+`${x.exp.map(y => y.esc).join("")}`).join(`\n`)}`)
        } else return mention(`*Agora é vez do @${campominado.jogadores[campominado.play].id.split("@")[0]} jogar* 💣`)
      }
    }
  }
}

if(isGroup && isJsonIncludes(adivinharnmr, from)) {
  AB = adivinharnmr.map(i => i.groupId).indexOf(from)
  AC = adivinharnmr[AB].participants.map(i => i.id).indexOf(sender)
  if(AC >= 0) {
    advnrnmr = adivinharnmr[AB].participants[AC]
    mini = rmLetras(budy2)
    if(!advnrnmr.fim) {
      if(mini == "pronto") {
        if(advnrnmr.progresso != 5) {
          if(advnrnmr.progresso == 0) txt = `🧙🏽‍♂️ _*Passo nº1:* pense em um número aleatório entre 5-50_`
          if(advnrnmr.progresso == 1) txt = `🧙🏽‍♂️ _*Passo nº2:* multiplique esse número por 2_`
          if(advnrnmr.progresso == 2) {
            nmr = (alerandom(14) + 1) * 2
            advnrnmr.resultado = nmr / 2
            saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
            txt = `🧙🏽‍♂️ _*Passo nº3:* agora adicione +${nmr} a este resultado_`
          }
          if(advnrnmr.progresso == 3) txt = `🧙🏽‍♂️ _*Passo nº4:* feito isso, divida o resultado por 2_`
          if(advnrnmr.progresso == 4) txt = `🧙🏽‍♂️ _*Passo nº5:* agora subtraia este resultado pelo primeiro número que você pensou_`
          advnrnmr.progresso += 1
          saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
          return reply(txt)
        } else {
          advnrnmr.fim = true
          saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
          return reply(`🧙🏽‍♂️ _Pela minha extrema sabedoria, posso presumir que o resultado final seja igual a ↴_\n\t\t\t\t\t\t\t» ${advnrnmr.resultado} «\n\n_Se eu acertei, digite *"sim"...* Caso contrário, digite *"não"* (sem as aspas é claro)_`)
        }
      }
    } else {
      if(mini == "sim" || mini == "nao") {
        snrp = mini == "sim" ? "🧙🏽‍♂️ O grande sábio sempre tem todas as respostas ✨" : "🧙🏽‍♂️ Podes mentir o quanto quiser, mas nós dois sabemos a resposta..."
        adivinharnmr[AB].participants.splice(AC, 1)
        saveJSON(adivinharnmr, `./armor/jogo/adivinharnmr.json`)
        return reply(snrp)
      }
    }
  }
}

//início do anagrama
if(fs.existsSync(`./armor/jogo/anagrama/anagrama-${from}.json`) && isGroup && isModobn) {
  ana = alerandom(palavrasANA.length)
  anagrama = `./armor/jogo/anagrama/anagrama-${from}.json`
  dataAnagrama = JSON.parse(fs.readFileSync(anagrama))
  if(rmLetras(budy2.toLowerCase().slice(0, 4)) == rmLetras(dataAnagrama.original.toLowerCase().slice(0, 4)) && rmLetras(budy2.toLowerCase()) != rmLetras(dataAnagrama.original.toLowerCase())) return reply(`Quase lá ${pushname}`)
  if(rmLetras(budy2.toLowerCase()) == rmLetras(dataAnagrama.original.toLowerCase())) {
    var bglh = [
      `[ ❗ ] Irei reiniciar o jogo em 3️⃣`,
      `[ ❗ ] Irei reiniciar o jogo em 2️⃣`,
      `[ ❗ ] Irei reiniciar o jogo em 1️⃣`,
      `✅ START THE GAME ✅`
    ]
    let { key } = await blackmd.sendMessage(from, {text: `Parabéns ${pushname}, você acertou a palavra do anagrama... 🎉🥳`}, {quoted: info})//primeira mensagem
    await sleep(1000)
    for(let i = 0; i < bglh.length; i++) {
      await sleep(1000)
      await blackmd.sendMessage(from, {text: bglh[i], edit: key }, {quoted: info})
    }
    saveJSON(palavrasANA[ana], anagrama)
    blackmd.sendMessage(from, {text: `
╭─────≽「 👾 ANAGRAMA 👾 」
│➽ *DESCUBRA A PALAVRA*
│➽ *ANAGRAMA:* ${shuffle(palavrasANA[ana].embaralhada)}
│➽ *DICA:* ${palavrasANA[ana].dica}
╰────────────────────────
`}, {quoted: info})
  }
}
//fim do anagrama

if(fs.existsSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`) && budy2.includes(`${JSON.parse(fs.readFileSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)).original.toLowerCase().replace("ã", "a").replace("á", "a").replace("ê", "e").replace("é", "e").replace("í", "i").replace("ó", "o").replace("ô", "o").replace("ú", "u")}`) && isGroup && args.length <= 2) {
fs.unlinkSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`)
var bglh = [
`[ ❗ ] Irei reiniciar o jogo em 3️⃣`,
`[ ❗ ] Irei reiniciar o jogo em 2️⃣`,
`[ ❗ ] Irei reiniciar o jogo em 1️⃣`,
`✅ START THE GAME ✅`
]
let { key } = await blackmd.sendMessage(from, {text: `Parabéns, você acertou o animal 🎉`}, {quoted: seloctt})//primeira mensagem
await sleep(1000)
for(let i = 0; i < bglh.length; i++) {
await sleep(1000)
await blackmd.sendMessage(from, {text: bglh[i], edit: key }, {quoted: seloctt})
}
matheuzinho = Math.floor(Math.random() * quizanimais.length)
fs.writeFileSync(`./armor/jogo/quizanimais/quizanimais-${from}.json`, `${JSON.stringify(quizanimais[matheuzinho])}`)
blackmd.sendMessage(from, {image: {url: quizanimais[matheuzinho].foto}, caption: `\n✔️ 𝙌𝙐𝙄𝙕 𝘼𝙉𝙄𝙈𝘼𝙄𝙎 ✔️\n\n🌚⃤ 𝘿𝙚𝙨𝙘𝙪𝙗𝙧𝙖 𝙊 𝘼𝙣𝙞𝙢𝙖𝙡 ↑↑↑\n`})
}

if(body != undefined) {
  if(!isJsonIncludes(pushnames, botNumber)) {
      pushnames.push({id: botNumber, nick: NomeDoBot})
      saveJSON(pushnames, "./basededados/pushnames.json")
    } else {
      AC = pushnames.map(i => i.id).indexOf(botNumber)
      pushnames[AC].nick = NomeDoBot
      saveJSON(pushnames, "./basededados/pushnames.json")
    }
    if(!isJsonIncludes(pushnames, sender)) {
      pushnames.push({id: sender, nick: pushTestName})
      saveJSON(pushnames, "./basededados/pushnames.json")
    } else {
      AB = pushnames.map(i => i.id).indexOf(sender)
      pushnames[AB].nick = pushTestName
      saveJSON(pushnames, "./basededados/pushnames.json")
    }
  }

//função do mute
if(body != undefined && !info.message?.reactionMessage?.text && isJsonIncludes(mute, from) && isBotGroupAdmins) {
  A1 = mute.map(i => i.gpid).indexOf(from)
  if(isJsonIncludes(mute[A1].mutados, sender)) {
    A2 = mute[A1].mutados.map(a => a.id).indexOf(sender)
    if(mute[A1].mutados[A2].sn == false) {
      mute[A1].mutados[A2].sn = true
      saveJSON(mute, "./basededados/mute.json")
      reply(`Você foi avisado ${pushname}... Você tem 30 segundos para declarar suas últimas palavras 😥`)
      await sleep(30000)
      B1 = mute.map(i => i.gpid).indexOf(from)
      if(isJsonIncludes(mute[B1].mutados, sender)) {
        B2 = mute[B1].mutados.map(a => a.id).indexOf(sender)
        mute[B1].mutados.splice(B2, 1)
        saveJSON(mute, "./basededados/mute.json")
        remover(from, sender)
        await sleep(2000)
        sendMess(from, `Falta de aviso não foi...`)
      }
    }
  }
}

if(JSON.stringify(music).includes(from) && isGroup) {
  AB = music.map(i => i.groupId).indexOf(from)
  if(JSON.stringify(music[AB].usus).includes(sender)) {
    BC = music[AB].usus.map(i => i.id).indexOf(sender)
    if(budy2.toLowerCase().replace("á", "a") === `audio` && isGroup) {
      link = music[AB].usus[BC].urlAudio.replace(`#API_KEY_ALEATORY#`, API_KEY_ALEATORY).replace(`#API_KEY_SABRINA#`, API_KEY_SABRINA).replace(`#API_KEY_BLACK#`, API_KEY_BLACK)
      music[AB].usus.splice(BC, 1)
      fs.writeFileSync("./basededados/music.json", JSON.stringify(music, null, 2))
      try {
        reply(`▧⃯⃟𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚂𝚞𝚊 𝙼ú𝚜𝚒𝚌𝚊ฺ͘.•🛸 ݈݇─`)
        blackmd.sendMessage(from, {audio: {url: link}, mimetype: "audio/mpeg"}, {quoted: seloctt}).catch(e => {
          return reply(downon)
        })
      } catch (e) {
        return reply(downoff)
      }
    }
    if(budy2.toLowerCase().replace("í", "i") === `video` && isGroup) {
      link = music[AB].usus[BC].urlVideo.replace(`#API_KEY_ALEATORY#`, API_KEY_ALEATORY).replace(`#API_KEY_SABRINA#`, API_KEY_SABRINA).replace(`#API_KEY_BLACK#`, API_KEY_BLACK)
      music[AB].usus.splice(BC, 1)
      fs.writeFileSync("./basededados/music.json", JSON.stringify(music, null, 2))
      try {
        reply(`▧⃯⃟𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝚅í𝚍𝚎𝚘ฺ͘.•🛸 ݈݇─`)
        blackmd.sendMessage(from, {video: {url: link}, mimetype: "video/mp4"}, {quoted: seloctt}).catch(e => {
          return reply(downon)
        })
      } catch (e) {
        return reply(downoff)
      }
    }
    if(budy2.toLowerCase() === `doc` && isGroup) {
      link = music[AB].usus[BC].urlAudio.replace(`#API_KEY_ALEATORY#`, API_KEY_ALEATORY).replace(`#API_KEY_SABRINA#`, API_KEY_SABRINA).replace(`#API_KEY_BLACK#`, API_KEY_BLACK)
      nome = music[AB].usus[BC].title
      music[AB].usus.splice(BC, 1)
      fs.writeFileSync("./basededados/music.json", JSON.stringify(music, null, 2))
      try {
        reply(`▧⃯⃟𝙴𝚗𝚟𝚒𝚊𝚗𝚍𝚘 𝙳𝚘𝚌𝚞𝚖𝚎𝚗𝚝𝚘ฺ͘.•🛸 ݈݇─`)
        blackmd.sendMessage(from, {document: {url: link}, fileName: nome+'.mp3', mimetype: "audio/mpeg"}, {quoted: info}).catch(e => {
          return reply(downon)
        })
      } catch (e) {
        return reply(downoff)
      }
    }
  }
}

if(JSON.stringify(vdddsf).includes(from) && isGroup) {
  AB = vdddsf.map(b => b.idgp).indexOf(from)
  if(JSON.stringify(vdddsf[AB].jogadores).includes(sender)) {
    BC = vdddsf.map(a => a.idvd).indexOf("matheuzinho")
    CD = vdddsf[AB].jogadores.map(i => i.id).indexOf(sender)
    if(budy2.toLowerCase() === "verdade") {
      if(vdddsf[AB].jogadores[CD].tipo == 1) {
        vdddsf[AB].jogadores.splice(CD, 1)
        fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
        sendStickerFromUrl(from, `https://telegra.ph/file/4b43ac115d66362540612.jpg`)
      } else if(vdddsf[AB].jogadores[CD].tipo <= 0) {
        alevdd = Math.floor(Math.random() * vdddsf[BC].verdades.length)
        vdddsf[AB].jogadores[CD].vdouds = vdddsf[BC].verdades[alevdd].vdd
        vdddsf[AB].jogadores[CD].tipo = 1
        fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
        reply(`\`\`\`😇 Verdade Ou Desafio 😈\`\`\`
『 VERDADE 』
✓ -> ${vdddsf[BC].verdades[alevdd].vdd}

_(responda com verdade ou mentira)_`)
      }
    }
    if(budy2.toLowerCase() === "mentira") {
      vdddsf[AB].jogadores.splice(CD, 1)
      fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
      sendStickerFromUrl(from, `https://telegra.ph/file/22e467ada05df439e3401.jpg`)
    }
    if(budy2.toLowerCase() === "desafio") {
      aledsf = Math.floor(Math.random() * vdddsf[BC].desafios.length)
      vdddsf[AB].jogadores[CD].vdouds = vdddsf[BC].desafios[aledsf].dsf
      vdddsf[AB].jogadores[CD].tipo = 2
      fs.writeFileSync("./armor/jogo/vdddsf.json", JSON.stringify(vdddsf, null, 2))
      reply(`\`\`\`😇 Verdade Ou Desafio 😈\`\`\`
『 DESAFIO 』
✓ -> ${vdddsf[BC].desafios[aledsf].dsf}

_(quando concluir o desafio, use ${prefix}pronto)_`)
    }
  }
}

if(body != undefined && isGroup && bcgp.length > 0) {
  AB = bcgp.map(i => i.tipo).indexOf("mensagem")
  AC = bcgp.map(i => i.tipo).indexOf("grupos")
  if(bcgp[AB].msg.length <= 0) return
  if(bcgp[AC].gps.length <= 0) return
  if(!JSON.stringify(bcgp[AC].gps).includes(from)) {
    grupo = from
    m = bcgp[AB].msg[0]
    if(m.cobrado == false) {
      msgEmMassa = m.txt
      m.cobrado = true
      fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
      for(i of somembros) {
        blackmd.sendMessage(i, {text: msgEmMassa})
      }
      await sleep(5000)
      blackmd.groupLeave(grupo)
      bcgp[AB].msg.splice(0, 1)
      fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
      if(bcgp[AB].msg.length > 0) {
        bcgp[AC].gps.push({groupId: grupo})
        fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
      } else {
        bcgp[AC].gps = []
        fs.writeFileSync("./basedefuncionamento/bcgp.json", JSON.stringify(bcgp, null, 2))
      }
    }
  }
}

//início do akinator

if(isGroup && isJsonIncludes(akinator, from)) {
  AB = akinator.map(i => i.id).indexOf(from)
  if(akinator[AB].jogador == sender && Number(akinator[AB].dia) === Number(sendHours("DD"))) {
    mini = budy2.toLowerCase().replace("ã", "a")
    if(mini == "sim" || mini == "s" || mini == "nao" || mini == "n" || mini == "nao sei" || mini == "nsei" || mini == "provavelmente sim" || mini == "tlvz sim" || mini == "talvez sim" || mini == "provavelmente nao" || mini == "tlvz nao" || mini == "talvez nao") {
      if(akinator[AB].finish > 0) {
        if(mini == "sim" || mini == "s") {
          akinator.splice(AB, 1)
          saveJSON(akinator, "./armor/jogo/akinator.json")
          reply(`Sabia mlk, eu sou demais 🥳`)
        } else if(mini == "nao" || mini == "n") {
          akinator.splice(AB, 1)
          saveJSON(akinator, "./armor/jogo/akinator.json")
          reply(`Hmm não foi dessa vez... Quem sabe na próxima 🧙🏼‍♂️`)
        }
      } else {
        if(aki.progress >= 90 || aki.currentStep >= 90) {
          await aki.win()
          jogo.now = true
          akinator[AB].finish += 1
          saveJSON(akinator, "./armor/jogo/akinator.json")
          i = aki.answers[0]
          txt = `『 ${i.name}: ${i.description} 』\n🧙🏼‍♂️ Hmm, acho que o seu personagem é esse aqui... Acertei ? _(responda com "sim" ou "não", sem as aspas)_`
          sendImage(from, i.absolute_picture_path, txt, seloctt)
        } else {
          if(mini == "sim" || mini == "s") nmr = "0"
          if(mini == "nao" || mini == "n") nmr = "1"
          if(mini == "nao sei" || mini == "nsei") nmr = "2"
          if(mini == "provavelmente sim" || mini == "tlvz sim" || mini == "talvez sim") nmr = "3"
          if(mini == "provavelmente nao" || mini == "tlvz nao" || mini == "talvez nao") nmr = "4"
          per = progresso(aki.progress, 100)
          await aki.step(nmr)
          reply(`*⏤͟͟͞͞ ꦿAKINATOR* 🧙🏼‍♂️\n🔮⃤ ${aki.question}\n\n${per}`)
        }
      }
    }
  }
}

//fim do akinator

async function msgGlobal() {
  if(gbmsg[1].msg.length > 0) {
    if(gbmsg[0].gp.length > 0) {
      horacerta = moment.tz('America/Sao_Paulo').format('HH:mm')
      day = moment.tz('America/Sao_Paulo').format('DD')
      for(a of gbmsg[1].msg) {
        if(Number(a.time.replace(":", "")) === Number(horacerta.replace(":", ""))) {
          if(Number(a.save) !== Number(day)) {
            a.save = day
            fs.writeFileSync("./basededados/gbmsg.json", JSON.stringify(gbmsg, null, 2))
            for(b of gbmsg[0].gp) {
              setTimeout(() => {
                blackmd.sendMessage(b.id, {text: a.frase})
              }, 1000)//1 segundo
            }
          }
        }
      }
    }
  }
}

msgGlobal();

async function funcgpByM4() {
  if(funcgp.length > 0) {
    for(a of funcgp) {
      config = funcgp.map(i => i.id).indexOf(a.id)
      if(a.tabela.length > 0) {
        for(b of a.tabela) {
          if(b.tipo == 1) tgp = "ss"
          if(b.tipo == 2) tgp = "mm"
          if(b.tipo == 3) tgp = "HH"
          if(Number(b.save) !== Number(moment.tz('America/Sao_Paulo').format(tgp))) {
            b.save = Number(moment.tz('America/Sao_Paulo').format(tgp))
            fs.writeFileSync("./basedefuncionamento/funcgp.json", JSON.stringify(funcgp, null, 2))
            if(b.tempo > 1) {
              b.tempo -= 1
              fs.writeFileSync("./basedefuncionamento/funcgp.json", JSON.stringify(funcgp, null, 2))
            } else {
              if(b.poder == 1) {
                blackmd.groupSettingUpdate(a.id, 'announcement')
                sendMess(a.id, `[ ❗ ] O grupo foi fechado após ${b.ordem} pelo ADM ${b.nome} ❌`)
                closegp = funcgp[config].tabela.map(i => i.idfunc).indexOf(b.idfunc)
                funcgp[config].tabela.splice(closegp, 1)
                fs.writeFileSync("./basedefuncionamento/funcgp.json", JSON.stringify(funcgp, null, 2))
              } else {
                blackmd.groupSettingUpdate(a.id, 'not_announcement')
                sendMess(a.id, `[ ❕ ] O grupo foi aberto após ${b.ordem} pelo ADM ${b.nome} ✅`)
                opengp = funcgp[config].tabela.map(i => i.idfunc).indexOf(b.idfunc)
                funcgp[config].tabela.splice(opengp, 1)
                fs.writeFileSync("./basedefuncionamento/funcgp.json", JSON.stringify(funcgp, null, 2))
              }
            }
          }
        }
      }
    }
  }
}

funcgpByM4();


async function avisosByMath() {
  if(avisos.length != 0) {
    for( i of avisos ) {
      if(i.groupId != "matheuzinho") {
        if(i.module == true) {
          if(i.mensagens.length != 0) {
            for( w of i.mensagens ) {
              if(Number(w.tempo.replace(":", "")) === Number(moment.tz('America/Sao_Paulo').format('HHmm')) && Number(w.dia) !== Number(moment.tz('America/Sao_Paulo').format('DD'))) {
                blackmd.sendMessage(i.groupId, {text: w.msg})
                w.dia = moment.tz('America/Sao_Paulo').format('DD')
                fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
              }
            }
          }
          BH = avisos.map(n => n.groupId).indexOf("matheuzinho")
          if(i.aleatory.length != 0) {
            for( a of i.aleatory ) {
              if(Number(a.tempo.replace(":", "")) === Number(moment.tz('America/Sao_Paulo').format('HHmm')) && Number(a.dia) !== Number(moment.tz('America/Sao_Paulo').format('DD'))) {
                if(a.ativation == 1 && i.globalAleatory.length <= 1) return
                if(a.ativation == 2 && avisos[BH].mensagens.length <= 1) return
                if(Number(a.ativation) <= 1) {
                  testMsg1 = i.globalAleatory
                  testMsg2 = testMsg1[Math.floor(Math.random()*testMsg1.length)]
                } else {
                  testMsg1 = avisos[BH].mensagens
                  testMsg2 = testMsg1[Math.floor(Math.random()*testMsg1.length)]
                }
                blackmd.sendMessage(i.groupId, {text: testMsg2})
                a.dia = moment.tz('America/Sao_Paulo').format('DD')
                fs.writeFileSync("./basededados/avisos.json", JSON.stringify(avisos, null, 2))
              }
            }
          }
        }
      }
    }
  }
}

avisosByMath();

if(budy2 === `${Number(body.split('!')[0])}!` && Number(body.split('!')[0]) > 2 && isGroup) {
  nmrX = Number(body.split('!')[0])
  nmrY = nmrX - 1
  for(i = nmrY; i > 0; i--) {
    nmrX *= i
  }
  reply(`${nmrX}`)
}

//========================================\\
}
}
}
msgupsrt().catch(async(e) => {
if(JSON.stringify(e).includes(API_KEY_BLACK)) {
return console.log("A api caiu ou não foi possivel executar esta ação., espere retornar")   
} else if(String(e).includes("Erro: aborted")) {
file = require.resolve("./start.js")  
delete require.cache[file]
require(file)
} else {
return console.log(e)
}
})
}
}
}
startBlack().catch(e => {
return console.log(e+" -INDEX..ERROS")
})

// Atualizar a Index.js automaticamente sempre que modificar alguma coisa \\
// Créditos: Victor Gabriel / Sabrina-bot
let file = require.resolve(__filename)
fs.watchFile(file, () => {
fs.unwatchFile(file);
console.log(colors.red(`Alterações salvas - '${__filename}'`));
delete require.cache[file]
require(file)
})
